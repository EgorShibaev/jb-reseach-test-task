{"code": "\n\npackage org.jetbrains.kotlin.fir.lightTree.fir.modifier\n\nimport org.jetbrains.kotlin.KtSourceElement\n\nclass TypeProjectionModifier(val source: KtSourceElement? = null, varianceModifiers: Long = ModifierFlag.NONE.value) :\n    Modifier(varianceModifiers) {\n}\n"}
{"code": "// IGNORE_FE10\nclass A {\n    operator fun <T> set(key: Int, value: T) {}\n}\n\nfun test(a: A) {\n    <expr>a[1]</expr> = \"\"\n}"}
{"code": "package user\n\npublic open class Any\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.expression\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.config.AnalysisFlags\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.descriptors.ClassKind\nimport org.jetbrains.kotlin.descriptors.Modality\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.extractClassFromArgument\nimport org.jetbrains.kotlin.fir.analysis.checkers.extractClassesFromArgument\nimport org.jetbrains.kotlin.fir.analysis.checkers.modality\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirClass\nimport org.jetbrains.kotlin.fir.declarations.findArgumentByName\nimport org.jetbrains.kotlin.fir.declarations.utils.isF"}
{"code": "un\nimport org.jetbrains.kotlin.fir.declarations.utils.isLocal\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotationCall\nimport org.jetbrains.kotlin.fir.expressions.arguments\nimport org.jetbrains.kotlin.fir.languageVersionSettings\nimport org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol\nimport org.jetbrains.kotlin.fir.types.ConeClassLikeType\nimport org.jetbrains.kotlin.fir.types.coneTypeSafe\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.resolve.checkers.OptInNames\nimport org.jetbrains.kotlin.resolve.checkers.OptInNames.OPT_IN_ANNOTATION_CLASS\nimport org.jetbrains.kotlin.resolve.checkers.OptInNames.OPT_IN_CLASS_ID\nimport org.jetbrains.kotlin.resolve.checkers.OptInNames.SUBCLASS_OPT_IN_REQUIRED_CLASS_ID\n\nobject FirOptInAnnotationCallChecker : FirAnnotationCallChecker(MppCheckerKind.Common) {\n    override fun check(expression: FirAnnotationCall, context: CheckerContext, reporter: DiagnosticReporter) {\n        val lookupTag = expression.annotationTypeRef"}
{"code": ".coneTypeSafe<ConeClassLikeType>()?.lookupTag ?: return\n        val classId = lookupTag.classId\n        val isRequiresOptIn = classId == OptInNames.REQUIRES_OPT_IN_CLASS_ID\n        val isOptIn = classId == OptInNames.OPT_IN_CLASS_ID\n        val isSubclassOptIn = classId == OptInNames.SUBCLASS_OPT_IN_REQUIRED_CLASS_ID\n        if (isRequiresOptIn || isOptIn) {\n            checkOptInIsEnabled(expression.source, context, reporter)\n            if (isOptIn) {\n                val arguments = expression.arguments\n                if (arguments.isEmpty()) {\n                    reporter.reportOn(expression.source, FirErrors.OPT_IN_WITHOUT_ARGUMENTS, context)\n                } else {\n                    val annotationClasses = expression.findArgumentByName(OPT_IN_ANNOTATION_CLASS)\n                    for (classSymbol in annotationClasses?.extractClassesFromArgument(context.session).orEmpty()) {\n                        checkOptInArgumentIsMarker(classSymbol, classId, expression.source, reporter, co"}
{"code": "ntext)\n                    }\n                }\n            }\n        } else if (isSubclassOptIn) {\n            val declaration = context.containingDeclarations.lastOrNull() as? FirClass\n            if (declaration != null) {\n                val kind = declaration.classKind\n                val classKindRepresentation = kind.representation\n                if (kind == ClassKind.ENUM_CLASS || kind == ClassKind.OBJECT || kind == ClassKind.ANNOTATION_CLASS) {\n                    reporter.reportOn(expression.source, FirErrors.SUBCLASS_OPT_IN_INAPPLICABLE, classKindRepresentation, context)\n                    return\n                }\n                val modality = declaration.modality()\n                if (modality == Modality.FINAL || modality == Modality.SEALED) {\n                    reporter.reportOn(\n                        expression.source,\n                        FirErrors.SUBCLASS_OPT_IN_INAPPLICABLE,\n                        \"${modality.name.lowercase()} $classKindRepresentation\",\n    "}
{"code": "                    context,\n                    )\n                    return\n                }\n                if (declaration.isFun) {\n                    reporter.reportOn(expression.source, FirErrors.SUBCLASS_OPT_IN_INAPPLICABLE, \"fun interface\", context)\n                    return\n                }\n                if (declaration.isLocal) {\n                    reporter.reportOn(expression.source, FirErrors.SUBCLASS_OPT_IN_INAPPLICABLE, \"local $classKindRepresentation\", context)\n                    return\n                }\n            }\n            val classSymbol = expression.findArgumentByName(OPT_IN_ANNOTATION_CLASS)?.extractClassFromArgument(context.session) ?: return\n            checkOptInArgumentIsMarker(classSymbol, classId, expression.source, reporter, context)\n        }\n    }\n\n    private val ClassKind.representation: String\n        get() = when (this) {\n            ClassKind.ENUM_ENTRY -> \"enum entry\"\n            else -> codeRepresentation!!\n        }\n\n    private fun che"}
{"code": "ckOptInIsEnabled(\n        element: KtSourceElement?,\n        context: CheckerContext,\n        reporter: DiagnosticReporter,\n    ) {\n        val languageVersionSettings = context.session.languageVersionSettings\n        val optInFqNames = languageVersionSettings.getFlag(AnalysisFlags.optIn)\n        if (!languageVersionSettings.supportsFeature(LanguageFeature.OptInRelease) &&\n            OptInNames.REQUIRES_OPT_IN_FQ_NAME.asString() !in optInFqNames\n        ) {\n            reporter.reportOn(element, FirErrors.OPT_IN_IS_NOT_ENABLED, context)\n        }\n    }\n\n    private fun checkOptInArgumentIsMarker(\n        classSymbol: FirRegularClassSymbol,\n        annotationClassId: ClassId,\n        source: KtSourceElement?,\n        reporter: DiagnosticReporter,\n        context: CheckerContext\n    ) {\n        with(FirOptInUsageBaseChecker) {\n            if (classSymbol.loadExperimentalityForMarkerAnnotation(context.session) == null) {\n                val diagnostic = when (annotationClassId) {\n       "}
{"code": "             OPT_IN_CLASS_ID -> FirErrors.OPT_IN_ARGUMENT_IS_NOT_MARKER\n                    SUBCLASS_OPT_IN_REQUIRED_CLASS_ID -> FirErrors.SUBCLASS_OPT_ARGUMENT_IS_NOT_MARKER\n                    else -> return\n                }\n                reporter.reportOn(\n                    source,\n                    diagnostic,\n                    classSymbol.classId,\n                    context\n                )\n            }\n        }\n    }\n}\n"}
{"code": "import kotlin.contracts.*\n\ninterface A\n\nfun A.foo() {}\n\n@OptIn(ExperimentalContracts::class)\nfun Any?.myRequireNotNull() {\n    contract {\n        returns() implies (this@myRequireNotNull != null)\n    }\n    if (this == null) throw IllegalStateException()\n}\n\nfun test_1(x: A?) {\n    x.myRequireNotNull()\n    x.foo()\n}\n\nfun test_2(x: A?) {\n    x.myRequireNotNull()\n    with(x) {\n        foo()\n    }\n}\n\nfun test_3(x: A?) {\n    with(x) {\n        myRequireNotNull()\n    }\n    x<!UNSAFE_CALL!>.<!>foo()\n}\n\nfun test_4(x: A?) {\n    with(x) {\n        myRequireNotNull()\n        foo()\n    }\n}\n\nfun A?.test_5() {\n    myRequireNotNull()\n    foo()\n}\n"}
{"code": "interface Foo\n\nfun Foo.foo(a: Int) {}\n\nfun test(foo: Foo) {\n    consume(<expr>Foo::foo</expr>)\n}\n\nfun consume(f: (Foo, Int) -> Unit) {}"}
{"code": "package a\n\nclass InheritingClasses {\n    abstract class A(override val c: Int = 1) : C {\n        open fun of() = 3\n        abstract fun af(): Int\n        open val op = 4\n        abstract val ap: Int\n    }\n\n    open class B : A(2) {\n        override fun of() = 4\n        override fun af() = 5\n        override val op = 5\n        override val ap = 5\n    }\n\n    interface C {\n        val c: Int\n    }\n\n    interface D<T> : C {\n        override val c: Int\n    }\n\n    interface E\n    class G : B(), C, D<Int>, E\n\n\n    class InheritAny {\n        interface SomeTrait\n        interface SomeTrait2\n\n        class ImplicitAny\n\n        class ExplicitAny : Any()\n\n        class OnlyTrait : SomeTrait\n        class OnlyTraits : SomeTrait, SomeTrait2\n\n        class TraitWithExplicitAny : Any(), SomeTrait\n        class TraitsWithExplicitAny : SomeTrait2, Any(), SomeTrait\n    }\n\n    abstract class InheritFunctionType : ((Int, String) -> Int)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.symbols.impl\n\nimport org.jetbrains.kotlin.fir.declarations.FirFile\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\n\nclass FirFileSymbol : FirBasedSymbol<FirFile>() {\n    override fun toString(): String = \"${this::class.simpleName} ${fir.name}\"\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirAnonymousFunction\nimport org.jetbrains.kotlin.fir.declarations.utils.isSuspend\n\nobject FirSuspendAnonymousFunctionChecker : FirAnonymousFunctionChecker(MppCheckerKind.Common) {\n    override fun check(declaration: FirAnonymousFunction, context: CheckerContext, reporter: DiagnosticReporter) {\n        if (!declaration.isLambda && declaration.isSuspend) {\n            reporter.reportOn(declaration.source, FirErrors.ANONYMOUS_SUSPEND_FUNCTION, context)\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.jvm.extensions\n\nimport com.intellij.openapi.project.Project\nimport org.jetbrains.kotlin.analyzer.AnalysisResult\nimport org.jetbrains.kotlin.container.ComponentProvider\nimport org.jetbrains.kotlin.container.get\nimport org.jetbrains.kotlin.context.ProjectContext\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.resolve.*\nimport org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo\nimport org.jetbrains.kotlin.resolve.descriptorUtil.isAnnotationConstructor\nimport org.jetbrains.kotlin.resolve.lazy.DeclarationScopeProvider\nimport org.jetbrains.kotlin.resolve.lazy.ForceResolveUtil\nimport org.jetbrains.kotlin.resolve.lazy.ResolveSession\nimport org.jetbrains.kotlin.resolve.scopes.LexicalScope\nimport org.jetbrains.kotlin.resolve.scopes.utils.memberScopeAsImportingScope\n\nopen class PartialAnalysisHandlerExtension : AnalysisHandlerExtension {\n    open val analyzePartially: Boolean\n        get() = true"}
{"code": "\n\n    open val analyzeDefaultParameterValues: Boolean\n        get() = false\n\n    override fun doAnalysis(\n        project: Project,\n        module: ModuleDescriptor,\n        projectContext: ProjectContext,\n        files: Collection<KtFile>,\n        bindingTrace: BindingTrace,\n        componentProvider: ComponentProvider\n    ): AnalysisResult? {\n        if (!analyzePartially) {\n            return null\n        }\n\n        val resolveSession = componentProvider.get<ResolveSession>()\n        val bodyResolver = componentProvider.get<BodyResolver>()\n        val declarationScopeProvider = componentProvider.get<DeclarationScopeProvider>()\n        val topDownAnalyzer = componentProvider.get<LazyTopDownAnalyzer>()\n\n        val topDownAnalysisContext = TopDownAnalysisContext(\n            TopDownAnalysisMode.TopLevelDeclarations, DataFlowInfo.EMPTY, declarationScopeProvider\n        )\n\n        for (file in files) {\n            ForceResolveUtil.forceResolveAllContents(resolveSession.getFileAnnotation"}
{"code": "s(file))\n            topDownAnalyzer.resolveImportsInFile(file)\n        }\n\n        doForEachDeclaration(files) { declaration ->\n            val descriptor = resolveSession.resolveToDescriptor(declaration)\n\n            when (descriptor) {\n                is ClassDescriptor -> {\n                    ForceResolveUtil.forceResolveAllContents(descriptor)\n                    ForceResolveUtil.forceResolveAllContents(descriptor.typeConstructor.supertypes)\n\n                    if (declaration is KtClassOrObject && descriptor is ClassDescriptorWithResolutionScopes) {\n                        bodyResolver.resolveSuperTypeEntryList(\n                            DataFlowInfo.EMPTY, declaration, descriptor, descriptor.unsubstitutedPrimaryConstructor,\n                            descriptor.scopeForConstructorHeaderResolution,\n                            descriptor.scopeForMemberDeclarationResolution,\n                            resolveSession.inferenceSession\n                        )\n                  "}
{"code": "  }\n                }\n\n                is PropertyDescriptor -> {\n                    if (declaration is KtProperty) {\n                        \n                        bodyResolver.resolveProperty(topDownAnalysisContext, declaration, descriptor)\n                    }\n                }\n\n                is FunctionDescriptor -> {\n                    if (declaration is KtPrimaryConstructor && (analyzeDefaultParameterValues || descriptor.isAnnotationConstructor())) {\n                        val containingScope = descriptor.containingScope\n                        if (containingScope != null) {\n                            bodyResolver.resolveConstructorParameterDefaultValues(\n                                topDownAnalysisContext.outerDataFlowInfo, bindingTrace,\n                                declaration, descriptor as ConstructorDescriptor, containingScope,\n                                resolveSession.inferenceSession\n                            )\n                        }\n              "}
{"code": "      } else if (declaration is KtFunction && !declaration.hasDeclaredReturnType() && !declaration.hasBlockBody()) {\n                        ForceResolveUtil.forceResolveAllContents(descriptor)\n                    }\n                }\n            }\n        }\n\n        return AnalysisResult.Companion.success(bindingTrace.bindingContext, module, true)\n    }\n\n    private val DeclarationDescriptor.containingScope: LexicalScope?\n        get() {\n            val containingDescriptor = containingDeclaration ?: return null\n            return when (containingDescriptor) {\n                is ClassDescriptorWithResolutionScopes -> containingDescriptor.scopeForInitializerResolution\n                is PackageFragmentDescriptor -> LexicalScope.Base(containingDescriptor.getMemberScope().memberScopeAsImportingScope(), this)\n                else -> null\n            }\n        }\n\n    private fun doForEachDeclaration(declaration: KtDeclaration, f: (KtDeclaration) -> Unit) {\n        if (declaration !is KtAnon"}
{"code": "ymousInitializer) {\n            f(declaration)\n        }\n\n        if (declaration is KtClassOrObject) {\n            val primaryConstructor = declaration.primaryConstructor\n            if (primaryConstructor != null) {\n                f(primaryConstructor)\n            }\n\n            declaration.declarations.forEach { doForEachDeclaration(it, f) }\n        }\n    }\n\n    private fun doForEachDeclaration(files: Collection<KtFile>, f: (KtDeclaration) -> Unit) {\n        for (file in files) {\n            file.declarations.forEach { doForEachDeclaration(it, f) }\n        }\n    }\n\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.fir.caches\n\nimport org.jetbrains.kotlin.fir.caches.FirLazyValue\n\ninternal class FirThreadSafeValue<V>(createValue: () -> V) : FirLazyValue<V>() {\n    private val lazyValue by lazy(LazyThreadSafetyMode.SYNCHRONIZED, createValue)\n    override fun getValue(): V = lazyValue\n}"}
{"code": "class X(x: Int) {\n    constructor(<expr>y: String</expr>): this(1)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.cli.jvm.compiler\n\nimport com.intellij.openapi.diagnostic.Logger\nimport com.intellij.openapi.project.Project\nimport com.intellij.openapi.vfs.StandardFileSystems\nimport com.intellij.openapi.vfs.VirtualFile\nimport com.intellij.openapi.vfs.VirtualFileManager\nimport com.intellij.psi.PsiManager\nimport org.jetbrains.kotlin.cli.common.CLIConfigurationKeys\nimport org.jetbrains.kotlin.cli.common.config.KotlinSourceRoot\nimport org.jetbrains.kotlin.cli.common.config.kotlinSourceRoots\nimport org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation\nimport org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity\nimport org.jetbrains.kotlin.cli.common.messages.MessageCollector\nimport org.jetbrains.kotlin.config.CompilerConfiguration\nimport org.jetbrains.kotlin.config.CompilerConfigurationKey\nimport org.jetbrains.kotlin.config.JVMConfigurationKeys\nimport org.jetbrains.kotlin.extensions.CompilerConfigurationExtension\nimport org.jetbrains.kotlin.extensions.P"}
{"code": "reprocessedFileCreator\nimport org.jetbrains.kotlin.idea.KotlinFileType\nimport org.jetbrains.kotlin.modules.Module\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.resolve.multiplatform.hmppModuleName\nimport org.jetbrains.kotlin.resolve.multiplatform.isCommonSource\nimport java.io.File\n\nfun CompilerConfiguration.report(severity: CompilerMessageSeverity, message: String, location: CompilerMessageLocation? = null) {\n    get(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY)?.report(severity, message, location)\n}\n\nfun List<KotlinSourceRoot>.forAllFiles(\n    configuration: CompilerConfiguration,\n    project: Project,\n    reportLocation: CompilerMessageLocation? = null,\n    body: (VirtualFile, Boolean, moduleName: String?) -> Unit\n) {\n    val localFileSystem = VirtualFileManager.getInstance()\n        .getFileSystem(StandardFileSystems.FILE_PROTOCOL)\n\n    val processedFiles = hashSetOf<VirtualFile>()\n\n    val virtualFileCreator = PreprocessedFileCreator(project)\n\n    var pluginsConf"}
{"code": "igured = false\n    fun ensurePluginsConfigured() {\n        if (!pluginsConfigured) {\n            for (extension in CompilerConfigurationExtension.getInstances(project)) {\n                extension.updateFileRegistry()\n            }\n            pluginsConfigured = true\n        }\n    }\n\n    for ((sourceRootPath, isCommon, hmppModuleName) in this) {\n        val sourceRoot = File(sourceRootPath)\n        val vFile = localFileSystem.findFileByPath(sourceRoot.normalize().path)\n        if (vFile == null) {\n            val message = \"Source file or directory not found: $sourceRootPath\"\n\n            val buildFilePath = configuration.get(JVMConfigurationKeys.MODULE_XML_FILE)\n            if (buildFilePath != null && Logger.isInitialized()) {\n                Logger.getInstance(KotlinCoreEnvironment::class.java)\n                    .warn(\"$message\\n\\nbuild file path: $buildFilePath\\ncontent:\\n${buildFilePath.readText()}\")\n            }\n\n            configuration.report(CompilerMessageSeverity.ERROR,"}
{"code": " message, reportLocation)\n            continue\n        }\n\n        if (!vFile.isDirectory && vFile.extension != KotlinFileType.EXTENSION) {\n            ensurePluginsConfigured()\n            if (vFile.fileType != KotlinFileType.INSTANCE) {\n                configuration.report(CompilerMessageSeverity.ERROR, \"Source entry is not a Kotlin file: $sourceRootPath\", reportLocation)\n                continue\n            }\n        }\n\n        for (file in sourceRoot.walkTopDown()) {\n            if (!file.isFile) continue\n\n            val virtualFile = localFileSystem.findFileByPath(file.absoluteFile.normalize().path)?.let(virtualFileCreator::create)\n            if (virtualFile != null && processedFiles.add(virtualFile)) {\n                if (virtualFile.extension != KotlinFileType.EXTENSION) {\n                    ensurePluginsConfigured()\n                }\n                if (virtualFile.extension == KotlinFileType.EXTENSION || virtualFile.fileType == KotlinFileType.INSTANCE) {\n                    "}
{"code": "body(virtualFile, isCommon, hmppModuleName)\n                }\n            }\n        }\n    }\n}\n\nfun createSourceFilesFromSourceRoots(\n    configuration: CompilerConfiguration,\n    project: Project,\n    sourceRoots: List<KotlinSourceRoot>,\n    reportLocation: CompilerMessageLocation? = null\n): MutableList<KtFile> {\n    val psiManager = PsiManager.getInstance(project)\n    val result = mutableListOf<KtFile>()\n    sourceRoots.forAllFiles(configuration, project, reportLocation) { virtualFile, isCommon, moduleName ->\n        psiManager.findFile(virtualFile)?.let {\n            if (it is KtFile) {\n                it.isCommonSource = isCommon\n                if (moduleName != null) {\n                    it.hmppModuleName = moduleName\n                }\n                result.add(it)\n            }\n        }\n    }\n    return result\n}\n\nval KotlinCoreEnvironment.messageCollector: MessageCollector\n    get() = configuration.getNotNull(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY)\n\nfun CompilerConfigurati"}
{"code": "on.applyModuleProperties(module: Module, buildFile: File?): CompilerConfiguration {\n    return copy().apply {\n        if (buildFile != null) {\n            fun checkKeyIsNull(key: CompilerConfigurationKey<*>, name: String) {\n                assert(get(key) == null) { \"$name should be null, when buildFile is used\" }\n            }\n\n            checkKeyIsNull(JVMConfigurationKeys.OUTPUT_DIRECTORY, \"OUTPUT_DIRECTORY\")\n            checkKeyIsNull(JVMConfigurationKeys.OUTPUT_JAR, \"OUTPUT_JAR\")\n            put(JVMConfigurationKeys.OUTPUT_DIRECTORY, File(module.getOutputDirectory()))\n        }\n    }\n}\n\nfun getSourceRootsCheckingForDuplicates(configuration: CompilerConfiguration, messageCollector: MessageCollector?): List<KotlinSourceRoot> {\n    val uniqueSourceRoots = hashSetOf<String>()\n    val result = mutableListOf<KotlinSourceRoot>()\n\n    for (root in configuration.kotlinSourceRoots) {\n        if (!uniqueSourceRoots.add(root.path)) {\n            messageCollector?.report(CompilerMessageSeveri"}
{"code": "ty.STRONG_WARNING, \"Duplicate source root: ${root.path}\")\n        }\n        result.add(root)\n    }\n\n    return result\n}\n\n\n"}
{"code": "fun test(n: Int) {\n    <expr>n = 5</expr>\n}"}
{"code": "package test\n\nobject Conflict\n\noperator fun Conflict.invoke() {}\n\nfun test() {\n    class Conflict(i: Int)\n\n    <caret>Conflict()\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen\n\nimport org.jetbrains.kotlin.codegen.JvmCodegenUtil.isJvmInterface\nimport org.jetbrains.kotlin.codegen.state.KotlinTypeMapper\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.ClassKind\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes.OBJECT_TYPE\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.org.objectweb.asm.Type\n\nclass SuperClassInfo(\n    val type: Type,\n    // null means java/lang/Object or irrelevant\n    val kotlinType: KotlinType?\n) {\n\n    companion object {\n        @JvmStatic\n        fun getSuperClassInfo(descriptor: ClassDescriptor, typeMapper: KotlinTypeMapper): SuperClassInfo {\n            if (descriptor.kind == ClassKind.INTERFACE) {\n                return SuperClassInfo(OBJECT_TYPE, null)\n            }\n\n            for (supertype in descriptor.typeConstructor.supertypes) {\n                val superClass = supertype.constructor.declarationDescriptor\n                if (sup"}
{"code": "erClass != null && !isJvmInterface(superClass)) {\n                    return SuperClassInfo(typeMapper.mapClass(superClass), supertype)\n                }\n            }\n\n            return SuperClassInfo(OBJECT_TYPE, null)\n        }\n    }\n\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.expression\n\nimport org.jetbrains.kotlin.KtNodeTypes\nimport org.jetbrains.kotlin.KtRealSourceElementKind\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.KtDiagnosticFactory2\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.analysis.checkers.*\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.expressions.FirEqualityOperatorCall\nimport org.jetbrains.kotlin.fir.expressions.FirOperation\nimport org.jetbrains.kotlin.fir.expressions.FirSmartCastExpression\nimport org.jetbrains.kotlin.fir.types.*\n\nobject FirEqualityCompatibilityChecker : FirEqualityOperatorCallChecker(MppCheckerKind.Common) {\n    override fun check(expression: FirEqualityOperatorCall, co"}
{"code": "ntext: CheckerContext, reporter: DiagnosticReporter) {\n        val arguments = expression.argumentList.arguments\n        require(arguments.size == 2) { \"Equality operator call with non-2 arguments\" }\n\n        val l = arguments[0].unwrapToMoreUsefulExpression().toArgumentInfo(context)\n        val r = arguments[1].unwrapToMoreUsefulExpression().toArgumentInfo(context)\n\n        checkSenselessness(l.smartCastType, r.smartCastType, context, expression, reporter)\n\n        val checkApplicability = when (expression.operation) {\n            FirOperation.EQ, FirOperation.NOT_EQ -> ::checkEqualityApplicability\n            FirOperation.IDENTITY, FirOperation.NOT_IDENTITY -> ::checkIdentityApplicability\n            else -> error(\"Invalid operator of FirEqualityOperatorCall\")\n        }\n\n        checkApplicability(l.originalTypeInfo, r.originalTypeInfo, context).ifInapplicable {\n            // K1 checks consist of 2 parts: reporting a\n            // diagnostic if the intersection is empty,\n          "}
{"code": "  // and otherwise reporting a diagnostic if\n            // `isIncompatibleEnums` returns true.\n            // In either case K1 may not report a diagnostic\n            // due to some reasons, and we need to\n            // account for them.\n            val isCaseMissedByK1 = isCaseMissedByK1Intersector(l.originalTypeInfo, r.originalTypeInfo)\n                    && isCaseMissedByAdditionalK1IncompatibleEnumsCheck(l.originalType, r.originalType, context.session)\n            val replicateK1Behavior = !context.languageVersionSettings.supportsFeature(LanguageFeature.ReportErrorsForComparisonOperators)\n\n            return reporter.reportInapplicabilityDiagnostic(\n                expression, it, expression.operation, forceWarning = isCaseMissedByK1 && replicateK1Behavior,\n                l.originalTypeInfo, r.originalTypeInfo,\n                l.userType, r.userType, context,\n            )\n        }\n\n        if (l.argument !is FirSmartCastExpression && r.argument !is FirSmartCastExpression) {\n"}
{"code": "            return\n        }\n\n        checkApplicability(l.smartCastTypeInfo, r.smartCastTypeInfo, context).ifInapplicable {\n            return reporter.reportInapplicabilityDiagnostic(\n                expression, it, expression.operation, forceWarning = true,\n                l.smartCastTypeInfo, r.smartCastTypeInfo,\n                l.userType, r.userType, context,\n            )\n        }\n    }\n\n    private fun checkEqualityApplicability(l: TypeInfo, r: TypeInfo, context: CheckerContext): Applicability {\n        val oneIsBuiltin = l.isBuiltin || r.isBuiltin\n        val oneIsIdentityLess = l.isIdentityLess || r.isIdentityLess\n\n        // The compiler should only check comparisons\n        // when builtins are involved.\n        // Builtins' supertypes must not be present in\n        // the list of special fqNames described in RULES1\n\n        return when {\n            (oneIsBuiltin || oneIsIdentityLess) && shouldReportAsPerRules1(l, r, context) -> getInapplicabilityFor(l, r)\n            els"}
{"code": "e -> Applicability.APPLICABLE\n        }\n    }\n\n    private fun checkIdentityApplicability(l: TypeInfo, r: TypeInfo, context: CheckerContext): Applicability {\n        val oneIsNotNull = !l.type.isNullable || !r.type.isNullable\n\n        return when {\n            l.type.isNullableNothing || r.type.isNullableNothing -> Applicability.APPLICABLE\n            l.isIdentityLess || r.isIdentityLess -> Applicability.INAPPLICABLE_AS_IDENTITY_LESS\n            oneIsNotNull && shouldReportAsPerRules1(l, r, context) -> getInapplicabilityFor(l, r)\n            else -> Applicability.APPLICABLE\n        }\n    }\n\n    private fun getInapplicabilityFor(l: TypeInfo, r: TypeInfo): Applicability {\n        val isNonEmptyIntersectionInK1 = isCaseMissedByK1Intersector(l, r)\n        val isOneEnum = l.isEnumClass || r.isEnumClass\n\n        return when {\n            // This code aims to replicate the K1's choice of diagnostics\n            isNonEmptyIntersectionInK1 && isOneEnum -> Applicability.INAPPLICABLE_AS_ENUMS\n   "}
{"code": "         else -> Applicability.GENERALLY_INAPPLICABLE\n        }\n    }\n\n    \n    private enum class Applicability {\n        APPLICABLE,\n        GENERALLY_INAPPLICABLE,\n        INAPPLICABLE_AS_ENUMS,\n        INAPPLICABLE_AS_IDENTITY_LESS,\n    }\n\n    private inline fun Applicability.ifInapplicable(block: (Applicability) -> Unit) = when (this) {\n        Applicability.APPLICABLE -> {}\n        else -> block(this)\n    }\n\n    private fun getGeneralInapplicabilityDiagnostic(forceWarning: Boolean) = when {\n        forceWarning -> FirErrors.EQUALITY_NOT_APPLICABLE_WARNING\n        else -> FirErrors.EQUALITY_NOT_APPLICABLE\n    }\n\n    private fun getIdentityLessInapplicabilityDiagnostic(\n        l: TypeInfo,\n        r: TypeInfo,\n        forceWarning: Boolean,\n        context: CheckerContext,\n    ): KtDiagnosticFactory2<ConeKotlinType, ConeKotlinType> {\n        val areBothPrimitives = l.isNotNullPrimitive && r.isNotNullPrimitive\n        val areSameTypes = l.type.classId == r.type.classId\n        val "}
{"code": "shouldProperlyReportError = context.languageVersionSettings.supportsFeature(LanguageFeature.ReportErrorsForComparisonOperators)\n\n        // In this case K1 reports nothing\n        val shouldRelaxDiagnostic = (l.isPrimitive || r.isPrimitive) && areRelated(l, r, context)\n                && !shouldProperlyReportError\n\n        return when {\n            // See: KT-28252\n            areSameTypes && areBothPrimitives -> FirErrors.DEPRECATED_IDENTITY_EQUALS\n            // The same reason as above\n            isIdentityComparedWithImplicitBoxing(l, r, context.session) -> FirErrors.IMPLICIT_BOXING_IN_IDENTITY_EQUALS\n            forceWarning || shouldRelaxDiagnostic -> FirErrors.FORBIDDEN_IDENTITY_EQUALS_WARNING\n            else -> FirErrors.FORBIDDEN_IDENTITY_EQUALS\n        }\n    }\n\n    private fun isIdentityComparedWithImplicitBoxing(l: TypeInfo, r: TypeInfo, session: FirSession) =\n        arePrimitiveAndNonPrimitiveSupertypeRespectively(l, r, session) || arePrimitiveAndNonPrimitiveSupertypeRes"}
{"code": "pectively(r, l, session)\n\n    private fun arePrimitiveAndNonPrimitiveSupertypeRespectively(l: TypeInfo, r: TypeInfo, session: FirSession) =\n        l.isNotNullPrimitive && !r.isNotNullPrimitive && l.type.isSubtypeOf(r.type, session)\n\n    private fun getSourceLessInapplicabilityDiagnostic(forceWarning: Boolean) = when {\n        forceWarning -> FirErrors.INCOMPATIBLE_TYPES_WARNING\n        else -> FirErrors.INCOMPATIBLE_TYPES\n    }\n\n    private fun getEnumInapplicabilityDiagnostic(\n        l: TypeInfo,\n        r: TypeInfo,\n        forceWarning: Boolean,\n        context: CheckerContext,\n    ): KtDiagnosticFactory2<ConeKotlinType, ConeKotlinType> {\n        // Preserving the behavior on the old test data\n        // simplifies detecting fir-differences,\n        // which is crucial for this checker\n        val isOldTestData = !context.languageVersionSettings.supportsFeature(\n            LanguageFeature.ProhibitComparisonOfIncompatibleEnums,\n        )\n\n        // In this corner case K1 reports "}
{"code": "nothing\n        val bothNullableEnums = l.isNullableEnum && r.isNullableEnum\n        // When comparing enums, for type parameters K1\n        // tries to pick the \"representative\" superclass\n        // instead of the proper intersection.\n        // We can't guarantee that in such cases\n        // K2 reports the same as K1\n        val areIntersectionsInvolved = l.type is ConeIntersectionType || r.type is ConeIntersectionType\n\n        val shouldProperlyReportError = context.languageVersionSettings.supportsFeature(LanguageFeature.ReportErrorsForComparisonOperators)\n        val shouldRelaxDiagnostic = (bothNullableEnums || areIntersectionsInvolved) && !shouldProperlyReportError\n\n        return when {\n            forceWarning || isOldTestData || shouldRelaxDiagnostic -> FirErrors.INCOMPATIBLE_ENUM_COMPARISON\n            else -> FirErrors.INCOMPATIBLE_ENUM_COMPARISON_ERROR\n        }\n    }\n\n    private fun DiagnosticReporter.reportInapplicabilityDiagnostic(\n        expression: FirEqualityOpera"}
{"code": "torCall,\n        applicability: Applicability,\n        operation: FirOperation,\n        forceWarning: Boolean,\n        l: TypeInfo,\n        r: TypeInfo,\n        lUserType: ConeKotlinType,\n        rUserType: ConeKotlinType,\n        context: CheckerContext,\n    ): Unit = when {\n        applicability == Applicability.INAPPLICABLE_AS_IDENTITY_LESS -> reportOn(\n            expression.source, getIdentityLessInapplicabilityDiagnostic(l, r, forceWarning, context),\n            lUserType, rUserType, context,\n        )\n        applicability == Applicability.INAPPLICABLE_AS_ENUMS -> reportOn(\n            expression.source, getEnumInapplicabilityDiagnostic(l, r, forceWarning, context),\n            lUserType, rUserType, context,\n        )\n        // This check ensures K2 reports the same diagnostics as K1 used to.\n        expression.source?.kind !is KtRealSourceElementKind -> reportOn(\n            expression.source, getSourceLessInapplicabilityDiagnostic(forceWarning),\n            lUserType, rUserTy"}
{"code": "pe, context,\n        )\n        applicability == Applicability.GENERALLY_INAPPLICABLE -> reportOn(\n            expression.source, getGeneralInapplicabilityDiagnostic(forceWarning),\n            operation.operator, lUserType, rUserType, context,\n        )\n        else -> error(\"Shouldn't be here\")\n    }\n\n    private fun checkSenselessness(\n        lType: ConeKotlinType,\n        rType: ConeKotlinType,\n        context: CheckerContext,\n        expression: FirEqualityOperatorCall,\n        reporter: DiagnosticReporter\n    ) {\n        val type = when {\n            rType.isNullableNothing -> lType\n            lType.isNullableNothing -> rType\n            else -> return\n        }\n        if (type is ConeErrorType) return\n        val isPositiveCompare = expression.operation == FirOperation.EQ || expression.operation == FirOperation.IDENTITY\n        val compareResult = with(context.session.typeContext) {\n            when {\n                // `null` literal has type `Nothing?`\n                type.is"}
{"code": "NullableNothing -> isPositiveCompare\n                !type.isNullableType() -> !isPositiveCompare\n                else -> return\n            }\n        }\n        // We only report `SENSELESS_NULL_IN_WHEN` if `lType = type` because `lType` is the type of the `when` subject. This diagnostic is\n        // only intended for cases where the branch condition contains a null. Also, the error message for SENSELESS_NULL_IN_WHEN\n        // says the value is *never* equal to null, so we can't report it if the value is *always* equal to null.\n        if (expression.source?.elementType != KtNodeTypes.BINARY_EXPRESSION && type === lType && !compareResult) {\n            reporter.reportOn(expression.source, FirErrors.SENSELESS_NULL_IN_WHEN, context)\n        } else {\n            reporter.reportOn(expression.source, FirErrors.SENSELESS_COMPARISON, compareResult, context)\n        }\n    }\n}\n\n\ninternal fun isCaseMissedByK1Intersector(a: TypeInfo, b: TypeInfo) =\n    a.canHaveSubtypesAccordingToK1 && b.canHav"}
{"code": "eSubtypesAccordingToK1\n\n\ninternal fun isCaseMissedByAdditionalK1IncompatibleEnumsCheck(a: ConeKotlinType, b: ConeKotlinType, session: FirSession): Boolean {\n    return when {\n        !a.isEnum(session) && !b.isEnum(session) -> true\n        a.isNullable && b.isNullable -> true\n        a.isNothingOrNullableNothing || b.isNothingOrNullableNothing -> true\n        else -> !a.isClass(session) || !b.isClass(session)\n    }\n}\n"}
{"code": "package foo.bar.baz\n\nclass AA {\n    class BB {\n        companion object\n    }\n}\n\nfun test(param: foo.bar.baz.<caret>AA.BB.Companion) {}\n\n"}
{"code": "fun foo(a: Int): Int {\n    val b: Int = 1\n    for (n in 1..a) {\n        <expr>if (a + b > 0) break\n        consume(a - b)\n        break</expr>\n    }\n    return 1\n}\n\nfun consume(obj: Any?) {}"}
{"code": "// FILE: main.kt\npackage foo.www.ddd\n\nclass Check {\n    class BBD {\n        companion object {\n            fun dad() {\n                val Bwd = 42\n                val a = <expr>foo.www.ddd.Check.BBD.Companion::class.java.annotatedInterfaces.size</expr>\n            }\n        }\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.intrinsics\n\nimport org.jetbrains.kotlin.builtins.KotlinBuiltIns\nimport org.jetbrains.kotlin.codegen.AsmUtil\nimport org.jetbrains.kotlin.codegen.ExpressionCodegen\nimport org.jetbrains.kotlin.codegen.StackValue\nimport org.jetbrains.kotlin.psi.KtClassLiteralExpression\nimport org.jetbrains.kotlin.resolve.BindingContext.DOUBLE_COLON_LHS\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\nimport org.jetbrains.kotlin.resolve.isInlineClassType\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes\nimport org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver\nimport org.jetbrains.kotlin.types.TypeUtils\nimport org.jetbrains.kotlin.types.expressions.DoubleColonLHS\nimport org.jetbrains.org.objectweb.asm.Type\n\nclass KClassJavaPrimitiveTypeProperty : IntrinsicPropertyGetter() {\n    override fun generate(resolvedCall: ResolvedCall<*>?, codegen: ExpressionCodegen, returnType: Type, receiver: StackValue): StackValue? {\n        val receiverValue = reso"}
{"code": "lvedCall!!.extensionReceiver as? ExpressionReceiver ?: return null\n        val classLiteralExpression = receiverValue.expression as? KtClassLiteralExpression ?: return null\n        val receiverExpression = classLiteralExpression.receiverExpression ?: return null\n        val lhs = codegen.bindingContext.get(DOUBLE_COLON_LHS, receiverExpression) ?: return null\n        if (TypeUtils.isTypeParameter(lhs.type)) {\n            // TODO: add new operation kind to ReifiedTypeInliner.OperationKind to generate a null value or a field access to TYPE\n            return null\n        }\n        if (lhs is DoubleColonLHS.Expression && !lhs.isObjectQualifier) {\n            val receiverType = codegen.bindingContext.getType(receiverExpression) ?: return null\n            if (!KotlinBuiltIns.isPrimitiveTypeOrNullablePrimitiveType(receiverType)) return null\n        }\n\n        val lhsType = codegen.asmType(lhs.type)\n        return StackValue.operation(returnType) { iv ->\n            when {\n                lhs "}
{"code": "is DoubleColonLHS.Expression && !lhs.isObjectQualifier -> {\n                    codegen.gen(receiverExpression).put(lhsType, iv)\n                    AsmUtil.pop(iv, lhsType)\n                    if (lhs.type.isInlineClassType())\n                        iv.aconst(null)\n                    else\n                        iv.getstatic(AsmUtil.boxType(lhsType).internalName, \"TYPE\", \"Ljava/lang/Class;\")\n                }\n\n                !lhs.type.isInlineClassType() && isPrimitiveOrWrapper(lhsType) -> {\n                    iv.getstatic(AsmUtil.boxType(lhsType).internalName, \"TYPE\", \"Ljava/lang/Class;\")\n                }\n\n                else -> iv.aconst(null)\n            }\n        }\n    }\n\n    private fun isPrimitiveOrWrapper(lhsType: Type) =\n        AsmUtil.isPrimitive(lhsType) || AsmUtil.unboxPrimitiveTypeOrNull(lhsType) != null || AsmTypes.VOID_WRAPPER_TYPE == lhsType\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.lazy.descriptors\n\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind.DELEGATION\nimport org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind.FAKE_OVERRIDE\nimport org.jetbrains.kotlin.descriptors.impl.ClassConstructorDescriptorImpl\nimport org.jetbrains.kotlin.descriptors.impl.FunctionDescriptorImpl\nimport org.jetbrains.kotlin.diagnostics.DiagnosticSink\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.diagnostics.reportOnDeclarationAs\nimport org.jetbrains.kotlin.diagnostics.reportOnDeclarationOrFail\nimport org.jetbrains.kotlin.incremental.components.LookupLocation\nimport org.jetbrains.kotlin.incremental.components.NoLookupLocation\nimport org.jetbrains.kotlin.incremental.record\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtClassOrObject\nimport org.jetbrains.kotlin.psi.KtDeclaratio"}
{"code": "n\nimport org.jetbrains.kotlin.psi.KtTypeReference\nimport org.jetbrains.kotlin.resolve.*\nimport org.jetbrains.kotlin.resolve.lazy.LazyClassContext\nimport org.jetbrains.kotlin.resolve.lazy.declarations.ClassMemberDeclarationProvider\nimport org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter\nimport org.jetbrains.kotlin.resolve.scopes.LexicalScope\nimport org.jetbrains.kotlin.resolve.scopes.MemberScope.Companion.ALL_NAME_FILTER\nimport org.jetbrains.kotlin.storage.NotNullLazyValue\nimport org.jetbrains.kotlin.storage.NullableLazyValue\nimport org.jetbrains.kotlin.storage.getValue\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.kotlin.types.TypeRefinement\nimport org.jetbrains.kotlin.types.checker.KotlinTypeRefiner\nimport org.jetbrains.kotlin.types.checker.NewKotlinTypeCheckerImpl\nimport org.jetbrains.kotlin.utils.addToStdlib.flatMapToNullable\n\nopen class LazyClassMemberScope(\n    c: LazyClassContext,\n    declarationProvider: ClassMemberDeclarationProvider,\n    thisClass: "}
{"code": "ClassDescriptorWithResolutionScopes,\n    trace: BindingTrace,\n    private val kotlinTypeRefiner: KotlinTypeRefiner = c.kotlinTypeCheckerOfOwnerModule.kotlinTypeRefiner,\n    scopeForDeclaredMembers: LazyClassMemberScope? = null\n) : AbstractLazyMemberScope<ClassDescriptorWithResolutionScopes, ClassMemberDeclarationProvider>(\n    c, declarationProvider, thisClass, trace, scopeForDeclaredMembers\n) {\n\n    private val allDescriptors = storageManager.createLazyValue {\n        doDescriptors(ALL_NAME_FILTER)\n    }\n\n    private fun doDescriptors(nameFilter: (Name) -> Boolean): List<DeclarationDescriptor> {\n        val result = computeDescriptorsFromDeclaredElements(\n            DescriptorKindFilter.ALL,\n            nameFilter,\n            NoLookupLocation.WHEN_GET_ALL_DESCRIPTORS\n        )\n        computeExtraDescriptors(result, NoLookupLocation.FOR_ALREADY_TRACKED)\n        return result.toList()\n    }\n\n    private val allClassifierDescriptors = storageManager.createLazyValue {\n        doClassif"}
{"code": "ierDescriptors(ALL_NAME_FILTER)\n    }\n\n    private fun doClassifierDescriptors(nameFilter: (Name) -> Boolean): List<DeclarationDescriptor> {\n        val result = computeDescriptorsFromDeclaredElements(\n            DescriptorKindFilter.CLASSIFIERS,\n            nameFilter,\n            NoLookupLocation.WHEN_GET_ALL_DESCRIPTORS\n        )\n        addSyntheticCompanionObject(result, NoLookupLocation.FOR_ALREADY_TRACKED)\n        addSyntheticNestedClasses(result, NoLookupLocation.FOR_ALREADY_TRACKED)\n        return result.toList()\n    }\n\n    override fun getContributedDescriptors(\n        kindFilter: DescriptorKindFilter,\n        nameFilter: (Name) -> Boolean\n    ): Collection<DeclarationDescriptor> = when (kindFilter) {\n        DescriptorKindFilter.CLASSIFIERS ->\n            if (nameFilter == ALL_NAME_FILTER || allClassifierDescriptors.isComputed() || allClassifierDescriptors.isComputing()) {\n                allClassifierDescriptors()\n            } else {\n                storageManager.comput"}
{"code": "e {\n                    doClassifierDescriptors(nameFilter)\n                }\n            }\n        else ->\n            if (nameFilter == ALL_NAME_FILTER || allDescriptors.isComputed() || allDescriptors.isComputing()) {\n                allDescriptors()\n            } else {\n                storageManager.compute {\n                    doDescriptors(nameFilter)\n                }\n            }\n    }\n\n    protected open fun computeExtraDescriptors(result: MutableCollection<DeclarationDescriptor>, location: LookupLocation) {\n        for (supertype in supertypes) {\n            for (descriptor in supertype.memberScope.getContributedDescriptors()) {\n                if (descriptor is FunctionDescriptor) {\n                    result.addAll(getContributedFunctions(descriptor.name, location))\n                } else if (descriptor is PropertyDescriptor) {\n                    result.addAll(getContributedVariables(descriptor.name, location))\n                }\n                // Nothing else is inherit"}
{"code": "ed\n            }\n        }\n\n        addDataClassMethods(result, location)\n        addSyntheticFunctions(result, location)\n        addSyntheticVariables(result, location)\n        addSyntheticCompanionObject(result, location)\n        addSyntheticNestedClasses(result, location)\n    }\n\n    val supertypes by storageManager.createLazyValue {\n        @OptIn(TypeRefinement::class)\n        kotlinTypeRefiner.refineSupertypes(thisDescriptor)\n    }\n\n    private val _variableNames: MutableSet<Name>\n            by storageManager.createLazyValue {\n                mutableSetOf<Name>().apply {\n                    addAll(declarationProvider.getDeclarationNames())\n                    addAll(c.syntheticResolveExtension.getSyntheticPropertiesNames(thisDescriptor))\n                    supertypes.flatMapTo(this) {\n                        it.memberScope.getVariableNames()\n                    }\n                }\n            }\n\n    private val _functionNames: MutableSet<Name>\n            by storageManager.creat"}
{"code": "eLazyValue {\n                mutableSetOf<Name>().apply {\n                    addAll(declarationProvider.getDeclarationNames())\n                    addAll(c.syntheticResolveExtension.getSyntheticFunctionNames(thisDescriptor))\n                    supertypes.flatMapTo(this) {\n                        it.memberScope.getFunctionNames()\n                    }\n\n                    addAll(getDataClassRelatedFunctionNames())\n                }\n            }\n\n    private val _classifierNames: Set<Name>?\n            by storageManager.createNullableLazyValue {\n                mutableSetOf<Name>().apply {\n                    supertypes.flatMapToNullable(this) {\n                        it.memberScope.getClassifierNames()\n                    } ?: return@createNullableLazyValue null\n\n                    addAll(declarationProvider.getDeclarationNames())\n                    with(c.syntheticResolveExtension) {\n                        getPossibleSyntheticNestedClassNames(thisDescriptor)?.let { addAll(it) } "}
{"code": "?: return@createNullableLazyValue null\n                        getSyntheticCompanionObjectNameIfNeeded(thisDescriptor)?.let { add(it) }\n                    }\n                }\n            }\n\n    private val _allNames: Set<Name>?\n            by storageManager.createNullableLazyValue {\n                val classifiers = getClassifierNames() ?: return@createNullableLazyValue null\n\n                mutableSetOf<Name>().apply {\n                    addAll(getVariableNames())\n                    addAll(getFunctionNames())\n                    addAll(classifiers)\n                }\n            }\n\n    private fun getDataClassRelatedFunctionNames(): Collection<Name> {\n        val declarations = mutableListOf<DeclarationDescriptor>()\n        addDataClassMethods(declarations, NoLookupLocation.WHEN_GET_ALL_DESCRIPTORS)\n        return declarations.map { it.name }\n    }\n\n    override fun getVariableNames() = _variableNames\n    override fun getFunctionNames() = _functionNames\n    override fun getClassifie"}
{"code": "rNames() = _classifierNames\n\n    override fun definitelyDoesNotContainName(name: Name): Boolean {\n        return _allNames?.let { name !in it } ?: false\n    }\n\n    private interface MemberExtractor<out T : CallableMemberDescriptor> {\n        fun extract(extractFrom: KotlinType, name: Name): Collection<T>\n    }\n\n    private val primaryConstructor: NullableLazyValue<ClassConstructorDescriptor> =\n        c.storageManager.createNullableLazyValue { resolvePrimaryConstructor() }\n\n    override fun getScopeForMemberDeclarationResolution(declaration: KtDeclaration): LexicalScope =\n        thisDescriptor.scopeForMemberDeclarationResolution\n\n    override fun getScopeForInitializerResolution(declaration: KtDeclaration): LexicalScope =\n        thisDescriptor.scopeForInitializerResolution\n\n    private fun <D : CallableMemberDescriptor> generateFakeOverrides(\n        name: Name,\n        fromSupertypes: Collection<D>,\n        result: MutableCollection<D>,\n        exactDescriptorClass: Class<out D>\n   "}
{"code": " ) {\n        NewKotlinTypeCheckerImpl(kotlinTypeRefiner).overridingUtil.generateOverridesInFunctionGroup(\n            name,\n            fromSupertypes,\n            ArrayList(result),\n            thisDescriptor,\n            object : OverridingStrategy() {\n                override fun addFakeOverride(fakeOverride: CallableMemberDescriptor) {\n                    assert(exactDescriptorClass.isInstance(fakeOverride)) { \"Wrong descriptor type in an override: \" + fakeOverride + \" while expecting \" + exactDescriptorClass.simpleName }\n                    @Suppress(\"UNCHECKED_CAST\")\n                    result.add(fakeOverride as D)\n                }\n\n                override fun overrideConflict(\n                    fromSuper: CallableMemberDescriptor,\n                    fromCurrent: CallableMemberDescriptor\n                ) {\n                    reportOnDeclarationOrFail(\n                        trace,\n                        fromCurrent\n                    ) { Errors.CONFLICTING_OVERLOADS.on"}
{"code": "(it, listOf(fromCurrent, fromSuper)) }\n                }\n\n                override fun inheritanceConflict(\n                    first: CallableMemberDescriptor,\n                    second: CallableMemberDescriptor\n                ) {\n                    reportOnDeclarationAs<KtClassOrObject>(\n                        trace,\n                        thisDescriptor\n                    ) { ktClassOrObject ->\n                        Errors.CONFLICTING_INHERITED_MEMBERS.on(\n                            ktClassOrObject,\n                            thisDescriptor,\n                            listOf(first, second)\n                        )\n                    }\n                }\n            })\n        for (descriptor in result) {\n            if (descriptor !is FunctionDescriptorImpl) continue\n            for (overriddenFunction in descriptor.overriddenDescriptors) {\n                if (overriddenFunction !is FunctionDescriptorImpl) continue\n                val conflictedDescriptor = overriddenFun"}
{"code": "ction.getUserData(DeserializedDeclarationsFromSupertypeConflictDataKey) ?: continue\n                reportOnDeclarationAs<KtClassOrObject>(\n                    trace,\n                    thisDescriptor\n                ) { ktClassOrObject ->\n                    Errors.CONFLICTING_INHERITED_MEMBERS_WARNING.on(\n                        ktClassOrObject,\n                        thisDescriptor,\n                        listOf(overriddenFunction, conflictedDescriptor)\n                    )\n                }\n            }\n        }\n        OverrideResolver.resolveUnknownVisibilities(result, trace)\n    }\n\n    override fun getContributedFunctions(name: Name, location: LookupLocation): Collection<SimpleFunctionDescriptor> {\n        // TODO: this should be handled by lazy function descriptors\n        val functions = super.getContributedFunctions(name, location)\n        resolveUnknownVisibilitiesForMembers(functions)\n        return functions\n    }\n\n    override fun getNonDeclaredClasses(name: Name, r"}
{"code": "esult: MutableSet<ClassDescriptor>) {\n        generateSyntheticCompanionObject(name, result)\n        c.syntheticResolveExtension.generateSyntheticClasses(thisDescriptor, name, c, declarationProvider, result)\n    }\n\n    override fun getNonDeclaredFunctions(name: Name, result: MutableSet<SimpleFunctionDescriptor>) {\n        val location = NoLookupLocation.FOR_ALREADY_TRACKED\n\n        val fromSupertypes = arrayListOf<SimpleFunctionDescriptor>()\n        for (supertype in supertypes) {\n            fromSupertypes.addAll(supertype.memberScope.getContributedFunctions(name, location))\n        }\n        result.addAll(generateDelegatingDescriptors(name, EXTRACT_FUNCTIONS, result))\n        generateDataClassMethods(result, name, location, fromSupertypes)\n        generateFunctionsFromAnyForValueClass(result, name, fromSupertypes)\n        c.syntheticResolveExtension.generateSyntheticMethods(thisDescriptor, name, trace.bindingContext, fromSupertypes, result)\n\n        c.additionalClassPartsProvider.gen"}
{"code": "erateAdditionalMethods(thisDescriptor, result, name, location, fromSupertypes)\n\n        generateFakeOverrides(name, fromSupertypes, result, SimpleFunctionDescriptor::class.java)\n    }\n\n    private fun generateFunctionsFromAnyForValueClass(\n        result: MutableCollection<SimpleFunctionDescriptor>,\n        name: Name,\n        fromSupertypes: List<SimpleFunctionDescriptor>\n    ) {\n        if (!thisDescriptor.isValueClass()) return\n        FunctionsFromAny.addFunctionFromAnyIfNeeded(thisDescriptor, result, name, fromSupertypes)\n    }\n\n    private fun generateDataClassMethods(\n        result: MutableCollection<SimpleFunctionDescriptor>,\n        name: Name,\n        location: LookupLocation,\n        fromSupertypes: List<SimpleFunctionDescriptor>\n    ) {\n        if (!thisDescriptor.isData) return\n\n        val constructor = getPrimaryConstructor() ?: return\n        val primaryConstructorParameters = declarationProvider.primaryConstructorParameters\n\n        assert(constructor.valueParameters."}
{"code": "size == primaryConstructorParameters.size) { \"From descriptor: \" + constructor.valueParameters.size + \" but from PSI: \" + primaryConstructorParameters.size }\n\n        if (DataClassDescriptorResolver.isComponentLike(name)) {\n            var componentIndex = 0\n\n            for (parameter in constructor.valueParameters) {\n                if (!primaryConstructorParameters.get(parameter.index).hasValOrVar()) continue\n\n                val properties = getContributedVariables(parameter.name, location)\n                val property = properties.firstOrNull { it.extensionReceiverParameter == null } ?: continue\n\n                ++componentIndex\n\n                if (name == DataClassDescriptorResolver.createComponentName(componentIndex)) {\n                    result.add(\n                        DataClassDescriptorResolver.createComponentFunctionDescriptor(\n                            componentIndex, property, parameter, thisDescriptor, trace\n                        )\n                    )\n        "}
{"code": "            break\n                }\n            }\n        }\n\n        if (name == DataClassDescriptorResolver.COPY_METHOD_NAME) {\n            for (parameter in constructor.valueParameters) {\n                // force properties resolution to fill BindingContext.VALUE_PARAMETER_AS_PROPERTY slice\n                getContributedVariables(parameter.name, location)\n            }\n\n            result.add(DataClassDescriptorResolver.createCopyFunctionDescriptor(constructor.valueParameters, thisDescriptor, trace))\n        }\n\n        if (c.languageVersionSettings.supportsFeature(LanguageFeature.DataClassInheritance)) {\n            FunctionsFromAny.addFunctionFromAnyIfNeeded(thisDescriptor, result, name, fromSupertypes)\n        }\n    }\n\n    private fun addSyntheticCompanionObject(result: MutableCollection<DeclarationDescriptor>, location: LookupLocation) {\n        val syntheticCompanionName = c.syntheticResolveExtension.getSyntheticCompanionObjectNameIfNeeded(thisDescriptor) ?: return\n        val de"}
{"code": "scriptor = getContributedClassifier(syntheticCompanionName, location) ?: return\n        result.add(descriptor)\n    }\n\n    private fun addSyntheticFunctions(result: MutableCollection<DeclarationDescriptor>, location: LookupLocation) {\n        result.addAll(c.syntheticResolveExtension.getSyntheticFunctionNames(thisDescriptor).flatMap {\n            getContributedFunctions(\n                it,\n                location\n            )\n        }.toList())\n    }\n\n    private fun addSyntheticVariables(result: MutableCollection<DeclarationDescriptor>, location: LookupLocation) {\n        result.addAll(c.syntheticResolveExtension.getSyntheticPropertiesNames(thisDescriptor).flatMap {\n            getContributedVariables(\n                it,\n                location\n            )\n        }.toList())\n    }\n\n    private fun addSyntheticNestedClasses(result: MutableCollection<DeclarationDescriptor>, location: LookupLocation) {\n        result.addAll(c.syntheticResolveExtension.getSyntheticNestedClassNames"}
{"code": "(thisDescriptor).mapNotNull {\n            getContributedClassifier(\n                it,\n                location\n            )\n        }.toList())\n    }\n\n    private fun generateSyntheticCompanionObject(name: Name, result: MutableSet<ClassDescriptor>) {\n        val syntheticCompanionName = c.syntheticResolveExtension.getSyntheticCompanionObjectNameIfNeeded(thisDescriptor) ?: return\n        if (name == syntheticCompanionName && result.none { it.isCompanionObject }) {\n            // forces creation of companion object if needed\n            val companionObjectDescriptor = thisDescriptor.companionObjectDescriptor ?: return\n            result.add(companionObjectDescriptor)\n        }\n    }\n\n    override fun getContributedVariables(name: Name, location: LookupLocation): Collection<PropertyDescriptor> {\n        // TODO: this should be handled by lazy property descriptors\n        val properties = super.getContributedVariables(name, location)\n        resolveUnknownVisibilitiesForMembers(properti"}
{"code": "es as Collection<CallableMemberDescriptor>)\n        return properties\n    }\n\n    private fun resolveUnknownVisibilitiesForMembers(descriptors: Collection<CallableMemberDescriptor>) {\n        for (descriptor in descriptors) {\n            if (descriptor.kind != FAKE_OVERRIDE && descriptor.kind != DELEGATION) {\n                OverridingUtil.resolveUnknownVisibilityForMember(descriptor, OverrideResolver.createCannotInferVisibilityReporter(trace))\n            }\n            VarianceCheckerCore(trace.bindingContext, DiagnosticSink.DO_NOTHING).recordPrivateToThisIfNeeded(descriptor)\n        }\n    }\n\n    override fun getNonDeclaredProperties(name: Name, result: MutableSet<PropertyDescriptor>) {\n        createPropertiesFromPrimaryConstructorParameters(name, result)\n\n        // Members from supertypes\n        val fromSupertypes = ArrayList<PropertyDescriptor>()\n        for (supertype in supertypes) {\n            fromSupertypes.addAll(supertype.memberScope.getContributedVariables(name, NoLookupLo"}
{"code": "cation.FOR_ALREADY_TRACKED))\n        }\n        result.addAll(generateDelegatingDescriptors(name, EXTRACT_PROPERTIES, result))\n        c.syntheticResolveExtension.generateSyntheticProperties(thisDescriptor, name, trace.bindingContext, fromSupertypes, result)\n        generateFakeOverrides(name, fromSupertypes, result, PropertyDescriptor::class.java)\n    }\n\n    protected open fun createPropertiesFromPrimaryConstructorParameters(name: Name, result: MutableSet<PropertyDescriptor>) {\n\n        // From primary constructor parameters\n        val primaryConstructor = getPrimaryConstructor() ?: return\n\n        val valueParameterDescriptors = primaryConstructor.valueParameters\n        val primaryConstructorParameters = declarationProvider.primaryConstructorParameters\n        assert(valueParameterDescriptors.size == primaryConstructorParameters.size) {\n            \"From descriptor: ${valueParameterDescriptors.size} but from PSI: ${primaryConstructorParameters.size}\"\n        }\n\n        for (valuePar"}
{"code": "ameterDescriptor in valueParameterDescriptors) {\n            if (name != valueParameterDescriptor.name) continue\n\n            val parameter = primaryConstructorParameters.get(valueParameterDescriptor.index)\n            if (parameter.hasValOrVar()) {\n                val propertyDescriptor =\n                    trace.get(BindingContext.PRIMARY_CONSTRUCTOR_PARAMETER, parameter)\n                        ?: c.descriptorResolver.resolvePrimaryConstructorParameterToAProperty(\n                            // TODO: can't test because we get types from cache for this case\n                            thisDescriptor, valueParameterDescriptor, thisDescriptor.scopeForConstructorHeaderResolution, parameter, trace\n                        )\n                result.add(propertyDescriptor)\n            }\n        }\n    }\n\n    private fun <T : CallableMemberDescriptor> generateDelegatingDescriptors(\n        name: Name,\n        extractor: MemberExtractor<T>,\n        existingDescriptors: Collection<CallableDescr"}
{"code": "iptor>\n    ): Collection<T> {\n        val classOrObject = declarationProvider.correspondingClassOrObject ?: return setOf()\n\n        val lazyTypeResolver = object : DelegationResolver.TypeResolver {\n            override fun resolve(reference: KtTypeReference): KotlinType? =\n                c.typeResolver.resolveType(thisDescriptor.scopeForClassHeaderResolution, reference, trace, false)\n        }\n        val lazyMemberExtractor = object : DelegationResolver.MemberExtractor<T> {\n            override fun getMembersByType(type: KotlinType): Collection<T> =\n                extractor.extract(type, name)\n        }\n        return DelegationResolver.generateDelegatedMembers(\n            classOrObject, thisDescriptor, existingDescriptors, trace, lazyMemberExtractor,\n            lazyTypeResolver, c.delegationFilter, c.languageVersionSettings\n        )\n    }\n\n    private fun addDataClassMethods(result: MutableCollection<DeclarationDescriptor>, location: LookupLocation) {\n        if (!thisDescriptor"}
{"code": ".isData || thisDescriptor.kind != ClassKind.CLASS) return\n\n        if (getPrimaryConstructor() == null) return\n\n        // Generate componentN functions until there's no such function for some n\n        var n = 1\n        while (true) {\n            val componentName = DataClassDescriptorResolver.createComponentName(n)\n            val functions = getContributedFunctions(componentName, location)\n            if (functions.isEmpty()) break\n\n            result.addAll(functions)\n\n            n++\n        }\n        result.addAll(getContributedFunctions(Name.identifier(\"copy\"), location))\n    }\n\n    private val secondaryConstructors: NotNullLazyValue<Collection<ClassConstructorDescriptor>> =\n        c.storageManager.createLazyValue { doGetConstructors() }\n\n    private fun doGetConstructors(): Collection<ClassConstructorDescriptor> {\n        val result = mutableListOf<ClassConstructorDescriptor>()\n        result.addAll(resolveSecondaryConstructors())\n        addSyntheticSecondaryConstructors(resu"}
{"code": "lt)\n        return result\n    }\n\n    private fun addSyntheticSecondaryConstructors(result: MutableCollection<ClassConstructorDescriptor>) {\n        c.syntheticResolveExtension.generateSyntheticSecondaryConstructors(thisDescriptor, trace.bindingContext, result)\n    }\n\n    fun getConstructors(): Collection<ClassConstructorDescriptor> {\n        val result = (mainScope as LazyClassMemberScope?)?.secondaryConstructors?.invoke() ?: secondaryConstructors()\n        val primaryConstructor = getPrimaryConstructor()\n        return if (primaryConstructor == null) result else result + primaryConstructor\n    }\n\n    fun getPrimaryConstructor(): ClassConstructorDescriptor? =\n        (mainScope as LazyClassMemberScope?)?.primaryConstructor?.invoke() ?: primaryConstructor()\n\n    protected open fun resolvePrimaryConstructor(): ClassConstructorDescriptor? {\n        val classOrObject = declarationProvider.correspondingClassOrObject ?: return null\n\n        val hasPrimaryConstructor = classOrObject.hasExplic"}
{"code": "itPrimaryConstructor()\n        if (!hasPrimaryConstructor) {\n            if (thisDescriptor.isExpect && !DescriptorUtils.isEnumEntry(thisDescriptor)) return null\n            if (DescriptorUtils.isInterface(thisDescriptor)) return null\n        }\n\n        if (DescriptorUtils.canHaveDeclaredConstructors(thisDescriptor) || hasPrimaryConstructor) {\n            val constructor = c.functionDescriptorResolver.resolvePrimaryConstructorDescriptor(\n                thisDescriptor.scopeForConstructorHeaderResolution, thisDescriptor,\n                classOrObject, trace, c.languageVersionSettings, c.inferenceSession\n            )\n            constructor ?: return null\n            setDeferredReturnType(constructor)\n            return constructor\n        }\n\n        val constructor = DescriptorResolver.createAndRecordPrimaryConstructorForObject(classOrObject, thisDescriptor, trace)\n        setDeferredReturnType(constructor)\n        return constructor\n    }\n\n    private fun resolveSecondaryConstructors("}
{"code": "): Collection<ClassConstructorDescriptor> {\n        val classOrObject = declarationProvider.correspondingClassOrObject ?: return emptyList()\n\n        return classOrObject.secondaryConstructors.map { constructor ->\n            val descriptor = c.functionDescriptorResolver.resolveSecondaryConstructorDescriptor(\n                thisDescriptor.scopeForConstructorHeaderResolution, thisDescriptor,\n                constructor, trace, c.languageVersionSettings, c.inferenceSession\n            )\n            setDeferredReturnType(descriptor)\n            descriptor\n        }\n    }\n\n    protected fun setDeferredReturnType(descriptor: ClassConstructorDescriptorImpl) {\n        descriptor.returnType = c.wrappedTypeFactory.createDeferredType(trace, { thisDescriptor.defaultType })\n    }\n\n    override fun recordLookup(name: Name, location: LookupLocation) {\n        c.lookupTracker.record(location, thisDescriptor, name)\n    }\n\n    // Do not add details here, they may compromise the laziness during debuggi"}
{"code": "ng\n    override fun toString() = \"lazy scope for class ${thisDescriptor.name}\"\n\n    companion object {\n        private val EXTRACT_FUNCTIONS: MemberExtractor<SimpleFunctionDescriptor> = object : MemberExtractor<SimpleFunctionDescriptor> {\n            override fun extract(extractFrom: KotlinType, name: Name): Collection<SimpleFunctionDescriptor> {\n                return extractFrom.memberScope.getContributedFunctions(name, NoLookupLocation.FOR_ALREADY_TRACKED)\n            }\n        }\n\n        private val EXTRACT_PROPERTIES: MemberExtractor<PropertyDescriptor> = object : MemberExtractor<PropertyDescriptor> {\n            override fun extract(extractFrom: KotlinType, name: Name): Collection<PropertyDescriptor> {\n                return extractFrom.memberScope.getContributedVariables(name, NoLookupLocation.FOR_ALREADY_TRACKED)\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.transformers.body.resolve\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fakeElement\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.copyWithNewSource\nimport org.jetbrains.kotlin.fir.declarations.FirValueParameter\nimport org.jetbrains.kotlin.fir.diagnostics.ConeSimpleDiagnostic\nimport org.jetbrains.kotlin.fir.diagnostics.DiagnosticKind\nimport org.jetbrains.kotlin.fir.expressions.FirBlock\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.expressions.FirNamedArgumentExpression\nimport org.jetbrains.kotlin.fir.expressions.UnresolvedExpressionTypeAccess\nimport org.jetbrains.kotlin.fir.expressions.builder.buildSpreadArgumentExpression\nimport org.jetbrains.kotlin.fir.expressions.builder.buildVarargArgumentsExpression\nimport org.jetbrains.kotlin.fir.resolve.providers.symbolProvider\nimport org.jetbrains.kotlin"}
{"code": ".fir.types.*\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.StandardClassIds\nimport org.jetbrains.kotlin.types.ConstantValueKind\n\n\ninternal inline var FirExpression.resultType: ConeKotlinType\n    get() = resolvedType\n    set(type) {\n        replaceConeTypeOrNull(type)\n    }\n\ninternal fun remapArgumentsWithVararg(\n    varargParameter: FirValueParameter,\n    varargArrayType: ConeKotlinType,\n    argumentMapping: LinkedHashMap<FirExpression, FirValueParameter>\n): LinkedHashMap<FirExpression, FirValueParameter> {\n    // Create a FirVarargArgumentExpression for the vararg arguments.\n    // The order of arguments in the mapping must be preserved for FIR2IR, hence we have to find where the vararg arguments end.\n    // FIR2IR uses the mapping order to determine if arguments need to be reordered.\n    val varargElementType = varargArrayType.arrayElementType()?.approximateIntegerLiteralType()\n    val argumentList = argumentMapping.keys.toList()\n    var indexAfterVarargs "}
{"code": "= argumentList.size\n    val newArgumentMapping = linkedMapOf<FirExpression, FirValueParameter>()\n    val varargArgument = buildVarargArgumentsExpression {\n        coneElementTypeOrNull = varargElementType\n        coneTypeOrNull = varargArrayType\n        var startOffset = Int.MAX_VALUE\n        var endOffset = 0\n        var firstVarargElementSource: KtSourceElement? = null\n\n        for ((i, arg) in argumentList.withIndex()) {\n            val valueParameter = argumentMapping.getValue(arg)\n            // Collect arguments if `arg` is a vararg argument of interest or other vararg arguments.\n            if (valueParameter == varargParameter ||\n                // NB: don't pull out of named arguments.\n                (valueParameter.isVararg && arg !is FirNamedArgumentExpression)\n            ) {\n                arguments += if (arg is FirNamedArgumentExpression) {\n                    buildSpreadArgumentExpression {\n                        this.source = arg.source\n                        this."}
{"code": "expression = arg.expression\n                        this.isNamed = true\n                        this.isFakeSpread = !arg.isSpread\n                    }\n                } else {\n                    arg\n                }\n                startOffset = minOf(startOffset, arg.source?.startOffset ?: Int.MAX_VALUE)\n                endOffset = maxOf(endOffset, arg.source?.endOffset ?: 0)\n                if (firstVarargElementSource == null) firstVarargElementSource = arg.source\n            } else if (arguments.isEmpty()) {\n                // `arg` is BEFORE the vararg arguments.\n                newArgumentMapping[arg] = valueParameter\n            } else {\n                // `arg` is AFTER the vararg arguments.\n                indexAfterVarargs = i\n                break\n            }\n        }\n\n        source = firstVarargElementSource?.fakeElement(KtFakeSourceElementKind.VarargArgument, startOffset, endOffset)\n    }\n    newArgumentMapping[varargArgument] = varargParameter\n\n    // Add mapping f"}
{"code": "or arguments after the vararg arguments, if any.\n    for (i in indexAfterVarargs until argumentList.size) {\n        val arg = argumentList[i]\n        newArgumentMapping[arg] = argumentMapping.getValue(arg)\n    }\n    return newArgumentMapping\n}\n\nfun FirBlock.writeResultType(session: FirSession) {\n    val resultExpression = when (val statement = statements.lastOrNull()) {\n        is FirExpression -> statement\n        else -> null\n    }\n\n    // If a lambda contains another lambda as result expression, it won't be resolved at this point\n    @OptIn(UnresolvedExpressionTypeAccess::class)\n    resultType = resultExpression?.coneTypeOrNull ?: session.builtinTypes.unitType.type\n}\n\nfun ConstantValueKind<*>.expectedConeType(session: FirSession): ConeKotlinType {\n    fun constructLiteralType(classId: ClassId, isNullable: Boolean = false): ConeKotlinType {\n        val symbol = session.symbolProvider.getClassLikeSymbolByClassId(classId)\n            ?: return ConeErrorType(ConeSimpleDiagnostic(\"Missin"}
{"code": "g stdlib class: $classId\", DiagnosticKind.MissingStdlibClass))\n        return symbol.toLookupTag().constructClassType(ConeTypeProjection.EMPTY_ARRAY, isNullable)\n    }\n    return when (this) {\n        ConstantValueKind.Null -> session.builtinTypes.nullableNothingType.type\n        ConstantValueKind.Boolean -> session.builtinTypes.booleanType.type\n        ConstantValueKind.Char -> constructLiteralType(StandardClassIds.Char)\n        ConstantValueKind.Byte -> constructLiteralType(StandardClassIds.Byte)\n        ConstantValueKind.Short -> constructLiteralType(StandardClassIds.Short)\n        ConstantValueKind.Int -> constructLiteralType(StandardClassIds.Int)\n        ConstantValueKind.Long -> constructLiteralType(StandardClassIds.Long)\n        ConstantValueKind.String -> constructLiteralType(StandardClassIds.String)\n        ConstantValueKind.Float -> constructLiteralType(StandardClassIds.Float)\n        ConstantValueKind.Double -> constructLiteralType(StandardClassIds.Double)\n\n        ConstantV"}
{"code": "alueKind.UnsignedByte -> constructLiteralType(StandardClassIds.UByte)\n        ConstantValueKind.UnsignedShort -> constructLiteralType(StandardClassIds.UShort)\n        ConstantValueKind.UnsignedInt -> constructLiteralType(StandardClassIds.UInt)\n        ConstantValueKind.UnsignedLong -> constructLiteralType(StandardClassIds.ULong)\n\n        ConstantValueKind.IntegerLiteral -> constructLiteralType(StandardClassIds.Int)\n        ConstantValueKind.UnsignedIntegerLiteral -> constructLiteralType(StandardClassIds.UInt)\n        ConstantValueKind.Error -> error(\"Unexpected error ConstantValueKind\")\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.expression\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.checkForLocalRedeclarations\nimport org.jetbrains.kotlin.fir.analysis.checkers.collectConflictingLocalFunctionsFrom\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.getDestructuredParameter\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirVariable\nimport org.jetbrains.kotlin.fir.expressions.FirBlock\nimport org.jetbrains.kotlin.fir.expressions.FirStatement\n\nobject FirConflictsExpressionChecker : FirBlockChecker(MppCheckerKind.Common) {\n    private fun FirStatement.isDestructuredParameter() = this is FirVariable && getDestructuredParameter() != null\n\n    override fun check"}
{"code": "(expression: FirBlock, context: CheckerContext, reporter: DiagnosticReporter) {\n        val elements =\n            if (expression.statements.none { it.isDestructuredParameter() }) expression.statements // optimization\n            else expression.statements.filterNot { it.isDestructuredParameter() }\n        checkForLocalRedeclarations(elements, context, reporter)\n        checkForLocalConflictingFunctions(expression, context, reporter)\n    }\n\n    private fun checkForLocalConflictingFunctions(expression: FirBlock, context: CheckerContext, reporter: DiagnosticReporter) {\n        val conflictingFunctions = collectConflictingLocalFunctionsFrom(expression, context)\n\n        for ((function, otherFunctionsThatConflictWithIt) in conflictingFunctions) {\n            if (otherFunctionsThatConflictWithIt.isEmpty()) {\n                continue\n            }\n\n            reporter.reportOn(function.source, FirErrors.CONFLICTING_OVERLOADS, otherFunctionsThatConflictWithIt, context)\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.declarations.impl\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.builtins.StandardNames\nimport org.jetbrains.kotlin.descriptors.EffectiveVisibility\nimport org.jetbrains.kotlin.descriptors.Modality\nimport org.jetbrains.kotlin.descriptors.Visibility\nimport org.jetbrains.kotlin.fakeElement\nimport org.jetbrains.kotlin.fir.FirImplementationDetail\nimport org.jetbrains.kotlin.fir.FirModuleData\nimport org.jetbrains.kotlin.fir.MutableOrEmptyList\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.declarations.builder.buildDefaultSetterValueParameter\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirBlock\nimport org.jetbrains.kotlin.fir.symbols.impl.FirPropertyAccessorSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirValueParameterSymbol"}
{"code": "\nimport org.jetbrains.kotlin.fir.types.ConeSimpleKotlinType\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.types.impl.FirImplicitUnitTypeRef\n\n@OptIn(FirImplementationDetail::class)\nabstract class FirDefaultPropertyAccessor(\n    source: KtSourceElement?,\n    moduleData: FirModuleData,\n    origin: FirDeclarationOrigin,\n    propertyTypeRef: FirTypeRef,\n    valueParameters: MutableList<FirValueParameter>,\n    propertySymbol: FirPropertySymbol,\n    isGetter: Boolean,\n    visibility: Visibility,\n    modality: Modality = Modality.FINAL,\n    effectiveVisibility: EffectiveVisibility? = null,\n    isInline: Boolean = false,\n    symbol: FirPropertyAccessorSymbol,\n    resolvePhase: FirResolvePhase,\n) : FirPropertyAccessorImpl(\n    source,\n    resolvePhase,\n    moduleData,\n    origin,\n    FirDeclarationAttributes(),\n    status = when (effectiveVisibility) {\n        null -> FirDeclarationStatusImpl(visibility, modality)\n        else -> FirResolvedDeclarationStatusImp"}
{"code": "l(visibility, modality, effectiveVisibility)\n    }.apply {\n        this.isInline = isInline\n    },\n    propertyTypeRef,\n    deprecationsProvider = UnresolvedDeprecationProvider,\n    containerSource = null,\n    dispatchReceiverType = null,\n    contextReceivers = MutableOrEmptyList.empty(),\n    valueParameters,\n    body = null,\n    contractDescription = null,\n    symbol,\n    propertySymbol,\n    isGetter,\n    annotations = MutableOrEmptyList.empty(),\n    typeParameters = mutableListOf(),\n) {\n    override val dispatchReceiverType: ConeSimpleKotlinType?\n        get() = propertySymbol.dispatchReceiverType\n\n    final override var body: FirBlock?\n        get() = null\n        set(_) {}\n\n    companion object {\n        fun createGetterOrSetter(\n            source: KtSourceElement?,\n            moduleData: FirModuleData,\n            origin: FirDeclarationOrigin,\n            propertyTypeRef: FirTypeRef,\n            visibility: Visibility,\n            propertySymbol: FirPropertySymbol,\n            i"}
{"code": "sGetter: Boolean,\n            parameterAnnotations: List<FirAnnotation> = emptyList(),\n        ): FirDefaultPropertyAccessor {\n            return if (isGetter) {\n                FirDefaultPropertyGetter(source, moduleData, origin, propertyTypeRef, visibility, propertySymbol, Modality.FINAL)\n            } else {\n                FirDefaultPropertySetter(\n                    source, moduleData, origin, propertyTypeRef, visibility, propertySymbol, Modality.FINAL,\n                    parameterAnnotations = parameterAnnotations\n                )\n            }\n        }\n    }\n}\n\nclass FirDefaultPropertyGetter(\n    source: KtSourceElement?,\n    moduleData: FirModuleData,\n    origin: FirDeclarationOrigin,\n    propertyTypeRef: FirTypeRef,\n    visibility: Visibility,\n    propertySymbol: FirPropertySymbol,\n    modality: Modality = Modality.FINAL,\n    effectiveVisibility: EffectiveVisibility? = null,\n    isInline: Boolean = false,\n    symbol: FirPropertyAccessorSymbol = FirPropertyAccessorSymbol(),"}
{"code": "\n    resolvePhase: FirResolvePhase = FirResolvePhase.RAW_FIR,\n) : FirDefaultPropertyAccessor(\n    source,\n    moduleData,\n    origin,\n    propertyTypeRef,\n    valueParameters = mutableListOf(),\n    propertySymbol,\n    isGetter = true,\n    visibility = visibility,\n    modality = modality,\n    effectiveVisibility = effectiveVisibility,\n    isInline = isInline,\n    symbol = symbol,\n    resolvePhase = resolvePhase,\n)\n\nclass FirDefaultPropertySetter(\n    source: KtSourceElement?,\n    moduleData: FirModuleData,\n    origin: FirDeclarationOrigin,\n    propertyTypeRef: FirTypeRef,\n    visibility: Visibility,\n    propertySymbol: FirPropertySymbol,\n    modality: Modality = Modality.FINAL,\n    effectiveVisibility: EffectiveVisibility? = null,\n    isInline: Boolean = false,\n    propertyAccessorSymbol: FirPropertyAccessorSymbol = FirPropertyAccessorSymbol(),\n    parameterAnnotations: List<FirAnnotation> = emptyList(),\n    resolvePhase: FirResolvePhase = FirResolvePhase.RAW_FIR,\n) : FirDefaultProperty"}
{"code": "Accessor(\n    source,\n    moduleData,\n    origin,\n    FirImplicitUnitTypeRef(source),\n    valueParameters = mutableListOf(\n        buildDefaultSetterValueParameter builder@{\n            this@builder.resolvePhase = resolvePhase\n            this@builder.source = source?.fakeElement(KtFakeSourceElementKind.DefaultAccessor)\n            this@builder.containingFunctionSymbol = propertyAccessorSymbol\n            this@builder.moduleData = moduleData\n            this@builder.origin = origin\n            this@builder.returnTypeRef = propertyTypeRef\n            this@builder.symbol = FirValueParameterSymbol(StandardNames.DEFAULT_VALUE_PARAMETER)\n            this@builder.annotations += parameterAnnotations\n        }\n    ),\n    propertySymbol,\n    isGetter = false,\n    visibility = visibility,\n    modality = modality,\n    effectiveVisibility = effectiveVisibility,\n    isInline = isInline,\n    symbol = propertyAccessorSymbol,\n    resolvePhase = resolvePhase,\n)\n"}
{"code": "package second\n\nopen class Base<T>\n\nclass MyCla<caret>ss : Base<Base<Int>>() {\n    open class Base<T>\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.serialization\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.resolve.ScopeSession\nimport org.jetbrains.kotlin.fir.serialization.constant.ConstValueProvider\nimport org.jetbrains.kotlin.fir.serialization.constant.ConstValueProviderInternals\nimport org.jetbrains.kotlin.fir.types.ConeErrorType\nimport org.jetbrains.kotlin.fir.types.ConeFlexibleType\nimport org.jetbrains.kotlin.metadata.ProtoBuf\nimport org.jetbrains.kotlin.metadata.deserialization.BinaryVersion\nimport org.jetbrains.kotlin.metadata.serialization.MutableVersionRequirementTable\nimport org.jetbrains.kotlin.name.FqName\n\nabstract class FirSerializerExtension {\n    abstract val session: FirSession\n    abstract val scopeSession: ScopeSession\n\n    abstract val stringTable: FirElementAwareStringTable\n\n    abstract val metadataVersion: BinaryVersion\n\n    val annotationSe"}
{"code": "rializer by lazy { FirAnnotationSerializer(session, scopeSession, stringTable, constValueProvider) }\n\n    abstract val constValueProvider: ConstValueProvider?\n    protected abstract val additionalMetadataProvider: FirAdditionalMetadataProvider?\n\n    @OptIn(ConstValueProviderInternals::class)\n    internal inline fun <T> processFile(firFile: FirFile, crossinline action: () -> T): T {\n        val previousFile = constValueProvider?.processingFirFile\n        constValueProvider?.processingFirFile = firFile\n        return try {\n            action()\n        } finally {\n            constValueProvider?.processingFirFile = previousFile\n        }\n    }\n\n    open fun shouldUseTypeTable(): Boolean = false\n    open fun shouldUseNormalizedVisibility(): Boolean = false\n\n    open fun serializePackage(packageFqName: FqName, proto: ProtoBuf.Package.Builder) {\n    }\n\n    open fun serializeClass(\n        klass: FirClass,\n        proto: ProtoBuf.Class.Builder,\n        versionRequirementTable: MutableVersionR"}
{"code": "equirementTable,\n        childSerializer: FirElementSerializer\n    ) {\n    }\n\n    open fun serializeScript(\n        script: FirScript,\n        proto: ProtoBuf.Class.Builder,\n        versionRequirementTable: MutableVersionRequirementTable,\n        childSerializer: FirElementSerializer\n    ) {\n    }\n\n    open fun serializeConstructor(\n        constructor: FirConstructor,\n        proto: ProtoBuf.Constructor.Builder,\n        childSerializer: FirElementSerializer\n    ) {\n    }\n\n    open fun serializeFunction(\n        function: FirFunction,\n        proto: ProtoBuf.Function.Builder,\n        versionRequirementTable: MutableVersionRequirementTable?,\n        childSerializer: FirElementSerializer\n    ) {\n    }\n\n    open fun serializeProperty(\n        property: FirProperty,\n        proto: ProtoBuf.Property.Builder,\n        versionRequirementTable: MutableVersionRequirementTable?,\n        childSerializer: FirElementSerializer\n    ) {\n    }\n\n    open fun serializeEnumEntry(enumEntry: FirEnumEntry, p"}
{"code": "roto: ProtoBuf.EnumEntry.Builder) {\n    }\n\n    open fun serializeValueParameter(parameter: FirValueParameter, proto: ProtoBuf.ValueParameter.Builder) {\n    }\n\n    open fun serializeFlexibleType(type: ConeFlexibleType, lowerProto: ProtoBuf.Type.Builder, upperProto: ProtoBuf.Type.Builder) {\n    }\n\n    open fun serializeTypeAnnotations(annotations: List<FirAnnotation>, proto: ProtoBuf.Type.Builder) {\n    }\n\n    open fun serializeTypeParameter(typeParameter: FirTypeParameter, proto: ProtoBuf.TypeParameter.Builder) {\n    }\n\n    open fun serializeTypeAlias(typeAlias: FirTypeAlias, proto: ProtoBuf.TypeAlias.Builder) {\n        for (annotation in typeAlias.nonSourceAnnotations(session)) {\n            proto.addAnnotation(annotationSerializer.serializeAnnotation(annotation))\n        }\n    }\n\n    fun hasAdditionalAnnotations(declaration: FirDeclaration): Boolean {\n        return additionalMetadataProvider?.hasGeneratedAnnotationsFor(declaration) ?: false\n    }\n\n    // TODO: add usages\n    fun getA"}
{"code": "nnotationsGeneratedByPlugins(declaration: FirDeclaration): List<FirAnnotation> {\n        return additionalMetadataProvider?.findGeneratedAnnotationsFor(declaration) ?: emptyList()\n    }\n\n    open fun serializeErrorType(type: ConeErrorType, builder: ProtoBuf.Type.Builder) {\n        error(\"Cannot serialize error type: $type\")\n    }\n}\n"}
{"code": "// Lint regression test from https://issuetracker.google.com/127955232\n\n// FILE: call.kt\n\npackage com.example.myapplication\n\nimport test.pkg.Context\nimport test.pkg.R\n\ndata class Test(\n    val context: Context,\n    val testInt: Int,\n    val testString: String = context.<expr>getString</expr>(if (testInt == 0) R.string.test_string_1 else R.string.test_string_2))\n)\n\n// FILE: Context.java\n\npackage test.pkg;\n\npublic final class Context {\n    public String getString(int id) {\n        if (id == R.string.test_string_1) return \"id1\"\n        if (id == R.string.test_string_2) return \"id2\"\n        return \"\";\n    }\n}\n\n// FILE: R.java\n\npackage test.pkg;\n\npublic final class R {\n    public static final class string {\n        public static final int test_string_1 = 0x7f0a000e;\n        public static final int test_string_2 = 0x7f020057;\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.jvm.checkers\n\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaClassDescriptor\nimport org.jetbrains.kotlin.psi.KtClassOrObject\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType\nimport org.jetbrains.kotlin.resolve.checkers.DeclarationChecker\nimport org.jetbrains.kotlin.resolve.checkers.DeclarationCheckerContext\n\nobject ClassInheritsJavaSealedClassChecker : DeclarationChecker {\n    override fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n        if (descriptor !is ClassDescriptor || declaration !is KtClassOrObject) return\n        for (superTypeListEntry in declaration.superTypeListEntries) {\n            val typeReference = superTypeListE"}
{"code": "ntry.typeReference ?: continue\n            val superType = typeReference.getAbbreviatedTypeOrType(context.trace.bindingContext)?.unwrap() ?: continue\n            val superClass = superType.constructor.declarationDescriptor as? LazyJavaClassDescriptor ?: continue\n            if (superClass.jClass.isSealed) {\n                context.trace.report(Errors.CLASS_INHERITS_JAVA_SEALED_CLASS.on(typeReference))\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.scopes\n\nimport org.jetbrains.kotlin.analysis.api.fir.KtFirAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion\nimport org.jetbrains.kotlin.analysis.api.scopes.KtScopeNameFilter\nimport org.jetbrains.kotlin.analysis.api.symbols.KtConstructorSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtPackageSymbol\nimport org.jetbrains.kotlin.fir.scopes.impl.FirDefaultStarImportingScope\nimport org.jetbrains.kotlin.name.Name\n\ninternal class KtFirDefaultStarImportingScope(\n    firScope: FirDefaultStarImportingScope,\n    analysisSession: KtFirAnalysisSession,\n) : KtFirBasedScope<FirDefaultStarImportingScope>(firScope, analysisSession.firSymbolBuilder) {\n\n    private val firstWrappedScope = KtFirStarImportingScope(firScope.first, analysisSession)\n    private val secondWrappedScope = KtFirStarImportingScope(firScope.second, analysisSession)\n\n    override fun getPackageSymbols(nameFilter: KtScopeNameFilter): Sequenc"}
{"code": "e<KtPackageSymbol> = withValidityAssertion {\n        emptySequence()\n    }\n\n    override fun getConstructors(): Sequence<KtConstructorSymbol> = withValidityAssertion { emptySequence() }\n\n    override fun getPossibleCallableNames(): Set<Name> = buildSet {\n        addAll(firstWrappedScope.getPossibleCallableNames())\n        addAll(secondWrappedScope.getPossibleCallableNames())\n    }\n\n    override fun getPossibleClassifierNames(): Set<Name> = buildSet {\n        addAll(firstWrappedScope.getPossibleClassifierNames())\n        addAll(secondWrappedScope.getPossibleClassifierNames())\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.project.structure\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.util.CachedValue\nimport com.intellij.psi.util.CachedValueProvider\nimport com.intellij.psi.util.CachedValuesManager\nimport org.jetbrains.annotations.TestOnly\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.LLFirInternals\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.providers.LLFirBuiltinsAndCloneableSessionProvider\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.sessions.LLFirBuiltinsAndCloneableSession\nimport org.jetbrains.kotlin.analysis.project.structure.KtBuiltinsModule\nimport org.jetbrains.kotlin.analyzer.common.CommonPlatformAnalyzerServices\nimport org.jetbrains.kotlin.config.LanguageVersionSettingsImpl\nimport org.jetbrains.kotlin.fir.BuiltinTypes\nimport org.jetbrains.kotlin.fir.PrivateSessionConstructor\nimport org.jetbrains.kotlin.fir.SessionConfiguration\nimport org.jetbrains.kotlin.fir.backend.jvm.FirJvmTypeMappe"}
{"code": "r\nimport org.jetbrains.kotlin.fir.resolve.providers.FirProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.impl.FirCloneableSymbolProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.impl.FirExtensionSyntheticFunctionInterfaceProvider\nimport org.jetbrains.kotlin.fir.resolve.scopes.wrapScopeWithJvmMapped\nimport org.jetbrains.kotlin.fir.resolve.transformers.FirDummyCompilerLazyDeclarationResolver\nimport org.jetbrains.kotlin.fir.scopes.FirKotlinScopeProvider\nimport org.jetbrains.kotlin.fir.session.*\nimport org.jetbrains.kotlin.fir.symbols.FirLazyDeclarationResolver\nimport org.jetbrains.kotlin.platform.TargetPlatform\nimport org.jetbrains.kotlin.platform.has\nimport org.jetbrains.kotlin.platform.isCommon\nimport org.jetbrains.kotlin.platform.isJs\nimport org.jetbrains.kotlin.platform.jvm.JvmPlatform\nimport org.jetbrains.kotlin.platform.jvm.isJvm\nimport org.jetbrains.kotlin.resolve.jvm.modules.JavaModuleResolver\nim"}
{"code": "port org.jetbrains.kotlin.resolve.jvm.platform.JvmPlatformAnalyzerServices\nimport java.util.concurrent.ConcurrentHashMap\n\n@OptIn(PrivateSessionConstructor::class, SessionConfiguration::class)\n@LLFirInternals\nclass LLFirBuiltinsSessionFactory(private val project: Project) {\n    private val builtInTypes = BuiltinTypes() // TODO should be platform-specific\n\n    private val builtinsModules = ConcurrentHashMap<TargetPlatform, KtBuiltinsModule>()\n\n    private val builtinsAndCloneableSessions = ConcurrentHashMap<TargetPlatform, CachedValue<LLFirBuiltinsAndCloneableSession>>()\n\n    \n    fun getBuiltinsModule(platform: TargetPlatform): KtBuiltinsModule =\n        builtinsModules.getOrPut(platform) { KtBuiltinsModule(platform, platform.getAnalyzerServices(), project) }\n\n    fun getBuiltinsSession(platform: TargetPlatform): LLFirBuiltinsAndCloneableSession =\n        builtinsAndCloneableSessions.getOrPut(platform) {\n            CachedValuesManager.getManager(project).createCachedValue {\n           "}
{"code": "     val session = createBuiltinsAndCloneableSession(platform)\n                CachedValueProvider.Result(session, session.createValidityTracker())\n            }\n        }.value\n\n    @TestOnly\n    fun clearForTheNextTest() {\n        builtinsModules.clear()\n        builtinsAndCloneableSessions.clear()\n    }\n\n    private fun createBuiltinsAndCloneableSession(platform: TargetPlatform): LLFirBuiltinsAndCloneableSession {\n        val builtinsModule = getBuiltinsModule(platform)\n\n        val session = LLFirBuiltinsAndCloneableSession(builtinsModule, builtInTypes)\n        val moduleData = LLFirModuleData(session)\n\n        return session.apply {\n            registerIdeComponents(project)\n            register(FirLazyDeclarationResolver::class, FirDummyCompilerLazyDeclarationResolver)\n            registerCommonComponents(LanguageVersionSettingsImpl.DEFAULT)\n            registerCommonComponentsAfterExtensionsAreConfigured()\n            registerModuleData(moduleData)\n\n            if (platform.isJv"}
{"code": "m()) {\n                registerJavaComponents(JavaModuleResolver.getInstance(project))\n            }\n\n            val kotlinScopeProvider = when {\n                platform.isJvm() -> FirKotlinScopeProvider(::wrapScopeWithJvmMapped)\n                else -> FirKotlinScopeProvider()\n            }\n            register(FirKotlinScopeProvider::class, kotlinScopeProvider)\n\n            val symbolProvider = createCompositeSymbolProvider(this) {\n                addAll(\n                    LLFirLibrarySymbolProviderFactory.getService(project)\n                        .createBuiltinsSymbolProvider(session, moduleData, kotlinScopeProvider)\n                )\n                add(FirExtensionSyntheticFunctionInterfaceProvider(session, moduleData, kotlinScopeProvider))\n                if (platform.has<JvmPlatform>()) {\n                    add(FirCloneableSymbolProvider(session, moduleData, kotlinScopeProvider))\n                }\n            }\n\n            register(FirSymbolProvider::class, symbolProvide"}
{"code": "r)\n            register(FirProvider::class, LLFirBuiltinsAndCloneableSessionProvider(symbolProvider))\n            register(FirJvmTypeMapper::class, FirJvmTypeMapper(this))\n        }\n    }\n\n    companion object {\n        fun getInstance(project: Project): LLFirBuiltinsSessionFactory =\n            project.getService(LLFirBuiltinsSessionFactory::class.java)\n    }\n}\n\nprivate fun TargetPlatform.getAnalyzerServices() = when {\n    isJvm() -> JvmPlatformAnalyzerServices\n    isJs() -> JvmPlatformAnalyzerServices\n//    isNative() -> NativePlatformAnalyzerServices\n    isCommon() -> CommonPlatformAnalyzerServices\n    else -> JvmPlatformAnalyzerServices\n}\n"}
{"code": "// FILE: main.kt\npackage test\n\nclass MyFoo\n\nval typeRef: MyFoo\n\nval myFoo = <expr>dependency.MyFoo()</expr>\n\n// FILE: dependency.kt\npackage dependency\n\nclass MyFoo\n\n"}
{"code": "class A {\n    class B {\n\n    }\n\n    object C {\n        class D {\n\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.checkers\n\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.descriptors.ValueDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtParameter\nimport org.jetbrains.kotlin.types.StubTypeForBuilderInference\n\nobject StubForBuilderInferenceParameterTypeChecker : DeclarationChecker {\n    override fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n        if (declaration !is KtParameter ||\n            descriptor !is ValueDescriptor ||\n            descriptor.returnType !is StubTypeForBuilderInference\n        ) return\n        if (context.languageVersionSettings.supportsFeature(LanguageFeature.NoBuilderInferenceWithoutAnnotationRestriction)) return\n\n        context.trace.report(Errors.BUILDER_INFERENCE_STUB_PARAMETER_TYPE.on(de"}
{"code": "claration, declaration.nameAsSafeName))\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen\n\nimport org.jetbrains.kotlin.builtins.jvm.JavaToKotlinClassMapper\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.ModuleDescriptor\nimport org.jetbrains.kotlin.descriptors.findClassAcrossModuleDependencies\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.org.objectweb.asm.Type\n\ninterface JvmBackendClassResolver {\n    fun resolveToClassDescriptors(type: Type): List<ClassDescriptor>\n\n    object Dummy : JvmBackendClassResolver {\n        override fun resolveToClassDescriptors(type: Type): List<ClassDescriptor> = emptyList()\n    }\n}\n\n\nclass JvmBackendClassResolverForModuleWithDependencies(\n    private val moduleDescriptor: ModuleDescriptor\n) : JvmBackendClassResolver {\n\n    override fun resolveToClassDescriptors(type: Type): List<ClassDescriptor> {\n        if (type.sort != Type.OBJECT) return emptyList()\n\n        val platformClass = moduleDescriptor.find"}
{"code": "ClassAcrossModuleDependencies(type.classId) ?: return emptyList()\n\n        return JavaToKotlinClassMapper.mapPlatformClass(platformClass) + platformClass\n    }\n}\n\nval Type.classId: ClassId\n    get() {\n        val className = this.className\n        val lastDotIndex = className.lastIndexOf('.')\n        val packageFQN = if (lastDotIndex >= 0) FqName(className.substring(0, lastDotIndex)) else FqName.ROOT\n        val classRelativeNameWithDollars = if (lastDotIndex >= 0) className.substring(lastDotIndex + 1) else className\n        val classFQN = FqName(classRelativeNameWithDollars.replace('$', '.'))\n        return ClassId(packageFQN, classFQN, isLocal = false)\n    }\n"}
{"code": "@Target(AnnotationTarget.TYPE)\nannotation class A1\n\n@Target(AnnotationTarget.TYPE)\nannotation class A2(val value: String)\n\nfun x(): @A1 @A2(\"LIST\") List<@A2(\"INT\") Int> {\n    TODO()\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.transformers\n\nimport kotlinx.collections.immutable.PersistentList\nimport kotlinx.collections.immutable.toImmutableList\nimport kotlinx.collections.immutable.toPersistentList\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.builtins.StandardNames\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget.*\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.copyWithNewSourceKind\nimport org.jetbrains.kotlin.fir.correspondingProperty\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.declarations.utils.isFromVararg\nimport org.jetbrains.kotlin.fir.declarations.utils.isInner\nimport org.jetbrains.kotlin.fir.declarations.utils.isLocal\nimport org.jetbrains.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.resolve.ScopeSession\nimport org.jetbrains.kotlin.fir.resolve.diagnost"}
{"code": "ics.ConeAmbiguouslyResolvedAnnotationFromPlugin\nimport org.jetbrains.kotlin.fir.resolve.diagnostics.ConeCyclicTypeBound\nimport org.jetbrains.kotlin.fir.resolve.lookupSuperTypes\nimport org.jetbrains.kotlin.fir.scopes.FirScope\nimport org.jetbrains.kotlin.fir.scopes.createImportingScopes\nimport org.jetbrains.kotlin.fir.scopes.getNestedClassifierScope\nimport org.jetbrains.kotlin.fir.scopes.impl.FirMemberTypeParameterScope\nimport org.jetbrains.kotlin.fir.scopes.impl.nestedClassifierScope\nimport org.jetbrains.kotlin.fir.scopes.impl.wrapNestedClassifierScopeWithSubstitutionForSuperType\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.fir.types.builder.buildErrorTypeRef\nimport org.jetbrains.kotlin.fir.visitors.transformSingle\nimport org.jetbrains.kotlin.fir.whileAnalysing\nimport org.jetbrains.kotlin.util.PrivateForInline\nimport org.jetbrains.kotlin.utils.addToStdlib.shouldNotBeCalled\n\nclass FirTypeResolveProcessor(\n    session: FirSession,\n    scopeSession: ScopeSession\n) : "}
{"code": "FirTransformerBasedResolveProcessor(session, scopeSession, FirResolvePhase.TYPES) {\n    override val transformer = FirTypeResolveTransformer(session, scopeSession)\n}\n\nfun <F : FirClassLikeDeclaration> F.runTypeResolvePhaseForLocalClass(\n    session: FirSession,\n    scopeSession: ScopeSession,\n    currentScopeList: List<FirScope>,\n    useSiteFile: FirFile,\n    containingDeclarations: List<FirDeclaration>,\n): F {\n    val transformer = FirTypeResolveTransformer(\n        session,\n        scopeSession,\n        currentScopeList,\n        initialCurrentFile = useSiteFile,\n        classDeclarationsStack = containingDeclarations.filterIsInstanceTo(ArrayDeque())\n    )\n\n    return this.transform(transformer, null)\n}\n\n@OptIn(PrivateForInline::class)\nopen class FirTypeResolveTransformer(\n    final override val session: FirSession,\n    @property:PrivateForInline val scopeSession: ScopeSession,\n    initialScopes: List<FirScope> = emptyList(),\n    initialCurrentFile: FirFile? = null,\n    @property:Priv"}
{"code": "ateForInline val classDeclarationsStack: ArrayDeque<FirClass> = ArrayDeque()\n) : FirAbstractTreeTransformer<Any?>(FirResolvePhase.TYPES) {\n    \n    @PrivateForInline\n    var scopes = initialScopes.asReversed().toPersistentList()\n\n    \n    @PrivateForInline\n    var staticScopes = scopes\n\n    @set:PrivateForInline\n    var scopesBefore: PersistentList<FirScope>? = null\n\n    @set:PrivateForInline\n    var staticScopesBefore: PersistentList<FirScope>? = null\n\n    private var currentDeclaration: FirDeclaration? = null\n\n    private inline fun <T> withDeclaration(declaration: FirDeclaration, crossinline action: () -> T): T {\n        val oldDeclaration = currentDeclaration\n        return try {\n            currentDeclaration = declaration\n            action()\n        } finally {\n            currentDeclaration = oldDeclaration\n        }\n    }\n\n    private val typeResolverTransformer: FirSpecificTypeResolverTransformer = FirSpecificTypeResolverTransformer(session)\n\n    @PrivateForInline\n    var cur"}
{"code": "rentFile: FirFile? = initialCurrentFile\n\n    override fun transformFile(file: FirFile, data: Any?): FirFile {\n        checkSessionConsistency(file)\n        return withFileScope(file) {\n            super.transformFile(file, data)\n        }\n    }\n\n    inline fun <R> withFileScope(file: FirFile, crossinline action: () -> R): R {\n        currentFile = file\n        return withScopeCleanup {\n            addScopes(createImportingScopes(file, session, scopeSession))\n            action()\n        }\n    }\n\n    override fun transformRegularClass(regularClass: FirRegularClass, data: Any?): FirStatement {\n        whileAnalysing(session, regularClass) {\n            withClassDeclarationCleanup(regularClass) {\n                transformClassTypeParameters(regularClass, data)\n                return resolveClassContent(regularClass, data)\n            }\n        }\n    }\n\n    fun transformClassTypeParameters(regularClass: FirRegularClass, data: Any?) {\n        withScopeCleanup {\n            // Remove type pa"}
{"code": "rameter scopes for classes that are neither inner nor local\n            if (removeOuterTypeParameterScope(regularClass)) {\n                this.scopes = staticScopes\n            }\n            addTypeParametersScope(regularClass)\n            regularClass.typeParameters.forEach {\n                it.accept(this, data)\n            }\n            unboundCyclesInTypeParametersSupertypes(regularClass)\n        }\n    }\n\n    inline fun <R> withClassDeclarationCleanup(regularClass: FirRegularClass, action: () -> R): R {\n        return withClassDeclarationCleanup(classDeclarationsStack, regularClass, action)\n    }\n\n    override fun transformAnonymousObject(anonymousObject: FirAnonymousObject, data: Any?): FirStatement {\n        withClassDeclarationCleanup(classDeclarationsStack, anonymousObject) {\n            return resolveClassContent(anonymousObject, data)\n        }\n    }\n\n    override fun transformConstructor(constructor: FirConstructor, data: Any?): FirConstructor = whileAnalysing(session, cons"}
{"code": "tructor) {\n        return withScopeCleanup {\n            addTypeParametersScope(constructor)\n            val result = transformDeclaration(constructor, data) as FirConstructor\n\n            if (result.isPrimary) {\n                for (valueParameter in result.valueParameters) {\n                    if (valueParameter.correspondingProperty != null) {\n                        valueParameter.moveOrDeleteIrrelevantAnnotations()\n                    }\n                }\n            }\n\n            result\n        }\n    }\n\n    override fun transformAnonymousInitializer(anonymousInitializer: FirAnonymousInitializer, data: Any?): FirAnonymousInitializer {\n        return withScopeCleanup {\n            transformDeclaration(anonymousInitializer, data) as FirAnonymousInitializer\n        }\n    }\n\n    override fun transformErrorPrimaryConstructor(errorPrimaryConstructor: FirErrorPrimaryConstructor, data: Any?) =\n        transformConstructor(errorPrimaryConstructor, data)\n\n    override fun transformTypeAlia"}
{"code": "s(typeAlias: FirTypeAlias, data: Any?): FirTypeAlias = whileAnalysing(session, typeAlias) {\n        withScopeCleanup {\n            addTypeParametersScope(typeAlias)\n            transformDeclaration(typeAlias, data)\n        } as FirTypeAlias\n    }\n\n    override fun transformEnumEntry(enumEntry: FirEnumEntry, data: Any?): FirEnumEntry = whileAnalysing(session, enumEntry) {\n        enumEntry.transformReturnTypeRef(this, data)\n        enumEntry.transformTypeParameters(this, data)\n        enumEntry.transformAnnotations(this, data)\n        enumEntry\n    }\n\n    override fun transformReceiverParameter(receiverParameter: FirReceiverParameter, data: Any?): FirReceiverParameter {\n        return receiverParameter.transformAnnotations(this, data).transformTypeRef(this, data)\n    }\n\n    override fun transformProperty(property: FirProperty, data: Any?): FirProperty = whileAnalysing(session, property) {\n        withScopeCleanup {\n            withDeclaration(property) {\n                addTypeParameter"}
{"code": "sScope(property)\n                property.transformTypeParameters(this, data)\n                    .transformReturnTypeRef(this, data)\n                    .transformReceiverParameter(this, data)\n                    .transformContextReceivers(this, data)\n                    .transformGetter(this, data)\n                    .transformSetter(this, data)\n                    .transformBackingField(this, data)\n                    .transformAnnotations(this, data)\n\n                if (property.isFromVararg == true) {\n                    property.transformTypeToArrayType(session)\n                    property.backingField?.transformTypeToArrayType(session)\n                    setAccessorTypesByPropertyType(property)\n                }\n\n                when {\n                    property.returnTypeRef is FirResolvedTypeRef && property.delegate != null -> {\n                        setAccessorTypesByPropertyType(property)\n                    }\n                    property.returnTypeRef !is FirResolve"}
{"code": "dTypeRef && property.initializer == null &&\n                            property.getter?.returnTypeRef is FirResolvedTypeRef -> {\n                        val returnTypeRef = property.getter!!.returnTypeRef\n\n                        property.replaceReturnTypeRef(returnTypeRef.copyWithNewSourceKind(KtFakeSourceElementKind.PropertyTypeFromGetterReturnType))\n                        property.backingField?.replaceReturnTypeRef(\n                            returnTypeRef.copyWithNewSourceKind(KtFakeSourceElementKind.PropertyTypeFromGetterReturnType)\n                        )\n\n                        property.setter?.valueParameters?.forEach {\n                            it.replaceReturnTypeRef(\n                                returnTypeRef.copyWithNewSourceKind(KtFakeSourceElementKind.PropertyTypeFromGetterReturnType)\n                            )\n                        }\n                    }\n                }\n\n                unboundCyclesInTypeParametersSupertypes(property)\n\n               "}
{"code": " property.moveOrDeleteIrrelevantAnnotations()\n                property\n            }\n        }\n    }\n\n    private fun setAccessorTypesByPropertyType(property: FirProperty) {\n        property.getter?.replaceReturnTypeRef(property.returnTypeRef)\n        property.setter?.valueParameters?.map { it.replaceReturnTypeRef(property.returnTypeRef) }\n    }\n\n    override fun transformField(field: FirField, data: Any?): FirField = whileAnalysing(session, field) {\n        withScopeCleanup {\n            field.transformReturnTypeRef(this, data).transformAnnotations(this, data)\n            field\n        }\n    }\n\n    override fun transformBackingField(backingField: FirBackingField, data: Any?): FirStatement = whileAnalysing(session, backingField) {\n        backingField.transformAnnotations(this, data)\n        super.transformBackingField(backingField, data)\n    }\n\n    override fun transformSimpleFunction(\n        simpleFunction: FirSimpleFunction,\n        data: Any?,\n    ): FirSimpleFunction = whileAnaly"}
{"code": "sing(session, simpleFunction) {\n        withScopeCleanup {\n            withDeclaration(simpleFunction) {\n                addTypeParametersScope(simpleFunction)\n                val result = transformDeclaration(simpleFunction, data).also {\n                    unboundCyclesInTypeParametersSupertypes(it as FirTypeParametersOwner)\n                }\n\n                if (result.source?.kind == KtFakeSourceElementKind.DataClassGeneratedMembers &&\n                    result is FirSimpleFunction &&\n                    result.name == StandardNames.DATA_CLASS_COPY\n                ) {\n                    for (valueParameter in result.valueParameters) {\n                        valueParameter.moveOrDeleteIrrelevantAnnotations()\n                    }\n                }\n\n                result\n            }\n        } as FirSimpleFunction\n    }\n\n    private fun unboundCyclesInTypeParametersSupertypes(typeParametersOwner: FirTypeParameterRefsOwner) {\n        for (typeParameter in typeParametersOwner.type"}
{"code": "Parameters) {\n            if (typeParameter !is FirTypeParameter) continue\n            if (hasSupertypePathToParameter(typeParameter, typeParameter, mutableSetOf())) {\n                val errorType = buildErrorTypeRef {\n                    diagnostic = ConeCyclicTypeBound(typeParameter.symbol, typeParameter.bounds.toImmutableList())\n                }\n                typeParameter.replaceBounds(\n                    listOf(errorType)\n                )\n            }\n        }\n    }\n\n    private fun hasSupertypePathToParameter(\n        currentTypeParameter: FirTypeParameter,\n        typeParameter: FirTypeParameter,\n        visited: MutableSet<FirTypeParameter>\n    ): Boolean {\n        if (visited.isNotEmpty() && currentTypeParameter == typeParameter) return true\n        if (!visited.add(currentTypeParameter)) return false\n\n        fun ConeKotlinType.toNextTypeParameter(): FirTypeParameter? = when (this) {\n            is ConeTypeParameterType -> lookupTag.typeParameterSymbol.fir\n           "}
{"code": " is ConeDefinitelyNotNullType -> original.toNextTypeParameter()\n            else -> null\n        }\n\n        return currentTypeParameter.bounds.any {\n            val nextTypeParameter = it.coneTypeOrNull?.toNextTypeParameter() ?: return@any false\n\n            hasSupertypePathToParameter(nextTypeParameter, typeParameter, visited)\n        }\n    }\n\n    override fun transformImplicitTypeRef(implicitTypeRef: FirImplicitTypeRef, data: Any?): FirTypeRef {\n        return implicitTypeRef\n    }\n\n    override fun transformTypeRef(typeRef: FirTypeRef, data: Any?): FirResolvedTypeRef {\n        return typeResolverTransformer.withFile(currentFile) {\n            typeRef.transform(\n                typeResolverTransformer,\n                ScopeClassDeclaration(scopes.asReversed(), classDeclarationsStack, containerDeclaration = currentDeclaration)\n            )\n        }\n    }\n\n    override fun transformValueParameter(\n        valueParameter: FirValueParameter,\n        data: Any?,\n    ): FirStatement = wh"}
{"code": "ileAnalysing(session, valueParameter) {\n        withDeclaration(valueParameter) {\n            valueParameter.transformReturnTypeRef(this, data)\n            valueParameter.transformAnnotations(this, data)\n            valueParameter.transformVarargTypeToArrayType(session)\n            valueParameter\n        }\n    }\n\n    override fun transformBlock(block: FirBlock, data: Any?): FirStatement {\n        return block\n    }\n\n    override fun transformArgumentList(argumentList: FirArgumentList, data: Any?): FirArgumentList {\n        return argumentList\n    }\n\n    override fun transformAnnotation(annotation: FirAnnotation, data: Any?): FirStatement {\n        shouldNotBeCalled()\n    }\n\n    override fun transformAnnotationCall(\n        annotationCall: FirAnnotationCall,\n        data: Any?\n    ): FirStatement = whileAnalysing(session, annotationCall) {\n        when (val originalTypeRef = annotationCall.annotationTypeRef) {\n            is FirResolvedTypeRef -> {\n                when (annotationCall.a"}
{"code": "nnotationResolvePhase) {\n                    FirAnnotationResolvePhase.Unresolved -> when (originalTypeRef) {\n                        is FirErrorTypeRef -> return annotationCall.also { it.replaceAnnotationResolvePhase(FirAnnotationResolvePhase.Types) }\n                        else -> shouldNotBeCalled()\n                    }\n                    FirAnnotationResolvePhase.CompilerRequiredAnnotations -> {\n                        annotationCall.transformTypeArguments(this, data)\n                        annotationCall.replaceAnnotationResolvePhase(FirAnnotationResolvePhase.Types)\n                        val alternativeResolvedTypeRef =\n                            originalTypeRef.delegatedTypeRef?.transformSingle(this, data) ?: return annotationCall\n                        val coneTypeFromCompilerRequiredPhase = originalTypeRef.coneType\n                        val coneTypeFromTypesPhase = alternativeResolvedTypeRef.coneType\n                        if (coneTypeFromTypesPhase != coneTypeFromCo"}
{"code": "mpilerRequiredPhase) {\n                            val errorTypeRef = buildErrorTypeRef {\n                                source = originalTypeRef.source\n                                type = coneTypeFromCompilerRequiredPhase\n                                annotations += originalTypeRef.annotations\n                                delegatedTypeRef = originalTypeRef.delegatedTypeRef\n                                diagnostic = ConeAmbiguouslyResolvedAnnotationFromPlugin(\n                                    coneTypeFromCompilerRequiredPhase,\n                                    coneTypeFromTypesPhase\n                                )\n                            }\n                            annotationCall.replaceAnnotationTypeRef(errorTypeRef)\n                        }\n                    }\n                    FirAnnotationResolvePhase.Types -> {}\n                }\n            }\n            else -> {\n                val transformedTypeRef = originalTypeRef.transformSingle(this, data)\n   "}
{"code": "             annotationCall.transformTypeArguments(this, data)\n                annotationCall.replaceAnnotationResolvePhase(FirAnnotationResolvePhase.Types)\n                annotationCall.replaceAnnotationTypeRef(transformedTypeRef)\n            }\n        }\n\n        return annotationCall\n    }\n\n    inline fun <T> withScopeCleanup(crossinline l: () -> T): T {\n        val scopesBeforeSnapshot = scopes\n        val scopesBeforeBeforeSnapshot = scopesBefore\n        scopesBefore = scopesBeforeSnapshot\n\n        val staticScopesBeforeSnapshot = staticScopes\n        val staticScopesBeforeBeforeSnapshot = staticScopesBefore\n        staticScopesBefore = staticScopesBeforeSnapshot\n\n        return try {\n            l()\n        } finally {\n            scopes = scopesBeforeSnapshot\n            scopesBefore = scopesBeforeBeforeSnapshot\n            staticScopes = staticScopesBeforeSnapshot\n            staticScopesBefore = staticScopesBeforeBeforeSnapshot\n        }\n    }\n\n    private fun resolveClassCont"}
{"code": "ent(\n        firClass: FirClass,\n        data: Any?\n    ): FirStatement = withClassScopes(\n        firClass,\n        actionInsideStaticScope = {\n            withScopeCleanup {\n                firClass.transformAnnotations(this, null)\n\n                if (firClass is FirRegularClass) {\n                    addTypeParametersScope(firClass)\n                }\n\n                // ConstructedTypeRef should be resolved only with type parameters, but not with nested classes and classes from supertypes\n                for (declaration in firClass.declarations) {\n                    when (declaration) {\n                        is FirConstructor -> transformDelegatedConstructorCall(declaration)\n                        is FirField -> {\n                            if (declaration.origin == FirDeclarationOrigin.Synthetic.DelegateField) {\n                                transformDelegateField(declaration)\n                            }\n                        }\n\n                        else -> {}\n     "}
{"code": "               }\n                }\n            }\n        }\n    ) {\n        // Note that annotations are still visited here\n        // again, although there's no need in it\n        transformElement(firClass, data)\n    }\n\n    fun transformDelegatedConstructorCall(constructor: FirConstructor) {\n        constructor.delegatedConstructor?.let(this::resolveConstructedTypeRefForDelegatedConstructorCall)\n    }\n\n    fun transformDelegateField(field: FirField) {\n        field.transformReturnTypeRef(this, null)\n    }\n\n    fun removeOuterTypeParameterScope(firClass: FirClass): Boolean = !firClass.isInner && !firClass.isLocal\n\n    \n    inline fun <R> withClassScopes(\n        firClass: FirClass,\n        crossinline actionInsideStaticScope: () -> Unit = {},\n        crossinline action: () -> R,\n    ): R = withScopeCleanup {\n        // Remove type parameter scopes for classes that are neither inner nor local\n        if (removeOuterTypeParameterScope(firClass)) {\n            this.scopes = staticScopes\n  "}
{"code": "      }\n\n        actionInsideStaticScope()\n\n        // ? Is it Ok to use original file session here ?\n        val superTypes = lookupSuperTypes(\n            firClass,\n            lookupInterfaces = false,\n            deep = true,\n            substituteTypes = true,\n            useSiteSession = session\n        ).asReversed()\n\n        val scopesToAdd = mutableListOf<FirScope>()\n\n        for (superType in superTypes) {\n            superType.lookupTag.getNestedClassifierScope(session, scopeSession)?.let { nestedClassifierScope ->\n                val scope = nestedClassifierScope.wrapNestedClassifierScopeWithSubstitutionForSuperType(superType, session)\n                scopesToAdd.add(scope)\n            }\n        }\n\n        if (firClass is FirRegularClass) {\n            // Companion scope is added before static scope,\n            // i.e., static scope is checked first during resolution (scopes are in reverse order).\n            // This is because we can qualify companion scope using `Compani"}
{"code": "on.` if we want to explicitly refer to a declaration in the\n            // companion.\n            firClass.companionObjectSymbol?.fir\n                ?.let(session::nestedClassifierScope)\n                ?.let(scopesToAdd::add)\n\n            session.nestedClassifierScope(firClass)?.let(scopesToAdd::add)\n\n            addScopes(scopesToAdd)\n            addTypeParametersScope(firClass)\n        } else {\n            session.nestedClassifierScope(firClass)?.let(scopesToAdd::add)\n            addScopes(scopesToAdd)\n        }\n\n        action()\n    }\n\n    private fun resolveConstructedTypeRefForDelegatedConstructorCall(\n        delegatedConstructorCall: FirDelegatedConstructorCall\n    ) {\n        delegatedConstructorCall.replaceConstructedTypeRef(delegatedConstructorCall.constructedTypeRef.transformSingle(this, null))\n        delegatedConstructorCall.transformCalleeReference(this, null)\n    }\n\n    fun addTypeParametersScope(firMemberDeclaration: FirMemberDeclaration) {\n        if (firMemberDeclar"}
{"code": "ation.typeParameters.isNotEmpty()) {\n            scopes = scopes.add(FirMemberTypeParameterScope(firMemberDeclaration))\n        }\n    }\n\n    fun addScopes(list: List<FirScope>) {\n        // small optimization to skip unnecessary allocations\n        val scopesAreTheSame = scopes === staticScopes\n\n        scopes = scopes.addAll(list)\n        staticScopes = if (scopesAreTheSame) scopes else staticScopes.addAll(list)\n    }\n\n    \n    private fun FirVariable.moveOrDeleteIrrelevantAnnotations() {\n        if (annotations.isEmpty()) return\n        val backingFieldAnnotations by lazy(LazyThreadSafetyMode.NONE) { backingField?.annotations?.toMutableList() ?: mutableListOf() }\n        var replaceBackingFieldAnnotations = false\n        replaceAnnotations(annotations.filter { annotation ->\n            when (annotation.useSiteTarget) {\n                null -> {\n                    val allowedTargets = annotation.useSiteTargetsFromMetaAnnotation(session)\n                    when {\n                    "}
{"code": "    this is FirValueParameter -> CONSTRUCTOR_PARAMETER in allowedTargets\n                        this.source?.kind == KtFakeSourceElementKind.PropertyFromParameter && CONSTRUCTOR_PARAMETER in allowedTargets -> false\n                        this is FirProperty && backingField != null && annotationShouldBeMovedToField(allowedTargets) -> {\n                            backingFieldAnnotations += annotation\n                            replaceBackingFieldAnnotations = true\n                            false\n                        }\n                        else -> true\n                    }\n                }\n                else -> true\n            }\n        })\n        if (replaceBackingFieldAnnotations) {\n            backingField?.replaceAnnotations(backingFieldAnnotations)\n        }\n    }\n\n    private fun annotationShouldBeMovedToField(allowedTargets: Set<AnnotationUseSiteTarget>): Boolean =\n        (FIELD in allowedTargets || PROPERTY_DELEGATE_FIELD in allowedTargets) && PROPERTY !in allowe"}
{"code": "dTargets\n}\n"}
{"code": "import java.lang.Exception\n\nfun test() {\n    <expr>try { throw Exception() } finally { return }</expr> + 4\n    return\n}"}
{"code": "open class resolve<caret>Me : C()\n\nopen class A : B()\n\nopen class B : C()\n\nopen class C : A()"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.types.renderers\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.renderer.types.KtTypeRenderer\nimport org.jetbrains.kotlin.analysis.api.types.KtClassErrorType\nimport org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter\n\npublic interface KtUnresolvedClassErrorTypeRenderer {\n    context(KtAnalysisSession, KtTypeRenderer)\n    public fun renderType(type: KtClassErrorType, printer: PrettyPrinter)\n\n    public object UNRESOLVED_QUALIFIER : KtUnresolvedClassErrorTypeRenderer {\n        context(KtAnalysisSession, KtTypeRenderer)\n        override fun renderType(type: KtClassErrorType, printer: PrettyPrinter): Unit = printer {\n            annotationsRenderer.renderAnnotations(type, printer)\n            classIdRenderer.renderClassTypeQualifier(type, printer)\n        }\n    }\n\n\n    public object AS_ERROR_WORD : KtUnresolvedClassErrorTypeRenderer {\n        context(KtAnalysisSession, KtTypeRend"}
{"code": "erer)\n        override fun renderType(type: KtClassErrorType, printer: PrettyPrinter) {\n            printer.append(\"ERROR_TYPE\")\n        }\n    }\n\n    public object WITH_ERROR_MESSAGE : KtUnresolvedClassErrorTypeRenderer {\n        context(KtAnalysisSession, KtTypeRenderer)\n        override fun renderType(type: KtClassErrorType, printer: PrettyPrinter) {\n            printer.append(\"ERROR_TYPE(${type.errorMessage})\")\n        }\n    }\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.expressions.impl\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.declarations.FirValueParameter\nimport org.jetbrains.kotlin.fir.expressions.FirAbstractArgumentList\nimport org.jetbrains.kotlin.fir.expressions.FirArgumentList\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.expressions.FirNamedArgumentExpression\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.fir.visitors.transformSingle\n\nabstract class FirResolvedArgumentList : FirAbstractArgumentList() {\n    \n    abstract val originalArgumentList: FirArgumentList?\n    abstract val mapping: LinkedHashMap<FirExpression, FirValueParameter>\n\n    final override val source: KtSourceElement?\n        get() = originalArgumentList?.source\n\n    override val arguments: List<FirExpression>\n        get() = mapping.key"}
{"code": "s.toList()\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {\n        for (argument in arguments) {\n            argument.accept(visitor, data)\n        }\n    }\n\n    abstract override fun <D> transformArguments(transformer: FirTransformer<D>, data: D): FirArgumentList\n\n    override fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirElement {\n        transformArguments(transformer, data)\n        return this\n    }\n}\n\n\ninternal class FirResolvedArgumentListImpl(\n    override val originalArgumentList: FirArgumentList?,\n    mapping: LinkedHashMap<FirExpression, FirValueParameter>,\n) : FirResolvedArgumentList() {\n    override var mapping: LinkedHashMap<FirExpression, FirValueParameter> = mapping\n        private set\n\n    override fun <D> transformArguments(transformer: FirTransformer<D>, data: D): FirArgumentList {\n        mapping = mapping.mapKeys { (k, _) -> k.transformSingle(transformer, data) } as LinkedHashMap<FirExpression, FirValueParameter>"}
{"code": "\n        return this\n    }\n}\n\ninternal class FirResolvedArgumentListForErrorCall(\n    override val originalArgumentList: FirArgumentList?,\n    private var _mapping: LinkedHashMap<FirExpression, FirValueParameter?>,\n) : FirResolvedArgumentList() {\n\n    override var mapping: LinkedHashMap<FirExpression, FirValueParameter> = computeMapping()\n        private set\n\n    private fun computeMapping(): LinkedHashMap<FirExpression, FirValueParameter> {\n        @Suppress(\"UNCHECKED_CAST\")\n        return _mapping.filterValues { it != null } as LinkedHashMap<FirExpression, FirValueParameter>\n    }\n\n    override val arguments: List<FirExpression>\n        get() = _mapping.keys.toList()\n\n    override fun <D> transformArguments(transformer: FirTransformer<D>, data: D): FirResolvedArgumentListForErrorCall {\n        _mapping = _mapping.mapKeys { (k, _) -> k.transformSingle(transformer, data) } as LinkedHashMap<FirExpression, FirValueParameter?>\n        mapping = computeMapping()\n        return this\n    }\n"}
{"code": "}\n"}
{"code": "class A {\n    var something: Int\n        set(value) {}\n        get() = 10\n}\n\nfun A.foo(a: A) {\n    print(a.<caret_1>something)\n    a.<caret_2>something = 1\n    a.<caret_3>something += 1\n    a.<caret_4>something++\n    --a.<caret_5>something\n\n    <caret_6>something++\n    (<caret_7>something)++\n    (<caret_8>something) = 1\n    (a.<caret_9>something) = 1\n}\n\n// MULTIRESOLVE\n\n\n\n\n\n\n\n\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.stubBased.deserialization\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.KtRealPsiSourceElement\nimport org.jetbrains.kotlin.constant.*\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.expressions.FirLiteralExpression\nimport org.jetbrains.kotlin.fir.expressions.buildUnaryArgumentList\nimport org.jetbrains.kotlin.fir.expressions.builder.*\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.fir.types.builder.buildResolvedTypeRef\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.name.StandardClassIds\nimport org.jetbrains.kotlin.psi.KtAnnotated\nim"}
{"code": "port org.jetbrains.kotlin.psi.KtAnnotationEntry\nimport org.jetbrains.kotlin.psi.KtProperty\nimport org.jetbrains.kotlin.psi.stubs.elements.KtStubElementTypes\nimport org.jetbrains.kotlin.psi.stubs.impl.KotlinAnnotationEntryStubImpl\nimport org.jetbrains.kotlin.psi.stubs.impl.KotlinClassTypeBean\nimport org.jetbrains.kotlin.psi.stubs.impl.KotlinPropertyStubImpl\nimport org.jetbrains.kotlin.types.ConstantValueKind\nimport org.jetbrains.kotlin.utils.exceptions.errorWithAttachment\n\nclass StubBasedAnnotationDeserializer(\n    private val session: FirSession,\n) {\n    fun loadAnnotations(\n        ktAnnotated: KtAnnotated,\n    ): List<FirAnnotation> {\n        val annotations = ktAnnotated.annotationEntries\n        if (annotations.isEmpty()) return emptyList()\n        return annotations.map { deserializeAnnotation(it) }\n    }\n\n    private val constantCache = mutableMapOf<CallableId, FirExpression>()\n\n    fun loadConstant(property: KtProperty, callableId: CallableId): FirExpression? {\n        if (!prop"}
{"code": "erty.hasModifier(KtTokens.CONST_KEYWORD)) return null\n        constantCache[callableId]?.let { return it }\n        val propertyStub = (property.stub ?: loadStubByElement(property)) as? KotlinPropertyStubImpl ?: return null\n        val constantValue = propertyStub.constantInitializer ?: return null\n        return resolveValue(property, constantValue)\n    }\n\n    private fun deserializeAnnotation(\n        ktAnnotation: KtAnnotationEntry\n    ): FirAnnotation {\n        return deserializeAnnotation(\n            ktAnnotation,\n            getAnnotationClassId(ktAnnotation),\n            ((ktAnnotation.stub ?: loadStubByElement(ktAnnotation)) as? KotlinAnnotationEntryStubImpl)?.valueArguments,\n            ktAnnotation.useSiteTarget?.getAnnotationUseSiteTarget()\n        )\n    }\n\n    fun getAnnotationClassId(ktAnnotation: KtAnnotationEntry): ClassId {\n        val userType = ktAnnotation.getStubOrPsiChild(KtStubElementTypes.CONSTRUCTOR_CALLEE)\n            ?.getStubOrPsiChild(KtStubElementTypes.TYPE"}
{"code": "_REFERENCE)\n            ?.getStubOrPsiChild(KtStubElementTypes.USER_TYPE)!!\n        return userType.classId()\n    }\n\n    private fun deserializeAnnotation(\n        ktAnnotation: PsiElement,\n        classId: ClassId,\n        valueArguments: Map<Name, ConstantValue<*>>?,\n        useSiteTarget: AnnotationUseSiteTarget? = null\n    ): FirAnnotation {\n        return buildAnnotation {\n            source = KtRealPsiSourceElement(ktAnnotation)\n            annotationTypeRef = buildResolvedTypeRef {\n                type = classId.toLookupTag().constructClassType(ConeTypeProjection.EMPTY_ARRAY, isNullable = false)\n            }\n            this.argumentMapping = buildAnnotationArgumentMapping {\n                valueArguments?.forEach { (name, constantValue) ->\n                    mapping[name] = resolveValue(ktAnnotation, constantValue)\n                }\n            }\n            useSiteTarget?.let {\n                this.useSiteTarget = it\n            }\n        }\n    }\n\n    private fun resolveValu"}
{"code": "e(\n        sourceElement: PsiElement,\n        value: ConstantValue<*>\n    ): FirExpression {\n        return when (value) {\n            is EnumValue -> sourceElement.toEnumEntryReferenceExpression(value.enumClassId, value.enumEntryName)\n            is KClassValue -> buildGetClassCall {\n                source = KtRealPsiSourceElement(sourceElement)\n                val lookupTag = (value.value as KClassValue.Value.NormalClass).classId.toLookupTag()\n                val referencedType = lookupTag.constructType(ConeTypeProjection.EMPTY_ARRAY, isNullable = false)\n                val resolvedType = StandardClassIds.KClass.constructClassLikeType(arrayOf(referencedType), false)\n                argumentList = buildUnaryArgumentList(\n                    buildClassReferenceExpression {\n                        classTypeRef = buildResolvedTypeRef { type = referencedType }\n                        coneTypeOrNull = resolvedType\n                    }\n                )\n                coneTypeOrNull = res"}
{"code": "olvedType\n            }\n            is ArrayValue -> {\n                buildArrayLiteral {\n                    source = KtRealPsiSourceElement(sourceElement)\n                    // Not quite precise, yet doesn't require annotation resolution\n                    coneTypeOrNull = (inferArrayValueType(value.value) ?: session.builtinTypes.anyType.type).createArrayType()\n\n                    argumentList = buildArgumentList {\n                        value.value.mapTo(arguments) { resolveValue(sourceElement, it) }\n                    }\n                }\n            }\n            is AnnotationValue -> {\n                deserializeAnnotation(\n                    sourceElement,\n                    value.value.classId,\n                    value.value.argumentsMapping\n                )\n            }\n            is BooleanValue -> const(ConstantValueKind.Boolean, value.value, session.builtinTypes.booleanType, sourceElement)\n            is ByteValue -> const(ConstantValueKind.Byte, value.value, ses"}
{"code": "sion.builtinTypes.byteType, sourceElement)\n            is CharValue -> const(ConstantValueKind.Char, value.value, session.builtinTypes.charType, sourceElement)\n            is ShortValue -> const(ConstantValueKind.Short, value.value, session.builtinTypes.shortType, sourceElement)\n            is LongValue -> const(ConstantValueKind.Long, value.value, session.builtinTypes.longType, sourceElement)\n            is FloatValue -> const(ConstantValueKind.Float, value.value, session.builtinTypes.floatType, sourceElement)\n            is DoubleValue -> const(ConstantValueKind.Double, value.value, session.builtinTypes.doubleType, sourceElement)\n            is UByteValue -> const(ConstantValueKind.UnsignedByte, value.value, session.builtinTypes.byteType, sourceElement)\n            is UShortValue -> const(ConstantValueKind.UnsignedShort, value.value, session.builtinTypes.shortType, sourceElement)\n            is UIntValue -> const(ConstantValueKind.UnsignedInt, value.value, session.builtinTypes.intTyp"}
{"code": "e, sourceElement)\n            is ULongValue -> const(ConstantValueKind.UnsignedLong, value.value, session.builtinTypes.longType, sourceElement)\n            is IntValue -> const(ConstantValueKind.Int, value.value, session.builtinTypes.intType, sourceElement)\n            NullValue -> const(ConstantValueKind.Null, null, session.builtinTypes.nullableAnyType, sourceElement)\n            is StringValue -> const(ConstantValueKind.String, value.value, session.builtinTypes.stringType, sourceElement)\n            else -> errorWithAttachment(\"Unexpected value ${value::class}\") {\n                withEntry(\"value\", value.toString())\n            }\n        }\n    }\n\n    private fun inferArrayValueType(values: List<ConstantValue<*>>): ConeClassLikeType? {\n        if (values.isNotEmpty()) {\n            val firstValue = values.first()\n\n            for ((index, value) in values.withIndex()) {\n                if (index > 0 && value.javaClass != firstValue.javaClass) {\n                    return null\n        "}
{"code": "        }\n            }\n\n            return when (firstValue) {\n                is BooleanValue -> session.builtinTypes.booleanType.type\n                is ByteValue -> session.builtinTypes.byteType.type\n                is CharValue -> session.builtinTypes.charType.type\n                is ShortValue -> session.builtinTypes.shortType.type\n                is IntValue -> session.builtinTypes.intType.type\n                is LongValue -> session.builtinTypes.longType.type\n                is UByteValue -> session.builtinTypes.byteType.type\n                is UShortValue -> session.builtinTypes.shortType.type\n                is UIntValue -> session.builtinTypes.intType.type\n                is ULongValue -> session.builtinTypes.longType.type\n                is DoubleValue -> session.builtinTypes.doubleType.type\n                is FloatValue -> session.builtinTypes.floatType.type\n                is AnnotationValue -> session.builtinTypes.annotationType.type\n                is StringValue -> ses"}
{"code": "sion.builtinTypes.stringType.type\n                is EnumValue -> firstValue.enumClassId.constructClassLikeType(ConeTypeProjection.EMPTY_ARRAY, isNullable = false)\n                is ArrayValue -> values.firstNotNullOfOrNull { inferArrayValueType((it as ArrayValue).value) }?.createArrayType()\n                is KClassValue -> {\n                    val kClassType = session.builtinTypes.anyType.type\n                    StandardClassIds.KClass.constructClassLikeType(arrayOf(kClassType), isNullable = false)\n                }\n                else -> null\n            }\n        }\n\n        return null\n    }\n\n    private fun <T> const(\n        kind: ConstantValueKind<T>,\n        value: T,\n        typeRef: FirResolvedTypeRef,\n        sourceElement: PsiElement\n    ): FirLiteralExpression<T> {\n        return buildLiteralExpression(\n            KtRealPsiSourceElement(sourceElement),\n            kind,\n            value,\n            setType = true\n        ).apply { this.replaceConeTypeOrNull(typeRef."}
{"code": "type) }\n    }\n\n    private fun PsiElement.toEnumEntryReferenceExpression(classId: ClassId, entryName: Name): FirExpression =\n        buildEnumEntryDeserializedAccessExpression {\n            enumClassId = classId\n            enumEntryName = entryName\n        }\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.expressions\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\n\nabstract class FirWrappedExpression : FirExpression() {\n    abstract override val source: KtSourceElement?\n    @UnresolvedExpressionTypeAccess\n    abstract override val coneTypeOrNull: ConeKotlinType?\n    abstract override val annotations: List<FirAnnotation>\n    abstract val expression: FirExpression\n\n    override fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitWrappedExpression(this, data)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transformer.transfor"}
{"code": "mWrappedExpression(this, data) as E\n\n    abstract override fun replaceConeTypeOrNull(newConeTypeOrNull: ConeKotlinType?)\n\n    abstract override fun replaceAnnotations(newAnnotations: List<FirAnnotation>)\n\n    abstract override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirWrappedExpression\n}\n"}
{"code": "@Target(AnnotationTarget.TYPE)\nannotation class Anno(val s: String)\n\ninterface One\ninterface Two\n\nfun <T> f<caret>oo(t: T) where T : One, T : @Anno(\"str\") Two = t"}
{"code": "package test\n\nclass Outer<MyParam> {\n    inner class Inner {\n        fun member(p: <expr>MyParam</expr>) {}\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.descriptors.ClassKind\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.classKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirTypeAlias\nimport org.jetbrains.kotlin.fir.declarations.utils.expandedConeType\nimport org.jetbrains.kotlin.fir.declarations.utils.isActual\nimport org.jetbrains.kotlin.fir.types.toSymbol\nimport org.jetbrains.kotlin.resolve.calls.mpp.ActualTypealiasToSpecialAnnotationUtils.isAnnotationProhibitedInActualTypeAlias\n\ninternal object FirActualTypealiasToSpecialAnnotationChecker : FirTypeAliasChecker(MppCheckerKind.Common"}
{"code": ") {\n    override fun check(declaration: FirTypeAlias, context: CheckerContext, reporter: DiagnosticReporter) {\n        if (!context.languageVersionSettings.supportsFeature(LanguageFeature.MultiplatformRestrictions)) return\n        if (!declaration.isActual) return\n        val typealiasedClassSymbol = declaration.expandedConeType?.toSymbol(context.session) ?: return\n        if (typealiasedClassSymbol.classKind != ClassKind.ANNOTATION_CLASS) {\n            return\n        }\n        val classId = typealiasedClassSymbol.classId\n        if (isAnnotationProhibitedInActualTypeAlias(classId)) {\n            reporter.reportOn(declaration.source, FirErrors.ACTUAL_TYPEALIAS_TO_SPECIAL_ANNOTATION, classId, context)\n        }\n    }\n}\n"}
{"code": "// DO_NOT_CHECK_SYMBOL_RESTORE_K1\nannotation class Foo(vararg val ints:) {\n\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.standalone.fir.test.configurators\n\nimport com.intellij.mock.MockProject\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisApiInternals\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeTokenProvider\nimport org.jetbrains.kotlin.analysis.api.standalone.KtAlwaysAccessibleLifetimeTokenProvider\nimport org.jetbrains.kotlin.analysis.api.standalone.base.project.structure.LLFirStandaloneLibrarySymbolProviderFactory\nimport org.jetbrains.kotlin.analysis.api.standalone.base.services.LLStandaloneFirElementByPsiElementChooser\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.services.LLFirElementByPsiElementChooser\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.project.structure.LLFirLibrarySymbolProviderFactory\nimport org.jetbrains.kotlin.analysis.providers.KotlinPsiDeclarationProviderFactory\nimport org.jetbrains.kotlin.analysis.providers.impl.KotlinStaticPsiDeclarationProviderFactory\nimport org.jetbrains.kotlin.analysis.test.f"}
{"code": "ramework.test.configurators.AnalysisApiTestServiceRegistrar\nimport org.jetbrains.kotlin.test.services.TestServices\n\n@OptIn(KtAnalysisApiInternals::class)\npublic object StandaloneModeTestServiceRegistrar : AnalysisApiTestServiceRegistrar() {\n    override fun registerProjectServices(project: MockProject, testServices: TestServices) {\n        project.apply {\n            registerService(KtLifetimeTokenProvider::class.java, KtAlwaysAccessibleLifetimeTokenProvider::class.java)\n            registerService(LLFirLibrarySymbolProviderFactory::class.java, LLFirStandaloneLibrarySymbolProviderFactory::class.java)\n            registerService(LLFirElementByPsiElementChooser::class.java, LLStandaloneFirElementByPsiElementChooser::class.java)\n        }\n    }\n\n    override fun registerProjectModelServices(project: MockProject, testServices: TestServices) {\n        project.apply {\n            registerService(\n                KotlinPsiDeclarationProviderFactory::class.java,\n                KotlinStaticPsi"}
{"code": "DeclarationProviderFactory::class.java\n            )\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.impl.base.test.cases.components.psiTypeProvider\n\nimport org.jetbrains.kotlin.analysis.api.analyze\nimport org.jetbrains.kotlin.analysis.api.impl.base.test.cases.components.psiTypeProvider.AnalysisApiPsiTypeProviderTestUtils.findLightDeclarationContext\nimport org.jetbrains.kotlin.analysis.api.impl.base.test.cases.components.psiTypeProvider.AnalysisApiPsiTypeProviderTestUtils.getContainingKtLightClass\nimport org.jetbrains.kotlin.analysis.api.types.KtTypeMappingMode\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.test.framework.services.expressionMarkerProvider\nimport org.jetbrains.kotlin.analysis.utils.printer.parentOfType\nimport org.jetbrains.kotlin.analysis.utils.printer.prettyPrint\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtExpression\nimport org.jetbr"}
{"code": "ains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.psi.KtValueArgument\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.assertions\n\nabstract class AbstractAnalysisApiExpressionPsiTypeProviderTest : AbstractAnalysisApiBasedTest() {\n    override fun doTestByMainFile(mainFile: KtFile, mainModule: KtTestModule, testServices: TestServices) {\n        val declarationAtCaret = when (val element = testServices.expressionMarkerProvider.getSelectedElement(mainFile)) {\n            is KtExpression -> element\n            is KtValueArgument -> element.getArgumentExpression()!!\n            else -> error(\"Unexpected element: $element of ${element::class}\")\n        }\n\n        val containingDeclaration = declarationAtCaret.parentOfType<KtDeclaration>()\n            ?: error(\"Can't find containing declaration for $declarationAtCaret\")\n\n        val containingClass = getContainingKtLightClass(containingDeclaration, mainFile)\n        val psiContext = containingC"}
{"code": "lass.findLightDeclarationContext(containingDeclaration)\n            ?: error(\"Can't find psi context for $containingDeclaration\")\n\n        val actual = analyze(mainFile) {\n            val returnType = declarationAtCaret.getKtType()\n            if (returnType != null) {\n                prettyPrint {\n                    appendLine(\"KtType: ${AnalysisApiPsiTypeProviderTestUtils.render(returnType)}\")\n                    for (allowErrorTypes in listOf(false, true)) {\n                        for (typeMappingMode in KtTypeMappingMode.entries) {\n                            for (isAnnotationMethod in listOf(false, true)) {\n                                val psiType = returnType.asPsiType(psiContext, allowErrorTypes, typeMappingMode, isAnnotationMethod)\n                                appendLine(\"asPsiType(allowErrorTypes=$allowErrorTypes, mode=$typeMappingMode, isAnnotationMethod=$isAnnotationMethod):\")\n                                withIndent {\n                                    appendLine"}
{"code": "(\"PsiType: ${AnalysisApiPsiTypeProviderTestUtils.render(psiType)}\")\n                                }\n                                appendLine()\n                            }\n                        }\n                    }\n                }\n            } else {\n                \"null\"\n            }\n        }\n\n        testServices.assertions.assertEqualsToTestDataFileSibling(actual)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cli.common\n\nimport org.jetbrains.kotlin.util.PerformanceCounter\nimport java.io.File\nimport java.lang.management.GarbageCollectorMXBean\nimport java.lang.management.ManagementFactory\nimport java.util.concurrent.TimeUnit\n\nabstract class CommonCompilerPerformanceManager(private val presentableName: String) {\n    @Suppress(\"MemberVisibilityCanBePrivate\")\n    protected val measurements: MutableList<PerformanceMeasurement> = mutableListOf()\n    protected var isEnabled: Boolean = false\n    private var initStartNanos = PerformanceCounter.currentTime()\n    private var analysisStart: Long = 0\n    private var generationStart: Long = 0\n\n    private var startGCData = mutableMapOf<String, GCData>()\n\n    private var irTranslationStart: Long = 0\n    private var irLoweringStart: Long = 0\n    private var irGenerationStart: Long = 0\n\n    private var targetDescription: String? = null\n    protected var files: Int? = null\n    protected var lines: Int? = null\n\n    fun getTargetI"}
{"code": "nfo(): String =\n        \"$targetDescription, $files files ($lines lines)\"\n\n    fun getMeasurementResults(): List<PerformanceMeasurement> = measurements\n\n    fun enableCollectingPerformanceStatistics() {\n        isEnabled = true\n        PerformanceCounter.setTimeCounterEnabled(true)\n        ManagementFactory.getGarbageCollectorMXBeans().associateTo(startGCData) { it.name to GCData(it) }\n    }\n\n    private fun deltaTime(start: Long): Long = PerformanceCounter.currentTime() - start\n\n    open fun notifyCompilerInitialized(files: Int, lines: Int, targetDescription: String) {\n        if (!isEnabled) return\n        recordInitializationTime()\n\n        this.files = files\n        this.lines = lines\n        this.targetDescription = targetDescription\n    }\n\n    open fun notifyCompilationFinished() {\n        if (!isEnabled) return\n        recordGcTime()\n        recordJitCompilationTime()\n        recordPerfCountersMeasurements()\n    }\n\n    open fun addSourcesStats(files: Int, lines: Int) {\n        i"}
{"code": "f (!isEnabled) return\n        this.files = this.files?.plus(files) ?: files\n        this.lines = this.lines?.plus(lines) ?: lines\n    }\n\n    open fun notifyAnalysisStarted() {\n        analysisStart = PerformanceCounter.currentTime()\n    }\n\n    open fun notifyAnalysisFinished() {\n        val time = PerformanceCounter.currentTime() - analysisStart\n        measurements += CodeAnalysisMeasurement(lines, TimeUnit.NANOSECONDS.toMillis(time))\n    }\n\n    open fun notifyGenerationStarted() {\n        generationStart = PerformanceCounter.currentTime()\n    }\n\n    open fun notifyGenerationFinished() {\n        val time = PerformanceCounter.currentTime() - generationStart\n        measurements += CodeGenerationMeasurement(lines, TimeUnit.NANOSECONDS.toMillis(time))\n    }\n\n    open fun notifyIRTranslationStarted() {\n        irTranslationStart = PerformanceCounter.currentTime()\n    }\n\n    open fun notifyIRTranslationFinished() {\n        val time = deltaTime(irTranslationStart)\n        measurements += IR"}
{"code": "Measurement(\n            lines,\n            TimeUnit.NANOSECONDS.toMillis(time),\n            IRMeasurement.Kind.TRANSLATION\n        )\n    }\n\n    open fun notifyIRLoweringStarted() {\n        irLoweringStart = PerformanceCounter.currentTime()\n    }\n\n    open fun notifyIRLoweringFinished() {\n        val time = deltaTime(irLoweringStart)\n        measurements += IRMeasurement(\n            lines,\n            TimeUnit.NANOSECONDS.toMillis(time),\n            IRMeasurement.Kind.LOWERING\n        )\n    }\n\n    open fun notifyIRGenerationStarted() {\n        irGenerationStart = PerformanceCounter.currentTime()\n    }\n\n    open fun notifyIRGenerationFinished() {\n        val time = deltaTime(irGenerationStart)\n        measurements += IRMeasurement(\n            lines,\n            TimeUnit.NANOSECONDS.toMillis(time),\n            IRMeasurement.Kind.GENERATION\n        )\n    }\n\n    fun dumpPerformanceReport(destination: File) {\n        destination.writeBytes(createPerformanceReport())\n    }\n\n    private fun"}
{"code": " recordGcTime() {\n        if (!isEnabled) return\n\n        ManagementFactory.getGarbageCollectorMXBeans().forEach {\n            val startCounts = startGCData[it.name]\n            val startCollectionTime = startCounts?.collectionTime ?: 0\n            val startCollectionCount = startCounts?.collectionCount ?: 0\n            measurements += GarbageCollectionMeasurement(\n                it.name,\n                it.collectionTime - startCollectionTime,\n                it.collectionCount - startCollectionCount\n            )\n        }\n    }\n\n    private fun recordJitCompilationTime() {\n        if (!isEnabled) return\n\n        val bean = ManagementFactory.getCompilationMXBean() ?: return\n        measurements += JitCompilationMeasurement(bean.totalCompilationTime)\n    }\n\n    private fun recordInitializationTime() {\n        val time = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - initStartNanos)\n        measurements += CompilerInitializationMeasurement(time)\n    }\n\n    private fun recordPerfCou"}
{"code": "ntersMeasurements() {\n        PerformanceCounter.report { s -> measurements += PerformanceCounterMeasurement(s) }\n    }\n\n    private fun createPerformanceReport(): ByteArray = buildString {\n        append(\"$presentableName performance report\\n\")\n        measurements.map { it.render() }.sorted().forEach { append(\"$it\\n\") }\n    }.toByteArray()\n\n    open fun notifyRepeat(total: Int, number: Int) {}\n\n    private data class GCData(val name: String, val collectionTime: Long, val collectionCount: Long) {\n        constructor(bean: GarbageCollectorMXBean) : this(bean.name, bean.collectionTime, bean.collectionCount)\n    }\n\n    fun renderCompilerPerformance(): String {\n        val relevantMeasurements = getMeasurementResults().filter {\n            it is CompilerInitializationMeasurement || it is CodeAnalysisMeasurement || it is CodeGenerationMeasurement || it is PerformanceCounterMeasurement\n        }\n\n        return \"Compiler perf stats:\\n\" + relevantMeasurements.joinToString(separator = \"\\n\") {"}
{"code": " \"  ${it.render()}\" }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.*\nimport com.intellij.psi.util.CachedValueProvider\nimport com.intellij.psi.util.CachedValuesManager\nimport com.intellij.psi.util.TypeConversionUtil\nimport com.intellij.util.IncorrectOperationException\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.annotations.*\nimport org.jetbrains.kotlin.analysis.api.base.KtConstantValue\nimport org.jetbrains.kotlin.analysis.api.symbols.*\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolWithModality\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolWithTypeParameters\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolWithVisibility\nimport org.jetbrains.kotlin.analysis.api.symbols.pointers.KtSymbolPointer\nimport org.jetbrains.kotlin.analysis.api.types.*\nimport org.jetbrains.kotlin.analysis.project.structure.KtModule\nimport org.jetbrains.k"}
{"code": "otlin.analysis.providers.createProjectWideOutOfBlockModificationTracker\nimport org.jetbrains.kotlin.asJava.elements.KtLightElement\nimport org.jetbrains.kotlin.asJava.elements.KtLightMember\nimport org.jetbrains.kotlin.asJava.elements.psiType\nimport org.jetbrains.kotlin.descriptors.Modality\nimport org.jetbrains.kotlin.descriptors.Visibilities\nimport org.jetbrains.kotlin.descriptors.Visibility\nimport org.jetbrains.kotlin.light.classes.symbol.annotations.*\nimport org.jetbrains.kotlin.light.classes.symbol.classes.SymbolLightClassBase\nimport org.jetbrains.kotlin.light.classes.symbol.classes.SymbolLightClassForClassLike\nimport org.jetbrains.kotlin.light.classes.symbol.classes.SymbolLightClassForInterface\nimport org.jetbrains.kotlin.light.classes.symbol.classes.SymbolLightClassForInterfaceDefaultImpls\nimport org.jetbrains.kotlin.light.classes.symbol.classes.modificationTrackerForClassInnerStuff\nimport org.jetbrains.kotlin.load.java.JvmAnnotationNames\nimport org.jetbrains.kotlin.name.SpecialNam"}
{"code": "es\nimport org.jetbrains.kotlin.psi.KtTypeParameterListOwner\nimport org.jetbrains.kotlin.utils.exceptions.errorWithAttachment\nimport java.util.*\n\ninternal fun <L : Any> L.invalidAccess(): Nothing =\n    error(\"Cls delegate shouldn't be accessed for symbol light classes! Qualified name: ${javaClass.name}\")\n\ncontext(KtAnalysisSession)\ninternal fun KtDeclarationSymbol.getContainingSymbolsWithSelf(): Sequence<KtDeclarationSymbol> =\n    generateSequence(this) { it.getContainingSymbol() }\n\ninternal fun KtAnalysisSession.mapType(\n    type: KtType,\n    psiContext: PsiElement,\n    mode: KtTypeMappingMode,\n): PsiClassType? {\n    val psiType = type.asPsiType(\n        useSitePosition = psiContext,\n        allowErrorTypes = true,\n        mode = mode,\n    )\n\n    return psiType as? PsiClassType\n}\n\ninternal fun KtSymbolWithModality.computeSimpleModality(): String? = when (modality) {\n    Modality.SEALED -> PsiModifier.ABSTRACT\n    Modality.FINAL -> PsiModifier.FINAL\n    Modality.ABSTRACT -> PsiModifier."}
{"code": "ABSTRACT\n    Modality.OPEN -> null\n}\n\ncontext(KtAnalysisSession)\ninternal fun KtClassOrObjectSymbol.enumClassModality(): String? {\n    if (getMemberScope().getCallableSymbols().any { (it as? KtSymbolWithModality)?.modality == Modality.ABSTRACT }) {\n        return PsiModifier.ABSTRACT\n    }\n\n    if (getStaticDeclaredMemberScope().getCallableSymbols().none { it is KtEnumEntrySymbol && it.requiresSubClass() }) {\n        return PsiModifier.FINAL\n    }\n\n    return null\n}\n\ncontext(KtAnalysisSession)\nprivate fun KtEnumEntrySymbol.requiresSubClass(): Boolean {\n    val initializer = enumEntryInitializer ?: return false\n    return initializer.getCombinedDeclaredMemberScope().getAllSymbols().any { it !is KtConstructorSymbol }\n}\n\ninternal fun KtSymbolWithVisibility.toPsiVisibilityForMember(): String = visibility.toPsiVisibilityForMember()\n\ninternal fun KtSymbolWithVisibility.toPsiVisibilityForClass(isNested: Boolean): String = visibility.toPsiVisibilityForClass(isNested)\n\nprivate fun Visibility.to"}
{"code": "PsiVisibilityForMember(): String = when (this) {\n    Visibilities.Private, Visibilities.PrivateToThis -> PsiModifier.PRIVATE\n    Visibilities.Protected -> PsiModifier.PROTECTED\n    else -> PsiModifier.PUBLIC\n}\n\nprivate fun Visibility.toPsiVisibilityForClass(isNested: Boolean): String = when (isNested) {\n    false -> when (this) {\n        Visibilities.Public,\n        Visibilities.Protected,\n        Visibilities.Local,\n        Visibilities.Internal -> PsiModifier.PUBLIC\n\n        else -> PsiModifier.PACKAGE_LOCAL\n    }\n\n    true -> when (this) {\n        Visibilities.Public, Visibilities.Internal, Visibilities.Local -> PsiModifier.PUBLIC\n        Visibilities.Protected -> PsiModifier.PROTECTED\n        Visibilities.Private -> PsiModifier.PRIVATE\n        else -> PsiModifier.PACKAGE_LOCAL\n    }\n}\n\ninternal fun basicIsEquivalentTo(`this`: PsiElement?, that: PsiElement?): Boolean {\n    if (`this` == null || that == null) return false\n    if (`this` == that) return true\n\n    if (`this` !is KtLigh"}
{"code": "tElement<*, *>) return false\n    if (that !is KtLightElement<*, *>) return false\n    if (`this`.kotlinOrigin?.isEquivalentTo(that.kotlinOrigin) == true) return true\n\n    val thisMemberOrigin = (`this` as? KtLightMember<*>)?.lightMemberOrigin ?: return false\n    if (thisMemberOrigin.isEquivalentTo(that)) return true\n\n    val thatMemberOrigin = (that as? KtLightMember<*>)?.lightMemberOrigin ?: return false\n    return thisMemberOrigin.isEquivalentTo(thatMemberOrigin)\n}\n\ninternal fun KtLightElement<*, *>.isOriginEquivalentTo(that: PsiElement?): Boolean {\n    return kotlinOrigin?.isEquivalentTo(that) == true\n}\n\ninternal fun KtAnalysisSession.getTypeNullability(type: KtType): KtTypeNullability {\n    if (type is KtClassErrorType) return KtTypeNullability.NON_NULLABLE\n\n    val ktType = type.fullyExpandedType\n    if (ktType.nullability != KtTypeNullability.NON_NULLABLE) return ktType.nullability\n\n    if (ktType.isUnit) return KtTypeNullability.NON_NULLABLE\n\n    if (ktType.isPrimitiveBacked) ret"}
{"code": "urn KtTypeNullability.UNKNOWN\n\n    if (ktType is KtTypeParameterType) {\n        if (ktType.isMarkedNullable) return KtTypeNullability.NULLABLE\n        val subtypeOfNullableSuperType = ktType.symbol.upperBounds.all { upperBound -> upperBound.canBeNull }\n        return if (!subtypeOfNullableSuperType) KtTypeNullability.NON_NULLABLE else KtTypeNullability.UNKNOWN\n    }\n\n    if (ktType !is KtNonErrorClassType) return KtTypeNullability.NON_NULLABLE\n    if (ktType.ownTypeArguments.any { it.type is KtClassErrorType }) return KtTypeNullability.NON_NULLABLE\n    if (ktType.classId.shortClassName.asString() == SpecialNames.ANONYMOUS_STRING) return KtTypeNullability.NON_NULLABLE\n\n    return ktType.nullability\n}\n\ninternal val KtTypeNullability.asAnnotationQualifier: String?\n    get() = when (this) {\n        KtTypeNullability.NON_NULLABLE -> JvmAnnotationNames.JETBRAINS_NOT_NULL_ANNOTATION\n        KtTypeNullability.NULLABLE -> JvmAnnotationNames.JETBRAINS_NULLABLE_ANNOTATION\n        else -> null\n   "}
{"code": " }?.asString()\n\nprivate fun escapeString(s: String): String = buildString {\n    s.forEach {\n        when (it) {\n            '\\n' -> append(\"\\\\n\")\n            '\\r' -> append(\"\\\\r\")\n            '\\t' -> append(\"\\\\t\")\n            '\"' -> append(\"\\\\\\\"\")\n            '\\\\' -> append(\"\\\\\\\\\")\n            else -> if (it.code in 32..128) {\n                append(it)\n            } else {\n                append(\"\\\\u%04X\".format(it.code))\n            }\n        }\n    }\n}\n\ninternal fun KtAnnotationValue.toAnnotationMemberValue(parent: PsiElement): PsiAnnotationMemberValue? = when (this) {\n    is KtArrayAnnotationValue ->\n        SymbolPsiArrayInitializerMemberValue(sourcePsi, parent) { arrayLiteralParent ->\n            values.mapNotNull { element -> element.toAnnotationMemberValue(arrayLiteralParent) }\n        }\n\n    is KtAnnotationApplicationValue -> {\n        SymbolLightSimpleAnnotation(\n            fqName = annotationValue.classId?.asFqNameString(),\n            parent = parent,\n            arguments "}
{"code": "= annotationValue.normalizedArguments(),\n            kotlinOrigin = annotationValue.psi,\n        )\n    }\n    is KtConstantAnnotationValue -> {\n        constantValue.createPsiExpression(parent)?.let {\n            when (it) {\n                is PsiLiteralExpression -> SymbolPsiLiteral(sourcePsi, parent, it)\n                else -> SymbolPsiExpression(sourcePsi, parent, it)\n            }\n        }\n    }\n\n    is KtEnumEntryAnnotationValue -> asPsiReferenceExpression(parent)\n    is KtKClassAnnotationValue -> toAnnotationMemberValue(parent)\n    KtUnsupportedAnnotationValue -> null\n}\n\ninternal fun KtAnnotationApplicationWithArgumentsInfo.normalizedArguments(): List<KtNamedAnnotationValue> {\n    val args = arguments\n    val ctorSymbolPointer = constructorSymbolPointer ?: return args\n    val element = psi ?: return args // May work incorrectly. See KT-63568\n\n    return analyzeForLightClasses(element) {\n        val constructorSymbol = ctorSymbolPointer.restoreSymbolOrThrowIfDisposed()\n        va"}
{"code": "l params = constructorSymbol.valueParameters\n        val missingVarargParameterName =\n            params.singleOrNull { it.isVararg && !it.hasDefaultValue }?.name?.takeIf { name -> args.none { it.name == name } }\n        if (missingVarargParameterName == null) args\n        else args + KtNamedAnnotationValue(missingVarargParameterName, KtArrayAnnotationValue(emptyList(), null))\n    }\n}\n\n\nprivate fun KtEnumEntryAnnotationValue.asPsiReferenceExpression(parent: PsiElement): SymbolPsiReference? {\n    val fqName = this.callableId?.asSingleFqName()?.asString() ?: return null\n    val psiReference = parent.project.withElementFactorySafe {\n        createExpressionFromText(fqName, parent) as? PsiReferenceExpression\n    } ?: return null\n\n    return SymbolPsiReference(sourcePsi, parent, psiReference)\n}\n\nprivate fun KtKClassAnnotationValue.toAnnotationMemberValue(parent: PsiElement): SymbolPsiClassObjectAccessExpression? {\n    val typeString = when (this) {\n        is KtKClassAnnotationValue.KtNonLo"}
{"code": "calKClassAnnotationValue -> classId.asSingleFqName().asString()\n        is KtKClassAnnotationValue.KtLocalKClassAnnotationValue -> null\n        is KtKClassAnnotationValue.KtErrorClassAnnotationValue -> unresolvedQualifierName\n    } ?: return null\n\n    val psiType = psiType(\n        kotlinFqName = typeString,\n        context = parent,\n        boxPrimitiveType = false, \n    ).let(TypeConversionUtil::erasure)\n\n    return SymbolPsiClassObjectAccessExpression(sourcePsi, parent, psiType)\n}\n\nprivate fun KtConstantValue.asStringForPsiExpression(): String =\n    when (val value = value) {\n        Double.NEGATIVE_INFINITY -> \"-1.0 / 0.0\"\n        Double.NaN -> \"0.0 / 0.0\"\n        Double.POSITIVE_INFINITY -> \"1.0 / 0.0\"\n        Float.NEGATIVE_INFINITY -> \"-1.0F / 0.0F\"\n        Float.NaN -> \"0.0F / 0.0F\"\n        Float.POSITIVE_INFINITY -> \"1.0F / 0.0F\"\n        '\\'' -> \"'\\\\''\"\n        is Char -> \"'${escapeString(value.toString())}'\"\n        is String -> \"\\\"${escapeString(value)}\\\"\"\n        is Long ->"}
{"code": " \"${value}L\"\n        is Float -> \"${value}f\"\n        else -> value.toString()\n    }\n\ninternal fun KtConstantValue.createPsiExpression(parent: PsiElement): PsiExpression? {\n    val asString = asStringForPsiExpression()\n    return parent.project.withElementFactorySafe {\n        createExpressionFromText(asString, parent)\n    }\n}\n\ninternal inline fun <T> Project.withElementFactorySafe(crossinline action: PsiElementFactory.() -> T): T? {\n    val instance = PsiElementFactory.getInstance(this)\n    return try {\n        instance.action()\n    } catch (_: IncorrectOperationException) {\n        null\n    }\n}\n\ninternal fun BitSet.copy(): BitSet = clone() as BitSet\n\ncontext(KtAnalysisSession)\ninternal fun <T : KtSymbol> KtSymbolPointer<T>.restoreSymbolOrThrowIfDisposed(): T =\n    restoreSymbol()\n        ?: errorWithAttachment(\"${this::class} pointer already disposed\") {\n            withEntry(\"pointer\", this@restoreSymbolOrThrowIfDisposed) { it.toString() }\n        }\n\ninternal fun hasTypeParameters(\n "}
{"code": "   ktModule: KtModule,\n    declaration: KtTypeParameterListOwner?,\n    declarationPointer: KtSymbolPointer<KtSymbolWithTypeParameters>,\n): Boolean = declaration?.typeParameters?.isNotEmpty() ?: declarationPointer.withSymbol(ktModule) {\n    it.typeParameters.isNotEmpty()\n}\n\ninternal val SymbolLightClassBase.interfaceIfDefaultImpls: SymbolLightClassForInterface?\n    get() = (this as? SymbolLightClassForInterfaceDefaultImpls)?.containingClass\n\ninternal val SymbolLightClassBase.isDefaultImplsForInterfaceWithTypeParameters: Boolean\n    get() = interfaceIfDefaultImpls?.hasTypeParameters() ?: false\n\ninternal fun KtSymbolPointer<*>.isValid(ktModule: KtModule): Boolean = analyzeForLightClasses(ktModule) {\n    restoreSymbol() != null\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun <T : KtSymbol> compareSymbolPointers(\n    left: KtSymbolPointer<T>,\n    right: KtSymbolPointer<T>,\n): Boolean = left === right || left.pointsToTheSameSymbolAs(right)\n\ninternal inline fun <T : KtSymbol, R> KtSymbo"}
{"code": "lPointer<T>.withSymbol(\n    ktModule: KtModule,\n    crossinline action: KtAnalysisSession.(T) -> R,\n): R = analyzeForLightClasses(ktModule) { action(this, restoreSymbolOrThrowIfDisposed()) }\n\ninternal val KtPropertySymbol.isConstOrJvmField: Boolean get() = isConst || isJvmField\ninternal val KtPropertySymbol.isJvmField: Boolean get() = backingFieldSymbol?.hasJvmFieldAnnotation() == true\ninternal val KtPropertySymbol.isConst: Boolean get() = (this as? KtKotlinPropertySymbol)?.isConst == true\ninternal val KtPropertySymbol.isLateInit: Boolean get() = (this as? KtKotlinPropertySymbol)?.isLateInit == true\ninternal val KtPropertySymbol.canHaveNonPrivateField: Boolean get() = isConstOrJvmField || isLateInit\n\ninternal inline fun <reified T> Collection<T>.toArrayIfNotEmptyOrDefault(default: Array<T>): Array<T> {\n    return if (isNotEmpty()) toTypedArray() else default\n}\n\ninternal inline fun <R : PsiElement, T> R.cachedValue(\n    crossinline computer: () -> T,\n): T = CachedValuesManager.getCached"}
{"code": "Value(this) {\n    val value = computer()\n    val specialClassTrackers = (this as? SymbolLightClassForClassLike<*>)?.classOrObjectDeclaration?.modificationTrackerForClassInnerStuff()\n    if (specialClassTrackers != null) {\n        CachedValueProvider.Result.create(value, specialClassTrackers)\n    } else {\n        CachedValueProvider.Result.createSingleDependency(value, project.createProjectWideOutOfBlockModificationTracker())\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.calls.util\n\nimport com.google.common.collect.Lists\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.builtins.KotlinBuiltIns\nimport org.jetbrains.kotlin.builtins.ReflectionTypes\nimport org.jetbrains.kotlin.builtins.isSuspendFunctionType\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.config.LanguageVersionSettings\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.descriptors.impl.TypeAliasConstructorDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.lexer.KtToken\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType\nimport org.jetbrains.kotlin.resolve.BindingTrace\nimport org.jetbrains.kotlin.resolve.calls.CallTransformer\nimport org.jetbrains.kotlin.resolve.calls.components.KotlinResolutionCallbacks\nimport org.jetbrains.kotlin.resolve.calls.components.isVararg\nimport org.jetbrains.kotlin.resolve.calls.context."}
{"code": "BasicCallResolutionContext\nimport org.jetbrains.kotlin.resolve.calls.context.ResolutionContext\nimport org.jetbrains.kotlin.resolve.calls.inference.ComposedSubstitutor\nimport org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem\nimport org.jetbrains.kotlin.resolve.calls.inference.components.EmptySubstitutor\nimport org.jetbrains.kotlin.resolve.calls.inference.components.NewTypeSubstitutor\nimport org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind.EXPECTED_TYPE_POSITION\nimport org.jetbrains.kotlin.resolve.calls.inference.getNestedTypeVariables\nimport org.jetbrains.kotlin.resolve.calls.model.*\nimport org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind\nimport org.jetbrains.kotlin.resolve.calls.tasks.OldResolutionCandidate\nimport org.jetbrains.kotlin.resolve.calls.tower.*\nimport org.jetbrains.kotlin.resolve.descriptorUtil.inlineClassRepresentation\nimport org.jetbrains.kotlin.resolve.descriptorUtil.isParameterOfAnnotation\nimport org.jetbrai"}
{"code": "ns.kotlin.resolve.isInlineClassType\nimport org.jetbrains.kotlin.resolve.scopes.LexicalScope\nimport org.jetbrains.kotlin.resolve.scopes.SyntheticScopes\nimport org.jetbrains.kotlin.resolve.scopes.collectSyntheticConstructors\nimport org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver\nimport org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValue\nimport org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValueWithSmartCastInfo\nimport org.jetbrains.kotlin.resolve.scopes.utils.getImplicitReceiversHierarchy\nimport org.jetbrains.kotlin.types.*\nimport org.jetbrains.kotlin.types.error.ErrorUtils\nimport org.jetbrains.kotlin.types.TypeUtils.DONT_CARE\nimport org.jetbrains.kotlin.types.checker.KotlinTypeChecker\nimport org.jetbrains.kotlin.types.error.ErrorScopeKind\nimport org.jetbrains.kotlin.types.expressions.OperatorConventions\nimport org.jetbrains.kotlin.types.typeUtil.contains\nimport org.jetbrains.kotlin.util.buildNotFixedVariablesToPossibleResultType\nimport org.jetbrains.kotl"}
{"code": "in.utils.SmartList\n\nenum class ResolveArgumentsMode {\n    RESOLVE_FUNCTION_ARGUMENTS,\n    SHAPE_FUNCTION_ARGUMENTS\n}\n\n\nfun hasUnknownFunctionParameter(type: KotlinType): Boolean {\n    assert(ReflectionTypes.isCallableType(type) || type.isSuspendFunctionType) { \"type $type is not a function or property\" }\n    return getParameterArgumentsOfCallableType(type).any { typeProjection ->\n        typeProjection.type.contains { TypeUtils.isDontCarePlaceholder(it) }\n                || ErrorUtils.containsUninferredTypeVariable(typeProjection.type)\n    }\n}\n\nfun hasUnknownReturnType(type: KotlinType): Boolean {\n    assert(ReflectionTypes.isCallableType(type) || type.isSuspendFunctionType) { \"type $type is not a function or property\" }\n    return ErrorUtils.containsErrorType(getReturnTypeForCallable(type))\n}\n\nfun replaceReturnTypeForCallable(type: KotlinType, given: KotlinType): KotlinType {\n    assert(ReflectionTypes.isCallableType(type) || type.isSuspendFunctionType) { \"type $type is not a function"}
{"code": " or property\" }\n    val newArguments = Lists.newArrayList<TypeProjection>()\n    newArguments.addAll(getParameterArgumentsOfCallableType(type))\n    newArguments.add(TypeProjectionImpl(Variance.INVARIANT, given))\n    return replaceTypeArguments(type, newArguments)\n}\n\nfun replaceReturnTypeByUnknown(type: KotlinType) = replaceReturnTypeForCallable(type, DONT_CARE)\n\nprivate fun replaceTypeArguments(type: KotlinType, newArguments: List<TypeProjection>) =\n    KotlinTypeFactory.simpleType(type.attributes, type.constructor, newArguments, type.isMarkedNullable)\n\nprivate fun getParameterArgumentsOfCallableType(type: KotlinType) =\n    type.arguments.dropLast(1)\n\nfun getReturnTypeForCallable(type: KotlinType) =\n    type.arguments.last().type\n\nprivate fun CallableDescriptor.hasReturnTypeDependentOnUninferredParams(constraintSystem: ConstraintSystem): Boolean {\n    val returnType = returnType ?: return false\n    val nestedTypeVariables = constraintSystem.getNestedTypeVariables(returnType)\n    return "}
{"code": "nestedTypeVariables.any { constraintSystem.getTypeBounds(it).value == null }\n}\n\nfun CallableDescriptor.hasInferredReturnType(constraintSystem: ConstraintSystem): Boolean {\n    if (hasReturnTypeDependentOnUninferredParams(constraintSystem)) return false\n\n    // Expected type mismatch was reported before as 'TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH'\n    if (constraintSystem.status.hasOnlyErrorsDerivedFrom(EXPECTED_TYPE_POSITION)) return false\n    return true\n}\n\nprivate fun filterOutTypeParameters(upperBounds: List<KotlinType>, candidateDescriptor: CallableDescriptor): List<KotlinType> {\n    if (upperBounds.size < 2) return upperBounds\n    val result = upperBounds.filterNot {\n        val declarationDescriptor = it.constructor.declarationDescriptor\n        declarationDescriptor is TypeParameterDescriptor && declarationDescriptor.containingDeclaration == candidateDescriptor\n    }\n    if (result.isEmpty()) return upperBounds\n    return result\n}\n\nfun getErasedReceiverType(receiverParameterDescri"}
{"code": "ptor: ReceiverParameterDescriptor, descriptor: CallableDescriptor): KotlinType {\n    var receiverType = receiverParameterDescriptor.type\n    for (typeParameter in descriptor.typeParameters) {\n        if (typeParameter.typeConstructor == receiverType.constructor) {\n            val properUpperBounds = filterOutTypeParameters(typeParameter.upperBounds, descriptor)\n            receiverType = TypeIntersector.intersectUpperBounds(typeParameter, properUpperBounds)\n        }\n    }\n    val fakeTypeArguments = SmartList<TypeProjection>()\n    for (typeProjection in receiverType.arguments) {\n        fakeTypeArguments.add(TypeProjectionImpl(typeProjection.projectionKind, DONT_CARE))\n    }\n\n    val oldReceiverTypeConstructor = receiverType.constructor\n    val receiverTypeConstructor = if (oldReceiverTypeConstructor is IntersectionTypeConstructor) {\n        oldReceiverTypeConstructor.transformComponents { supertype ->\n            val fakeArguments = supertype.arguments.map { TypeProjectionImpl(it.pro"}
{"code": "jectionKind, DONT_CARE) }\n            supertype.replace(fakeArguments)\n        } ?: oldReceiverTypeConstructor\n    } else {\n        oldReceiverTypeConstructor\n    }\n\n    return KotlinTypeFactory.simpleTypeWithNonTrivialMemberScope(\n        receiverType.attributes, receiverTypeConstructor, fakeTypeArguments,\n        receiverType.isMarkedNullable, ErrorUtils.createErrorScope(ErrorScopeKind.ERASED_RECEIVER_TYPE_SCOPE, throwExceptions = true)\n    )\n}\n\nfun isOrOverridesSynthesized(descriptor: CallableMemberDescriptor): Boolean {\n    if (descriptor.kind == CallableMemberDescriptor.Kind.SYNTHESIZED) {\n        return true\n    }\n    if (descriptor.kind == CallableMemberDescriptor.Kind.FAKE_OVERRIDE) {\n        return descriptor.overriddenDescriptors.all(::isOrOverridesSynthesized)\n    }\n    return false\n}\n\nfun isBinaryRemOperator(call: Call): Boolean {\n    val callElement = call.callElement as? KtBinaryExpression ?: return false\n    val operator = callElement.operationToken\n    if (operator !is "}
{"code": "KtToken) return false\n\n    val name = OperatorConventions.getNameForOperationSymbol(operator, true, true) ?: return false\n    return name in OperatorConventions.REM_TO_MOD_OPERATION_NAMES.keys\n}\n\nfun isConventionCall(call: Call): Boolean {\n    if (call is CallTransformer.CallForImplicitInvoke) return true\n    val callElement = call.callElement\n    if (callElement is KtArrayAccessExpression || callElement is KtDestructuringDeclarationEntry) return true\n    val calleeExpression = call.calleeExpression as? KtOperationReferenceExpression ?: return false\n    return calleeExpression.isConventionOperator()\n}\n\nfun isInfixCall(call: Call): Boolean {\n    val operationRefExpression = call.calleeExpression as? KtOperationReferenceExpression ?: return false\n    val binaryExpression = operationRefExpression.parent as? KtBinaryExpression ?: return false\n    return binaryExpression.operationReference === operationRefExpression && operationRefExpression.operationSignTokenType == null\n}\n\nfun isSuperOrDe"}
{"code": "legatingConstructorCall(call: Call): Boolean =\n    call.calleeExpression.let { it is KtConstructorCalleeExpression || it is KtConstructorDelegationReferenceExpression }\n\nfun isInvokeCallOnVariable(call: Call): Boolean {\n    if (call.callType !== Call.CallType.INVOKE) return false\n    val dispatchReceiver = call.dispatchReceiver\n    //calleeExpressionAsDispatchReceiver for invoke is always ExpressionReceiver, see CallForImplicitInvoke\n    val expression = (dispatchReceiver as ExpressionReceiver).expression\n    return expression is KtSimpleNameExpression\n}\n\nfun isInvokeCallOnExpressionWithBothReceivers(call: Call): Boolean {\n    if (call.callType !== Call.CallType.INVOKE || isInvokeCallOnVariable(call)) return false\n    return call.explicitReceiver != null && call.dispatchReceiver != null\n}\n\nfun getSuperCallExpression(call: Call): KtSuperExpression? {\n    return (call.explicitReceiver as? ExpressionReceiver)?.expression as? KtSuperExpression\n}\n\nfun getEffectiveExpectedType(\n    parameter"}
{"code": "Descriptor: ValueParameterDescriptor,\n    resolvedArgument: ResolvedValueArgument,\n    languageVersionSettings: LanguageVersionSettings,\n    trace: BindingTrace\n): KotlinType {\n    val argument = resolvedArgument.arguments.singleOrNull()\n    return if (argument != null)\n        getEffectiveExpectedTypeForSingleArgument(parameterDescriptor, argument, languageVersionSettings, trace)\n    else\n        getExpectedType(parameterDescriptor)\n}\n\nfun getEffectiveExpectedType(\n    parameterDescriptor: ValueParameterDescriptor,\n    argument: ValueArgument,\n    context: ResolutionContext<*>\n): KotlinType {\n    return getEffectiveExpectedTypeForSingleArgument(parameterDescriptor, argument, context.languageVersionSettings, context.trace)\n}\n\nfun getEffectiveExpectedTypeForSingleArgument(\n    parameterDescriptor: ValueParameterDescriptor,\n    argument: ValueArgument,\n    languageVersionSettings: LanguageVersionSettings,\n    trace: BindingTrace\n): KotlinType {\n    if (argument.getSpreadElement() != null"}
{"code": ") {\n        // Spread argument passed to a non-vararg parameter, an error is already reported by ValueArgumentsToParametersMapper\n        return if (parameterDescriptor.varargElementType == null) DONT_CARE else parameterDescriptor.type\n    }\n\n    if (\n        arrayAssignmentToVarargInNamedFormInAnnotation(parameterDescriptor, argument, languageVersionSettings, trace) ||\n        arrayAssignmentToVarargInNamedFormInFunction(parameterDescriptor, argument, languageVersionSettings, trace)\n    ) {\n        return parameterDescriptor.type\n    }\n\n    return getExpectedType(parameterDescriptor)\n}\n\nprivate fun getExpectedType(parameterDescriptor: ValueParameterDescriptor): KotlinType {\n    return parameterDescriptor.varargElementType ?: parameterDescriptor.type\n}\n\nprivate fun arrayAssignmentToVarargInNamedFormInAnnotation(\n    parameterDescriptor: ValueParameterDescriptor,\n    argument: ValueArgument,\n    languageVersionSettings: LanguageVersionSettings,\n    trace: BindingTrace\n): Boolean {\n    i"}
{"code": "f (!languageVersionSettings.supportsFeature(LanguageFeature.AssigningArraysToVarargsInNamedFormInAnnotations)) return false\n\n    val isAllowedAssigningSingleElementsToVarargsInNamedForm =\n        !languageVersionSettings.supportsFeature(LanguageFeature.ProhibitAssigningSingleElementsToVarargsInNamedForm)\n\n    if (isAllowedAssigningSingleElementsToVarargsInNamedForm && !isArrayOrArrayLiteral(argument, trace)) return false\n\n    return isParameterOfAnnotation(parameterDescriptor) && argument.isNamed() && parameterDescriptor.isVararg\n}\n\nprivate fun arrayAssignmentToVarargInNamedFormInFunction(\n    parameterDescriptor: ValueParameterDescriptor,\n    argument: ValueArgument,\n    languageVersionSettings: LanguageVersionSettings,\n    trace: BindingTrace\n): Boolean {\n    if (!languageVersionSettings.supportsFeature(LanguageFeature.AllowAssigningArrayElementsToVarargsInNamedFormForFunctions)) return false\n\n    val isAllowedAssigningSingleElementsToVarargsInNamedForm =\n        !languageVersionSett"}
{"code": "ings.supportsFeature(LanguageFeature.ProhibitAssigningSingleElementsToVarargsInNamedForm)\n\n    if (isAllowedAssigningSingleElementsToVarargsInNamedForm && !isArrayOrArrayLiteral(argument, trace)) return false\n\n    return argument.isNamed() && parameterDescriptor.isVararg\n}\n\nfun isArrayOrArrayLiteral(argument: ValueArgument, trace: BindingTrace): Boolean {\n    val argumentExpression = argument.getArgumentExpression() ?: return false\n    if (argumentExpression is KtCollectionLiteralExpression) return true\n\n    val type = trace.getType(argumentExpression) ?: return false\n    return KotlinBuiltIns.isArrayOrPrimitiveArray(type) || KotlinBuiltIns.isUnsignedArrayType(type)\n}\n\nfun createResolutionCandidatesForConstructors(\n    lexicalScope: LexicalScope,\n    call: Call,\n    typeWithConstructors: KotlinType,\n    useKnownTypeSubstitutor: Boolean,\n    syntheticScopes: SyntheticScopes\n): List<OldResolutionCandidate<ConstructorDescriptor>> {\n    val classWithConstructors = typeWithConstructors.cons"}
{"code": "tructor.declarationDescriptor as ClassDescriptor\n\n    val unwrappedType = typeWithConstructors.unwrap()\n    val knownSubstitutor =\n        if (useKnownTypeSubstitutor)\n            TypeSubstitutor.create(\n                (unwrappedType as? AbbreviatedType)?.abbreviation ?: unwrappedType\n            )\n        else null\n\n    val typeAliasDescriptor =\n        if (unwrappedType is AbbreviatedType)\n            unwrappedType.abbreviation.constructor.declarationDescriptor as? TypeAliasDescriptor\n        else\n            null\n\n    val constructors = typeAliasDescriptor?.constructors?.mapNotNull(TypeAliasConstructorDescriptor::withDispatchReceiver)\n            ?: classWithConstructors.constructors\n\n    if (constructors.isEmpty()) return emptyList()\n\n    val receiverKind: ExplicitReceiverKind\n    val dispatchReceiver: ReceiverValue?\n\n    if (classWithConstructors.isInner) {\n        val outerClassType = (classWithConstructors.containingDeclaration as? ClassDescriptor)?.defaultType ?: return emptyL"}
{"code": "ist()\n        val substitutedOuterClassType = knownSubstitutor?.substitute(outerClassType, Variance.INVARIANT) ?: outerClassType\n\n        val receiver = lexicalScope.getImplicitReceiversHierarchy().firstOrNull {\n            KotlinTypeChecker.DEFAULT.isSubtypeOf(it.type, substitutedOuterClassType)\n        } ?: return emptyList()\n\n        receiverKind = ExplicitReceiverKind.DISPATCH_RECEIVER\n        dispatchReceiver = receiver.value\n    } else {\n        receiverKind = ExplicitReceiverKind.NO_EXPLICIT_RECEIVER\n        dispatchReceiver = null\n    }\n\n    val syntheticConstructors = constructors.flatMap { syntheticScopes.collectSyntheticConstructors(it) }\n\n    return (constructors + syntheticConstructors).map {\n        OldResolutionCandidate.create(call, it, dispatchReceiver, receiverKind, knownSubstitutor)\n    }\n}\n\ninternal fun PsiElement.reportOnElement() =\n    (this as? KtConstructorDelegationCall)\n        ?.takeIf { isImplicit }\n        ?.let { getStrictParentOfType<KtSecondaryConstructo"}
{"code": "r>()!! }\n        ?: this\n\ninternal fun List<KotlinCallArgument>.replaceTypes(\n    context: BasicCallResolutionContext,\n    resolutionCallbacks: KotlinResolutionCallbacks,\n    replace: (Int, UnwrappedType) -> UnwrappedType?,\n): List<KotlinCallArgument> = mapIndexed { i, argument ->\n    if (argument !is SimpleKotlinCallArgument) return@mapIndexed argument\n\n    val psiExpression = argument.psiExpression ?: return@mapIndexed argument\n    val argumentSubstitutor = if (argument is SubKotlinCallArgument) {\n        val notFixedVariablesSubstitutor =\n            argument.callResult.constraintSystem.buildNotFixedVariablesToPossibleResultType(resolutionCallbacks) as NewTypeSubstitutor\n        val fixedVariablesSubstitutor =\n            argument.callResult.constraintSystem.getBuilder().buildCurrentSubstitutor() as NewTypeSubstitutor\n\n        ComposedSubstitutor(notFixedVariablesSubstitutor, fixedVariablesSubstitutor)\n    } else EmptySubstitutor\n\n    val newType = replace(i, argumentSubstitutor.saf"}
{"code": "eSubstitute(argument.receiver.receiverValue.type.unwrap()))\n        ?: return@mapIndexed argument\n\n    ExpressionKotlinCallArgumentImpl(\n        argument.psiCallArgument.valueArgument,\n        argument.psiCallArgument.dataFlowInfoBeforeThisArgument,\n        argument.psiCallArgument.dataFlowInfoAfterThisArgument,\n        ReceiverValueWithSmartCastInfo(\n            ExpressionReceiver.create(psiExpression, newType, context.trace.bindingContext),\n            typesFromSmartCasts = emptySet(),\n            isStable = true\n        )\n    )\n}\n\ninternal fun PSIKotlinCall.replaceArguments(\n    newArguments: List<KotlinCallArgument>,\n    newReceiverArgument: ReceiverKotlinCallArgument? = null,\n): PSIKotlinCall = PSIKotlinCallImpl(\n    callKind, psiCall, tracingStrategy, newReceiverArgument, dispatchReceiverForInvokeExtension, name, typeArguments, newArguments,\n    externalArgument, startingDataFlowInfo, resultDataFlowInfo, dataFlowInfoForArguments, isForImplicitInvoke\n)\n\nfun checkForConstructorCall"}
{"code": "OnFunctionalType(\n    typeReference: KtTypeReference?,\n    context: BasicCallResolutionContext\n) {\n    if (typeReference?.typeElement is KtFunctionType) {\n        val factory = when (context.languageVersionSettings.supportsFeature(LanguageFeature.ProhibitConstructorCallOnFunctionalSupertype)) {\n            true -> Errors.NO_CONSTRUCTOR\n            false -> Errors.NO_CONSTRUCTOR_WARNING\n        }\n        context.trace.report(factory.on(context.call.getValueArgumentListOrElement()))\n    }\n}\n"}
{"code": "open class A\nopen class B : A()\n\nopen class First<T> {\n    open fun test(item: T) {}\n}\n\nopen class Second : First<A>() {\n    override fun test(item: A) {}\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.diagnostics.ConeDiagnostic\nimport org.jetbrains.kotlin.fir.resolve.calls.*\n\n\nfun createErrorReferenceWithErrorCandidate(\n    callInfo: CallInfo,\n    diagnostic: ConeDiagnostic,\n    source: KtSourceElement?,\n    resolutionContext: ResolutionContext,\n    resolutionStageRunner: ResolutionStageRunner\n): FirErrorReferenceWithCandidate {\n    return FirErrorReferenceWithCandidate(\n        source,\n        callInfo.name,\n        resolutionStageRunner.createErrorCandidate(callInfo, resolutionContext, diagnostic),\n        diagnostic\n    )\n}\n\nfun createErrorReferenceWithExistingCandidate(\n    candidate: Candidate,\n    diagnostic: ConeDiagnostic,\n    source: KtSourceElement?,\n    resolutionContext: ResolutionContext,\n    resolutionStageRunner: ResolutionStageRunner,\n): FirErrorReferenceWithCandidate {\n    resolutionStageRunner.fullyProcessCandidate(candidate, resolutionContext)\n  "}
{"code": "  return FirErrorReferenceWithCandidate(source, candidate.callInfo.name, candidate, diagnostic)\n}\n\nfun ResolutionStageRunner.createErrorCandidate(\n    callInfo: CallInfo,\n    resolutionContext: ResolutionContext,\n    diagnostic: ConeDiagnostic\n): Candidate {\n    val candidate = CandidateFactory(resolutionContext, callInfo).createErrorCandidate(callInfo, diagnostic)\n    processCandidate(candidate, resolutionContext, stopOnFirstError = false)\n    return candidate\n}\n\nfun ResolutionStageRunner.fullyProcessCandidate(candidate: Candidate, resolutionContext: ResolutionContext) {\n    if (!candidate.fullyAnalyzed) {\n        processCandidate(candidate, resolutionContext, stopOnFirstError = false)\n    }\n}\n"}
{"code": "// ISSUE: KT-37488\n\nsealed class A\n\nclass B : A()\nobject C : A()\n\nfun takeString(s: String) {}\n\nfun test_1(a: A) {\n    val s = when(a) {\n        is B -> \"\"\n        is C -> \"\"\n    }\n    takeString(s)\n}\n\nfun test_2(a: A) {\n    val s = when(a) {\n        is B -> \"\"\n        C -> \"\"\n    }\n    takeString(s)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.inference\n\nimport org.jetbrains.kotlin.builtins.functions.FunctionTypeKind\nimport org.jetbrains.kotlin.fir.declarations.FirAnonymousFunction\nimport org.jetbrains.kotlin.fir.diagnostics.ConeCannotInferValueParameterType\nimport org.jetbrains.kotlin.fir.expressions.FirReturnExpression\nimport org.jetbrains.kotlin.fir.expressions.impl.FirUnitExpression\nimport org.jetbrains.kotlin.fir.resolve.BodyResolveComponents\nimport org.jetbrains.kotlin.fir.resolve.calls.Candidate\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.utils.addToStdlib.runIf\n\n\nfun extractLambdaInfoFromFunctionType(\n    expectedType: ConeKotlinType?,\n    argument: FirAnonymousFunction,\n    returnTypeVariable: ConeTypeVariableForLambdaReturnType?,\n    components: BodyResolveComponents,\n    candidate: Candidate?,\n    allowCoercionToExtensionReceiver: Boolean,\n): ResolvedLambdaAtom? {\n    val session = components.session\n    if (expectedType == null) return null\n    if"}
{"code": " (expectedType is ConeFlexibleType) {\n        return extractLambdaInfoFromFunctionType(\n            expectedType.lowerBound,\n            argument,\n            returnTypeVariable,\n            components,\n            candidate,\n            allowCoercionToExtensionReceiver,\n        )\n    }\n    val expectedFunctionKind = expectedType.functionTypeKind(session) ?: return null\n\n    val actualFunctionKind = session.functionTypeService.extractSingleSpecialKindForFunction(argument.symbol)\n        ?: runIf(!argument.isLambda) {\n            // There is no function -> suspend function conversions for non-lambda anonymous functions\n            // If function is suspend then functionTypeService will return SuspendFunction kind\n            FunctionTypeKind.Function\n        }\n\n    val singleStatement = argument.body?.statements?.singleOrNull() as? FirReturnExpression\n    if (argument.returnType == null && singleStatement != null &&\n        singleStatement.target.labeledElement == argument && singleStat"}
{"code": "ement.result is FirUnitExpression\n    ) {\n        // Simply { }, i.e., function literals without body. Raw FIR added an implicit return with an implicit unit type ref.\n        argument.replaceReturnTypeRef(session.builtinTypes.unitType)\n    }\n    val returnType = argument.returnType ?: expectedType.returnType(session)\n\n    // `fun (x: T) = ...` and `fun T.() = ...` are both instances of `T.() -> V` and `(T) -> V`; `fun () = ...` is not.\n    // For lambdas, the existence of the receiver is always implied by the expected type, and a value parameter\n    // can never fill its role.\n    val receiverType = if (argument.isLambda) expectedType.receiverType(session) else argument.receiverType\n    val contextReceiversNumber =\n        if (argument.isLambda) expectedType.contextReceiversNumberForFunctionType else argument.contextReceivers.size\n\n    val valueParametersTypesIncludingReceiver = expectedType.valueParameterTypesIncludingReceiver(session)\n    val isExtensionFunctionType = expectedType.i"}
{"code": "sExtensionFunctionType(session)\n    val expectedParameters = valueParametersTypesIncludingReceiver.let {\n        val forExtension = if (receiverType != null && isExtensionFunctionType) 1 else 0\n        val toDrop = forExtension + contextReceiversNumber\n\n        if (toDrop > 0) it.drop(toDrop) else it\n    }\n\n    var coerceFirstParameterToExtensionReceiver = false\n    val argumentValueParameters = argument.valueParameters\n    val parameters = if (argument.isLambda && !argument.hasExplicitParameterList && expectedParameters.size < 2) {\n        expectedParameters // Infer existence of a parameter named `it` of an appropriate type.\n    } else {\n        if (allowCoercionToExtensionReceiver &&\n            argument.isLambda &&\n            isExtensionFunctionType &&\n            valueParametersTypesIncludingReceiver.size == argumentValueParameters.size\n        ) {\n            // (T, ...) -> V can be converter to T.(...) -> V\n            val firstValueParameter = argumentValueParameters.firstOrNu"}
{"code": "ll()\n            val extensionParameter = valueParametersTypesIncludingReceiver.firstOrNull()\n            if (firstValueParameter?.returnTypeRef?.coneTypeSafe<ConeKotlinType>() == extensionParameter?.type) {\n                coerceFirstParameterToExtensionReceiver = true\n            }\n        }\n\n        if (coerceFirstParameterToExtensionReceiver) {\n            argumentValueParameters.drop(1)\n        } else {\n            argumentValueParameters\n        }.mapIndexed { index, parameter ->\n            parameter.returnTypeRef.coneTypeSafe()\n                ?: expectedParameters.getOrNull(index)\n                ?: ConeErrorType(ConeCannotInferValueParameterType(parameter.symbol))\n        }\n    }\n\n    val contextReceivers =\n        when {\n            contextReceiversNumber == 0 -> emptyList()\n            argument.isLambda -> valueParametersTypesIncludingReceiver.subList(0, contextReceiversNumber)\n            else -> argument.contextReceivers.map { it.typeRef.coneType }\n        }\n\n    return R"}
{"code": "esolvedLambdaAtom(\n        argument,\n        expectedType,\n        actualFunctionKind ?: expectedFunctionKind,\n        receiverType,\n        contextReceivers,\n        parameters,\n        returnType,\n        typeVariableForLambdaReturnType = returnTypeVariable,\n        coerceFirstParameterToExtensionReceiver\n    ).also {\n        candidate?.postponedAtoms?.add(it)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.descriptors.components\n\nimport org.jetbrains.kotlin.analysis.api.components.KtSubstitutorBuilder\nimport org.jetbrains.kotlin.analysis.api.components.KtSubstitutorFactory\nimport org.jetbrains.kotlin.analysis.api.descriptors.KtFe10AnalysisSession\nimport org.jetbrains.kotlin.analysis.api.descriptors.components.base.Fe10KtAnalysisSessionComponent\nimport org.jetbrains.kotlin.analysis.api.types.KtSubstitutor\n\ninternal class KtFe10SubstitutorFactory(\n    override val analysisSession: KtFe10AnalysisSession\n) : KtSubstitutorFactory(), Fe10KtAnalysisSessionComponent {\n\n    override fun buildSubstitutor(builder: KtSubstitutorBuilder): KtSubstitutor {\n        if (builder.mappings.isEmpty()) return KtSubstitutor.Empty(token)\n        TODO()\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fileClasses\n\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.descriptors.PackageFragmentDescriptor\nimport org.jetbrains.kotlin.load.kotlin.JvmPackagePartSource\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.resolve.DescriptorToSourceUtils\nimport org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedMemberDescriptor\n\nfun DeclarationDescriptor.isTopLevelInJvmMultifileClass(): Boolean {\n    if (containingDeclaration !is PackageFragmentDescriptor) return false\n\n    val declaration = DescriptorToSourceUtils.descriptorToDeclaration(this)\n    if (declaration is KtDeclaration) {\n        return declaration.isInsideJvmMultifileClassFile()\n    }\n\n    if (this is DeserializedMemberDescriptor) {\n        val containerSource = containerSource\n        if (containerSource is JvmPackagePartSource && containerSource.facadeClassName != null) {\n            return true\n        }\n    }\n\n  "}
{"code": "  return false\n}"}
{"code": "import kotlin.reflect.KClass\n\n@Repeatable\nannotation class Ann(val a: Array<KClass<*>>)\n\nclass Foo\n\nval foo = Foo::class\nfun bar() = Foo::class\n\n@Ann(\n    [\n        <!ANNOTATION_ARGUMENT_MUST_BE_KCLASS_LITERAL!>\"\"::class<!>,\n        <!ANNOTATION_ARGUMENT_MUST_BE_KCLASS_LITERAL!>true::class<!>,\n        <!ANNOTATION_ARGUMENT_MUST_BE_KCLASS_LITERAL!>1::class<!>\n    ]\n)\n@Ann(\n    [\n        <!ANNOTATION_ARGUMENT_MUST_BE_KCLASS_LITERAL!>foo<!>,\n        <!ANNOTATION_ARGUMENT_MUST_BE_KCLASS_LITERAL!>bar()<!>\n    ]\n)\nfun test1() {}\n"}
{"code": "fun test() {\n    buildFoo {\n        value = <expr>produceString()</expr>\n    }\n}\n\nfun buildFoo(builder: Foo.() -> Unit): Foo {\n    val foo = Foo()\n    foo.builder()\n    return foo\n}\n\nfun Foo {\n    var value: String? = null\n}\n\nfun produceString(): String = \"\""}
{"code": "sealed class Foo {\n    object A : Foo()\n    class B(val i: Int) : Foo()\n}\n\nfun test(e: Foo) {\n    <caret>when (e) {\n        else -> {}\n    }\n}\n"}
{"code": "@WithEnumFromBody(\"\", WithEnumFromBody.MyLevel.ERROR)\npublic annotation class WithEnumFromBody cons<caret>tructor(\n    val a: String = \"\",\n    @WithEnumFromBody(\"\", WithEnumFromBody.MyLevel.WARNING) val b: MyLevel = MyLevel.ERROR\n) {\n    public enum class MyLevel {\n        WARNING,\n        ERROR,\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.components\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion\nimport org.jetbrains.kotlin.analysis.api.types.KtType\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtExpression\nimport org.jetbrains.kotlin.psi.KtFunction\n\npublic abstract class KtExpressionTypeProvider : KtAnalysisSessionComponent() {\n    public abstract fun getKtExpressionType(expression: KtExpression): KtType?\n    public abstract fun getReturnTypeForKtDeclaration(declaration: KtDeclaration): KtType\n    public abstract fun getFunctionalTypeForKtFunction(declaration: KtFunction): KtType\n\n    public abstract fun getExpectedType(expression: PsiElement): KtType?\n    public abstract fun isDefinitelyNull(expression: KtExpression): Boolean\n    public abstract fun isDefinitelyNotNull(expression: KtExpression): Boolean\n}\n\npublic interface KtExpressionTypeProviderMixIn : KtAnalysisSessionMixIn {\n    \n"}
{"code": "    public fun KtExpression.getKtType(): KtType? =\n        withValidityAssertion { analysisSession.expressionTypeProvider.getKtExpressionType(this) }\n\n    \n    public fun KtDeclaration.getReturnKtType(): KtType =\n        withValidityAssertion { analysisSession.expressionTypeProvider.getReturnTypeForKtDeclaration(this) }\n\n    \n    public fun KtFunction.getFunctionalType(): KtType =\n        withValidityAssertion { analysisSession.expressionTypeProvider.getFunctionalTypeForKtFunction(this) }\n\n    \n    public fun PsiElement.getExpectedType(): KtType? =\n        withValidityAssertion { analysisSession.expressionTypeProvider.getExpectedType(this) }\n\n    \n    public fun KtExpression.isDefinitelyNull(): Boolean =\n        withValidityAssertion { analysisSession.expressionTypeProvider.isDefinitelyNull(this) }\n\n    \n    public fun KtExpression.isDefinitelyNotNull(): Boolean =\n        withValidityAssertion { analysisSession.expressionTypeProvider.isDefinitelyNotNull(this) }\n}\n"}
{"code": "fun test(f: String.() -> Int = { 45 * <expr>this.length</expr> }) {\n    \"hello\".f()\n}"}
{"code": "interface A<D : A<D>> {\n    fun foo(): Any\n\n    val cond: Boolean\n    val field: Any\n}\n\ninterface B<F : B<F>> : A<F> {\n    override fun foo(): CharSequence\n}\n\ninterface C : B<C> {\n    override fun foo(): String\n}\n\nfun test(x: A<*>) {\n    when ((x as? C)?.field) {\n        is String -> {\n            if ((x as? B)?.cond == true) {\n                x.foo()\n            }\n        }\n    }\n\n}\n"}
{"code": "fun Any.hashKode(): Int = 404\n\nfun test(b: Boolean): Int {\n    val n: Int = b.<expr>hashKode</expr>()\n    return n * 2\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.inline\n\nimport com.intellij.util.ArrayUtil\nimport org.jetbrains.kotlin.codegen.*\nimport org.jetbrains.kotlin.codegen.coroutines.DEBUG_METADATA_ANNOTATION_ASM_TYPE\nimport org.jetbrains.kotlin.codegen.coroutines.isCoroutineSuperClass\nimport org.jetbrains.kotlin.codegen.inline.coroutines.CoroutineTransformer\nimport org.jetbrains.kotlin.codegen.inline.coroutines.FOR_INLINE_SUFFIX\nimport org.jetbrains.kotlin.codegen.serialization.JvmCodegenStringTable\nimport org.jetbrains.kotlin.codegen.state.KotlinTypeMapperBase\nimport org.jetbrains.kotlin.config.JVMConfigurationKeys\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.load.java.JvmAnnotationNames\nimport org.jetbrains.kotlin.load.kotlin.FileBasedKotlinClass\nimport org.jetbrains.kotlin.load.kotlin.header.KotlinClassHeader\nimport org.jetbrains.kotlin.load.kotlin.header.ReadKotlinClassHeaderAnnotationVisitor\nimport org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf\nimport org.jetbrai"}
{"code": "ns.kotlin.metadata.jvm.deserialization.JvmProtoBufUtil\nimport org.jetbrains.kotlin.metadata.jvm.serialization.JvmStringTable\nimport org.jetbrains.kotlin.protobuf.MessageLite\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin.Companion.NO_ORIGIN\nimport org.jetbrains.kotlin.utils.toMetadataVersion\nimport org.jetbrains.org.objectweb.asm.*\nimport org.jetbrains.org.objectweb.asm.commons.Method\nimport org.jetbrains.org.objectweb.asm.tree.*\nimport java.util.*\n\nclass AnonymousObjectTransformer(\n    transformationInfo: AnonymousObjectTransformationInfo,\n    private val inliningContext: InliningContext,\n    private val isSameModule: Boolean,\n    private val continuationClassName: String?\n) : ObjectTransformer<AnonymousObjectTransformationInfo>(transformationInfo, inliningContext.state) {\n\n    private val oldObjectType = Type.getObjectType(transformationInfo.oldClassName)\n\n    private val fieldNames = hashMapOf<String, MutableList<String>>()\n\n    private var constructor: Met"}
{"code": "hodNode? = null\n    private lateinit var sourceMap: SMAP\n    private lateinit var sourceMapper: SourceMapper\n\n    // TODO: use IrTypeMapper in the IR backend\n    private val typeMapper: KotlinTypeMapperBase = state.typeMapper\n\n    override fun doTransform(parentRemapper: FieldRemapper): InlineResult {\n        val innerClassNodes = ArrayList<InnerClassNode>()\n        val classBuilder = createRemappingClassBuilderViaFactory(inliningContext)\n        val methodsToTransform = ArrayList<MethodNode>()\n        val metadataReader = ReadKotlinClassHeaderAnnotationVisitor()\n        lateinit var superClassName: String\n        var debugFileName: String? = null\n        var debugInfo: String? = null\n        var debugMetadataAnnotation: AnnotationNode? = null\n\n        createClassReader().accept(object : ClassVisitor(Opcodes.API_VERSION, classBuilder.visitor) {\n            override fun visit(version: Int, access: Int, name: String, signature: String?, superName: String, interfaces: Array<String>) {\n   "}
{"code": "             classBuilder.defineClass(\n                    null, maxOf(version, state.config.classFileVersion), access, name, signature, superName, interfaces\n                )\n                if (superName.isCoroutineSuperClass()) {\n                    inliningContext.isContinuation = true\n                }\n                superClassName = superName\n            }\n\n            override fun visitInnerClass(name: String, outerName: String?, innerName: String?, access: Int) {\n                innerClassNodes.add(InnerClassNode(name, outerName, innerName, access))\n            }\n\n            override fun visitAnnotation(desc: String, visible: Boolean): AnnotationVisitor? {\n                when (desc) {\n                    JvmAnnotationNames.METADATA_DESC -> {\n                        // Empty inner class info because no inner classes are used in kotlin.Metadata and its arguments\n                        val innerClassesInfo = FileBasedKotlinClass.InnerClassesInfo()\n                        retu"}
{"code": "rn FileBasedKotlinClass.convertAnnotationVisitor(metadataReader, desc, innerClassesInfo)\n                    }\n                    DEBUG_METADATA_ANNOTATION_ASM_TYPE.descriptor -> {\n                        debugMetadataAnnotation = AnnotationNode(desc)\n                        return debugMetadataAnnotation\n                    }\n                    JvmAnnotationNames.SOURCE_DEBUG_EXTENSION_DESC -> {\n                        // The new value of @SourceDebugExtension will be written along with the new SMAP via ClassBuilder.visitSMAP.\n                        return null\n                    }\n                    else -> return classBuilder.newAnnotation(desc, visible)\n                }\n            }\n\n            override fun visitMethod(\n                access: Int, name: String, desc: String, signature: String?, exceptions: Array<String>?\n            ): MethodVisitor {\n                val node = MethodNode(access, name, desc, signature, exceptions)\n                if (name == \"<init>\") {\n  "}
{"code": "                  if (constructor != null) {\n                        throw RuntimeException(\n                            \"Lambda, SAM or anonymous object should have only one constructor.\\n\" +\n                                    \"First:\\n${constructor.nodeText}\\n\\nSecond:\\n${node.nodeText}\\n\"\n                        )\n                    }\n                    constructor = node\n                } else {\n                    methodsToTransform.add(node)\n                }\n                return node\n            }\n\n            override fun visitField(access: Int, name: String, desc: String, signature: String?, value: Any?): FieldVisitor? {\n                addUniqueField(name)\n                return if (isCapturedFieldName(name)) {\n                    null\n                } else {\n                    classBuilder.newField(NO_ORIGIN, access, name, desc, signature, value)\n                }\n            }\n\n            override fun visitSource(source: String, debug: String?) {\n                deb"}
{"code": "ugFileName = source\n                debugInfo = debug\n            }\n\n            override fun visitEnd() {}\n        }, ClassReader.SKIP_FRAMES)\n        val header = metadataReader.createHeader(inliningContext.state.languageVersionSettings.languageVersion.toMetadataVersion())\n        assert(isSameModule || (header != null && isPublicAbi(header))) {\n            \"Trying to inline an anonymous object which is not part of the public ABI: ${oldObjectType.className}\"\n        }\n\n        // When regenerating objects in inline lambdas, keep the old SMAP and don't remap the line numbers to\n        // save time. The result is effectively the same anyway.\n        sourceMap = debugInfo.takeIf { !inliningContext.isInliningLambda }?.let(SMAPParser::parseOrNull)\n            ?: SMAP.identityMapping(debugFileName, oldObjectType.internalName, methodsToTransform + listOfNotNull(constructor))\n        sourceMapper = SourceMapper(debugFileName, sourceMap)\n\n        val allCapturedParamBuilder = ParametersBuild"}
{"code": "er.newBuilder()\n        val constructorParamBuilder = ParametersBuilder.newBuilder()\n        extractParametersMappingAndPatchConstructor(\n            constructor!!, allCapturedParamBuilder, constructorParamBuilder, transformationInfo, parentRemapper\n        )\n\n        val deferringMethods = ArrayList<DeferredMethodVisitor>()\n\n        generateConstructorAndFields(classBuilder, constructorParamBuilder, parentRemapper)\n\n        val coroutineTransformer = CoroutineTransformer(\n            inliningContext,\n            classBuilder,\n            methodsToTransform,\n            superClassName\n        )\n        var putDebugMetadata = false\n        loop@ for (next in methodsToTransform) {\n            val deferringVisitor =\n                when {\n                    coroutineTransformer.shouldSkip(next) -> continue@loop\n                    coroutineTransformer.shouldGenerateStateMachine(next) -> coroutineTransformer.newMethod(next)\n                    else -> {\n                        // Debug me"}
{"code": "tadata is not put, but we should keep, since we do not generate state-machine,\n                        // if the lambda does not capture crossinline lambdas.\n                        if (coroutineTransformer.suspendLambdaWithGeneratedStateMachine(next)) {\n                            putDebugMetadata = true\n                        }\n                        newMethod(classBuilder, next)\n                    }\n                }\n\n            if (next.name == \"<clinit>\") {\n                rewriteAssertionsDisabledFieldInitialization(next, inliningContext.root.callSiteInfo.ownerClassName)\n            }\n\n            val funResult = inlineMethodAndUpdateGlobalResult(parentRemapper, deferringVisitor, next, allCapturedParamBuilder, false)\n\n            val returnType = Type.getReturnType(next.desc)\n            if (!AsmUtil.isPrimitive(returnType)) {\n                val oldFunReturnType = returnType.internalName\n                val newFunReturnType = funResult.getChangedTypes()[oldFunReturnType]\n   "}
{"code": "             if (newFunReturnType != null) {\n                    inliningContext.typeRemapper.addAdditionalMappings(oldFunReturnType, newFunReturnType)\n                }\n            }\n            deferringMethods.add(deferringVisitor)\n        }\n\n        deferringMethods.forEach { method ->\n            val continuationToRemove = CoroutineTransformer.findFakeContinuationConstructorClassName(method.intermediate)\n            val oldContinuationName = coroutineTransformer.oldContinuationFrom(method.intermediate)\n            coroutineTransformer.replaceFakesWithReals(method.intermediate)\n            removeFinallyMarkers(method.intermediate)\n            method.visitEnd()\n            if (continuationToRemove != null && coroutineTransformer.safeToRemoveContinuationClass(method.intermediate)) {\n                transformationResult.addClassToRemove(continuationToRemove)\n                innerClassNodes.removeIf { it.name == oldContinuationName }\n            }\n        }\n\n        if (GENERATE_SMAP &"}
{"code": "& !inliningContext.isInliningLambda) {\n            classBuilder.visitSMAP(sourceMapper, !state.languageVersionSettings.supportsFeature(LanguageFeature.CorrectSourceMappingSyntax))\n        } else if (debugFileName != null) {\n            classBuilder.visitSource(debugFileName!!, debugInfo)\n        }\n\n        innerClassNodes.forEach { node ->\n            classBuilder.visitInnerClass(node.name, node.outerName, node.innerName, node.access)\n        }\n\n        if (header != null) {\n            writeTransformedMetadata(header, classBuilder)\n        }\n\n        // debugMetadataAnnotation can be null in LV < 1.3\n        if (putDebugMetadata && debugMetadataAnnotation != null) {\n            classBuilder.newAnnotation(debugMetadataAnnotation!!.desc, true).also {\n                debugMetadataAnnotation!!.accept(it)\n            }\n        }\n\n        writeOuterInfo(classBuilder)\n\n        if (inliningContext.generateAssertField && fieldNames.none { it.key == ASSERTIONS_DISABLED_FIELD_NAME }) {\n         "}
{"code": "   val clInitBuilder = classBuilder.newMethod(NO_ORIGIN, Opcodes.ACC_STATIC, \"<clinit>\", \"()V\", null, null)\n            generateAssertionsDisabledFieldInitialization(classBuilder, clInitBuilder, inliningContext.root.callSiteInfo.ownerClassName)\n            clInitBuilder.visitInsn(Opcodes.RETURN)\n            clInitBuilder.visitEnd()\n        }\n\n        if (continuationClassName == transformationInfo.oldClassName) {\n            coroutineTransformer.registerClassBuilder(continuationClassName)\n        } else {\n            classBuilder.done(state.config.generateSmapCopyToAnnotation)\n        }\n\n        return transformationResult\n    }\n\n    private fun writeTransformedMetadata(header: KotlinClassHeader, classBuilder: ClassBuilder) {\n        // The transformed anonymous object becomes part of the public ABI if it is inside of a public inline function.\n        val publicAbi = inliningContext.callSiteInfo.isInPublicInlineScope\n        writeKotlinMetadata(\n            classBuilder,\n            st"}
{"code": "ate.config,\n            header.kind,\n            publicAbi,\n            header.extraInt and JvmAnnotationNames.METADATA_PUBLIC_ABI_FLAG.inv()\n        ) action@{ av ->\n            val (newProto, newStringTable) = transformMetadata(header) ?: run {\n                val data = header.data\n                val strings = header.strings\n                if (data != null && strings != null) {\n                    AsmUtil.writeAnnotationData(av, data, strings)\n                }\n                return@action\n            }\n            DescriptorAsmUtil.writeAnnotationData(av, newProto, newStringTable)\n        }\n    }\n\n    private fun isPublicAbi(header: KotlinClassHeader): Boolean =\n        // The public abi flag was only introduced in metadata version 1.6.0, before then we have to skip this check.\n        !header.metadataVersion.isAtLeast(1, 6, 0) ||\n                header.extraInt and JvmAnnotationNames.METADATA_PUBLIC_ABI_FLAG != 0\n\n    private fun transformMetadata(header: KotlinClassHeader): Pa"}
{"code": "ir<MessageLite, JvmStringTable>? {\n        val data = header.data ?: return null\n        val strings = header.strings ?: return null\n\n        when (header.kind) {\n            KotlinClassHeader.Kind.CLASS -> {\n                val (nameResolver, classProto) = JvmProtoBufUtil.readClassDataFrom(data, strings)\n                val newStringTable = JvmCodegenStringTable(typeMapper, nameResolver)\n                val newProto = classProto.toBuilder().apply {\n                    setExtension(JvmProtoBuf.anonymousObjectOriginName, newStringTable.getStringIndex(oldObjectType.internalName))\n                }.build()\n                return newProto to newStringTable\n            }\n            KotlinClassHeader.Kind.SYNTHETIC_CLASS -> {\n                val (nameResolver, functionProto) = JvmProtoBufUtil.readFunctionDataFrom(data, strings)\n                val newStringTable = JvmCodegenStringTable(typeMapper, nameResolver)\n                val newProto = functionProto.toBuilder().apply {\n               "}
{"code": "     setExtension(JvmProtoBuf.lambdaClassOriginName, newStringTable.getStringIndex(oldObjectType.internalName))\n                }.build()\n                return newProto to newStringTable\n            }\n            else -> return null\n        }\n    }\n\n    private fun writeOuterInfo(classBuilder: ClassBuilder) {\n        val info = inliningContext.callSiteInfo\n        // Since $$forInline functions are not generated if retransformation is the last one (i.e. call site is not inline)\n        // link to the function in OUTERCLASS field becomes invalid. However, since $$forInline function always has no-inline\n        // companion without the suffix, use it.\n        classBuilder.visitOuterClass(info.ownerClassName, info.method.name.removeSuffix(FOR_INLINE_SUFFIX), info.method.descriptor)\n    }\n\n    private fun inlineMethodAndUpdateGlobalResult(\n        parentRemapper: FieldRemapper,\n        deferringVisitor: MethodVisitor,\n        next: MethodNode,\n        allCapturedParamBuilder: ParametersBu"}
{"code": "ilder,\n        isConstructor: Boolean\n    ): InlineResult {\n        val funResult = inlineMethod(parentRemapper, deferringVisitor, next, allCapturedParamBuilder, isConstructor)\n        transformationResult.merge(funResult)\n        transformationResult.reifiedTypeParametersUsages.mergeAll(funResult.reifiedTypeParametersUsages)\n        return funResult\n    }\n\n    private fun inlineMethod(\n        parentRemapper: FieldRemapper,\n        deferringVisitor: MethodVisitor,\n        sourceNode: MethodNode,\n        capturedBuilder: ParametersBuilder,\n        isConstructor: Boolean\n    ): InlineResult {\n        val parameters =\n            if (isConstructor) capturedBuilder.buildParameters() else getMethodParametersWithCaptured(capturedBuilder, sourceNode)\n\n        val remapper = RegeneratedLambdaFieldRemapper(\n            oldObjectType.internalName, transformationInfo.newClassName, parameters,\n            transformationInfo.capturedLambdasToInline, parentRemapper, isConstructor\n        )\n\n       "}
{"code": " val reifiedTypeParametersUsages =\n            if (inliningContext.shouldReifyTypeParametersInObjects) {\n                inliningContext.root.inlineMethodReifier.reifyInstructions(sourceNode)\n            } else {\n                null\n            }\n        val inlineScopesGenerator =\n            if (state.configuration.getBoolean(JVMConfigurationKeys.USE_INLINE_SCOPES_NUMBERS)) {\n                InlineScopesGenerator()\n            } else {\n                null\n            }\n        val result = MethodInliner(\n            sourceNode,\n            parameters,\n            inliningContext.subInline(\n                transformationInfo.nameGenerator,\n                inlineScopesGenerator = inlineScopesGenerator\n            ),\n            remapper,\n            isSameModule,\n            { \"Transformer for \" + transformationInfo.oldClassName },\n            SourceMapCopier(sourceMapper, sourceMap),\n            InlineCallSiteInfo(\n                transformationInfo.oldClassName,\n                Met"}
{"code": "hod(sourceNode.name, if (isConstructor) transformationInfo.newConstructorDescriptor else sourceNode.desc),\n                inliningContext.callSiteInfo.inlineScopeVisibility,\n                inliningContext.callSiteInfo.file,\n                inliningContext.callSiteInfo.lineNumber\n            ),\n            isInlineOnlyMethod = false\n        ).doInline(deferringVisitor, LocalVarRemapper(parameters, 0), false, mapOf())\n        reifiedTypeParametersUsages?.let(result.reifiedTypeParametersUsages::mergeAll)\n        deferringVisitor.visitMaxs(-1, -1)\n        return result\n    }\n\n    private fun generateConstructorAndFields(\n        classBuilder: ClassBuilder,\n        constructorInlineBuilder: ParametersBuilder,\n        parentRemapper: FieldRemapper\n    ) {\n        val constructorParams = constructorInlineBuilder.buildParameters()\n        val constructorParamTypes = constructorParams.filter { !it.isSkipped }.map { it.type }.drop(1)\n        val constructorDescriptor = Type.getMethodDescriptor"}
{"code": "(Type.VOID_TYPE, *constructorParamTypes.toTypedArray())\n        //TODO for inline method make public class\n        transformationInfo.newConstructorDescriptor = constructorDescriptor\n        val constructorVisitor = classBuilder.newMethod(\n            NO_ORIGIN, constructor!!.access, \"<init>\", constructorDescriptor, null, ArrayUtil.EMPTY_STRING_ARRAY\n        )\n\n        val newBodyStartLabel = Label()\n        constructorVisitor.visitLabel(newBodyStartLabel)\n\n        //initialize captured fields\n        var nextParamOffset = 0\n        for (param in constructorParams) {\n            val offset = if (param.isSkipped) -1 else nextParamOffset.also { nextParamOffset += param.type.size }\n            val info = param.fieldEquivalent?.also {\n                // Permit to access this capture through a field within the constructor itself, but remap to local loads.\n                constructorInlineBuilder.addCapturedParam(it, it.newFieldName).remapValue =\n                    if (offset == -1) null el"}
{"code": "se StackValue.local(offset, param.type)\n            } ?: param\n            if (!param.isSkipped && info is CapturedParamInfo && !info.isSkipInConstructor) {\n                val desc = info.type.descriptor\n                val access = AsmUtil.NO_FLAG_PACKAGE_PRIVATE or Opcodes.ACC_SYNTHETIC or Opcodes.ACC_FINAL\n                classBuilder.newField(NO_ORIGIN, access, info.newFieldName, desc, null, null)\n                constructorVisitor.visitVarInsn(Opcodes.ALOAD, 0)\n                constructorVisitor.visitVarInsn(info.type.getOpcode(Opcodes.ILOAD), offset)\n                constructorVisitor.visitFieldInsn(Opcodes.PUTFIELD, transformationInfo.newClassName, info.newFieldName, desc)\n            }\n        }\n\n        val intermediateMethodNode = MethodNode(constructor!!.access, \"<init>\", constructorDescriptor, null, ArrayUtil.EMPTY_STRING_ARRAY)\n        inlineMethodAndUpdateGlobalResult(parentRemapper, intermediateMethodNode, constructor!!, constructorInlineBuilder, true)\n        removeFin"}
{"code": "allyMarkers(intermediateMethodNode)\n\n        val first = intermediateMethodNode.instructions.first\n        val oldStartLabel = (first as? LabelNode)?.label\n        intermediateMethodNode.accept(object : MethodBodyVisitor(constructorVisitor) {\n            override fun visitLocalVariable(\n                name: String, desc: String, signature: String?, start: Label, end: Label, index: Int\n            ) {\n                super.visitLocalVariable(\n                    name, desc, signature,\n                    //patch for jack&jill\n                    if (oldStartLabel === start) newBodyStartLabel else start,\n                    end, index\n                )\n            }\n        })\n        constructorVisitor.visitEnd()\n    }\n\n    private fun getMethodParametersWithCaptured(capturedBuilder: ParametersBuilder, sourceNode: MethodNode): Parameters {\n        val builder = ParametersBuilder.newBuilder()\n        if (sourceNode.access and Opcodes.ACC_STATIC == 0) {\n            builder.addThis(oldObj"}
{"code": "ectType, skipped = false)\n        }\n        for (type in Type.getArgumentTypes(sourceNode.desc)) {\n            builder.addNextParameter(type, false)\n        }\n        for (param in capturedBuilder.listCaptured()) {\n            builder.addCapturedParamCopy(param)\n        }\n        return builder.buildParameters()\n    }\n\n    private fun newMethod(builder: ClassBuilder, original: MethodNode): DeferredMethodVisitor {\n        return DeferredMethodVisitor(\n            MethodNode(\n                original.access, original.name, original.desc, original.signature,\n                ArrayUtil.toStringArray(original.exceptions)\n            )\n        ) {\n            builder.newMethod(\n                NO_ORIGIN, original.access, original.name, original.desc, original.signature,\n                ArrayUtil.toStringArray(original.exceptions)\n            )\n        }\n    }\n\n    private fun extractParametersMappingAndPatchConstructor(\n        constructor: MethodNode,\n        capturedParamBuilder: Parameters"}
{"code": "Builder,\n        constructorParamBuilder: ParametersBuilder,\n        transformationInfo: AnonymousObjectTransformationInfo,\n        parentFieldRemapper: FieldRemapper\n    ) {\n        val capturedParams = HashMap<Int, CapturedParamInfo>()\n        val capturedLambdas = LinkedHashSet<LambdaInfo>() //captured var of inlined parameter\n        val indexToFunctionalArgument = transformationInfo.functionalArguments\n\n        // Possible cases where we need to add each lambda's captures separately:\n        //\n        //   1. Top-level object in an inline lambda that is *not* being inlined into another object. In this case, we\n        //      have no choice but to add a separate field for each captured variable. `capturedLambdas` is either empty\n        //      (already have the fields) or contains the parent lambda object (captures used to be read from it, but\n        //      the object will be removed and its contents inlined).\n        //\n        //   2. Top-level object in a named inline funct"}
{"code": "ion. Again, there's no option but to add separate fields.\n        //      `capturedLambdas` contains all lambdas used by this object and nested objects.\n        //\n        //   3. Nested object, either in an inline lambda or an inline function. This case has two subcases:\n        //      * The object's captures are passed as separate arguments (e.g. KT-28064 style object that used to be in a lambda);\n        //        we *could* group them into `this$0` now, but choose not to. Lambdas are replaced by their captures to match.\n        //      * The object's captures are already grouped into `this$0`; this includes captured lambda parameters (for objects in\n        //        inline functions) and a reference to the outer object or lambda (for objects in lambdas), so `capturedLambdas` is\n        //        empty anyway.\n        //\n        // The only remaining case is a top-level object inside a (crossinline) lambda that is inlined into another object.\n        // Then, the reference to the "}
{"code": "soon-to-be-removed lambda class containing the captures (and it exists, or else the object\n        // would not have needed regeneration in the first place) is simply replaced with a reference to the outer object, and\n        // that object will contain loose fields for everything we need to capture.\n        val topLevelInCrossinlineLambda = parentFieldRemapper is InlinedLambdaRemapper && !parentFieldRemapper.parent!!.isRoot\n\n        //load captured parameters and patch instruction list\n        //  NB: there is also could be object fields\n        val toDelete = arrayListOf<AbstractInsnNode>()\n        constructor.findCapturedFieldAssignmentInstructions().forEach { fieldNode ->\n            val fieldName = fieldNode.name\n            val parameterAload = fieldNode.previous as VarInsnNode\n            val varIndex = parameterAload.`var`\n            val functionalArgument = indexToFunctionalArgument[varIndex]\n            // If an outer `this` is already captured by this object, rename it if a"}
{"code": "ny inline lambda will capture\n            // one of the same type, causing the code below to create a clash. Note that the values can be different.\n            // TODO: this is only really necessary if there will be a name *and* type clash.\n            val shouldRename = !topLevelInCrossinlineLambda && isThis0(fieldName) &&\n                    indexToFunctionalArgument.values.any { it is LambdaInfo && it.capturedVars.any { it.fieldName == fieldName } }\n            val newFieldName = if (shouldRename) addUniqueField(fieldName + INLINE_FUN_THIS_0_SUFFIX) else fieldName\n            val info = capturedParamBuilder.addCapturedParam(\n                Type.getObjectType(transformationInfo.oldClassName), fieldName, newFieldName,\n                Type.getType(fieldNode.desc), functionalArgument is LambdaInfo, null\n            )\n            info.functionalArgument = functionalArgument\n            if (functionalArgument is LambdaInfo) {\n                capturedLambdas.add(functionalArgument)\n      "}
{"code": "      }\n            capturedParams[varIndex] = info\n            toDelete.add(parameterAload.previous)\n            toDelete.add(parameterAload)\n            toDelete.add(fieldNode)\n        }\n        constructor.remove(toDelete)\n\n        constructorParamBuilder.addThis(oldObjectType, false)\n\n        val paramTypes = transformationInfo.constructorDesc?.let { Type.getArgumentTypes(it) } ?: emptyArray()\n        for (type in paramTypes) {\n            val functionalArgument = indexToFunctionalArgument[constructorParamBuilder.nextParameterOffset]\n            val fieldEquivalent = capturedParams[constructorParamBuilder.nextParameterOffset]\n            val parameterInfo = constructorParamBuilder.addNextParameter(type, functionalArgument is LambdaInfo)\n            parameterInfo.functionalArgument = functionalArgument\n            parameterInfo.fieldEquivalent = fieldEquivalent\n            if (functionalArgument is LambdaInfo && parameterInfo.fieldEquivalent == null) {\n                // TODO: check"}
{"code": " if this is enough to support lambdas that have no field equivalent because they are only used\n                //  in the constructor - see `LocalClassContext` in `LocalDeclarationsLowering`.\n                // TODO: these lambdas' captures should have no fields either.\n                capturedLambdas.add(functionalArgument)\n            }\n        }\n\n        //For all inlined lambdas add their captured parameters\n        //TODO: some of such parameters could be skipped - we should perform additional analysis\n        val allRecapturedParameters = ArrayList<CapturedParamDesc>()\n        if (!topLevelInCrossinlineLambda) {\n            val capturedOuterThisTypes = mutableSetOf<String>()\n            for (info in capturedLambdas) {\n                for (desc in info.capturedVars) {\n                    val recapturedParamInfo = constructorParamBuilder.addCapturedParam(\n                        desc,\n                        // Merge all outer `this` of the same type captured by inlined lambdas, si"}
{"code": "nce they have to be the same\n                        // object. Outer `this` captured by the original object itself should have been renamed above,\n                        // and can have a different value even if the same type is captured by a lambda.\n                        if (isThis0(desc.fieldName)) desc.fieldName else addUniqueField(desc.fieldName + INLINE_TRANSFORMATION_SUFFIX),\n                        (isThis0(desc.fieldName) && !capturedOuterThisTypes.add(desc.type.className))\n                    )\n                    if (desc.isSuspend) {\n                        recapturedParamInfo.functionalArgument = NonInlineArgumentForInlineSuspendParameter.INLINE_LAMBDA_AS_VARIABLE\n                    }\n                    capturedParamBuilder.addCapturedParam(recapturedParamInfo, recapturedParamInfo.newFieldName).remapValue =\n                        StackValue.field(desc.type, oldObjectType, recapturedParamInfo.newFieldName, false, StackValue.LOCAL_0)\n                    allRecapturedPa"}
{"code": "rameters.add(desc)\n                }\n            }\n        } else if (capturedLambdas.isNotEmpty()) {\n            // Top-level object in a lambda inlined into another object. As already said above, either `capturedLambdas` is empty\n            // (no captures or captures were generated as loose fields) or it contains a single entry for the parent lambda itself.\n            // Simply replace one `this$0` (of lambda type) with another (of destination object type).\n            val parent = parentFieldRemapper.parent as? RegeneratedLambdaFieldRemapper\n                ?: throw AssertionError(\"Expecting RegeneratedLambdaFieldRemapper, but ${parentFieldRemapper.parent}\")\n            val ownerType = Type.getObjectType(parent.originalLambdaInternalName)\n            val desc = CapturedParamDesc(ownerType, AsmUtil.THIS, ownerType)\n            val recapturedParamInfo =\n                constructorParamBuilder.addCapturedParam(desc, AsmUtil.CAPTURED_THIS_FIELD, false)\n            capturedParamBuilde"}
{"code": "r.addCapturedParam(recapturedParamInfo, recapturedParamInfo.newFieldName).remapValue = StackValue.LOCAL_0\n            allRecapturedParameters.add(desc)\n        }\n\n        transformationInfo.allRecapturedParameters = allRecapturedParameters\n        transformationInfo.capturedLambdasToInline = capturedLambdas.associateBy { it.lambdaClassType.internalName }\n    }\n\n    private fun addUniqueField(name: String): String {\n        val existNames = fieldNames.getOrPut(name) { LinkedList() }\n        val suffix = if (existNames.isEmpty()) \"\" else \"$\" + existNames.size\n        val newName = name + suffix\n        existNames.add(newName)\n        return newName\n    }\n}\n"}
{"code": "fun foo(p0 : Any) {\n    val s = p<caret>0 as? String\n}\n"}
{"code": "// WITH_REFLECT\n\nimport kotlin.reflect.KSuspendFunction0\n\nfun foo(pause : suspend () -> Unit) {\n    pause()\n}\n\nfun bar() {\n    foo(x<caret>y as KSuspendFunction0<Unit>)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analyzer\n\nimport org.jetbrains.kotlin.platform.TargetPlatform\n\ninterface LibraryModuleInfo : ModuleInfo {\n    override val platform: TargetPlatform\n\n    fun getLibraryRoots(): Collection<String>\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.annotations\n\nimport com.intellij.psi.*\nimport com.intellij.psi.impl.light.LightReferenceListBuilder\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisNonPublicApi\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.annotations.*\nimport org.jetbrains.kotlin.analysis.api.annotations.KtKClassAnnotationValue.KtNonLocalKClassAnnotationValue\nimport org.jetbrains.kotlin.analysis.api.components.buildClassType\nimport org.jetbrains.kotlin.analysis.api.symbols.KtDeclarationSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtFunctionSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtPropertySymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtAnnotatedSymbol\nimport org.jetbrains.kotlin.analysis.api.types.KtFlexibleType\nimport org.jetbrains.kotlin.analysis.api.types.KtNonErrorClassType\nimport org.jetbrains.kotlin.analysis.api.types.KtType\nimport org.jetbrains.kotlin.analysi"}
{"code": "s.api.types.KtTypeMappingMode\nimport org.jetbrains.kotlin.analysis.api.types.KtTypeNullability\nimport org.jetbrains.kotlin.asJava.classes.annotateByTypeAnnotationProvider\nimport org.jetbrains.kotlin.builtins.StandardNames\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget\nimport org.jetbrains.kotlin.light.classes.symbol.classes.SymbolLightClassBase\nimport org.jetbrains.kotlin.light.classes.symbol.getContainingSymbolsWithSelf\nimport org.jetbrains.kotlin.light.classes.symbol.getTypeNullability\nimport org.jetbrains.kotlin.light.classes.symbol.asAnnotationQualifier\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.JvmStandardClassIds\nimport org.jetbrains.kotlin.name.JvmStandardClassIds.JVM_OVERLOADS_CLASS_ID\nimport org.jetbrains.kotlin.name.JvmStandardClassIds.JVM_SYNTHETIC_ANNOTATION_CLASS_ID\nimport org.jetbrains.kotlin.name.StandardClassIds\nimport org.jetbrains.kotlin.resolve.deprecation.DeprecationLevelValue\n\n\ninternal fun AnnotationUseSi"}
{"code": "teTarget?.toOptionalFilter(): AnnotationUseSiteTargetFilter {\n    if (this == null) return NoAnnotationUseSiteTargetFilter\n\n    return annotationUseSiteTargetFilterOf(NoAnnotationUseSiteTargetFilter, toFilter())\n}\n\ninternal fun annotationUseSiteTargetFilterOf(\n    vararg filters: AnnotationUseSiteTargetFilter,\n): AnnotationUseSiteTargetFilter = AnnotationUseSiteTargetFilter { useSiteTarget ->\n    filters.any { filter -> filter.isAllowed(useSiteTarget) }\n}\n\ninternal fun KtAnnotatedSymbol.hasJvmSyntheticAnnotation(\n    useSiteTargetFilter: AnnotationUseSiteTargetFilter = AnyAnnotationUseSiteTargetFilter,\n): Boolean {\n    if (this is KtPropertySymbol) return backingFieldSymbol?.hasJvmSyntheticAnnotation(useSiteTargetFilter) == true\n    return hasAnnotation(JVM_SYNTHETIC_ANNOTATION_CLASS_ID, useSiteTargetFilter)\n}\n\ninternal fun KtAnnotatedSymbol.getJvmNameFromAnnotation(\n    useSiteTargetFilter: AnnotationUseSiteTargetFilter = AnyAnnotationUseSiteTargetFilter,\n): String? {\n    val annotati"}
{"code": "on = findAnnotation(JvmStandardClassIds.Annotations.JvmName, useSiteTargetFilter)\n    return annotation?.let {\n        (it.arguments.firstOrNull()?.expression as? KtConstantAnnotationValue)?.constantValue?.value as? String\n    }\n}\n\ncontext(KtAnalysisSession)\ninternal fun isHiddenByDeprecation(\n    symbol: KtAnnotatedSymbol,\n    annotationUseSiteTarget: AnnotationUseSiteTarget? = null,\n): Boolean = symbol.getDeprecationStatus(annotationUseSiteTarget)?.deprecationLevel == DeprecationLevelValue.HIDDEN\n\ncontext(KtAnalysisSession)\ninternal fun KtAnnotatedSymbol.isHiddenOrSynthetic(\n    annotationUseSiteTarget: AnnotationUseSiteTarget? = null,\n    useSiteTargetFilter: AnnotationUseSiteTargetFilter = annotationUseSiteTarget.toFilter(),\n) = isHiddenByDeprecation(this, annotationUseSiteTarget) || hasJvmSyntheticAnnotation(useSiteTargetFilter)\n\ninternal fun KtAnnotatedSymbol.hasJvmFieldAnnotation(): Boolean = hasAnnotation(JvmStandardClassIds.Annotations.JvmField)\n\ninternal fun KtAnnotatedSymbol"}
{"code": ".hasPublishedApiAnnotation(\n    useSiteTargetFilter: AnnotationUseSiteTargetFilter = AnyAnnotationUseSiteTargetFilter,\n): Boolean = hasAnnotation(StandardClassIds.Annotations.PublishedApi, useSiteTargetFilter)\n\ninternal fun KtAnnotatedSymbol.hasDeprecatedAnnotation(\n    useSiteTargetFilter: AnnotationUseSiteTargetFilter = AnyAnnotationUseSiteTargetFilter,\n): Boolean = hasAnnotation(StandardClassIds.Annotations.Deprecated, useSiteTargetFilter)\n\ninternal fun KtAnnotatedSymbol.hasJvmOverloadsAnnotation(): Boolean = hasAnnotation(JVM_OVERLOADS_CLASS_ID)\n\ninternal fun KtAnnotatedSymbol.hasJvmNameAnnotation(): Boolean = hasAnnotation(JvmStandardClassIds.Annotations.JvmName)\n\ninternal fun KtAnnotatedSymbol.hasJvmStaticAnnotation(\n    useSiteTargetFilter: AnnotationUseSiteTargetFilter = AnyAnnotationUseSiteTargetFilter,\n): Boolean = hasAnnotation(JvmStandardClassIds.Annotations.JvmStatic, useSiteTargetFilter)\n\ninternal fun KtAnnotatedSymbol.hasInlineOnlyAnnotation(): Boolean = hasAnnotation(St"}
{"code": "andardClassIds.Annotations.InlineOnly)\n\ncontext(KtAnalysisSession)\ninternal fun KtDeclarationSymbol.suppressWildcardMode(\n    declarationFilter: (KtDeclarationSymbol) -> Boolean = { true },\n): Boolean? {\n    return getContainingSymbolsWithSelf().firstNotNullOfOrNull { symbol ->\n        symbol.takeIf(declarationFilter)?.suppressWildcard()\n    }\n}\n\ninternal fun KtAnnotatedSymbol.suppressWildcard(): Boolean? {\n    if (hasJvmWildcardAnnotation()) return true\n    return getJvmSuppressWildcardsFromAnnotation()\n}\n\ninternal fun KtAnnotatedSymbol.getJvmSuppressWildcardsFromAnnotation(): Boolean? {\n    return annotationsByClassId(JvmStandardClassIds.Annotations.JvmSuppressWildcards).firstOrNull()?.let { annoApp ->\n        (annoApp.arguments.firstOrNull()?.expression as? KtConstantAnnotationValue)?.constantValue?.value as? Boolean\n    }\n}\n\ninternal fun KtAnnotatedSymbol.hasJvmWildcardAnnotation(): Boolean = hasAnnotation(JvmStandardClassIds.Annotations.JvmWildcard)\n\ninternal fun KtAnnotatedSymbol"}
{"code": ".findAnnotation(\n    classId: ClassId,\n    useSiteTargetFilter: AnnotationUseSiteTargetFilter = AnyAnnotationUseSiteTargetFilter,\n): KtAnnotationApplicationWithArgumentsInfo? {\n    if (!hasAnnotation(classId, useSiteTargetFilter)) return null\n\n    return annotationsByClassId(classId, useSiteTargetFilter).firstOrNull()\n}\n\ncontext(KtAnalysisSession)\ninternal fun KtAnnotatedSymbol.computeThrowsList(\n    builder: LightReferenceListBuilder,\n    useSitePosition: PsiElement,\n    containingClass: SymbolLightClassBase,\n    useSiteTargetFilter: AnnotationUseSiteTargetFilter = AnyAnnotationUseSiteTargetFilter,\n) {\n    if (containingClass.isEnum && this is KtFunctionSymbol && name == StandardNames.ENUM_VALUE_OF && isStatic) {\n        builder.addReference(java.lang.IllegalArgumentException::class.qualifiedName)\n        builder.addReference(java.lang.NullPointerException::class.qualifiedName)\n    }\n\n    val annoApp = findAnnotation(JvmStandardClassIds.Annotations.Throws, useSiteTargetFilter) ?: retu"}
{"code": "rn\n\n    fun handleAnnotationValue(annotationValue: KtAnnotationValue) = when (annotationValue) {\n        is KtArrayAnnotationValue -> {\n            annotationValue.values.forEach(::handleAnnotationValue)\n        }\n\n        is KtNonLocalKClassAnnotationValue -> {\n            val psiType = buildClassType(annotationValue.classId).asPsiType(\n                useSitePosition,\n                allowErrorTypes = true,\n                KtTypeMappingMode.DEFAULT,\n                containingClass.isAnnotationType,\n            )\n            (psiType as? PsiClassType)?.let {\n                builder.addReference(it)\n            }\n        }\n        else -> {}\n    }\n\n    annoApp.arguments.forEach { handleAnnotationValue(it.expression) }\n}\n\ncontext(KtAnalysisSession)\n@KtAnalysisNonPublicApi\nfun annotateByKtType(\n    psiType: PsiType,\n    ktType: KtType,\n    annotationParent: PsiElement,\n): PsiType {\n    fun getAnnotationsSequence(type: KtType): Sequence<List<PsiAnnotation>> = sequence {\n        val unwrap"}
{"code": "pedType = when (type) {\n            // We assume that flexible types have to have the same set of annotations on upper and lower bound.\n            // Also, the upper bound is more similar to the resulting PsiType as it has fewer restrictions.\n            is KtFlexibleType -> type.upperBound\n            else -> type\n        }\n\n        val explicitTypeAnnotations = unwrappedType.annotations.map { annoApp ->\n            SymbolLightSimpleAnnotation(\n                annoApp.classId?.asFqNameString(),\n                annotationParent,\n                annoApp.arguments,\n                annoApp.psi,\n            )\n        }\n\n        // Original type should be used to infer nullability\n        val typeNullability = when {\n            psiType !is PsiPrimitiveType && type.isPrimitiveBacked -> KtTypeNullability.NON_NULLABLE\n            else -> getTypeNullability(type)\n        }\n\n        val nullabilityAnnotation = typeNullability.asAnnotationQualifier?.let {\n            SymbolLightSimpleAnnotation"}
{"code": "(it, annotationParent)\n        }\n\n        yield(explicitTypeAnnotations + listOfNotNull(nullabilityAnnotation))\n\n        if (unwrappedType is KtNonErrorClassType) {\n            unwrappedType.ownTypeArguments.forEach { typeProjection ->\n                typeProjection.type?.let {\n                    yieldAll(getAnnotationsSequence(it))\n                }\n            }\n        }\n    }\n\n    return psiType.annotateByTypeAnnotationProvider(getAnnotationsSequence(ktType))\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.declarations\n\nimport org.jetbrains.kotlin.fir.labelName\nimport org.jetbrains.kotlin.fir.resolve.SessionHolder\nimport org.jetbrains.kotlin.fir.resolve.calls.ImplicitReceiverValueForScript\nimport org.jetbrains.kotlin.fir.scopes.FirScope\nimport org.jetbrains.kotlin.fir.scopes.impl.FirScriptDeclarationsScope\nimport org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase\nimport org.jetbrains.kotlin.fir.types.coneType\n\nclass TowerElementsForScript(\n    val implicitReceivers: List<ImplicitReceiverValueForScript>,\n    val staticScope: FirScope?,\n)\n\nfun SessionHolder.collectTowerDataElementsForScript(owner: FirScript): TowerElementsForScript {\n    owner.lazyResolveToPhase(FirResolvePhase.TYPES)\n\n    val contextReceivers = owner.contextReceivers.mapIndexed { index, receiver ->\n        ImplicitReceiverValueForScript(\n            owner.symbol, receiver.typeRef.coneType, receiver.labelName, session, scopeSession,\n            contextReceiverNumber = index,\n        )\n  "}
{"code": "  }.asReversed()\n\n    return TowerElementsForScript(\n        contextReceivers,\n        FirScriptDeclarationsScope(session, owner),\n    )\n}\n"}
{"code": "import kotlin.contracts.*\n\n@OptIn(ExperimentalContracts::class)\nfun foo(x: Any, y: Any) {\n    contract {\n        returns() implies (x is Int && y is String)\n    }\n    if (x !is Int || y !is String) {\n        throw IllegalStateException()\n    }\n}\n\nfun test_1(x: Any, y: Any) {\n    foo(x = x, y = y)\n    x.inc()\n    y.length\n}\n\nfun test_2(x: Any, y: Any) {\n    foo(x, y = y)\n    x.inc()\n    y.length\n}\n\nfun test_3(x: Any, y: Any) {\n    foo(y = y, x = x)\n    x.inc()\n    y.length\n}\n\n"}
{"code": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE_K1\n@Target(AnnotationTarget.TYPE)\nannotation class Anno5(val s: String)\n\nfun f<caret>oo(): List<@Anno5(\"1\") Int>? = null\n"}
{"code": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE_K1\nenum class X {\n  Y, Z;\n}\n"}
{"code": "fun foo(x: Any): String {\n    return <expr>if (x is String) \"1\" else \"2\"</expr>\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.buildtools.api.tests.compilation.model\n\nimport org.junit.jupiter.params.ParameterizedTest\nimport org.junit.jupiter.params.provider.ArgumentsSource\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY_SETTER)\n@Retention(AnnotationRetention.RUNTIME)\n@ParameterizedTest(name = \"{0}: {displayName}\")\n@ArgumentsSource(\n    DefaultStrategyAgnosticCompilationTestArgumentProvider::class\n)\nannotation class DefaultStrategyAgnosticCompilationTest\n\n"}
{"code": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE_K1\nfun x(): Int = 10\nfun y() {}\n"}
{"code": "\npackage org.jetbrains.kotlin.analysis.decompiler.konan\n\nimport com.intellij.openapi.fileTypes.FileType\nimport com.intellij.openapi.fileTypes.FileTypeRegistry\nimport com.intellij.openapi.vfs.VirtualFile\nimport com.intellij.psi.PsiManager\nimport com.intellij.psi.compiled.ClassFileDecompilers\nimport org.jetbrains.annotations.TestOnly\nimport org.jetbrains.kotlin.analysis.decompiler.psi.KotlinDecompiledFileViewProvider\nimport org.jetbrains.kotlin.analysis.decompiler.psi.text.DecompiledText\nimport org.jetbrains.kotlin.analysis.decompiler.psi.text.createIncompatibleAbiVersionDecompiledText\nimport org.jetbrains.kotlin.metadata.deserialization.BinaryVersion\nimport org.jetbrains.kotlin.serialization.SerializerExtensionProtocol\nimport org.jetbrains.kotlin.serialization.deserialization.FlexibleTypeDeserializer\nimport java.io.IOException\n\nabstract class KlibMetadataDecompiler<out V : BinaryVersion>(\n    private val fileType: FileType,\n    private val serializerProtocol: () -> SerializerExtensionPr"}
{"code": "otocol,\n    private val flexibleTypeDeserializer: FlexibleTypeDeserializer,\n    private val expectedBinaryVersion: () -> V,\n    private val invalidBinaryVersion: () -> V\n) : ClassFileDecompilers.Full() {\n    protected abstract val metadataStubBuilder: KlibMetadataStubBuilder\n\n    protected abstract fun doReadFile(file: VirtualFile): FileWithMetadata?\n\n    protected abstract fun getDecompiledText(\n        file: FileWithMetadata.Compatible,\n        serializerProtocol: SerializerExtensionProtocol,\n        flexibleTypeDeserializer: FlexibleTypeDeserializer\n    ): DecompiledText\n\n    override fun accepts(file: VirtualFile) = FileTypeRegistry.getInstance().isFileOfType(file, fileType)\n\n    override fun getStubBuilder() = metadataStubBuilder\n\n    override fun createFileViewProvider(file: VirtualFile, manager: PsiManager, physical: Boolean) =\n        KotlinDecompiledFileViewProvider(manager, file, physical) { provider ->\n            KlibDecompiledFile(\n                provider,\n               "}
{"code": " ::buildDecompiledText\n            )\n        }\n\n    protected fun readFileSafely(file: VirtualFile): FileWithMetadata? {\n        if (!file.isValid) return null\n\n        return try {\n            doReadFile(file)\n        } catch (e: IOException) {\n            // This is needed because sometimes we're given VirtualFile instances that point to non-existent .jar entries.\n            // Such files are valid (isValid() returns true), but an attempt to read their contents results in a FileNotFoundException.\n            // Note that although calling \"refresh()\" instead of catching an exception would seem more correct here,\n            // it's not always allowed and also is likely to degrade performance\n            null\n        }\n    }\n\n    private fun buildDecompiledText(virtualFile: VirtualFile): DecompiledText {\n        assert(FileTypeRegistry.getInstance().isFileOfType(virtualFile, fileType)) { \"Unexpected file type ${virtualFile.fileType}\" }\n\n        return when (val file = readFileSafely(v"}
{"code": "irtualFile)) {\n            is FileWithMetadata.Incompatible -> createIncompatibleAbiVersionDecompiledText(expectedBinaryVersion(), file.version)\n            is FileWithMetadata.Compatible -> getDecompiledText(file, serializerProtocol(), flexibleTypeDeserializer)\n            null -> createIncompatibleAbiVersionDecompiledText(expectedBinaryVersion(), invalidBinaryVersion())\n        }\n    }\n\n    @TestOnly\n    internal fun buildDecompiledTextForTests(virtualFile: VirtualFile): DecompiledText = buildDecompiledText(virtualFile)\n}"}
{"code": "class A(a: Boolean, val pro<caret>p: Int = 42) {\n    fun foo() = \"str\"\n}"}
{"code": "// FILE: KtVisitor.java\n\npublic class KtVisitor<R, D> {}\n\n// FILE: A.java\n\npublic interface A {\n    public <R, D> R accept(@org.jetbrains.annotations.NotNull KtVisitor<R, D> visitor, D data)\n}\n\n// FILE: B.kt\n\ninterface B : A {\n    override fun <R, D> accept(visitor: KtVisitor<R, D>, data: D): R\n}\n\n// FILE: main.kt\n\nfun test(visitor: KtVisitor<String, Unit>, element: B) {\n    element.accept(visitor, Unit)\n}\n"}
{"code": "// FILE: main.kt\npackage foo.www.ddd\n\nclass Check {\n    class BBD {\n        class Bwd {\n            fun dad() {\n\n                val a = <expr>foo.www.ddd.Check.BBD.Bwd::class.java.annotatedInterfaces.size</expr>\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.test.framework.project.structure\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.PsiFile\nimport com.intellij.psi.PsiFileSystemItem\nimport com.intellij.psi.PsiJavaFile\nimport org.jetbrains.kotlin.analysis.api.standalone.base.project.structure.StandaloneProjectFactory.findJvmRootsForJavaFiles\nimport org.jetbrains.kotlin.analysis.project.structure.KtBinaryModule\nimport org.jetbrains.kotlin.analysis.project.structure.KtModule\nimport org.jetbrains.kotlin.analysis.test.framework.test.configurators.TestModuleKind\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.model.TestModule\nimport org.jetbrains.kotlin.test.services.TestModuleStructure\nimport kotlin.collections.addAll\nimport kotlin.collections.filterIsInstance\nimport kotlin.collections.flatMap\nimport kotlin.collections.mapTo\n\n\nclass KtTestModule(\n    val moduleKind: TestModuleKind,\n    val testModule: TestModule,\n    val ktModule: KtModule,\n    val files: L"}
{"code": "ist<PsiFile>,\n) {\n    val ktFiles: List<KtFile> get() = files.filterIsInstance<KtFile>()\n}\n\n\nclass KtTestModuleStructure(\n    val testModuleStructure: TestModuleStructure,\n    val mainModules: List<KtTestModule>,\n    val binaryModules: Iterable<KtBinaryModule>,\n) {\n    private val mainModulesByName: Map<String, KtTestModule> = mainModules.associateBy { it.testModule.name }\n\n    val project: Project get() = mainModules.first().ktModule.project\n\n    val allMainKtFiles: List<KtFile> get() = mainModules.flatMap { it.ktFiles }\n\n    val mainAndBinaryKtModules: List<KtModule>\n        get() = buildList {\n            mainModules.mapTo(this) { it.ktModule }\n            addAll(binaryModules)\n        }\n\n    val allSourceFiles: List<PsiFileSystemItem>\n        get() = buildList {\n            val files = mainModules.flatMap { it.files }\n            addAll(files)\n            addAll(findJvmRootsForJavaFiles(files.filterIsInstance<PsiJavaFile>()))\n        }\n\n    fun getKtTestModule(moduleName: String): "}
{"code": "KtTestModule {\n        return mainModulesByName.getValue(moduleName)\n    }\n\n    fun getKtTestModule(testModule: TestModule): KtTestModule {\n        return mainModulesByName[testModule.name] ?: mainModulesByName.getValue(testModule.files.single().name)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.expressions\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\nabstract class FirAbstractArgumentList : FirArgumentList() {\n    override fun <D> transformArguments(transformer: FirTransformer<D>, data: D): FirArgumentList {\n        return this\n    }\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {\n        // DO NOTHING\n    }\n\n    override fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirElement {\n        return this\n    }\n}"}
{"code": "// SKIP_WHEN_OUT_OF_CONTENT_ROOT\n// MODULE: topmost\n// MODULE_KIND: LibraryBinary\n// FILE: topmost.kt\npackage org.example\n\ninterface Base {\n    fun topmost()\n}\n\ninterface Topmost : Base\n\n// MODULE: top(topmost)\n// FILE: top.kt\npackage org.example\n\ninterface Base : TopAdditional {\n    fun top()\n}\n\n// FILE: TopAdditional.java\npackage org.example;\n\npublic interface TopAdditional extends Top {\n\n}\n\n// FILE: Top.java\npackage org.example;\n\npublic interface Top extends Topmost {\n\n}\n\n// MODULE: middle(top)\n// FILE: middle.kt\npackage org.example\n\ninterface Base : MiddleAdditional {\n    fun middle()\n}\n\ninterface MiddleAdditional : Middle\n\ninterface Middle : Top\n\n// MODULE: bottom(middle)\n// FILE: bottom.kt\npackage org.example\n\ninterface Ba<caret>se : BottomAdditional {\n    fun bottom()\n}\n\ninterface BottomAdditional : Bottom\n\ninterface Bottom : Middle\n"}
{"code": "\n\npackage org.jetbrains.kotlin.contracts.parsing\n\nimport org.jetbrains.kotlin.contracts.description.expressions.BooleanConstantReference\nimport org.jetbrains.kotlin.contracts.description.expressions.ConstantReference\nimport org.jetbrains.kotlin.psi.KtConstantExpression\nimport org.jetbrains.kotlin.psi.KtElement\nimport org.jetbrains.kotlin.psi.KtVisitor\nimport org.jetbrains.kotlin.resolve.BindingContext\nimport org.jetbrains.kotlin.resolve.constants.CompileTimeConstant\nimport org.jetbrains.kotlin.types.KotlinType\n\ninternal class PsiConstantParser(private val callContext: ContractCallContext) : KtVisitor<ConstantReference?, Unit>() {\n    override fun visitKtElement(element: KtElement, data: Unit?): ConstantReference? = null\n\n    override fun visitConstantExpression(expression: KtConstantExpression, data: Unit?): ConstantReference? {\n        val type: KotlinType = callContext.bindingContext.getType(expression) ?: return null\n\n        val compileTimeConstant: CompileTimeConstant<*> = callCon"}
{"code": "text.bindingContext.get(BindingContext.COMPILE_TIME_VALUE, expression)\n            ?: return null\n\n        val value: Any? = compileTimeConstant.getValue(type)\n\n        return when (value) {\n            true -> BooleanConstantReference.TRUE\n            false -> BooleanConstantReference.FALSE\n            null -> ConstantReference.NULL\n            else -> null\n        }\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.dfa.cfg\n\nabstract class ControlFlowGraphVisitorVoid : ControlFlowGraphVisitor<Unit, Nothing?>() {\n    abstract fun visitNode(node: CFGNode<*>)\n\n    // ----------------------------------- Simple function -----------------------------------\n\n    open fun visitFunctionEnterNode(node: FunctionEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitFunctionExitNode(node: FunctionExitNode) {\n        visitNode(node)\n    }\n\n    open fun visitLocalFunctionDeclarationNode(node: LocalFunctionDeclarationNode) {\n        visitNode(node)\n    }\n\n    // ----------------------------------- Anonymous function -----------------------------------\n\n    open fun visitSplitPostponedLambdasNode(node: SplitPostponedLambdasNode) {\n        visitNode(node)\n    }\n\n    open fun visitPostponedLambdaExitNode(node: PostponedLambdaExitNode) {\n        visitNode(node)\n    }\n\n    open fun visitMergePostponedLambdaExitsNode(node: MergePostponedLambdaExitsNode) {\n        visit"}
{"code": "Node(node)\n    }\n\n    open fun visitAnonymousFunctionExpressionNode(node: AnonymousFunctionExpressionNode) {\n        visitNode(node)\n    }\n\n    // ----------------------------------- Property -----------------------------------\n\n    open fun visitPropertyInitializerEnterNode(node: PropertyInitializerEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitPropertyInitializerExitNode(node: PropertyInitializerExitNode) {\n        visitNode(node)\n    }\n\n    open fun visitDelegateExpressionExitNode(node: DelegateExpressionExitNode) {\n        visitNode(node)\n    }\n\n    // ----------------------------------- Init -----------------------------------\n\n    open fun visitInitBlockEnterNode(node: InitBlockEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitInitBlockExitNode(node: InitBlockExitNode) {\n        visitNode(node)\n    }\n\n    // ----------------------------------- Block -----------------------------------\n\n    open fun visitBlockEnterNode(node: BlockEnterNode) {\n        vis"}
{"code": "itNode(node)\n    }\n\n    open fun visitBlockExitNode(node: BlockExitNode) {\n        visitNode(node)\n    }\n\n    // ----------------------------------- When -----------------------------------\n\n    open fun visitWhenEnterNode(node: WhenEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitWhenExitNode(node: WhenExitNode) {\n        visitNode(node)\n    }\n\n    open fun visitWhenBranchConditionEnterNode(node: WhenBranchConditionEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitWhenBranchConditionExitNode(node: WhenBranchConditionExitNode) {\n        visitNode(node)\n    }\n\n    open fun visitWhenBranchResultEnterNode(node: WhenBranchResultEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitWhenBranchResultExitNode(node: WhenBranchResultExitNode) {\n        visitNode(node)\n    }\n\n    open fun visitWhenSyntheticElseBranchNode(node: WhenSyntheticElseBranchNode) {\n        visitNode(node)\n    }\n\n\n    // ----------------------------------- Loop ----------------------------"}
{"code": "-------\n\n    open fun visitLoopEnterNode(node: LoopEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitLoopBlockEnterNode(node: LoopBlockEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitLoopBlockExitNode(node: LoopBlockExitNode) {\n        visitNode(node)\n    }\n\n    open fun visitLoopConditionEnterNode(node: LoopConditionEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitLoopConditionExitNode(node: LoopConditionExitNode) {\n        visitNode(node)\n    }\n\n    open fun visitLoopExitNode(node: LoopExitNode) {\n        visitNode(node)\n    }\n\n    // ----------------------------------- Try-catch-finally -----------------------------------\n\n    open fun visitTryExpressionEnterNode(node: TryExpressionEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitTryMainBlockEnterNode(node: TryMainBlockEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitTryMainBlockExitNode(node: TryMainBlockExitNode) {\n        visitNode(node)\n    }\n\n    open fun visitCat"}
{"code": "chClauseEnterNode(node: CatchClauseEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitCatchClauseExitNode(node: CatchClauseExitNode) {\n        visitNode(node)\n    }\n\n    open fun visitFinallyBlockEnterNode(node: FinallyBlockEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitFinallyBlockExitNode(node: FinallyBlockExitNode) {\n        visitNode(node)\n    }\n\n    open fun visitTryExpressionExitNode(node: TryExpressionExitNode) {\n        visitNode(node)\n    }\n\n    // ----------------------------------- Boolean operators -----------------------------------\n\n    open fun visitBinaryAndEnterNode(node: BinaryAndEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitBinaryAndExitLeftOperandNode(node: BinaryAndExitLeftOperandNode) {\n        visitNode(node)\n    }\n\n    open fun visitBinaryAndEnterRightOperandNode(node: BinaryAndEnterRightOperandNode) {\n        visitNode(node)\n    }\n\n    open fun visitBinaryAndExitNode(node: BinaryAndExitNode) {\n        visitNode(node)\n  "}
{"code": "  }\n\n    open fun visitBinaryOrEnterNode(node: BinaryOrEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitBinaryOrExitLeftOperandNode(node: BinaryOrExitLeftOperandNode) {\n        visitNode(node)\n    }\n\n    open fun visitBinaryOrEnterRightOperandNode(node: BinaryOrEnterRightOperandNode) {\n        visitNode(node)\n    }\n\n    open fun visitBinaryOrExitNode(node: BinaryOrExitNode) {\n        visitNode(node)\n    }\n\n    // ----------------------------------- Operator call -----------------------------------\n\n    open fun visitTypeOperatorCallNode(node: TypeOperatorCallNode) {\n        visitNode(node)\n    }\n\n    open fun visitComparisonExpressionNode(node: ComparisonExpressionNode) {\n        visitNode(node)\n    }\n\n    open fun visitEqualityOperatorCallNode(node: EqualityOperatorCallNode) {\n        visitNode(node)\n    }\n\n    // ----------------------------------- Jump -----------------------------------\n\n    open fun visitJumpNode(node: JumpNode) {\n        visitNode(node)\n    }\n\n    op"}
{"code": "en fun visitLiteralExpressionNode(node: LiteralExpressionNode) {\n        visitNode(node)\n    }\n\n    // ----------------------------------- Check not null call -----------------------------------\n\n    open fun visitCheckNotNullCallNode(node: CheckNotNullCallNode) {\n        visitNode(node)\n    }\n\n    // ----------------------------------- Resolvable call -----------------------------------\n\n    open fun visitQualifiedAccessNode(node: QualifiedAccessNode) {\n        visitNode(node)\n    }\n\n    open fun visitResolvedQualifierNode(node: ResolvedQualifierNode) {\n        visitNode(node)\n    }\n\n    open fun visitFunctionCallArgumentsEnterNode(node: FunctionCallArgumentsEnterNode) {\n        visitNode(node)\n    }\n\n    open fun visitFunctionCallArgumentsExitNode(node: FunctionCallArgumentsExitNode) {\n        visitNode(node)\n    }\n\n    open fun visitFunctionCallNode(node: FunctionCallNode) {\n        visitNode(node)\n    }\n\n    open fun visitDelegatedConstructorCallNode(node: DelegatedConstructorCallN"}
{"code": "ode) {\n        visitNode(node)\n    }\n\n    open fun visitStringConcatenationCallNode(node: StringConcatenationCallNode) {\n        visitNode(node)\n    }\n\n    open fun visitThrowExceptionNode(node: ThrowExceptionNode) {\n        visitNode(node)\n    }\n\n    open fun visitStubNode(node: StubNode) {\n        visitNode(node)\n    }\n\n    open fun visitVariableDeclarationNode(node: VariableDeclarationNode) {\n        visitNode(node)\n    }\n\n    open fun visitVariableAssignmentNode(node: VariableAssignmentNode) {\n        visitNode(node)\n    }\n\n    open fun visitEnterSafeCallNode(node: EnterSafeCallNode) {\n        visitNode(node)\n    }\n\n    open fun visitExitSafeCallNode(node: ExitSafeCallNode) {\n        visitNode(node)\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------------\n\n    final override fun visitNode(node: CFGNode<*>, data: Nothing?) {\n        visitNode(node)\n    }\n\n    // ----------------------------------- Simple func"}
{"code": "tion -----------------------------------\n\n    final override fun visitFunctionEnterNode(node: FunctionEnterNode, data: Nothing?) {\n        visitFunctionEnterNode(node)\n    }\n\n    final override fun visitFunctionExitNode(node: FunctionExitNode, data: Nothing?) {\n        visitFunctionExitNode(node)\n    }\n\n    final override fun visitLocalFunctionDeclarationNode(node: LocalFunctionDeclarationNode, data: Nothing?) {\n        visitLocalFunctionDeclarationNode(node)\n    }\n\n    // ----------------------------------- Anonymous function -----------------------------------\n\n    final override fun visitSplitPostponedLambdasNode(node: SplitPostponedLambdasNode, data: Nothing?) {\n        visitSplitPostponedLambdasNode(node)\n    }\n\n    final override fun visitPostponedLambdaExitNode(node: PostponedLambdaExitNode, data: Nothing?) {\n        visitPostponedLambdaExitNode(node)\n    }\n\n    final override fun visitMergePostponedLambdaExitsNode(node: MergePostponedLambdaExitsNode, data: Nothing?) {\n        v"}
{"code": "isitMergePostponedLambdaExitsNode(node)\n    }\n\n    final override fun visitAnonymousFunctionExpressionNode(node: AnonymousFunctionExpressionNode, data: Nothing?) {\n        visitAnonymousFunctionExpressionNode(node)\n    }\n\n    // ----------------------------------- Property -----------------------------------\n\n    final override fun visitPropertyInitializerEnterNode(node: PropertyInitializerEnterNode, data: Nothing?) {\n        visitPropertyInitializerEnterNode(node)\n    }\n\n    final override fun visitPropertyInitializerExitNode(node: PropertyInitializerExitNode, data: Nothing?) {\n        visitPropertyInitializerExitNode(node)\n    }\n\n    final override fun visitDelegateExpressionExitNode(node: DelegateExpressionExitNode, data: Nothing?) {\n        visitDelegateExpressionExitNode(node)\n    }\n\n    // ----------------------------------- Init -----------------------------------\n\n    final override fun visitInitBlockEnterNode(node: InitBlockEnterNode, data: Nothing?) {\n        visitInitBlockEn"}
{"code": "terNode(node)\n    }\n\n    final override fun visitInitBlockExitNode(node: InitBlockExitNode, data: Nothing?) {\n        visitInitBlockExitNode(node)\n    }\n\n    // ----------------------------------- Block -----------------------------------\n\n    final override fun visitBlockEnterNode(node: BlockEnterNode, data: Nothing?) {\n        visitBlockEnterNode(node)\n    }\n\n    final override fun visitBlockExitNode(node: BlockExitNode, data: Nothing?) {\n        visitBlockExitNode(node)\n    }\n\n    // ----------------------------------- When -----------------------------------\n\n    final override fun visitWhenEnterNode(node: WhenEnterNode, data: Nothing?) {\n        visitWhenEnterNode(node)\n    }\n\n    final override fun visitWhenExitNode(node: WhenExitNode, data: Nothing?) {\n        visitWhenExitNode(node)\n    }\n\n    final override fun visitWhenBranchConditionEnterNode(node: WhenBranchConditionEnterNode, data: Nothing?) {\n        visitWhenBranchConditionEnterNode(node)\n    }\n\n    final override fun vi"}
{"code": "sitWhenBranchConditionExitNode(node: WhenBranchConditionExitNode, data: Nothing?) {\n        visitWhenBranchConditionExitNode(node)\n    }\n\n    final override fun visitWhenBranchResultEnterNode(node: WhenBranchResultEnterNode, data: Nothing?) {\n        visitWhenBranchResultEnterNode(node)\n    }\n\n    final override fun visitWhenBranchResultExitNode(node: WhenBranchResultExitNode, data: Nothing?) {\n        visitWhenBranchResultExitNode(node)\n    }\n\n    final override fun visitWhenSyntheticElseBranchNode(node: WhenSyntheticElseBranchNode, data: Nothing?) {\n        visitWhenSyntheticElseBranchNode(node)\n    }\n\n\n    // ----------------------------------- Loop -----------------------------------\n\n    final override fun visitLoopEnterNode(node: LoopEnterNode, data: Nothing?) {\n        visitLoopEnterNode(node)\n    }\n\n    final override fun visitLoopBlockEnterNode(node: LoopBlockEnterNode, data: Nothing?) {\n        visitLoopBlockEnterNode(node)\n    }\n\n    final override fun visitLoopBlockExitNode"}
{"code": "(node: LoopBlockExitNode, data: Nothing?) {\n        visitLoopBlockExitNode(node)\n    }\n\n    final override fun visitLoopConditionEnterNode(node: LoopConditionEnterNode, data: Nothing?) {\n        visitLoopConditionEnterNode(node)\n    }\n\n    final override fun visitLoopConditionExitNode(node: LoopConditionExitNode, data: Nothing?) {\n        visitLoopConditionExitNode(node)\n    }\n\n    final override fun visitLoopExitNode(node: LoopExitNode, data: Nothing?) {\n        visitLoopExitNode(node)\n    }\n\n    // ----------------------------------- Try-catch-finally -----------------------------------\n\n    final override fun visitTryExpressionEnterNode(node: TryExpressionEnterNode, data: Nothing?) {\n        visitTryExpressionEnterNode(node)\n    }\n\n    final override fun visitTryMainBlockEnterNode(node: TryMainBlockEnterNode, data: Nothing?) {\n        visitTryMainBlockEnterNode(node)\n    }\n\n    final override fun visitTryMainBlockExitNode(node: TryMainBlockExitNode, data: Nothing?) {\n        visitTr"}
{"code": "yMainBlockExitNode(node)\n    }\n\n    final override fun visitCatchClauseEnterNode(node: CatchClauseEnterNode, data: Nothing?) {\n        visitCatchClauseEnterNode(node)\n    }\n\n    final override fun visitCatchClauseExitNode(node: CatchClauseExitNode, data: Nothing?) {\n        visitCatchClauseExitNode(node)\n    }\n\n    final override fun visitFinallyBlockEnterNode(node: FinallyBlockEnterNode, data: Nothing?) {\n        visitFinallyBlockEnterNode(node)\n    }\n\n    final override fun visitFinallyBlockExitNode(node: FinallyBlockExitNode, data: Nothing?) {\n        visitFinallyBlockExitNode(node)\n    }\n\n    final override fun visitTryExpressionExitNode(node: TryExpressionExitNode, data: Nothing?) {\n        visitTryExpressionExitNode(node)\n    }\n\n    // ----------------------------------- Boolean operators -----------------------------------\n\n    final override fun visitBinaryAndEnterNode(node: BinaryAndEnterNode, data: Nothing?) {\n        visitBinaryAndEnterNode(node)\n    }\n\n    final override fu"}
{"code": "n visitBinaryAndExitLeftOperandNode(node: BinaryAndExitLeftOperandNode, data: Nothing?) {\n        visitBinaryAndExitLeftOperandNode(node)\n    }\n\n    final override fun visitBinaryAndEnterRightOperandNode(node: BinaryAndEnterRightOperandNode, data: Nothing?) {\n        visitBinaryAndEnterRightOperandNode(node)\n    }\n\n    final override fun visitBinaryAndExitNode(node: BinaryAndExitNode, data: Nothing?) {\n        visitBinaryAndExitNode(node)\n    }\n\n    final override fun visitBinaryOrEnterNode(node: BinaryOrEnterNode, data: Nothing?) {\n        visitBinaryOrEnterNode(node)\n    }\n\n    final override fun visitBinaryOrExitLeftOperandNode(node: BinaryOrExitLeftOperandNode, data: Nothing?) {\n        visitBinaryOrExitLeftOperandNode(node)\n    }\n\n    final override fun visitBinaryOrEnterRightOperandNode(node: BinaryOrEnterRightOperandNode, data: Nothing?) {\n        visitBinaryOrEnterRightOperandNode(node)\n    }\n\n    final override fun visitBinaryOrExitNode(node: BinaryOrExitNode, data: Nothing?) "}
{"code": "{\n        visitBinaryOrExitNode(node)\n    }\n\n    // ----------------------------------- Operator call -----------------------------------\n\n    final override fun visitTypeOperatorCallNode(node: TypeOperatorCallNode, data: Nothing?) {\n        visitTypeOperatorCallNode(node)\n    }\n\n    final override fun visitEqualityOperatorCallNode(node: EqualityOperatorCallNode, data: Nothing?) {\n        visitEqualityOperatorCallNode(node)\n    }\n\n    final override fun visitComparisonExpressionNode(node: ComparisonExpressionNode, data: Nothing?) {\n        visitComparisonExpressionNode(node)\n    }\n\n    // ----------------------------------- Jump -----------------------------------\n\n    final override fun visitJumpNode(node: JumpNode, data: Nothing?) {\n        visitJumpNode(node)\n    }\n\n    final override fun visitLiteralExpressionNode(node: LiteralExpressionNode, data: Nothing?) {\n        visitLiteralExpressionNode(node)\n    }\n\n    // ----------------------------------- Check not null call ------------"}
{"code": "-----------------------\n\n    final override fun visitCheckNotNullCallNode(node: CheckNotNullCallNode, data: Nothing?) {\n        visitCheckNotNullCallNode(node)\n    }\n\n    // ----------------------------------- Resolvable call -----------------------------------\n\n    final override fun visitQualifiedAccessNode(node: QualifiedAccessNode, data: Nothing?) {\n        visitQualifiedAccessNode(node)\n    }\n\n    final override fun visitResolvedQualifierNode(node: ResolvedQualifierNode, data: Nothing?) {\n        visitResolvedQualifierNode(node)\n    }\n\n    final override fun visitFunctionCallArgumentsEnterNode(node: FunctionCallArgumentsEnterNode, data: Nothing?) {\n        visitFunctionCallArgumentsEnterNode(node)\n    }\n\n    final override fun visitFunctionCallArgumentsExitNode(node: FunctionCallArgumentsExitNode, data: Nothing?) {\n        visitFunctionCallArgumentsExitNode(node)\n    }\n\n    final override fun visitFunctionCallNode(node: FunctionCallNode, data: Nothing?) {\n        visitFunctionCall"}
{"code": "Node(node)\n    }\n\n    final override fun visitDelegatedConstructorCallNode(node: DelegatedConstructorCallNode, data: Nothing?) {\n        visitDelegatedConstructorCallNode(node)\n    }\n\n    final override fun visitStringConcatenationCallNode(node: StringConcatenationCallNode, data: Nothing?) {\n        visitStringConcatenationCallNode(node)\n    }\n\n    final override fun visitThrowExceptionNode(node: ThrowExceptionNode, data: Nothing?) {\n        visitThrowExceptionNode(node)\n    }\n\n    final override fun visitStubNode(node: StubNode, data: Nothing?) {\n        visitStubNode(node)\n    }\n\n    final override fun visitVariableDeclarationNode(node: VariableDeclarationNode, data: Nothing?) {\n        visitVariableDeclarationNode(node)\n    }\n\n    final override fun visitVariableAssignmentNode(node: VariableAssignmentNode, data: Nothing?) {\n        visitVariableAssignmentNode(node)\n    }\n\n    final override fun visitEnterSafeCallNode(node: EnterSafeCallNode, data: Nothing?) {\n        visitEnterSafeC"}
{"code": "allNode(node)\n    }\n\n    final override fun visitExitSafeCallNode(node: ExitSafeCallNode, data: Nothing?) {\n        visitExitSafeCallNode(node)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.extensions.predicate\n\nimport org.jetbrains.kotlin.fir.extensions.AnnotationFqn\n\n\nsealed class LookupPredicate : AbstractPredicate<LookupPredicate> {\n    abstract override val annotations: Set<AnnotationFqn>\n    final override val metaAnnotations: Set<AnnotationFqn>\n        get() = emptySet()\n\n    abstract override fun <R, D> accept(visitor: PredicateVisitor<LookupPredicate, R, D>, data: D): R\n\n    class Or(\n        override val a: LookupPredicate,\n        override val b: LookupPredicate\n    ) : LookupPredicate(), AbstractPredicate.Or<LookupPredicate> {\n        override val annotations: Set<AnnotationFqn> = a.annotations + b.annotations\n\n        override fun <R, D> accept(visitor: PredicateVisitor<LookupPredicate, R, D>, data: D): R {\n            return visitor.visitOr(this, data)\n        }\n    }\n\n    class And(\n        override val a: LookupPredicate,\n        override val b: LookupPredicate\n    ) : LookupPredicate(), AbstractPredicate.And<LookupPredic"}
{"code": "ate> {\n        override val annotations: Set<AnnotationFqn> = a.annotations + b.annotations\n\n        override fun <R, D> accept(visitor: PredicateVisitor<LookupPredicate, R, D>, data: D): R {\n            return visitor.visitAnd(this, data)\n        }\n    }\n\n    sealed class Annotated(final override val annotations: Set<AnnotationFqn>) : LookupPredicate(), AbstractPredicate.Annotated<LookupPredicate> {\n        init {\n            require(annotations.isNotEmpty()) {\n                \"Annotations should be not empty\"\n            }\n        }\n\n        override fun <R, D> accept(visitor: PredicateVisitor<LookupPredicate, R, D>, data: D): R {\n            return visitor.visitAnnotated(this, data)\n        }\n    }\n\n    class AnnotatedWith(annotations: Set<AnnotationFqn>) : Annotated(annotations), AbstractPredicate.AnnotatedWith<LookupPredicate> {\n        override fun <R, D> accept(visitor: PredicateVisitor<LookupPredicate, R, D>, data: D): R {\n            return visitor.visitAnnotatedWith(this, dat"}
{"code": "a)\n        }\n    }\n\n    class AncestorAnnotatedWith(annotations: Set<AnnotationFqn>) : Annotated(annotations), AbstractPredicate.AncestorAnnotatedWith<LookupPredicate> {\n        override fun <R, D> accept(visitor: PredicateVisitor<LookupPredicate, R, D>, data: D): R {\n            return visitor.visitAncestorAnnotatedWith(this, data)\n        }\n    }\n\n    class ParentAnnotatedWith(annotations: Set<AnnotationFqn>) : Annotated(annotations), AbstractPredicate.ParentAnnotatedWith<LookupPredicate> {\n        override fun <R, D> accept(visitor: PredicateVisitor<LookupPredicate, R, D>, data: D): R {\n            return visitor.visitParentAnnotatedWith(this, data)\n        }\n    }\n\n\n    class HasAnnotatedWith(annotations: Set<AnnotationFqn>) : Annotated(annotations), AbstractPredicate.HasAnnotatedWith<LookupPredicate> {\n        override fun <R, D> accept(visitor: PredicateVisitor<LookupPredicate, R, D>, data: D): R {\n            return visitor.visitHasAnnotatedWith(this, data)\n        }\n    }\n\n    "}
{"code": "// -------------------------------------------- DSL --------------------------------------------\n\n    object BuilderContext : AbstractPredicate.BuilderContext<LookupPredicate>() {\n        override infix fun LookupPredicate.or(other: LookupPredicate): LookupPredicate = Or(this, other)\n        override infix fun LookupPredicate.and(other: LookupPredicate): LookupPredicate = And(this, other)\n\n        // ------------------- varargs -------------------\n        override fun annotated(vararg annotations: AnnotationFqn): LookupPredicate = annotated(annotations.toList())\n        override fun ancestorAnnotated(vararg annotations: AnnotationFqn): LookupPredicate = ancestorAnnotated(annotations.toList())\n        override fun parentAnnotated(vararg annotations: AnnotationFqn): LookupPredicate = parentAnnotated(annotations.toList())\n        override fun hasAnnotated(vararg annotations: AnnotationFqn): LookupPredicate = hasAnnotated(annotations.toList())\n\n        override fun annotatedOrUnder(vararg "}
{"code": "annotations: AnnotationFqn): LookupPredicate =\n            annotated(*annotations) or ancestorAnnotated(*annotations)\n\n        // ------------------- collections -------------------\n        override fun annotated(annotations: Collection<AnnotationFqn>): LookupPredicate = AnnotatedWith(annotations.toSet())\n        override fun ancestorAnnotated(annotations: Collection<AnnotationFqn>): LookupPredicate = AncestorAnnotatedWith(annotations.toSet())\n        override fun parentAnnotated(annotations: Collection<AnnotationFqn>): LookupPredicate = ParentAnnotatedWith(annotations.toSet())\n        override fun hasAnnotated(annotations: Collection<AnnotationFqn>): LookupPredicate = HasAnnotatedWith(annotations.toSet())\n        override fun annotatedOrUnder(annotations: Collection<AnnotationFqn>): LookupPredicate =\n            annotated(annotations) or ancestorAnnotated(annotations)\n    }\n\n    companion object {\n        inline fun create(init: BuilderContext.() -> LookupPredicate): LookupPredicate ="}
{"code": " BuilderContext.init()\n    }\n}\n"}
{"code": "fun take(lambda: (Int) -> String) {\n    <expr>lambda</expr>(10)\n}"}
{"code": "package myPack\n\n@Target(\n    AnnotationTarget.PROPERTY,\n    AnnotationTarget.TYPE_PARAMETER,\n    AnnotationTarget.FUNCTION,\n    AnnotationTarget.VALUE_PARAMETER,\n    AnnotationTarget.TYPE,\n    AnnotationTarget.EXPRESSION,\n)\n@Retention(AnnotationRetention.SOURCE)\nannotation class Anno(val number: Int)\n\n@Anno(functionProperty)\nconst val functionProperty = 42\n\n@Anno(parameterProperty)\nconst val parameterProperty = 42\n\n@Anno(defaultValueProperty)\nconst val defaultValueProperty = 42\n\n@Anno(receiverProperty)\nconst val receiverProperty = 42\n\n@Anno(receiverTypeProperty)\nconst val receiverTypeProperty = 42\n\n@Anno(typeParameterProperty)\nconst val typeParameterProperty = 42\n\n@Anno(valueParameterTypeProperty)\nconst val valueParameterTypeProperty = 42\n\n@Anno(expressionProperty)\nconst val expressionProperty = 42\n\nfun topLevelFun() = run {\n    @Anno(functionProperty)\n    fun <@Anno(typeParameterProperty) T> @receiver:Anno(receiverProperty) @Anno(receiverTypeProperty) Int.function(\n        @Anno(param"}
{"code": "eterProperty) param: @Anno(\n            valueParameterTypeProperty\n        ) Int = defaultValueProperty,\n    ) = @Anno(expressionProperty) \"str\"\n}\n"}
{"code": "sealed class A\n\nsealed class B : A()\nclass C : A()\n\nsealed class D : B()\nsealed class E : B()\n\nfun test_1(e: A) {\n    val a = when (e) {\n        is C -> 1\n        is D -> 2\n        is E -> 3\n    }.plus(0)\n\n    val b = when (e) {\n        is B -> 1\n        is C -> 2\n    }.plus(0)\n\n    val c = when (e) {\n        is B -> 1\n        is C -> 2\n        is E -> 3\n        is D -> 4\n    }.plus(0)\n\n    val d = when (e) {\n        is E -> 1\n        <!USELESS_IS_CHECK!>is A<!> -> 2\n    }.plus(0)\n}\n\nfun test_2(e: A) {\n    val a = <!NO_ELSE_IN_WHEN!>when<!> (e) {\n        is D -> 1\n        is E -> 2\n    }.plus(0)\n\n    val b = <!NO_ELSE_IN_WHEN!>when<!> (e) {\n        is B -> 1\n        is D -> 2\n        is E -> 3\n    }.plus(0)\n\n    val c = <!NO_ELSE_IN_WHEN!>when<!> (e) {\n        is B -> 1\n        is D -> 2\n    }.plus(0)\n\n    val d = when (e) {\n        is C -> 1\n    }.plus(0)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen\n\nimport org.jetbrains.kotlin.codegen.binding.CalculatedClosure\nimport org.jetbrains.kotlin.codegen.binding.CodegenBinding\nimport org.jetbrains.kotlin.codegen.state.GenerationState\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.descriptors.annotations.Annotations\nimport org.jetbrains.kotlin.descriptors.impl.LocalVariableDescriptor\nimport org.jetbrains.kotlin.psi.KtCallableReferenceExpression\nimport org.jetbrains.kotlin.resolve.DescriptorFactory\nimport org.jetbrains.kotlin.resolve.DescriptorUtils\nimport org.jetbrains.kotlin.resolve.isGetterOfUnderlyingPropertyOfInlineClass\nimport org.jetbrains.kotlin.resolve.isInlineClass\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes\nimport org.jetbrains.kotlin.resolve.jvm.shouldHideConstructorDueToValueClassTypeValueParameters\nimport org.jetbrains.kotlin.resolve.source.KotlinSourceElement\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.kotlin.types.typeUtil.builtIns\nimpor"}
{"code": "t org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\n\nfun capturedBoundReferenceReceiver(\n    ownerType: Type,\n    expectedReceiverType: Type,\n    expectedReceiverKotlinType: KotlinType?,\n    isInliningStrategy: Boolean\n): StackValue =\n    StackValue.operation(expectedReceiverType) { iv ->\n        iv.load(0, ownerType)\n        iv.getfield(\n            ownerType.internalName,\n            //HACK for inliner - it should recognize field as captured receiver\n            if (isInliningStrategy) AsmUtil.CAPTURED_RECEIVER_FIELD else AsmUtil.BOUND_REFERENCE_RECEIVER,\n            AsmTypes.OBJECT_TYPE.descriptor\n        )\n        val nullableAny = expectedReceiverKotlinType?.run { builtIns.nullableAnyType }\n        StackValue.coerce(AsmTypes.OBJECT_TYPE, nullableAny, expectedReceiverType, expectedReceiverKotlinType, iv)\n    }\n\nfun ClassDescriptor.isSyntheticClassForCallableReference(): Boolean =\n    this is SyntheticClassDescriptorForLambda &&\n "}
{"code": "           (this.source as? KotlinSourceElement)?.psi is KtCallableReferenceExpression\n\nfun CalculatedClosure.isForCallableReference(): Boolean =\n    closureClass.isSyntheticClassForCallableReference()\n\nfun CalculatedClosure.isForBoundCallableReference(): Boolean =\n    isForCallableReference() && capturedReceiverFromOuterContext != null\n\nfun InstructionAdapter.loadBoundReferenceReceiverParameter(index: Int, type: Type, kotlinType: KotlinType?) {\n    load(index, type)\n    val nullableAny = kotlinType?.run { builtIns.nullableAnyType }\n    StackValue.coerce(type, kotlinType, AsmTypes.OBJECT_TYPE, nullableAny, this)\n}\n\nfun CalculatedClosure.isBoundReferenceReceiverField(fieldInfo: FieldInfo): Boolean =\n    isForBoundCallableReference() &&\n            fieldInfo.fieldName == AsmUtil.CAPTURED_RECEIVER_FIELD\n\nfun InstructionAdapter.generateClosureFieldsInitializationFromParameters(\n    closure: CalculatedClosure,\n    args: List<FieldInfo>\n): Pair<Int, FieldInfo>? {\n    var k = 1\n    var boundR"}
{"code": "eferenceReceiverParameterIndex = -1\n    var boundReferenceReceiverFieldInfo: FieldInfo? = null\n    for (fieldInfo in args) {\n        if (closure.isBoundReferenceReceiverField(fieldInfo)) {\n            boundReferenceReceiverParameterIndex = k\n            boundReferenceReceiverFieldInfo = fieldInfo\n            k += fieldInfo.fieldType.size\n            continue\n        }\n        k = DescriptorAsmUtil.genAssignInstanceFieldFromParam(fieldInfo, k, this)\n    }\n\n    return boundReferenceReceiverFieldInfo?.let { Pair(boundReferenceReceiverParameterIndex, it) }\n}\n\nfun computeExpectedNumberOfReceivers(referencedFunction: FunctionDescriptor, isBound: Boolean): Int {\n    val receivers = referencedFunction.contextReceiverParameters.size +\n            (if (referencedFunction.dispatchReceiverParameter != null) 1 else 0) +\n            (if (referencedFunction.extensionReceiverParameter != null) 1 else 0) -\n            (if (isBound) 1 else 0)\n\n    if (receivers < 0 && referencedFunction is ConstructorDe"}
{"code": "scriptor &&\n        DescriptorUtils.isObject(referencedFunction.containingDeclaration.containingDeclaration)\n    ) {\n        //reference to object nested class\n        //TODO: seems problem should be fixed on frontend side (note that object instance are captured by generated class)\n        return 0\n    }\n\n    return receivers\n}\n\n// Returns false if null was generated.\ninternal fun generateCallableReferenceDeclarationContainerClass(\n    iv: InstructionAdapter,\n    descriptor: CallableDescriptor,\n    state: GenerationState\n): Boolean {\n    val typeMapper = state.typeMapper\n    val container = descriptor.containingDeclaration\n    when {\n        container is ClassDescriptor -> {\n            // TODO: would it work for arrays?\n            val containerKotlinType = container.defaultType\n            val containerType = typeMapper.mapClass(container)\n            DescriptorAsmUtil.putJavaLangClassInstance(iv, containerType, containerKotlinType, typeMapper)\n        }\n        container is PackageF"}
{"code": "ragmentDescriptor -> {\n            iv.aconst(typeMapper.mapOwner(descriptor))\n        }\n        descriptor is VariableDescriptorWithAccessors -> {\n            iv.aconst(state.bindingContext[CodegenBinding.DELEGATED_PROPERTY_METADATA_OWNER, descriptor])\n        }\n        else -> {\n            iv.aconst(null)\n            return false\n        }\n    }\n    return true\n}\n\ninternal fun generateCallableReferenceDeclarationContainer(\n    iv: InstructionAdapter,\n    descriptor: CallableDescriptor,\n    state: GenerationState\n) {\n    if (!generateCallableReferenceDeclarationContainerClass(iv, descriptor, state)) return\n    if (isTopLevelCallableReference(descriptor)) {\n        // Note that this name is not used in reflection. There should be the name of the referenced declaration's module instead,\n        // but there's no nice API to obtain that name here yet\n        // TODO: write the referenced declaration's module name and use it in reflection\n        iv.aconst(state.moduleName)\n        iv.inv"}
{"code": "okestatic(\n            AsmTypes.REFLECTION, \"getOrCreateKotlinPackage\",\n            Type.getMethodDescriptor(\n                AsmTypes.K_DECLARATION_CONTAINER_TYPE, AsmTypes.getType(Class::class.java), AsmTypes.getType(String::class.java)\n            ), false\n        )\n    } else {\n        AsmUtil.wrapJavaClassIntoKClass(iv)\n    }\n}\n\nprivate fun isTopLevelCallableReference(descriptor: CallableDescriptor): Boolean =\n    if (descriptor is LocalVariableDescriptor)\n        DescriptorUtils.getParentOfType(descriptor, ClassDescriptor::class.java) == null\n    else descriptor.containingDeclaration is PackageFragmentDescriptor\n\ninternal fun getCallableReferenceTopLevelFlag(descriptor: CallableDescriptor): Int =\n    if (isTopLevelCallableReference(descriptor)) 1 else 0\n\ninternal fun generateFunctionReferenceSignature(iv: InstructionAdapter, callable: CallableDescriptor, state: GenerationState) {\n    iv.aconst(getSignatureString(callable, state))\n}\n\ninternal fun generatePropertyReferenceSignature"}
{"code": "(iv: InstructionAdapter, callable: CallableDescriptor, state: GenerationState) {\n    iv.aconst(getSignatureString(callable, state, isPropertySignature = true))\n}\n\nprivate fun getSignatureString(callable: CallableDescriptor, state: GenerationState, isPropertySignature: Boolean = false): String {\n    if (callable is LocalVariableDescriptor) {\n        val asmType = state.bindingContext.get(CodegenBinding.DELEGATED_PROPERTY_METADATA_OWNER, callable)\n            ?: throw AssertionError(\"No delegated property metadata owner for $callable\")\n        val localDelegatedProperties = CodegenBinding.getLocalDelegatedProperties(state.bindingContext, asmType)\n        val index = localDelegatedProperties?.indexOf(callable) ?: -1\n        if (index < 0) {\n            throw AssertionError(\"Local delegated property is not found in $asmType: $callable\")\n        }\n        return \"<v#$index>\"\n    }\n\n    val accessor = when (callable) {\n        is ClassConstructorDescriptor ->\n            if (shouldHideConstr"}
{"code": "uctorDueToValueClassTypeValueParameters(callable))\n                AccessorForConstructorDescriptor(callable, callable.containingDeclaration, null, AccessorKind.NORMAL)\n            else\n                callable\n        is FunctionDescriptor -> callable\n        is VariableDescriptorWithAccessors ->\n            callable.getter ?: DescriptorFactory.createDefaultGetter(callable as PropertyDescriptor, Annotations.EMPTY).apply {\n                initialize(callable.type)\n            }\n        else -> error(\"Unsupported callable reference: $callable\")\n    }\n    val declaration = DescriptorUtils.unwrapFakeOverride(accessor).original\n    val method = when {\n        callable.containingDeclaration.isInlineClass() && !declaration.isGetterOfUnderlyingPropertyOfInlineClass() ->\n            state.typeMapper.mapSignatureForInlineErasedClassSkipGeneric(declaration).asmMethod\n        isPropertySignature ->\n            state.typeMapper.mapPropertyReferenceSignature(declaration)\n        else ->\n           "}
{"code": " state.typeMapper.mapAsmMethod(declaration)\n    }\n    return method.name + method.descriptor\n}\n"}
{"code": "fun test() {\n    val f = { x, y ->\n        <expr>x + y</expr>\n        }\n    f(5, 4)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.calls.inference.constraintPosition\n\nimport org.jetbrains.kotlin.descriptors.TypeParameterDescriptor\nimport org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind.*\nimport org.jetbrains.kotlin.types.KotlinType\n\nenum class ConstraintPositionKind {\n    RECEIVER_POSITION,\n    EXPECTED_TYPE_POSITION,\n    VALUE_PARAMETER_POSITION,\n    TYPE_BOUND_POSITION,\n    COMPOUND_CONSTRAINT_POSITION,\n    FROM_COMPLETER,\n    SPECIAL;\n\n    fun position(): ConstraintPosition {\n        assert(this in setOf(RECEIVER_POSITION, EXPECTED_TYPE_POSITION, FROM_COMPLETER, SPECIAL))\n        return ConstraintPositionImpl(this)\n    }\n\n    fun position(index: Int): ConstraintPosition {\n        assert(this in setOf(VALUE_PARAMETER_POSITION, TYPE_BOUND_POSITION))\n        return ConstraintPositionWithIndex(this, index)\n    }\n}\n\nfun valueParameterPosition(index: Int) = ConstraintPositionKind.VALUE_PARAMETER_POSITION.position(index)\n\ninterface Constraint"}
{"code": "Position {\n    val kind: ConstraintPositionKind\n\n    fun isStrong(): Boolean = kind != TYPE_BOUND_POSITION\n\n    fun isParameter(): Boolean = kind in setOf(VALUE_PARAMETER_POSITION, RECEIVER_POSITION)\n}\n\nprivate data class ConstraintPositionImpl(override val kind: ConstraintPositionKind) : ConstraintPosition {\n    override fun toString() = \"$kind\"\n}\n\nprivate data class ConstraintPositionWithIndex(override val kind: ConstraintPositionKind, val index: Int) : ConstraintPosition {\n    override fun toString() = \"$kind($index)\"\n}\n\nclass CompoundConstraintPosition(vararg positions: ConstraintPosition) : ConstraintPosition {\n\n    override val kind: ConstraintPositionKind\n        get() = COMPOUND_CONSTRAINT_POSITION\n\n    val positions: Collection<ConstraintPosition> =\n        positions.flatMap { (it as? CompoundConstraintPosition)?.positions ?: listOf(it) }.toSet()\n\n    override fun isStrong() = positions.any { it.isStrong() }\n\n    override fun toString() = \"$kind(${positions.joinToString()})\"\n}"}
{"code": "\n\nfun ConstraintPosition.derivedFrom(kind: ConstraintPositionKind): Boolean {\n    return if (this !is CompoundConstraintPosition) this.kind == kind else positions.any { it.kind == kind }\n}\n\nclass ValidityConstraintForConstituentType(\n    val typeArgument: KotlinType,\n    val typeParameter: TypeParameterDescriptor,\n    val bound: KotlinType\n) : ConstraintPosition {\n    override val kind: ConstraintPositionKind get() = TYPE_BOUND_POSITION\n}\n\nfun ConstraintPosition.getValidityConstraintForConstituentType(): ValidityConstraintForConstituentType? =\n    when (this) {\n        is ValidityConstraintForConstituentType ->\n            this\n        is CompoundConstraintPosition ->\n            positions.asSequence().map { it.getValidityConstraintForConstituentType() }.firstOrNull { it != null }\n        else ->\n            null\n    }"}
{"code": "class C {\n\n    fun create() = C()\n}\n\nfun foo() = C()\nfun bar() = foo().create()\n"}
{"code": "// LOOK_UP_FOR_ELEMENT_OF_TYPE: org.jetbrains.kotlin.psi.KtBlockExpression\n\nfun doo() <expr>{}</expr>"}
{"code": "fun test(a: Any) {\n    if (a is String) {\n        <expr>a</expr>.length\n    }\n}"}
{"code": "// SUBSTITUTOR: T -> kotlin.collections.List<S>, S -> kotlin.Long\n\nval <T, S> Map<T, S>.val<caret>ue: List<S>"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.checkTypeRefForUnderscore\nimport org.jetbrains.kotlin.fir.analysis.checkers.isTopLevel\nimport org.jetbrains.kotlin.fir.declarations.FirTypeAlias\nimport org.jetbrains.kotlin.fir.resolve.fullyExpandedType\nimport org.jetbrains.kotlin.fir.resolve.toSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirTypeAliasSymbol\nimport org.jetbrains.kotlin.fir.types.*\n\nobject FirTopLevelTypeAliasChecker : FirTypeAliasChecker(MppCheckerKind.Common) {\n    override fun check(declaration: FirTypeAlias, context: CheckerContext, reporter: DiagnosticReporter) {\n        if (!context.isTopLev"}
{"code": "el) {\n            reporter.reportOn(declaration.source, FirErrors.TOPLEVEL_TYPEALIASES_ONLY, context)\n        }\n\n        fun containsTypeParameter(type: ConeKotlinType): Boolean {\n            val unwrapped = type.unwrapFlexibleAndDefinitelyNotNull()\n\n            if (unwrapped is ConeTypeParameterType) {\n                return true\n            }\n\n            if (unwrapped is ConeClassLikeType && unwrapped.lookupTag.toSymbol(context.session) is FirTypeAliasSymbol) {\n                for (typeArgument in unwrapped.typeArguments) {\n                    val typeArgumentType = (typeArgument as? ConeKotlinType) ?: (typeArgument as? ConeKotlinTypeProjection)?.type\n                    if (typeArgumentType != null && containsTypeParameter(typeArgumentType)) {\n                        return true\n                    }\n                }\n            }\n\n            return false\n        }\n\n        val expandedTypeRef = declaration.expandedTypeRef\n        val fullyExpandedType = expandedTypeRef.coneType."}
{"code": "fullyExpandedType(context.session)\n\n        if (containsTypeParameter(fullyExpandedType) || fullyExpandedType is ConeDynamicType) {\n            reporter.reportOn(\n                declaration.expandedTypeRef.source,\n                FirErrors.TYPEALIAS_SHOULD_EXPAND_TO_CLASS,\n                expandedTypeRef.coneType,\n                context\n            )\n        }\n        checkTypeRefForUnderscore(expandedTypeRef, context, reporter)\n    }\n}\n"}
{"code": "fun f() {\n    class C {\n        \n        fun aa() {}\n\n        fun bb() {}\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.declarations.bodies\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.symbols.*\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolWithMembers\n\npublic interface KtRendererBodyMemberScopeProvider {\n    context(KtAnalysisSession)\n    public fun getMemberScope(symbol: KtSymbolWithMembers): List<KtDeclarationSymbol>\n\n    public object ALL : KtRendererBodyMemberScopeProvider {\n        context(KtAnalysisSession)\n        override fun getMemberScope(symbol: KtSymbolWithMembers): List<KtDeclarationSymbol> {\n            return symbol.getCombinedDeclaredMemberScope().getAllSymbols().toList()\n        }\n    }\n\n    public object ALL_DECLARED : KtRendererBodyMemberScopeProvider {\n        context(KtAnalysisSession)\n        override fun getMemberScope(symbol: KtSymbolWithMembers): List<KtDeclarationSymbol> {\n            return symbol.getCombinedDeclaredMemberScope().getAllSymbols()\n    "}
{"code": "            .filter { member ->\n                    val origin = member.origin\n                    origin != KtSymbolOrigin.DELEGATED &&\n                            origin != KtSymbolOrigin.SOURCE_MEMBER_GENERATED &&\n                            origin != KtSymbolOrigin.SUBSTITUTION_OVERRIDE &&\n                            origin != KtSymbolOrigin.INTERSECTION_OVERRIDE\n                }.filter { member ->\n                    member !is KtConstructorSymbol || symbol !is KtClassOrObjectSymbol || !symbol.classKind.isObject\n                }.filterNot { member ->\n                    member is KtConstructorSymbol && symbol is KtEnumEntrySymbol\n                }\n                .toList()\n        }\n    }\n\n    public object NONE : KtRendererBodyMemberScopeProvider {\n        context(KtAnalysisSession)\n        override fun getMemberScope(symbol: KtSymbolWithMembers): List<KtDeclarationSymbol> {\n            return emptyList()\n        }\n    }\n}\n"}
{"code": "val x = 1\nval y = 2 as Any\n\nval f = fun() = 3 as Any\nval g = {}\nval h: (String) -> Boolean = { _ -> false }\nval hError = { <!VALUE_PARAMETER_WITH_NO_TYPE_ANNOTATION!>_<!> -> true }\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.checkers\n\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtNamedFunction\nimport org.jetbrains.kotlin.psi.KtPropertyAccessor\n\nobject ContractDescriptionBlockChecker: DeclarationChecker {\n    override fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n        val contractDescription = when (declaration) {\n            is KtNamedFunction -> declaration.contractDescription\n            is KtPropertyAccessor -> declaration.contractDescription\n            else -> null\n        }\n        if (contractDescription != null) {\n            context.trace.report(Errors.UNSUPPORTED.on(contractDescription, \"Contract description blocks are not supported\"))\n        }\n    }\n}"}
{"code": "import java.lang.annotation.ElementType\n\n@java.lang.annotation.Target(ElementType.TYPE_USE)\nannotation class Reso<caret>lveMe"}
{"code": "// FILE: main.kt\nimport other.*\n\nval a = 5\n\n// FILE: other/other.kt\npackage other\n\nclass A\nfun b() {}"}
{"code": "// MODULE: lib\n// MODULE_KIND: LibraryBinary\n// FILE: p3/foo.kt\npackage p3\n\nfun foo() = 3\n\n// MODULE: lib2(lib)\n// MODULE_KIND: LibraryBinary\n// FILE: p2/bar.kt\npackage p2\n\nfun bar() = 4 + p3.foo()\n\n// MODULE: main(lib, lib2)\n// FILE: main.kt\nimport p2.bar\n\nfun test() = bar()\n"}
{"code": "fun x() {\n    toCall(1, z = a<caret>v)\n}\n\nfun toCall(x: Int, y: String, z: Boolean): Char = 'a'\n\n"}
{"code": "// CLASS: test/Foo\n// CLASS: test/Bar\n// CLASS: test/Bar.Baz\n// CLASS: test/Bar.Boo\n// CLASS: test/Bar.Bok\n// FUNCTION: test/#foo\n// PROPERTY: test/#foo\n\npackage test\n\nclass Foo\ninterface Foo\ntypealias Foo = Foo\nenum class Foo\n\nclass Bar {\n    class Baz\n    object Boo\n}\n\ninterface Bar {\n    object Baz\n    interface Bok\n}\n\nfun foo() {}\nfun foo(a: Int) {}\n\nval foo: String = \"foo\""}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.intrinsics\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.codegen.*\nimport org.jetbrains.kotlin.codegen.DescriptorAsmUtil.genInvokeAppendMethod\nimport org.jetbrains.kotlin.codegen.state.GenerationState\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.psi.KtBinaryExpression\nimport org.jetbrains.kotlin.psi.KtCallableReferenceExpression\nimport org.jetbrains.kotlin.psi.KtExpression\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes.JAVA_STRING_TYPE\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\n\nclass Concat : IntrinsicMethod() {\n    fun generateImpl(\n        codegen: ExpressionCodegen,\n        v: InstructionAdapter,\n        returnType: Type,\n        element: PsiElement?,\n        arguments: List<KtExpression>,\n        receiver: StackValue\n    ):"}
{"code": " Type {\n        val generator = StringConcatGenerator.create(codegen.state, v)\n        if (element is KtBinaryExpression && element.operationReference.getReferencedNameElementType() == KtTokens.PLUS) {\n            // LHS + RHS            \n            generator.genStringBuilderConstructorIfNeded()\n            codegen.invokeAppend(generator, element.left)\n            codegen.invokeAppend(generator, element.right)\n        } else {\n            // Explicit plus call LHS?.plus(RHS) or LHS.plus(RHS)\n            receiver.put(AsmTypes.JAVA_STRING_TYPE, v)\n            generator.genStringBuilderConstructorIfNeded(true)\n            genInvokeAppendMethod(generator, returnType, null, null, StackValue.onStack(JAVA_STRING_TYPE))\n            codegen.invokeAppend(generator, arguments[0])\n        }\n        generator.genToString()\n        return JAVA_STRING_TYPE\n    }\n\n\n    override fun toCallable(method: CallableMethod): Callable =\n        object : IntrinsicCallable(method) {\n            lateinit var gen"}
{"code": "erator: StringConcatGenerator\n            override fun invokeMethodWithArguments(\n                resolvedCall: ResolvedCall<*>,\n                receiver: StackValue,\n                codegen: ExpressionCodegen\n            ): StackValue {\n                if (resolvedCall.call.callElement.parent is KtCallableReferenceExpression) {\n                    // NB we come here only in case of inlined callable reference to String::plus.\n                    // This will map arguments properly, invoking callbacks defined in Callable.\n                    return super.invokeMethodWithArguments(resolvedCall, receiver, codegen)\n                }\n                return StackValue.operation(returnType) {\n                    val arguments = resolvedCall.call.valueArguments.map { it.getArgumentExpression()!! }\n                    val actualType = generateImpl(\n                        codegen, it, returnType,\n                        resolvedCall.call.callElement,\n                        arguments,\n         "}
{"code": "               StackValue.receiver(resolvedCall, receiver, codegen, this)\n                    )\n                    StackValue.coerce(actualType, returnType, it)\n                }\n            }\n\n            override fun afterReceiverGeneration(v: InstructionAdapter, frameMap: FrameMap, state: GenerationState) {\n                generator = StringConcatGenerator.create(state, v)\n                if (!generator.mode.isDynamic) {\n                    v.generateNewInstanceDupAndPlaceBeforeStackTop(frameMap, JAVA_STRING_TYPE, \"java/lang/StringBuilder\")\n                    v.invokespecial(\"java/lang/StringBuilder\", \"<init>\", \"(Ljava/lang/String;)V\", false)\n                } else {\n                    generator.invokeAppend(JAVA_STRING_TYPE)\n                }\n            }\n\n            override fun invokeIntrinsic(v: InstructionAdapter) {\n                // String::plus has type String.(Any?) -> String, thus we have no argument type information\n                // in case of callable reference pa"}
{"code": "ssed to a generic function, e.g.:\n                //      charArrayOf('O', 'K').fold(\"\", String::plus)\n                // TODO Make String::plus generic, and invoke proper StringBuilder#append.\n                generator.invokeAppend(AsmTypes.OBJECT_TYPE)\n                generator.genToString()\n            }\n        }\n}\n"}
{"code": "// LOOK_UP_FOR_ELEMENT_OF_TYPE: org.jetbrains.kotlin.psi.KtAnnotationEntry\n\n@Target(AnnotationTarget.TYPE)\nannotation class Anno\n\nopen class A\n\nclass B : <expr>@Anno</expr> A()"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.DiagnosticCheckerFilter\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.collectDiagnosticsForFile\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.getFirResolveSession\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.getOrBuildFirFile\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.compile.CodeFragmentCapturedValueAnalyzer\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators.AnalysisApiFirSourceTestConfigurator\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.util.codeFragment\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.test.framework.utils.indented\nimport org.jetbrains.kotlin.diagnostics.Severity\nimport org.jetbrains.kotlin.fir.declarations.FirRe"}
{"code": "solvePhase\nimport org.jetbrains.kotlin.fir.render\nimport org.jetbrains.kotlin.fir.renderer.FirRenderer\nimport org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.builders.TestConfigurationBuilder\nimport org.jetbrains.kotlin.test.directives.ConfigurationDirectives\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.assertions\n\nabstract class AbstractCodeFragmentCapturingTest : AbstractAnalysisApiBasedTest() {\n    override val configurator = AnalysisApiFirSourceTestConfigurator(analyseInDependentSession = false)\n\n    override fun doTestByMainFile(mainFile: KtFile, mainModule: KtTestModule, testServices: TestServices) {\n        val project = mainFile.project\n\n        val resolveSession = mainModule.ktModule.getFirResolveSession(project)\n        val firFile = mainFile.getOrBuildFirFile(resolveSession)\n\n        val firCodeFragment = firFile.codeFragment\n        firCodeFragmen"}
{"code": "t.lazyResolveToPhase(FirResolvePhase.BODY_RESOLVE)\n\n        val frontendDiagnostics = mainFile.collectDiagnosticsForFile(resolveSession, DiagnosticCheckerFilter.ONLY_COMMON_CHECKERS)\n        val frontendErrors = frontendDiagnostics.filter { it.severity == Severity.ERROR }\n\n        require(frontendErrors.isEmpty()) {\n            frontendErrors\n        }\n\n        val capturedSymbols = CodeFragmentCapturedValueAnalyzer.analyze(resolveSession, firCodeFragment).symbols\n\n        val actualText = capturedSymbols.joinToString(\"\\n\") { capturedSymbol ->\n            val firRenderer = FirRenderer(\n                bodyRenderer = null,\n                classMemberRenderer = null,\n                contractRenderer = null,\n                modifierRenderer = null\n            )\n\n            buildString {\n                append(capturedSymbol.value)\n                appendLine().append(firRenderer.renderElementAsString(capturedSymbol.symbol.fir).indented(4))\n                appendLine().append(capturedSymbo"}
{"code": "l.typeRef.render().indented(4))\n            }\n        }\n\n        testServices.assertions.assertEqualsToTestDataFileSibling(\n            actual = actualText.ifEmpty { \"No captured values\" },\n            extension = \".capturing.txt\"\n        )\n    }\n\n    override fun configureTest(builder: TestConfigurationBuilder) {\n        super.configureTest(builder)\n        with(builder) {\n            defaultDirectives {\n                +ConfigurationDirectives.WITH_STDLIB\n            }\n        }\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen\n\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin\nimport org.jetbrains.org.objectweb.asm.*\nimport org.jetbrains.org.objectweb.asm.tree.*\n\nclass OriginCollectingClassBuilderFactory(private val builderMode: ClassBuilderMode) : ClassBuilderFactory {\n    val compiledClasses = mutableListOf<ClassNode>()\n    val origins = mutableMapOf<Any, JvmDeclarationOrigin>()\n\n    override fun getClassBuilderMode(): ClassBuilderMode = builderMode\n\n    override fun newClassBuilder(origin: JvmDeclarationOrigin): AbstractClassBuilder.Concrete {\n        val classNode = ClassNode()\n        compiledClasses += classNode\n        origins[classNode] = origin\n        return OriginCollectingClassBuilder(classNode)\n    }\n\n    private inner class OriginCollectingClassBuilder(val classNode: ClassNode) : AbstractClassBuilder.Concrete(classNode) {\n        override fun newField(\n                origin: JvmDeclarationOrigin,\n                access: Int,\n       "}
{"code": "         name: String,\n                desc: String,\n                signature: String?,\n                value: Any?\n        ): FieldVisitor {\n            val fieldNode = super.newField(origin, access, name, desc, signature, value) as FieldNode\n            origins[fieldNode] = origin\n            return fieldNode\n        }\n\n        override fun newMethod(\n                origin: JvmDeclarationOrigin,\n                access: Int,\n                name: String,\n                desc: String,\n                signature: String?,\n                exceptions: Array<out String>?\n        ): MethodVisitor {\n            val methodNode = super.newMethod(origin, access, name, desc, signature, exceptions) as MethodNode\n            origins[methodNode] = origin\n\n            // ASM doesn't read information about local variables for the `abstract` methods so we need to get it manually\n            if ((access and Opcodes.ACC_ABSTRACT) != 0 && methodNode.localVariables == null) {\n                methodNode.l"}
{"code": "ocalVariables = mutableListOf<LocalVariableNode>()\n            }\n\n            return methodNode\n        }\n    }\n\n    override fun asBytes(builder: ClassBuilder): ByteArray {\n        val classWriter = ClassWriter(ClassWriter.COMPUTE_FRAMES or ClassWriter.COMPUTE_MAXS)\n        (builder as OriginCollectingClassBuilder).classNode.accept(classWriter)\n        return classWriter.toByteArray()\n    }\n\n    override fun asText(builder: ClassBuilder) = throw UnsupportedOperationException()\n\n    override fun close() {}\n}\n"}
{"code": "// WITH_STDLIB\n// CLASS_ID: java.lang.annotation/Target\n\nimport java.lang.annotation.ElementType\nimport java.lang.annotation.ElementType.PACKAGE\n\n@java.lang.annotation.Target(PACKAGE, ElementType.FIELD)\nannotation class KotlinAnno<caret>tation"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.test.framework\n\nimport com.intellij.openapi.Disposable\nimport com.intellij.openapi.util.Disposer\nimport org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.TestInfo\n\nabstract class TestWithDisposable {\n    private var _disposable: Disposable? = Disposer.newDisposable(\"Disposable for Analysis Api tests\")\n    protected val disposable: Disposable get() = _disposable!!\n\n    @BeforeEach\n    fun initDisposable(testInfo: TestInfo) {\n        _disposable = Disposer.newDisposable(\"disposable for ${testInfo.displayName}\")\n    }\n\n    @AfterEach\n    fun disposeDisposable() {\n        _disposable?.let { Disposer.dispose(it) }\n        _disposable = null\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.cli.common.arguments\n\nimport org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity\nimport org.jetbrains.kotlin.cli.common.messages.MessageCollector\nimport org.jetbrains.kotlin.config.*\n\nclass K2JVMCompilerArguments : CommonCompilerArguments() {\n    companion object {\n        @JvmStatic\n        private val serialVersionUID = 0L\n    }\n\n    @Argument(value = \"-d\", valueDescription = \"<directory|jar>\", description = \"Destination for generated class files.\")\n    var destination: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n    @Argument(\n        value = \"-classpath\",\n        shortName = \"-cp\",\n        valueDescription = \"<path>\",\n        description = \"List of directories and JAR/ZIP archives to search for user class files.\"\n    )\n    var classpath: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) nul"}
{"code": "l else value\n        }\n\n    @Argument(value = \"-include-runtime\", description = \"Include the Kotlin runtime in the resulting JAR.\")\n    var includeRuntime = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-jdk-home\",\n        valueDescription = \"<path>\",\n        description = \"Include a custom JDK from the specified location in the classpath instead of the default 'JAVA_HOME'.\"\n    )\n    var jdkHome: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n    @GradleOption(\n        value = DefaultValue.BOOLEAN_FALSE_DEFAULT,\n        gradleInputType = GradleInputTypes.INPUT,\n        shouldGenerateDeprecatedKotlinOptions = true,\n    )\n    @Argument(value = \"-no-jdk\", description = \"Don't automatically include the Java runtime in the classpath.\")\n    var noJdk = false\n        set(value) {\n            checkFrozen()\n            field = valu"}
{"code": "e\n        }\n\n    @Argument(\n        value = \"-no-stdlib\",\n        description = \"Don't automatically include the Kotlin/JVM stdlib and Kotlin reflection dependencies in the classpath.\"\n    )\n    var noStdlib = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(value = \"-no-reflect\", description = \"Don't automatically include the Kotlin reflection dependency in the classpath.\")\n    var noReflect = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-expression\",\n        shortName = \"-e\",\n        description = \"Evaluate the given string as a Kotlin script.\"\n    )\n    var expression: String? = null\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-script-templates\",\n        valueDescription = \"<fully qualified class name[,]>\",\n        description = \"Script definition template classes.\"\n    )\n    var sc"}
{"code": "riptTemplates: Array<String>? = null\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @GradleOption(\n        value = DefaultValue.STRING_NULL_DEFAULT,\n        gradleInputType = GradleInputTypes.INPUT,\n        shouldGenerateDeprecatedKotlinOptions = true,\n    )\n    @Argument(value = \"-module-name\", valueDescription = \"<name>\", description = \"Name of the generated '.kotlin_module' file.\")\n    var moduleName: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n    @GradleOption(\n        value = DefaultValue.JVM_TARGET_VERSIONS,\n        gradleInputType = GradleInputTypes.INPUT,\n        shouldGenerateDeprecatedKotlinOptions = true,\n    )\n    @Argument(\n        value = \"-jvm-target\",\n        valueDescription = \"<version>\",\n        description = \"The target version of the generated JVM bytecode (${JvmTarget.SUPPORTED_VERSIONS_DESCRIPTION}), with 1.8 as the default.\",\n    "}
{"code": ")\n    var jvmTarget: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n    @GradleOption(\n        value = DefaultValue.BOOLEAN_FALSE_DEFAULT,\n        gradleInputType = GradleInputTypes.INPUT,\n        shouldGenerateDeprecatedKotlinOptions = true,\n    )\n    @Argument(value = \"-java-parameters\", description = \"Generate metadata for Java 1.8 reflection on method parameters.\")\n    var javaParameters = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    // Advanced options\n\n    @Argument(value = \"-Xuse-old-backend\", description = \"Use the old JVM backend.\")\n    var useOldBackend = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xallow-unstable-dependencies\",\n        description = \"Do not report errors on classes in dependencies that were compiled by an unstable version of the Kotlin compiler."}
{"code": "\"\n    )\n    var allowUnstableDependencies = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xabi-stability\",\n        valueDescription = \"{stable|unstable}\",\n        description = \"\"\"When using unstable compiler features such as FIR, use 'stable' to mark generated class files as stable\nto prevent diagnostics from being reported when using stable compilers at the call site.\nWhen using the JVM IR backend, conversely, use 'unstable' to mark generated class files as unstable\nto force diagnostics to be reported.\"\"\"\n    )\n    var abiStability: String? = null\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xir-do-not-clear-binding-context\",\n        description = \"When using the IR backend, do not clear BindingContext between 'psi2ir' and lowerings.\"\n    )\n    var doNotClearBindingContext = false\n        set(value) {\n            checkFrozen()\n          "}
{"code": "  field = value\n        }\n\n    @Argument(\n        value = \"-Xbackend-threads\",\n        valueDescription = \"<N>\",\n        description = \"\"\"When using the IR backend, run lowerings by file in N parallel threads.\n0 means use one thread per processor core.\nThe default value is 1.\"\"\"\n    )\n    var backendThreads: String = \"1\"\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(value = \"-Xmodule-path\", valueDescription = \"<path>\", description = \"Paths to Java 9+ modules.\")\n    var javaModulePath: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n    @Argument(\n        value = \"-Xadd-modules\",\n        valueDescription = \"<module[,]>\",\n        description = \"\"\"Root modules to resolve in addition to the initial modules, or all modules on the module path if <module> is ALL-MODULE-PATH.\"\"\"\n    )\n    var additionalJavaModules: Array<String>? = null\n        set(value) "}
{"code": "{\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(value = \"-Xno-call-assertions\", description = \"Don't generate not-null assertions for arguments of platform types.\")\n    var noCallAssertions = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xno-receiver-assertions\",\n        description = \"Don't generate not-null assertions for extension receiver arguments of platform types.\"\n    )\n    var noReceiverAssertions = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xno-param-assertions\",\n        description = \"Don't generate not-null assertions on parameters of methods accessible from Java.\"\n    )\n    var noParamAssertions = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(value = \"-Xno-optimize\", description = \"Disable optimizations.\")\n    var noOptimize = fals"}
{"code": "e\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xassertions\", valueDescription = \"{always-enable|always-disable|jvm|legacy}\",\n        description = \"\"\"'kotlin.assert' call behavior:\n-Xassertions=always-enable:  enable, ignore JVM assertion settings;\n-Xassertions=always-disable: disable, ignore JVM assertion settings;\n-Xassertions=jvm:            enable, depend on JVM assertion settings;\n-Xassertions=legacy:         calculate the condition on each call, the behavior depends on JVM assertion settings in the kotlin package;\ndefault: legacy\"\"\"\n    )\n    var assertionsMode: String? = JVMAssertionsMode.DEFAULT.description\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) JVMAssertionsMode.DEFAULT.description else value\n        }\n\n    @Argument(\n        value = \"-Xbuild-file\",\n        deprecatedName = \"-module\",\n        valueDescription = \"<path>\",\n        description = \"Path to "}
{"code": "the .xml build file to compile.\"\n    )\n    var buildFile: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n    @Argument(value = \"-Xmultifile-parts-inherit\", description = \"Compile multifile classes as a hierarchy of parts and a facade.\")\n    var inheritMultifileParts = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(value = \"-Xuse-type-table\", description = \"Use a type table in metadata serialization.\")\n    var useTypeTable = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xuse-old-class-files-reading\",\n        description = \"\"\"Use the old implementation for reading class files. This may slow down the compilation and cause problems with Groovy interop.\nThis can be used in the event of problems with the new implementation.\"\"\"\n    )\n    var useOldClassFilesReading = false\n"}
{"code": "        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xuse-fast-jar-file-system\",\n        description = \"Use the fast implementation of Jar FS. This may speed up compilation time, but it is experimental.\"\n    )\n    var useFastJarFileSystem = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xsuppress-missing-builtins-error\",\n        description = \"\"\"Suppress the \"cannot access built-in declaration\" error (useful with '-no-stdlib').\"\"\"\n    )\n    var suppressMissingBuiltinsError = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xscript-resolver-environment\",\n        valueDescription = \"<key=value[,]>\",\n        description = \"Set the script resolver environment in key-value pairs (the value can be quoted and escaped).\"\n    )\n    var scriptResolverEnvironment: Array<String>? = null\n"}
{"code": "        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    // Javac options\n    @Argument(value = \"-Xuse-javac\", description = \"Use javac for Java source and class file analysis.\")\n    var useJavac = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(value = \"-Xcompile-java\", description = \"Reuse 'javac' analysis and compile Java source files.\")\n    var compileJava = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xjavac-arguments\",\n        valueDescription = \"<option[,]>\",\n        description = \"Java compiler arguments.\"\n    )\n    var javacArguments: Array<String>? = null\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n\n    @Argument(\n        value = \"-Xjava-source-roots\",\n        valueDescription = \"<path>\",\n        description = \"Paths to directories with Java source files.\"\n    )\n    var java"}
{"code": "SourceRoots: Array<String>? = null\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xjava-package-prefix\",\n        description = \"Package prefix for Java files.\"\n    )\n    var javaPackagePrefix: String? = null\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xjsr305\",\n        deprecatedName = \"-Xjsr305-annotations\",\n        valueDescription = \"{ignore/strict/warn}\" +\n                \"|under-migration:{ignore/strict/warn}\" +\n                \"|@<fq.name>:{ignore/strict/warn}\",\n        description = \"\"\"Specify the behavior of 'JSR-305' nullability annotations:\n-Xjsr305={ignore/strict/warn}                   global (all non-@UnderMigration annotations)\n-Xjsr305=under-migration:{ignore/strict/warn}   all @UnderMigration annotations\n-Xjsr305=@<fq.name>:{ignore/strict/warn}        annotation with the given fully qualified class name\nModes:\n* ignore\n* strict ("}
{"code": "experimental; treat like other supported nullability annotations)\n* warn (report a warning)\"\"\"\n    )\n    var jsr305: Array<String>? = null\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xnullability-annotations\",\n        valueDescription = \"@<fq.name>:{ignore/strict/warn}\",\n        description = \"\"\"Specify the behavior for specific Java nullability annotations (provided with fully qualified package name).\nModes:\n* ignore\n* strict\n* warn (report a warning)\"\"\"\n    )\n    var nullabilityAnnotations: Array<String>? = null\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xsupport-compatqual-checker-framework-annotations\",\n        valueDescription = \"enable|disable\",\n        description = \"\"\"Specify the behavior for Checker Framework 'compatqual' annotations ('NullableDecl'/'NonNullDecl').\nThe default value is 'enable'.\"\"\"\n    )\n    var supportCompatqualChe"}
{"code": "ckerFrameworkAnnotations: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n    @Argument(\n        value = \"-Xjspecify-annotations\",\n        valueDescription = \"ignore|strict|warn\",\n        description = \"\"\"Specify the behavior of 'jspecify' annotations.\nThe default value is 'warn'.\"\"\"\n    )\n    var jspecifyAnnotations: String? = null\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xjvm-default\",\n        valueDescription = \"{all|all-compatibility|disable}\",\n        description = \"\"\"Emit JVM default methods for interface declarations with bodies. The default is 'disable'.\n-Xjvm-default=all                Generate JVM default methods for all interface declarations with bodies in the module.\n                                 Do not generate 'DefaultImpls' stubs for interface declarations with bodies. If an interface inherits a method wit"}
{"code": "h a\n                                 body from an interface compiled in 'disable' mode and doesn't override it, then a 'DefaultImpls' stub will be\n                                 generated for it.\n                                 This BREAKS BINARY COMPATIBILITY if some client code relies on the presence of 'DefaultImpls' classes.\n                                 Note that if interface delegation is used, all interface methods are delegated.\n-Xjvm-default=all-compatibility  Like 'all', but additionally generate compatibility stubs in the 'DefaultImpls' classes.\n                                 Compatibility stubs can help library and runtime authors maintain backward binary compatibility\n                                 for existing clients compiled against previous library versions.\n                                 'all' and 'all-compatibility' modes change the library ABI surface that will be used by clients after\n                                 the recompilation of the library. Be"}
{"code": "cause of this, clients might be incompatible with previous library\n                                 versions. This usually means that proper library versioning is required, for example with major version increases in SemVer.\n                                 In subtypes of Kotlin interfaces compiled in 'all' or 'all-compatibility' mode, 'DefaultImpls'\n                                 compatibility stubs will invoke the default method of the interface with standard JVM runtime resolution semantics.\n                                 Perform additional compatibility checks for classes inheriting generic interfaces where in some cases an\n                                 additional implicit method with specialized signatures was generated in 'disable' mode.\n                                 Unlike in 'disable' mode, the compiler will report an error if such a method is not overridden explicitly\n                                 and the class is not annotated with '@JvmDefaultWithoutCompatibilit"}
{"code": "y' (see KT-39603 for more details).\n-Xjvm-default=disable            Default behavior. Do not generate JVM default methods.\"\"\"\n    )\n    var jvmDefault: String = JvmDefaultMode.DISABLE.description\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xdefault-script-extension\",\n        valueDescription = \"<script filename extension>\",\n        description = \"Compile expressions and unrecognized scripts passed with the -script argument as scripts with the given filename extension.\"\n    )\n    var defaultScriptExtension: String? = null\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(value = \"-Xdisable-standard-script\", description = \"Disable standard Kotlin scripting support.\")\n    var disableStandardScript = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xgenerate-strict-metadata-version\",\n        descr"}
{"code": "iption = \"Generate metadata with strict version semantics (see the KDoc entry on 'Metadata.extraInt').\"\n    )\n    var strictMetadataVersionSemantics = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xsanitize-parentheses\",\n        description = \"\"\"Transform '(' and ')' in method names to some other character sequence.\nThis mode can BREAK BINARY COMPATIBILITY and should only be used as a workaround for\nproblems with parentheses in identifiers on certain platforms.\"\"\"\n    )\n    var sanitizeParentheses = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xfriend-paths\",\n        valueDescription = \"<path>\",\n        description = \"Paths to output directories for friend modules (modules whose internals should be visible).\"\n    )\n    var friendPaths: Array<String>? = null\n        set(value) {\n            checkFrozen()\n            field = value\n    "}
{"code": "    }\n\n    @Argument(\n        value = \"-Xallow-no-source-files\",\n        description = \"Allow the set of source files to be empty.\"\n    )\n    var allowNoSourceFiles = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xemit-jvm-type-annotations\",\n        description = \"Emit JVM type annotations in bytecode.\"\n    )\n    var emitJvmTypeAnnotations = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xstring-concat\",\n        valueDescription = \"{indy-with-constants|indy|inline}\",\n        description = \"\"\"Select the code generation scheme for string concatenation:\n-Xstring-concat=indy-with-constants  Concatenate strings using 'invokedynamic' and 'makeConcatWithConstants'. This requires '-jvm-target 9' or greater.\n-Xstring-concat=indy                 Concatenate strings using 'invokedynamic' and 'makeConcat'. This requires '-jvm-target 9' or greater."}
{"code": "\n-Xstring-concat=inline               Concatenate strings using 'StringBuilder'\ndefault: 'indy-with-constants' for JVM targets 9 or greater, 'inline' otherwise.\"\"\"\n\n    )\n    var stringConcat: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n    @Argument(\n        value = \"-Xjdk-release\",\n        valueDescription = \"<version>\",\n        description = \"\"\"Compile against the specified JDK API version, similarly to javac's '-release'. This requires JDK 9 or newer.\nThe supported versions depend on the JDK used; for JDK 17+, the supported versions are 1.8 and 9\u201322.\nThis also sets the value of '-jvm-target' to be equal to the selected JDK version.\"\"\"\n    )\n    var jdkRelease: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n\n    @Argument(\n        value = \"-Xsam-conversions\",\n        valueDescription = \"{class|indy}\",\n   "}
{"code": "     description = \"\"\"Select the code generation scheme for SAM conversions.\n-Xsam-conversions=indy          Generate SAM conversions using 'invokedynamic' with 'LambdaMetafactory.metafactory'. Requires '-jvm-target 1.8' or greater.\n-Xsam-conversions=class         Generate SAM conversions as explicit classes\"\"\"\n    )\n    var samConversions: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n    @Argument(\n        value = \"-Xlambdas\",\n        valueDescription = \"{class|indy}\",\n        description = \"\"\"Select the code generation scheme for lambdas.\n-Xlambdas=indy                  Generate lambdas using 'invokedynamic' with 'LambdaMetafactory.metafactory'. This requires '-jvm-target 1.8' or greater.\n                                A lambda object created using 'LambdaMetafactory.metafactory' will have a different 'toString()'.\n-Xlambdas=class                 Generate lambdas as explicit classes.\"\"\"\n    )\n"}
{"code": "    var lambdas: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n    @Argument(\n        value = \"-Xklib\",\n        valueDescription = \"<path>\",\n        description = \"Paths to cross-platform libraries in the .klib format.\"\n    )\n    var klibLibraries: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n    @Argument(\n        value = \"-Xno-optimized-callable-references\",\n        description = \"Don't use optimized callable reference superclasses, which have been available since 1.4.\"\n    )\n    var noOptimizedCallableReferences = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xno-kotlin-nothing-value-exception\",\n        description = \"Don't use KotlinNothingValueException, which has been available since 1.4.\"\n    )\n    var noKotlinNothingValueExc"}
{"code": "eption = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xno-reset-jar-timestamps\",\n        description = \"Don't reset jar entry timestamps to a fixed date.\"\n    )\n    var noResetJarTimestamps = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xno-unified-null-checks\",\n        description = \"Use pre-1.4 exception types instead of 'java.lang.NPE' in null checks. See KT-22275 for more details.\"\n    )\n    var noUnifiedNullChecks = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xno-source-debug-extension\",\n        description = \"Don't generate the '@kotlin.jvm.internal.SourceDebugExtension' annotation with an SMAP copy on classes.\"\n    )\n    var noSourceDebugExtension = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argum"}
{"code": "ent(\n        value = \"-Xprofile\",\n        valueDescription = \"<profilerPath:command:outputDir>\",\n        description = \"\"\"Debug option: Run the compiler with the async profiler and save snapshots to `outputDir`; `command` is passed to the async profiler on start.\n`profilerPath` is the path to libasyncProfiler.so; async-profiler.jar should be on the compiler classpath.\nIf it's not on the classpath, the compiler will attempt to load async-profiler.jar from the containing directory of profilerPath.\nExample: -Xprofile=<PATH_TO_ASYNC_PROFILER>/async-profiler/build/libasyncProfiler.so:event=cpu,interval=1ms,threads,start:<SNAPSHOT_DIR_PATH>\"\"\"\n    )\n    var profileCompilerCommand: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n    @Argument(\n        value = \"-Xrepeat\",\n        valueDescription = \"<number>\",\n        description = \"Debug option: Repeat module compilation <number> times.\"\n    )\n    var repe"}
{"code": "atCompileModules: String? = null\n        set(value) {\n            checkFrozen()\n            field = if (value.isNullOrEmpty()) null else value\n        }\n\n    @Argument(\n        value = \"-Xuse-14-inline-classes-mangling-scheme\",\n        description = \"Use the scheme for inline class mangling from version 1.4 instead of the one from 1.4.30.\"\n    )\n    var useOldInlineClassesManglingScheme = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xjvm-enable-preview\",\n        description = \"\"\"Allow using Java features that are in the preview phase.\nThis works like '--enable-preview' in Java. All class files are marked as compiled with preview features, meaning it won't be possible to use them in release environments.\"\"\"\n    )\n    var enableJvmPreview = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xsuppress-deprecated-jvm-target-warning\",\n        "}
{"code": "description = \"\"\"Suppress warnings about deprecated JVM target versions.\nThis option has no effect and will be deleted in a future version.\"\"\"\n    )\n    var suppressDeprecatedJvmTargetWarning = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xtype-enhancement-improvements-strict-mode\",\n        description = \"\"\"Enable strict mode for improvements to type enhancement for loaded Java types based on nullability annotations,\nincluding the ability to read type-use annotations from class files.\nSee KT-45671 for more details.\"\"\"\n    )\n    var typeEnhancementImprovementsInStrictMode = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xserialize-ir\",\n        valueDescription = \"{none|inline|all}\",\n        description = \"Save the IR to metadata (Experimental).\"\n    )\n    var serializeIr: String = \"none\"\n        set(value) {\n            checkFrozen()\n "}
{"code": "           field = value\n        }\n\n    @Argument(\n        value = \"-Xvalidate-ir\",\n        description = \"Validate IR before and after lowering.\"\n    )\n    var validateIr = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xvalidate-bytecode\",\n        description = \"Validate generated JVM bytecode before and after optimizations.\"\n    )\n    var validateBytecode = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xenhance-type-parameter-types-to-def-not-null\",\n        description = \"Enhance not-null-annotated type parameter types to definitely-non-nullable types ('@NotNull T' => 'T & Any').\"\n    )\n    var enhanceTypeParameterTypesToDefNotNull = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xlink-via-signatures\",\n        description = \"\"\"Link JVM IR symbols via signatu"}
{"code": "res instead of descriptors.\nThis mode is slower, but it can be useful for troubleshooting problems with the JVM IR backend.\nThis option is deprecated and will be deleted in future versions.\nIt has no effect when -language-version is 2.0 or higher.\"\"\"\n    )\n    var linkViaSignatures = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xdebug\",\n        description = \"\"\"Enable debug mode for compilation.\nCurrently this includes spilling all variables in a suspending context regardless of whether they are alive.\"\"\"\n    )\n    var enableDebugMode = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xno-new-java-annotation-targets\",\n        description = \"Don't generate Java 1.8+ targets for Kotlin annotation classes.\"\n    )\n    var noNewJavaAnnotationTargets = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n "}
{"code": "   @Argument(\n        value = \"-Xuse-old-innerclasses-logic\",\n        description = \"\"\"Use the old logic for the generation of 'InnerClasses' attributes.\nThis option is deprecated and will be deleted in future versions.\"\"\"\n    )\n    var oldInnerClassesLogic = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xvalue-classes\",\n        description = \"Enable experimental value classes.\"\n    )\n    var valueClasses = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xir-inliner\",\n        description = \"Inline functions using the IR inliner instead of the bytecode inliner.\"\n    )\n    var enableIrInliner: Boolean = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xuse-inline-scopes-numbers\",\n        description = \"Use inline scopes numbers for inline marker variables.\"\n    )\n  "}
{"code": "  var useInlineScopesNumbers: Boolean = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    @Argument(\n        value = \"-Xuse-kapt4\",\n        description = \"Enable the experimental KAPT 4.\"\n    )\n    var useKapt4 = false\n        set(value) {\n            checkFrozen()\n            field = value\n        }\n\n    override fun configureAnalysisFlags(collector: MessageCollector, languageVersion: LanguageVersion): MutableMap<AnalysisFlag<*>, Any> {\n        val result = super.configureAnalysisFlags(collector, languageVersion)\n        result[JvmAnalysisFlags.strictMetadataVersionSemantics] = strictMetadataVersionSemantics\n        result[JvmAnalysisFlags.javaTypeEnhancementState] = JavaTypeEnhancementStateParser(collector, languageVersion.toKotlinVersion())\n            .parse(jsr305, supportCompatqualCheckerFrameworkAnnotations, jspecifyAnnotations, nullabilityAnnotations)\n        result[AnalysisFlags.ignoreDataFlowInAssert] = JVMAssertionsMode.fromString("}
{"code": "assertionsMode) != JVMAssertionsMode.LEGACY\n        JvmDefaultMode.fromStringOrNull(jvmDefault)?.let {\n            result[JvmAnalysisFlags.jvmDefaultMode] = it\n        } ?: collector.report(\n            CompilerMessageSeverity.ERROR,\n            \"Unknown -Xjvm-default mode: $jvmDefault, supported modes: ${JvmDefaultMode.entries.map(JvmDefaultMode::description)}\"\n        )\n        result[JvmAnalysisFlags.inheritMultifileParts] = inheritMultifileParts\n        result[JvmAnalysisFlags.sanitizeParentheses] = sanitizeParentheses\n        result[JvmAnalysisFlags.suppressMissingBuiltinsError] = suppressMissingBuiltinsError\n        result[JvmAnalysisFlags.enableJvmPreview] = enableJvmPreview\n        result[AnalysisFlags.allowUnstableDependencies] = allowUnstableDependencies\n        result[JvmAnalysisFlags.useIR] = !useOldBackend\n        return result\n    }\n\n    override fun configureLanguageFeatures(collector: MessageCollector): MutableMap<LanguageFeature, LanguageFeature.State> {\n        val re"}
{"code": "sult = super.configureLanguageFeatures(collector)\n        if (typeEnhancementImprovementsInStrictMode) {\n            result[LanguageFeature.TypeEnhancementImprovementsInStrictMode] = LanguageFeature.State.ENABLED\n        }\n        if (enhanceTypeParameterTypesToDefNotNull) {\n            result[LanguageFeature.ProhibitUsingNullableTypeParameterAgainstNotNullAnnotated] = LanguageFeature.State.ENABLED\n        }\n        if (JvmDefaultMode.fromStringOrNull(jvmDefault)?.isEnabled == true) {\n            result[LanguageFeature.ForbidSuperDelegationToAbstractFakeOverride] = LanguageFeature.State.ENABLED\n            result[LanguageFeature.AbstractClassMemberNotImplementedWithIntermediateAbstractClass] = LanguageFeature.State.ENABLED\n        }\n        if (valueClasses) {\n            result[LanguageFeature.ValueClasses] = LanguageFeature.State.ENABLED\n        }\n        return result\n    }\n\n    override fun defaultLanguageVersion(collector: MessageCollector): LanguageVersion =\n        if (useOldBac"}
{"code": "kend) {\n            if (!suppressVersionWarnings) {\n                collector.report(\n                    CompilerMessageSeverity.STRONG_WARNING,\n                    \"Language version is automatically inferred to ${LanguageVersion.KOTLIN_1_5.versionString} when using \" +\n                            \"the old JVM backend. Consider specifying -language-version explicitly, or remove -Xuse-old-backend\"\n                )\n            }\n            LanguageVersion.KOTLIN_1_5\n        } else super.defaultLanguageVersion(collector)\n\n    override fun checkPlatformSpecificSettings(languageVersionSettings: LanguageVersionSettings, collector: MessageCollector) {\n        if (useOldBackend && languageVersionSettings.languageVersion >= LanguageVersion.KOTLIN_1_6) {\n            collector.report(\n                CompilerMessageSeverity.ERROR,\n                \"Old JVM backend does not support language version 1.6 or above. \" +\n                        \"Please use language version 1.5 or below, or remove -Xu"}
{"code": "se-old-backend\"\n            )\n        }\n        if (oldInnerClassesLogic) {\n            collector.report(\n                CompilerMessageSeverity.WARNING,\n                \"The -Xuse-old-innerclasses-logic option is deprecated and will be deleted in future versions.\"\n            )\n        }\n    }\n\n    override fun copyOf(): Freezable = copyK2JVMCompilerArguments(this, K2JVMCompilerArguments())\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental.storage\n\nimport com.intellij.util.containers.hash.EqualityPolicy\nimport com.intellij.util.io.DataExternalizer\nimport com.intellij.util.io.IOUtil\nimport com.intellij.util.io.KeyDescriptor\nimport org.jetbrains.kotlin.inline.InlineFunction\nimport org.jetbrains.kotlin.inline.InlineFunctionOrAccessor\nimport org.jetbrains.kotlin.inline.InlinePropertyAccessor\nimport org.jetbrains.kotlin.metadata.jvm.deserialization.JvmMemberSignature\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.resolve.jvm.JvmClassName\nimport java.io.*\n\nclass DefaultEqualityPolicy<T> : EqualityPolicy<T> {\n    override fun getHashCode(value: T): Int = value.hashCode()\n    override fun isEqual(value1: T, value2: T): Boolean = (value1 == value2)\n}\n\nfun <T> DataExternalizer<T>.toDescriptor(): KeyDescriptor<T> =\n    object : KeyDescriptor<T>,\n        DataExternalizer<T> by this,\n        EqualityPolicy<T> by DefaultEqualityPol"}
{"code": "icy<T>() {\n    }\n\nclass LookupSymbolKeyDescriptor(\n    \n    private val storeFullFqNames: Boolean = false\n) : KeyDescriptor<LookupSymbolKey>, EqualityPolicy<LookupSymbolKey> by DefaultEqualityPolicy() {\n\n    override fun read(input: DataInput): LookupSymbolKey {\n        // Note: The value of the storeFullFqNames variable below may or may not be the same as LookupSymbolKeyDescriptor.storeFullFqNames.\n        // Byte value `0` means storeFullFqNames == true, see `save` function below.\n        val storeFullFqNames = when (val byteValue = input.readByte().toInt()) {\n            0 -> true\n            1 -> false\n            else -> error(\"Unexpected byte value for storeFullFqNames: $byteValue\")\n        }\n        return if (storeFullFqNames) {\n            val name = input.readUTF()\n            val scope = input.readUTF()\n            LookupSymbolKey(name.hashCode(), scope.hashCode(), name, scope)\n        } else {\n            val nameHash = input.readInt()\n            val scopeHash = input.read"}
{"code": "Int()\n            LookupSymbolKey(nameHash, scopeHash, \"\", \"\")\n        }\n    }\n\n    override fun save(output: DataOutput, value: LookupSymbolKey) {\n        // Write a Byte value `0` to represent storeFullFqNames == true for historical reasons (if we switch this value to `1` or write a\n        // Boolean instead, it might impact some tests).\n        output.writeByte(if (storeFullFqNames) 0 else 1)\n        if (storeFullFqNames) {\n            output.writeUTF(value.name)\n            output.writeUTF(value.scope)\n        } else {\n            output.writeInt(value.nameHash)\n            output.writeInt(value.scopeHash)\n        }\n    }\n}\n\nobject FqNameExternalizer : DataExternalizer<FqName> {\n\n    override fun save(output: DataOutput, fqName: FqName) {\n        output.writeString(fqName.asString())\n    }\n\n    override fun read(input: DataInput): FqName {\n        return FqName(input.readString())\n    }\n}\n\nobject ClassIdExternalizer : DataExternalizer<ClassId> {\n\n    override fun save(output: Data"}
{"code": "Output, classId: ClassId) {\n        FqNameExternalizer.save(output, classId.packageFqName)\n        FqNameExternalizer.save(output, classId.relativeClassName)\n        output.writeBoolean(classId.isLocal)\n    }\n\n    override fun read(input: DataInput): ClassId {\n        return ClassId(\n            packageFqName = FqNameExternalizer.read(input),\n            relativeClassName = FqNameExternalizer.read(input),\n            isLocal = input.readBoolean()\n        )\n    }\n}\n\nobject JvmClassNameExternalizer : DataExternalizer<JvmClassName> {\n\n    override fun save(output: DataOutput, jvmClassName: JvmClassName) {\n        output.writeString(jvmClassName.internalName)\n    }\n\n    override fun read(input: DataInput): JvmClassName {\n        return JvmClassName.byInternalName(input.readString())\n    }\n}\n\nobject ProtoMapValueExternalizer : DataExternalizer<ProtoMapValue> {\n    override fun save(output: DataOutput, value: ProtoMapValue) {\n        output.writeBoolean(value.isPackageFacade)\n        output."}
{"code": "writeInt(value.bytes.size)\n        output.write(value.bytes)\n        output.writeInt(value.strings.size)\n\n        for (string in value.strings) {\n            output.writeUTF(string)\n        }\n    }\n\n    override fun read(input: DataInput): ProtoMapValue {\n        val isPackageFacade = input.readBoolean()\n        val bytesLength = input.readInt()\n        val bytes = ByteArray(bytesLength)\n        input.readFully(bytes, 0, bytesLength)\n        val stringsLength = input.readInt()\n        val strings = Array<String>(stringsLength) { input.readUTF() }\n        return ProtoMapValue(isPackageFacade, bytes, strings)\n    }\n}\n\nabstract class StringMapExternalizer<T> : DataExternalizer<Map<String, T>> {\n    override fun save(output: DataOutput, map: Map<String, T>?) {\n        output.writeInt(map!!.size)\n\n        for ((key, value) in map.entries) {\n            output.writeString(key)\n            writeValue(output, value)\n        }\n    }\n\n    override fun read(input: DataInput): Map<String, T>? {\n  "}
{"code": "      val size = input.readInt()\n        val map = HashMap<String, T>(size)\n\n        repeat(size) {\n            val name = input.readString()\n            map[name] = readValue(input)\n        }\n\n        return map\n    }\n\n    protected abstract fun writeValue(output: DataOutput, value: T)\n    protected abstract fun readValue(input: DataInput): T\n}\n\nobject StringToLongMapExternalizer : StringMapExternalizer<Long>() {\n    override fun readValue(input: DataInput): Long = input.readLong()\n\n    override fun writeValue(output: DataOutput, value: Long) {\n        output.writeLong(value)\n    }\n}\n\nfun <T> DataExternalizer<T>.saveToFile(file: File, value: T) {\n    return DataOutputStream(FileOutputStream(file).buffered()).use {\n        save(it, value)\n    }\n}\n\nfun <T> DataExternalizer<T>.loadFromFile(file: File): T {\n    return DataInputStream(FileInputStream(file).buffered()).use {\n        read(it)\n    }\n}\n\nfun <T> DataExternalizer<T>.toByteArray(value: T): ByteArray {\n    val byteArrayOutputStrea"}
{"code": "m = ByteArrayOutputStream()\n    DataOutputStream(byteArrayOutputStream.buffered()).use {\n        save(it, value)\n    }\n    return byteArrayOutputStream.toByteArray()\n}\n\nfun <T> DataExternalizer<T>.fromByteArray(byteArray: ByteArray): T {\n    return DataInputStream(ByteArrayInputStream(byteArray).buffered()).use {\n        read(it)\n    }\n}\n\nobject IntExternalizer : DataExternalizer<Int> {\n    override fun save(output: DataOutput, value: Int) = output.writeInt(value)\n    override fun read(input: DataInput): Int = input.readInt()\n}\n\nobject LongExternalizer : DataExternalizer<Long> {\n    override fun save(output: DataOutput, value: Long) = output.writeLong(value)\n    override fun read(input: DataInput): Long = input.readLong()\n}\n\nobject FloatExternalizer : DataExternalizer<Float> {\n    override fun save(output: DataOutput, value: Float) = output.writeFloat(value)\n    override fun read(input: DataInput): Float = input.readFloat()\n}\n\nobject DoubleExternalizer : DataExternalizer<Double> {\n    "}
{"code": "override fun save(output: DataOutput, value: Double) = output.writeDouble(value)\n    override fun read(input: DataInput): Double = input.readDouble()\n}\n\nobject StringExternalizer : DataExternalizer<String> {\n    override fun save(output: DataOutput, value: String) = IOUtil.writeString(value, output)\n    override fun read(input: DataInput): String = IOUtil.readString(input)\n}\n\n\nclass DelegateDataExternalizer<T>(\n    val types: List<Class<out T>>,\n    val typesExternalizers: List<DataExternalizer<out T>>\n) : DataExternalizer<T> {\n\n    init {\n        check(types.size == typesExternalizers.size)\n        check(types.size < Byte.MAX_VALUE) // We will writeByte(index), so we need lastIndex (types.size - 1) <= Byte.MAX_VALUE\n    }\n\n    override fun save(output: DataOutput, objectToExternalize: T) {\n        val type = types.single { it.isAssignableFrom(objectToExternalize!!::class.java) }\n        val typeIndex = types.indexOf(type)\n\n        output.writeByte(typeIndex)\n        @Suppress(\"UNCHECK"}
{"code": "ED_CAST\")\n        (typesExternalizers[typeIndex] as DataExternalizer<T>).save(output, objectToExternalize)\n    }\n\n    override fun read(input: DataInput): T {\n        val typeIndex = input.readByte().toInt()\n        return typesExternalizers[typeIndex].read(input)\n    }\n}\n\nfun DataOutput.writeString(value: String) = StringExternalizer.save(this, value)\n\nfun DataInput.readString(): String = StringExternalizer.read(this)\n\nclass NullableValueExternalizer<T>(private val valueExternalizer: DataExternalizer<T>) : DataExternalizer<T> {\n\n    override fun save(output: DataOutput, value: T?) {\n        output.writeBoolean(value != null)\n        value?.let {\n            valueExternalizer.save(output, it)\n        }\n    }\n\n    override fun read(input: DataInput): T? {\n        return if (input.readBoolean()) {\n            valueExternalizer.read(input)\n        } else null\n    }\n}\n\nobject ByteArrayExternalizer : DataExternalizer<ByteArray> {\n\n    override fun save(output: DataOutput, bytes: ByteArray) "}
{"code": "{\n        output.writeInt(bytes.size)\n        output.write(bytes)\n    }\n\n    override fun read(input: DataInput): ByteArray {\n        val size = input.readInt()\n        return ByteArray(size).also {\n            input.readFully(it, 0, size)\n        }\n    }\n}\n\n\nprivate class CollectionExternalizerForPersistentHashMap<T>(\n    private val elementExternalizer: DataExternalizer<T>,\n    private val newCollection: () -> MutableCollection<T>,\n) : DataExternalizer<Collection<T>> {\n\n    override fun save(output: DataOutput, value: Collection<T>) {\n        value.forEach { elementExternalizer.save(output, it) }\n    }\n\n    override fun read(input: DataInput): Collection<T> {\n        val result = newCollection()\n        val stream = input as DataInputStream\n\n        while (stream.available() > 0) {\n            result.add(elementExternalizer.read(stream))\n        }\n\n        return result\n    }\n}\n\n\nclass CollectionExternalizer<T>(\n    private val elementExternalizer: DataExternalizer<T>,\n    private va"}
{"code": "l newCollection: () -> MutableCollection<T>,\n) : DataExternalizer<Collection<T>> by CollectionExternalizerForPersistentHashMap(elementExternalizer, newCollection)\n\n\n@Suppress(\"unused\") // See `CollectionExternalizer`\nobject IntCollectionExternalizer :\n    DataExternalizer<Collection<Int>> by CollectionExternalizerForPersistentHashMap(IntExternalizer, { ArrayList() })\n\n\nopen class CollectionExternalizerV2<T, C : Collection<T>>(\n    private val elementExternalizer: DataExternalizer<T>,\n    private val newCollection: (size: Int) -> MutableCollection<T> = { size -> ArrayList(size) },\n) : DataExternalizer<C> {\n\n    override fun save(output: DataOutput, collection: C) {\n        output.writeInt(collection.size)\n        collection.forEach {\n            elementExternalizer.save(output, it)\n        }\n    }\n\n    override fun read(input: DataInput): C {\n        val size = input.readInt()\n        val collection = newCollection(size)\n        repeat(size) {\n            collection.add(elementExternali"}
{"code": "zer.read(input))\n        }\n        // We want `collection` to be both a mutable collection (so we can add elements to it as done above) and a type that can be safely\n        // converted to type `C` (to be used as the returned value of this method). However, there is no type-safe way to express that, so\n        // we have to use this unsafe cast.\n        @Suppress(\"UNCHECKED_CAST\")\n        return collection as C\n    }\n}\n\nclass ListExternalizer<T>(elementExternalizer: DataExternalizer<T>) :\n    CollectionExternalizerV2<T, List<T>>(elementExternalizer, { size -> ArrayList(size) })\n\nclass SetExternalizer<T>(elementExternalizer: DataExternalizer<T>) :\n    CollectionExternalizerV2<T, Set<T>>(elementExternalizer, { size -> LinkedHashSet(size) })\n\nopen class MapExternalizer<K, V, M : Map<K, V>>(\n    private val keyExternalizer: DataExternalizer<K>,\n    private val valueExternalizer: DataExternalizer<V>,\n    private val newMap: (size: Int) -> MutableMap<K, V> = { size -> LinkedHashMap(size) }\n"}
{"code": ") : DataExternalizer<M> {\n\n    override fun save(output: DataOutput, map: M) {\n        output.writeInt(map.size)\n        for ((key, value) in map) {\n            keyExternalizer.save(output, key)\n            valueExternalizer.save(output, value)\n        }\n    }\n\n    override fun read(input: DataInput): M {\n        val size = input.readInt()\n        val map = newMap(size)\n        repeat(size) {\n            val key = keyExternalizer.read(input)\n            val value = valueExternalizer.read(input)\n            map[key] = value\n        }\n        @Suppress(\"UNCHECKED_CAST\")\n        return map as M\n    }\n}\n\nclass LinkedHashMapExternalizer<K, V>(\n    keyExternalizer: DataExternalizer<K>,\n    valueExternalizer: DataExternalizer<V>\n) : MapExternalizer<K, V, LinkedHashMap<K, V>>(keyExternalizer, valueExternalizer, { size -> LinkedHashMap(size) })\n\nobject JvmMethodSignatureExternalizer : DataExternalizer<JvmMemberSignature.Method> {\n\n    override fun save(output: DataOutput, method: JvmMemberSigna"}
{"code": "ture.Method) {\n        StringExternalizer.save(output, method.name)\n        StringExternalizer.save(output, method.desc)\n    }\n\n    override fun read(input: DataInput): JvmMemberSignature.Method {\n        return JvmMemberSignature.Method(\n            name = StringExternalizer.read(input),\n            desc = StringExternalizer.read(input)\n        )\n    }\n}\n\nobject InlineFunctionOrAccessorExternalizer : DataExternalizer<InlineFunctionOrAccessor> by DelegateDataExternalizer(\n    types = listOf(InlineFunction::class.java, InlinePropertyAccessor::class.java),\n    typesExternalizers = listOf(InlineFunctionExternalizer, InlinePropertyAccessorExternalizer)\n)\n\nprivate object InlineFunctionExternalizer : DataExternalizer<InlineFunction> {\n\n    override fun save(output: DataOutput, function: InlineFunction) {\n        JvmMethodSignatureExternalizer.save(output, function.jvmMethodSignature)\n        StringExternalizer.save(output, function.kotlinFunctionName)\n    }\n\n    override fun read(input: Data"}
{"code": "Input): InlineFunction {\n        return InlineFunction(\n            jvmMethodSignature = JvmMethodSignatureExternalizer.read(input),\n            kotlinFunctionName = StringExternalizer.read(input)\n        )\n    }\n}\n\nprivate object InlinePropertyAccessorExternalizer : DataExternalizer<InlinePropertyAccessor> {\n\n    override fun save(output: DataOutput, accessor: InlinePropertyAccessor) {\n        JvmMethodSignatureExternalizer.save(output, accessor.jvmMethodSignature)\n        StringExternalizer.save(output, accessor.propertyName)\n    }\n\n    override fun read(input: DataInput): InlinePropertyAccessor {\n        return InlinePropertyAccessor(\n            jvmMethodSignature = JvmMethodSignatureExternalizer.read(input),\n            propertyName = StringExternalizer.read(input)\n        )\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.lightTree.converter\n\nimport com.intellij.lang.LighterASTNode\nimport com.intellij.openapi.util.Ref\nimport com.intellij.psi.TokenType\nimport com.intellij.psi.tree.IElementType\nimport com.intellij.util.diff.FlyweightCapableTreeStructure\nimport org.jetbrains.kotlin.*\nimport org.jetbrains.kotlin.ElementTypeUtils.isExpression\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.builder.AbstractRawFirBuilder\nimport org.jetbrains.kotlin.fir.builder.Context\nimport org.jetbrains.kotlin.fir.builder.escapedStringToCharacter\nimport org.jetbrains.kotlin.fir.types.impl.FirImplicitTypeRefImplWithoutSource\nimport org.jetbrains.kotlin.lexer.KtToken\nimport org.jetbrains.kotlin.lexer.KtTokens.*\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtPsiUtil.unquoteIdentifier\n\nabstract class AbstractLightTreeRawFirBuilder(\n    baseSession: FirSession,\n    val tree: FlyweightCapableTreeStructure<LighterASTNode>,\n    context: Context<Li"}
{"code": "ghterASTNode> = Context()\n) : AbstractRawFirBuilder<LighterASTNode>(baseSession, context) {\n    protected val implicitType = FirImplicitTypeRefImplWithoutSource\n\n    override fun LighterASTNode.toFirSourceElement(kind: KtFakeSourceElementKind?): KtLightSourceElement {\n        val startOffset = tree.getStartOffset(this)\n        val endOffset = tree.getEndOffset(this)\n        return toKtLightSourceElement(tree, kind ?: KtRealSourceElementKind, startOffset, endOffset)\n    }\n\n    override val LighterASTNode.elementType: IElementType\n        get() = this.tokenType\n\n    override val LighterASTNode.asText: String\n        get() = this.toString()\n\n    override val LighterASTNode.unescapedValue: String\n        get() {\n            val escape = this.asText\n            return escapedStringToCharacter(escape).value?.toString()\n                ?: escape.replace(\"\\\\\", \"\").replace(\"u\", \"\\\\u\")\n        }\n\n    override fun LighterASTNode.getReferencedNameAsName(): Name {\n        return this.asText.nameAsS"}
{"code": "afeName()\n    }\n\n    override fun LighterASTNode.getLabelName(): String? {\n        if (tokenType == KtNodeTypes.FUN) {\n            return getParent()?.getLabelName()\n        }\n        this.forEachChildren {\n            when (it.tokenType) {\n                KtNodeTypes.LABEL_QUALIFIER -> return it.asText.replaceFirst(\"@\", \"\").let(::unquoteIdentifier)\n            }\n        }\n\n        return null\n    }\n\n    override fun LighterASTNode.getExpressionInParentheses() = getFirstChildExpression()\n\n    override fun LighterASTNode.getAnnotatedExpression() = getFirstChildExpression()\n\n    override fun LighterASTNode.getLabeledExpression() = getLastChildExpression()\n\n    fun LighterASTNode.getChildExpression() = getFirstChildExpression()\n\n    private fun LighterASTNode.getFirstChildExpression(): LighterASTNode? {\n        forEachChildren {\n            if (it.isExpression()) return it\n        }\n\n        return null\n    }\n\n    protected fun LighterASTNode.getFirstChildExpressionUnwrapped(): LighterAST"}
{"code": "Node? {\n        val expression = getFirstChildExpression() ?: return null\n        return if (expression.tokenType == KtNodeTypes.PARENTHESIZED) {\n            expression.getFirstChildExpressionUnwrapped()\n        } else {\n            expression\n        }\n    }\n\n    fun LighterASTNode.getLastChildExpression(): LighterASTNode? {\n        var result: LighterASTNode? = null\n        forEachChildren {\n            if (it.isExpression()) {\n                result = it\n            }\n        }\n\n        return result\n    }\n\n    override fun LighterASTNode.getChildNodeByType(type: IElementType): LighterASTNode? {\n        return getChildrenAsArray().firstOrNull { it?.tokenType == type }\n    }\n\n    override val LighterASTNode?.receiverExpression: LighterASTNode?\n        get() {\n            var candidate: LighterASTNode? = null\n            this?.forEachChildren {\n                when (it.tokenType) {\n                    DOT, SAFE_ACCESS -> return if (candidate?.elementType != TokenType.ERROR_ELEMENT) ca"}
{"code": "ndidate else null\n                    else -> candidate = it\n                }\n            }\n            return null\n        }\n\n    override val LighterASTNode?.selectorExpression: LighterASTNode?\n        get() {\n            var isSelector = false\n            this?.forEachChildren {\n                when (it.tokenType) {\n                    DOT, SAFE_ACCESS -> isSelector = true\n                    else -> if (isSelector) return if (it.elementType != TokenType.ERROR_ELEMENT) it else null\n                }\n            }\n            return null\n        }\n\n    override val LighterASTNode?.arrayExpression: LighterASTNode?\n        get() = this?.getFirstChildExpression()\n\n    override val LighterASTNode?.indexExpressions: List<LighterASTNode>?\n        get() = this?.getLastChildExpression()?.getChildrenAsArray()?.filterNotNull()?.filter { it.isExpression() }\n\n    override val LighterASTNode.isVararg: Boolean\n        get() = getChildNodeByType(KtNodeTypes.MODIFIER_LIST)?.getChildNodeByType(VARAR"}
{"code": "G_KEYWORD) != null\n\n    fun LighterASTNode.getParent(): LighterASTNode? {\n        return tree.getParent(this)\n    }\n\n    fun LighterASTNode?.getChildNodesByType(type: IElementType): List<LighterASTNode> {\n        return this?.forEachChildrenReturnList { node, container ->\n            when (node.tokenType) {\n                type -> container += node\n            }\n        } ?: emptyList()\n    }\n\n    fun LighterASTNode?.getChildrenAsArray(): Array<out LighterASTNode?> {\n        if (this == null) return arrayOf()\n\n        val kidsRef = Ref<Array<LighterASTNode?>>()\n        tree.getChildren(this, kidsRef)\n        return kidsRef.get()\n    }\n\n    fun LighterASTNode?.getFirstChild(): LighterASTNode? {\n        return getChildrenAsArray().firstOrNull()\n    }\n\n    protected inline fun LighterASTNode.forEachChildren(vararg skipTokens: KtToken, f: (LighterASTNode) -> Unit) {\n        val kidsArray = this.getChildrenAsArray()\n        for (kid in kidsArray) {\n            if (kid == null) break\n       "}
{"code": "     val tokenType = kid.tokenType\n            if (COMMENTS.contains(tokenType) || tokenType == WHITE_SPACE || tokenType == SEMICOLON || tokenType in skipTokens || tokenType == TokenType.ERROR_ELEMENT) continue\n            f(kid)\n        }\n    }\n\n    protected inline fun <T> LighterASTNode.forEachChildrenReturnList(f: (LighterASTNode, MutableList<T>) -> Unit): List<T> {\n        val kidsArray = this.getChildrenAsArray()\n\n        val container = mutableListOf<T>()\n        for (kid in kidsArray) {\n            if (kid == null) break\n            val tokenType = kid.tokenType\n            if (COMMENTS.contains(tokenType) || tokenType == WHITE_SPACE || tokenType == SEMICOLON || tokenType == TokenType.ERROR_ELEMENT) continue\n            f(kid, container)\n        }\n\n        return container\n    }\n}\n"}
{"code": "// FILE: MyAnno.kt\n@Target(AnnotationTarget.TYPE)\nannotation class MyAnno(val s: String)\n\n// FILE: JavaClass.java\n\nclass JavaClass {\n    void materialize(@MyAnno(\"outer type\") List<@MyAnno(\"middle\") List<@MyAnno(\"nested\") String>> @MyAnno(\"array\") [] va<caret>lues) {}\n}\n"}
{"code": "package second\n\nopen class Base<T>\n\nclass MyCla<caret>ss() : Base<Base<Int>>() {\n    open class Base<T>\n}\n"}
{"code": "val x = <expr>\"string\"</expr>"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve\n\nimport com.google.common.collect.Maps\nimport com.google.common.collect.Sets\nimport com.intellij.psi.PsiElement\nimport com.intellij.util.SmartList\nimport com.intellij.util.containers.ContainerUtil\nimport com.intellij.util.containers.SmartHashSet\nimport org.jetbrains.kotlin.config.LanguageFeature.AbstractClassMemberNotImplementedWithIntermediateAbstractClass\nimport org.jetbrains.kotlin.config.LanguageVersionSettings\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind.DELEGATION\nimport org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind.FAKE_OVERRIDE\nimport org.jetbrains.kotlin.descriptors.DescriptorVisibilityUtils.useSpecialRulesForPrivateSealedConstructors\nimport org.jetbrains.kotlin.diagnostics.DiagnosticFactory2\nimport org.jetbrains.kotlin.diagnostics.DiagnosticFactoryWithPsiElement\nimport org.jetbrains.kotlin.diagnostics.Errors.*\nimport org.jetbrains.kotlin.diagnostics.rende"}
{"code": "ring.DeclarationWithDiagnosticComponents\nimport org.jetbrains.kotlin.incremental.components.NoLookupLocation\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.platform.PlatformSpecificDiagnosticComponents\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.resolve.DescriptorUtils.classCanHaveAbstractFakeOverride\nimport org.jetbrains.kotlin.resolve.OverridingUtil.OverrideCompatibilityInfo.Result.OVERRIDABLE\nimport org.jetbrains.kotlin.resolve.calls.util.isOrOverridesSynthesized\nimport org.jetbrains.kotlin.types.*\nimport org.jetbrains.kotlin.types.checker.KotlinTypeRefiner\nimport org.jetbrains.kotlin.types.checker.NewKotlinTypeCheckerImpl\nimport java.util.*\n\nclass OverrideResolver(\n    private val trace: BindingTrace,\n    private val overridesBackwardCompatibilityHelper: OverridesBackwardCompatibilityHelper,\n    private val languageVersionSettings: LanguageVersionSettings,\n    private val kotlinTypeRefiner: KotlinTypeRefiner,\n    private val platformSpecifi"}
{"code": "cDiagnosticComponents: PlatformSpecificDiagnosticComponents\n) {\n\n    fun check(c: TopDownAnalysisContext) {\n        checkVisibility(c)\n        checkOverrides(c)\n        checkParameterOverridesForAllClasses(c)\n    }\n\n\n    private fun checkOverrides(c: TopDownAnalysisContext) {\n        for ((key, value) in c.declaredClasses) {\n            checkOverridesInAClass(value, key)\n        }\n    }\n\n    private fun checkOverridesInAClass(classDescriptor: ClassDescriptorWithResolutionScopes, klass: KtClassOrObject) {\n        // Check overrides for internal consistency\n        for (member in classDescriptor.declaredCallableMembers) {\n            checkOverrideForMember(member)\n        }\n\n        val inheritedMemberErrors = CollectErrorInformationForInheritedMembersStrategy(klass, classDescriptor)\n\n        checkInheritedAndDelegatedSignatures(classDescriptor, inheritedMemberErrors, inheritedMemberErrors, kotlinTypeRefiner)\n        inheritedMemberErrors.doReportErrors()\n    }\n\n    private interface Che"}
{"code": "ckInheritedSignaturesReportStrategy {\n        fun abstractMemberNotImplemented(descriptor: CallableMemberDescriptor)\n        fun abstractBaseClassMemberNotImplemented(descriptor: CallableMemberDescriptor)\n        fun abstractMemberWithMoreSpecificType(abstractMember: CallableMemberDescriptor, concreteMember: CallableMemberDescriptor)\n        fun multipleImplementationsMemberNotImplemented(descriptor: CallableMemberDescriptor)\n        fun conflictingInterfaceMemberNotImplemented(descriptor: CallableMemberDescriptor)\n        fun typeMismatchOnInheritance(descriptor1: CallableMemberDescriptor, descriptor2: CallableMemberDescriptor)\n        fun abstractInvisibleMember(descriptor: CallableMemberDescriptor)\n    }\n\n    private class CollectMissingImplementationsStrategy : CheckInheritedSignaturesReportStrategy {\n        val shouldImplement = LinkedHashSet<CallableMemberDescriptor>()\n\n        override fun abstractMemberNotImplemented(descriptor: CallableMemberDescriptor) {\n            shouldIm"}
{"code": "plement.add(descriptor)\n        }\n\n        override fun abstractBaseClassMemberNotImplemented(descriptor: CallableMemberDescriptor) {\n            // don't care\n        }\n\n        override fun multipleImplementationsMemberNotImplemented(descriptor: CallableMemberDescriptor) {\n            shouldImplement.add(descriptor)\n        }\n\n        override fun conflictingInterfaceMemberNotImplemented(descriptor: CallableMemberDescriptor) {\n            if (descriptor.modality === Modality.ABSTRACT) {\n                shouldImplement.add(descriptor)\n            }\n        }\n\n        override fun typeMismatchOnInheritance(descriptor1: CallableMemberDescriptor, descriptor2: CallableMemberDescriptor) {\n            // don't care\n        }\n\n        override fun abstractInvisibleMember(descriptor: CallableMemberDescriptor) {\n            // don't care\n        }\n\n        override fun abstractMemberWithMoreSpecificType(\n            abstractMember: CallableMemberDescriptor,\n            concreteMember: Callable"}
{"code": "MemberDescriptor\n        ) {\n            shouldImplement.add(abstractMember)\n        }\n    }\n\n    private inner class CollectWarningInformationForInheritedMembersStrategy(\n        klass: KtClassOrObject,\n        classDescriptor: ClassDescriptor\n    ) : CollectErrorInformationForInheritedMembersStrategy(klass, classDescriptor) {\n        constructor(delegateStrategy: CollectErrorInformationForInheritedMembersStrategy) :\n                this(delegateStrategy.klass, delegateStrategy.classDescriptor)\n\n        override fun doReportErrors() {\n            val canHaveAbstractMembers = classCanHaveAbstractFakeOverride(classDescriptor)\n            if (abstractInBaseClassNoImpl.isNotEmpty() && !canHaveAbstractMembers) {\n                if (languageVersionSettings.supportsFeature(AbstractClassMemberNotImplementedWithIntermediateAbstractClass)) {\n                    trace.report(ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED.on(klass, klass, abstractInBaseClassNoImpl.first()))\n                } else {\n      "}
{"code": "              trace.report(ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED_WARNING.on(klass, klass, abstractInBaseClassNoImpl.first()))\n                }\n            }\n            if (conflictingInterfaceMembers.isNotEmpty()) {\n                val interfaceMember = conflictingInterfaceMembers.first()\n                if (languageVersionSettings.supportsFeature(AbstractClassMemberNotImplementedWithIntermediateAbstractClass)) {\n                    trace.report(MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED.on(klass, klass, interfaceMember))\n                } else {\n                    trace.report(MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED_WARNING.on(klass, klass, interfaceMember))\n                }\n            }\n        }\n    }\n\n    private open inner class CollectErrorInformationForInheritedMembersStrategy(\n        val klass: KtClassOrObject,\n        val classDescriptor: ClassDescriptor\n    ) : CheckInheritedSignaturesReportStrategy, CheckOverrideReportStrategy {\n\n        private val abstractNoImpl = linkedS"}
{"code": "etOf<CallableMemberDescriptor>()\n        protected val abstractInBaseClassNoImpl = linkedSetOf<CallableMemberDescriptor>()\n        private val abstractInvisibleSuper = linkedSetOf<CallableMemberDescriptor>()\n        private val multipleImplementations = linkedSetOf<CallableMemberDescriptor>()\n        protected val conflictingInterfaceMembers = linkedSetOf<CallableMemberDescriptor>()\n        private val conflictingReturnTypes = linkedSetOf<CallableMemberDescriptor>()\n\n        private val onceErrorsReported = SmartHashSet<DiagnosticFactoryWithPsiElement<*, *>>()\n\n        fun toDeprecationStrategy() =\n            CollectWarningInformationForInheritedMembersStrategy(this)\n\n        override fun abstractMemberNotImplemented(descriptor: CallableMemberDescriptor) {\n            abstractNoImpl.add(descriptor)\n        }\n\n        override fun abstractBaseClassMemberNotImplemented(descriptor: CallableMemberDescriptor) {\n            abstractInBaseClassNoImpl.add(descriptor)\n        }\n\n        overri"}
{"code": "de fun multipleImplementationsMemberNotImplemented(descriptor: CallableMemberDescriptor) {\n            multipleImplementations.add(descriptor)\n        }\n\n        override fun conflictingInterfaceMemberNotImplemented(descriptor: CallableMemberDescriptor) {\n            conflictingInterfaceMembers.add(descriptor)\n        }\n\n        override fun typeMismatchOnInheritance(descriptor1: CallableMemberDescriptor, descriptor2: CallableMemberDescriptor) {\n            conflictingReturnTypes.add(descriptor1)\n            conflictingReturnTypes.add(descriptor2)\n\n            if (descriptor1 is PropertyDescriptor && descriptor2 is PropertyDescriptor) {\n                if (descriptor1.isVar || descriptor2.isVar) {\n                    reportInheritanceConflictIfRequired(VAR_TYPE_MISMATCH_ON_INHERITANCE, descriptor1, descriptor2)\n                } else {\n                    reportInheritanceConflictIfRequired(PROPERTY_TYPE_MISMATCH_ON_INHERITANCE, descriptor1, descriptor2)\n                }\n            }"}
{"code": " else {\n                reportInheritanceConflictIfRequired(RETURN_TYPE_MISMATCH_ON_INHERITANCE, descriptor1, descriptor2)\n            }\n        }\n\n        override fun abstractInvisibleMember(descriptor: CallableMemberDescriptor) {\n            abstractInvisibleSuper.add(descriptor)\n        }\n\n        override fun abstractMemberWithMoreSpecificType(\n            abstractMember: CallableMemberDescriptor,\n            concreteMember: CallableMemberDescriptor\n        ) {\n            typeMismatchOnInheritance(abstractMember, concreteMember)\n        }\n\n        private fun reportInheritanceConflictIfRequired(\n            diagnosticFactory: DiagnosticFactory2<KtClassOrObject, CallableMemberDescriptor, CallableMemberDescriptor>,\n            descriptor1: CallableMemberDescriptor,\n            descriptor2: CallableMemberDescriptor\n        ) {\n            if (!onceErrorsReported.contains(diagnosticFactory)) {\n                onceErrorsReported.add(diagnosticFactory)\n                trace.report(diag"}
{"code": "nosticFactory.on(klass, descriptor1, descriptor2))\n            }\n        }\n\n        override fun overridingFinalMember(overriding: CallableMemberDescriptor, overridden: CallableMemberDescriptor) {\n            reportDelegationProblemIfRequired(OVERRIDING_FINAL_MEMBER_BY_DELEGATION, null, overriding, overridden)\n        }\n\n        override fun returnTypeMismatchOnOverride(\n            overriding: CallableMemberDescriptor,\n            overridden: CallableMemberDescriptor\n        ) {\n            val (diagnosticFactory, relevantDiagnosticFromInheritance) = if (overridden is PropertyDescriptor)\n                PROPERTY_TYPE_MISMATCH_BY_DELEGATION to PROPERTY_TYPE_MISMATCH_ON_INHERITANCE\n            else\n                RETURN_TYPE_MISMATCH_BY_DELEGATION to RETURN_TYPE_MISMATCH_ON_INHERITANCE\n\n            reportDelegationProblemIfRequired(\n                diagnosticFactory, relevantDiagnosticFromInheritance, overriding, overridden\n            )\n        }\n\n        override fun varOverriddenByV"}
{"code": "al(overriding: CallableMemberDescriptor, overridden: CallableMemberDescriptor) {\n            reportDelegationProblemIfRequired(VAR_OVERRIDDEN_BY_VAL_BY_DELEGATION, null, overriding, overridden)\n        }\n\n        private fun reportDelegationProblemIfRequired(\n            diagnosticFactory: DiagnosticFactory2<KtClassOrObject, CallableMemberDescriptor, CallableMemberDescriptor>,\n            relevantDiagnosticFromInheritance: DiagnosticFactoryWithPsiElement<*, *>?,\n            delegate: CallableMemberDescriptor,\n            overridden: CallableMemberDescriptor\n        ) {\n            assert(delegate.kind == DELEGATION) { \"Delegate expected, got \" + delegate + \" of kind \" + delegate.kind }\n\n            if (!onceErrorsReported.contains(diagnosticFactory) &&\n                (relevantDiagnosticFromInheritance == null || !onceErrorsReported.contains(relevantDiagnosticFromInheritance))\n            ) {\n                onceErrorsReported.add(diagnosticFactory)\n                trace.report(diagnos"}
{"code": "ticFactory.on(klass, delegate, overridden))\n            }\n        }\n\n        open fun doReportErrors() {\n            val canHaveAbstractMembers = classCanHaveAbstractFakeOverride(classDescriptor)\n            if (abstractInBaseClassNoImpl.isNotEmpty() && !canHaveAbstractMembers) {\n                trace.report(ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED.on(klass, klass, abstractInBaseClassNoImpl.first()))\n            } else if (abstractNoImpl.isNotEmpty() && !canHaveAbstractMembers) {\n                trace.report(ABSTRACT_MEMBER_NOT_IMPLEMENTED.on(klass, klass, abstractNoImpl.first()))\n            }\n\n            if (abstractInvisibleSuper.isNotEmpty() && !canHaveAbstractMembers) {\n                trace.report(INVISIBLE_ABSTRACT_MEMBER_FROM_SUPER.on(languageVersionSettings, klass, classDescriptor, abstractInvisibleSuper))\n            }\n\n            conflictingInterfaceMembers.removeAll(conflictingReturnTypes)\n            multipleImplementations.removeAll(conflictingReturnTypes)\n            if ("}
{"code": "conflictingInterfaceMembers.isNotEmpty()) {\n                trace.report(MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED.on(klass, klass, conflictingInterfaceMembers.first()))\n            } else if (multipleImplementations.isNotEmpty()) {\n                trace.report(MANY_IMPL_MEMBER_NOT_IMPLEMENTED.on(klass, klass, multipleImplementations.first()))\n            }\n        }\n    }\n\n    private interface CheckOverrideReportStrategy {\n        fun overridingFinalMember(overriding: CallableMemberDescriptor, overridden: CallableMemberDescriptor)\n        fun returnTypeMismatchOnOverride(overriding: CallableMemberDescriptor, overridden: CallableMemberDescriptor)\n        fun varOverriddenByVal(overriding: CallableMemberDescriptor, overridden: CallableMemberDescriptor)\n    }\n\n    private interface CheckOverrideReportForDeclaredMemberStrategy : CheckOverrideReportStrategy {\n        fun nothingToOverride(overriding: CallableMemberDescriptor)\n        fun cannotOverrideInvisibleMember(overriding: CallableMemb"}
{"code": "erDescriptor, invisibleOverridden: CallableMemberDescriptor)\n    }\n\n    private fun checkOverrideForMember(declared: CallableMemberDescriptor) {\n        if (declared.kind == CallableMemberDescriptor.Kind.SYNTHESIZED) {\n            if (DataClassDescriptorResolver.isComponentLike(declared.name)) {\n                checkOverrideForComponentFunction(declared)\n            } else if (declared.name == DataClassDescriptorResolver.COPY_METHOD_NAME) {\n                checkOverrideForCopyFunction(declared)\n            }\n            return\n        }\n\n        if (declared.kind != CallableMemberDescriptor.Kind.DECLARATION) {\n            return\n        }\n\n        val member = DescriptorToSourceUtils.descriptorToDeclaration(declared) as KtNamedDeclaration?\n            ?: throw IllegalStateException(\"declared descriptor is not resolved to declaration: $declared\")\n\n        val modifierList = member.modifierList\n        val hasOverrideNode = modifierList != null && modifierList.hasModifier(KtTokens.OVERRI"}
{"code": "DE_KEYWORD)\n        val overriddenDescriptors = declared.overriddenDescriptors\n\n        if (hasOverrideNode) {\n            checkOverridesForMemberMarkedOverride(\n                declared, kotlinTypeRefiner, object : CheckOverrideReportForDeclaredMemberStrategy {\n                    private var finalOverriddenError = false\n                    private var typeMismatchError = false\n                    private var kindMismatchError = false\n\n                    override fun overridingFinalMember(overriding: CallableMemberDescriptor, overridden: CallableMemberDescriptor) {\n                        if (!finalOverriddenError) {\n                            finalOverriddenError = true\n                            trace.report(OVERRIDING_FINAL_MEMBER.on(member, overridden, overridden.containingDeclaration))\n                        }\n                    }\n\n                    override fun returnTypeMismatchOnOverride(overriding: CallableMemberDescriptor, overridden: CallableMemberDescriptor) {\n     "}
{"code": "                   if (!typeMismatchError) {\n                            typeMismatchError = true\n\n                            when {\n                                overridden is PropertyDescriptor && overridden.isVar ->\n                                    trace.report(VAR_TYPE_MISMATCH_ON_OVERRIDE.on(member, declared, overridden))\n\n                                overridden is PropertyDescriptor && !overridden.isVar ->\n                                    trace.report(PROPERTY_TYPE_MISMATCH_ON_OVERRIDE.on(member, declared, overridden))\n\n                                else -> trace.report(\n                                    RETURN_TYPE_MISMATCH_ON_OVERRIDE.on(\n                                        member, declared,\n                                        DeclarationWithDiagnosticComponents(overridden, platformSpecificDiagnosticComponents)\n                                    )\n                                )\n                            }\n                        }\n                 "}
{"code": "   }\n\n                    override fun varOverriddenByVal(overriding: CallableMemberDescriptor, overridden: CallableMemberDescriptor) {\n                        if (!kindMismatchError) {\n                            kindMismatchError = true\n                            trace.report(VAR_OVERRIDDEN_BY_VAL.on(member, declared as PropertyDescriptor, overridden as PropertyDescriptor))\n                        }\n                    }\n\n                    override fun cannotOverrideInvisibleMember(\n                        overriding: CallableMemberDescriptor,\n                        invisibleOverridden: CallableMemberDescriptor\n                    ) {\n                        trace.report(CANNOT_OVERRIDE_INVISIBLE_MEMBER.on(member, declared, invisibleOverridden))\n                    }\n\n                    override fun nothingToOverride(overriding: CallableMemberDescriptor) {\n                        trace.report(NOTHING_TO_OVERRIDE.on(member, declared))\n                    }\n                }, lang"}
{"code": "uageVersionSettings\n            )\n        } else if (!overriddenDescriptors.isEmpty() && !overridesBackwardCompatibilityHelper.overrideCanBeOmitted(declared)) {\n            val overridden = overriddenDescriptors.first()\n            trace.report(VIRTUAL_MEMBER_HIDDEN.on(member, declared, overridden, overridden.containingDeclaration))\n        }\n    }\n\n    private fun checkOverrideForComponentFunction(componentFunction: CallableMemberDescriptor) {\n        val dataModifier = findDataModifierForDataClass(componentFunction.containingDeclaration)\n\n        checkOverridesForMember(componentFunction, componentFunction.overriddenDescriptors, object : CheckOverrideReportStrategy {\n            private var overrideConflict = false\n\n            override fun overridingFinalMember(overriding: CallableMemberDescriptor, overridden: CallableMemberDescriptor) {\n                if (!overrideConflict) {\n                    overrideConflict = true\n                    trace.report(DATA_CLASS_OVERRIDE_CONFLICT."}
{"code": "on(dataModifier, componentFunction, overridden.containingDeclaration))\n                }\n            }\n\n            override fun returnTypeMismatchOnOverride(overriding: CallableMemberDescriptor, overridden: CallableMemberDescriptor) {\n                if (!overrideConflict) {\n                    overrideConflict = true\n                    trace.report(DATA_CLASS_OVERRIDE_CONFLICT.on(dataModifier, componentFunction, overridden.containingDeclaration))\n                }\n            }\n\n            override fun varOverriddenByVal(overriding: CallableMemberDescriptor, overridden: CallableMemberDescriptor) {\n                throw IllegalStateException(\"Component functions are not properties\")\n            }\n        }, kotlinTypeRefiner)\n    }\n\n    private fun checkOverrideForCopyFunction(copyFunction: CallableMemberDescriptor) {\n        val overridden = copyFunction.overriddenDescriptors.firstOrNull()\n        if (overridden != null) {\n            val baseClassifier = overridden.containingDecla"}
{"code": "ration\n            val dataModifier = findDataModifierForDataClass(copyFunction.containingDeclaration)\n            trace.report(DATA_CLASS_OVERRIDE_DEFAULT_VALUES.on(languageVersionSettings, dataModifier, copyFunction, baseClassifier))\n        }\n    }\n\n    private fun checkParameterOverridesForAllClasses(c: TopDownAnalysisContext) {\n        for (classDescriptor in c.declaredClasses.values) {\n            for (member in DescriptorUtils.getAllDescriptors(classDescriptor.defaultType.memberScope)) {\n                if (member is CallableMemberDescriptor) {\n                    checkOverridesForParameters(member)\n                }\n            }\n        }\n    }\n\n    private fun checkOverridesForParameters(declared: CallableMemberDescriptor) {\n        val isDeclaration = declared.kind == CallableMemberDescriptor.Kind.DECLARATION\n        if (isDeclaration) {\n            // No check if the function is not marked as 'override'\n            val declaration = DescriptorToSourceUtils.descriptorToDecla"}
{"code": "ration(declared) as KtModifierListOwner?\n            if (declaration != null && !declaration.hasModifier(KtTokens.OVERRIDE_KEYWORD)) {\n                return\n            }\n        }\n\n        // Let p1 be a parameter of the overriding function\n        // Let p2 be a parameter of the function being overridden\n        // Then\n        //  a) p1 is not allowed to have a default value declared\n        //  b) p1 must have the same name as p2\n        for (parameterFromSubclass in declared.valueParameters) {\n            var defaultsInSuper = 0\n            for (parameterFromSuperclass in parameterFromSubclass.overriddenDescriptors) {\n                if (parameterFromSuperclass.declaresDefaultValue()) {\n                    defaultsInSuper++\n                }\n            }\n            val multipleDefaultsInSuper = defaultsInSuper > 1\n\n            if (isDeclaration) {\n                checkNameAndDefaultForDeclaredParameter(parameterFromSubclass, multipleDefaultsInSuper)\n            } else {\n       "}
{"code": "         checkNameAndDefaultForFakeOverrideParameter(declared, parameterFromSubclass, multipleDefaultsInSuper)\n            }\n        }\n    }\n\n    private fun checkNameAndDefaultForDeclaredParameter(descriptor: ValueParameterDescriptor, multipleDefaultsInSuper: Boolean) {\n        val parameter = DescriptorToSourceUtils.descriptorToDeclaration(descriptor) as? KtParameter\n            ?: error(\"Declaration not found for parameter: $descriptor\")\n\n        if (descriptor.declaresDefaultValue()) {\n            trace.report(DEFAULT_VALUE_NOT_ALLOWED_IN_OVERRIDE.on(parameter))\n        }\n\n        if (multipleDefaultsInSuper) {\n            trace.report(MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES.on(parameter, descriptor))\n        }\n\n        for (parameterFromSuperclass in descriptor.overriddenDescriptors) {\n            if (shouldReportParameterNameOverrideWarning(descriptor, parameterFromSuperclass)) {\n\n                trace.report(\n                    PARAMETER_NAME_CHANGED_ON_OVERRIDE.on(\n       "}
{"code": "                 parameter,\n                        parameterFromSuperclass.containingDeclaration.containingDeclaration as ClassDescriptor,\n                        parameterFromSuperclass\n                    )\n                )\n            }\n        }\n    }\n\n    private fun checkNameAndDefaultForFakeOverrideParameter(\n        containingFunction: CallableMemberDescriptor,\n        descriptor: ValueParameterDescriptor,\n        multipleDefaultsInSuper: Boolean\n    ) {\n        val containingClass = containingFunction.containingDeclaration\n        val classElement = DescriptorToSourceUtils.descriptorToDeclaration(containingClass) as KtClassOrObject?\n            ?: error(\"Declaration not found for class: $containingClass\")\n\n        if (multipleDefaultsInSuper) {\n            trace.report(MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_WHEN_NO_EXPLICIT_OVERRIDE.on(classElement, descriptor))\n        }\n\n        for (parameterFromSuperclass in descriptor.overriddenDescriptors) {\n            if (should"}
{"code": "ReportParameterNameOverrideWarning(descriptor, parameterFromSuperclass)) {\n                trace.report(\n                    DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES.on(\n                        classElement,\n                        containingFunction.overriddenDescriptors,\n                        parameterFromSuperclass.index + 1\n                    )\n                )\n            }\n        }\n    }\n\n    private fun checkVisibility(c: TopDownAnalysisContext) {\n        for ((key, value) in c.members) {\n            checkVisibilityForMember(key, value)\n            if (key is KtProperty && value is PropertyDescriptor) {\n                val setter = key.setter\n                val setterDescriptor = value.setter\n                if (setter != null && setterDescriptor != null) {\n                    checkVisibilityForMember(setter, setterDescriptor)\n                }\n            }\n        }\n    }\n\n    private fun checkVisibilityForMember(declaration: KtDeclaration, memberDescriptor: "}
{"code": "CallableMemberDescriptor) {\n        val visibility = memberDescriptor.visibility\n        for (descriptor in memberDescriptor.overriddenDescriptors) {\n            val compare = DescriptorVisibilities.compare(visibility, descriptor.visibility)\n            if (compare == null) {\n                trace.report(\n                    CANNOT_CHANGE_ACCESS_PRIVILEGE.on(\n                        declaration,\n                        descriptor.visibility,\n                        descriptor,\n                        descriptor.containingDeclaration\n                    )\n                )\n                return\n            } else if (compare < 0) {\n                trace.report(\n                    CANNOT_WEAKEN_ACCESS_PRIVILEGE.on(\n                        declaration,\n                        descriptor.visibility,\n                        descriptor,\n                        descriptor.containingDeclaration\n                    )\n                )\n                return\n            }\n        }\n    }\n\n    "}
{"code": "companion object {\n\n        fun resolveUnknownVisibilities(\n            descriptors: Collection<CallableMemberDescriptor>,\n            trace: BindingTrace\n        ) {\n            for (descriptor in descriptors) {\n                OverridingUtil.resolveUnknownVisibilityForMember(descriptor, createCannotInferVisibilityReporter(trace))\n            }\n        }\n\n        fun createCannotInferVisibilityReporter(trace: BindingTrace): Function1<CallableMemberDescriptor, Unit> {\n            return fun(descriptor: CallableMemberDescriptor) {\n                val reportOn: DeclarationDescriptor = when {\n                    descriptor.kind == FAKE_OVERRIDE || descriptor.kind == DELEGATION ->\n                        DescriptorUtils.getContainingClass(descriptor) ?: throw AssertionError(\"Class member expected: $descriptor\")\n                    descriptor is PropertyAccessorDescriptor && descriptor.isDefault ->\n                        descriptor.correspondingProperty\n                    else ->\n        "}
{"code": "                descriptor\n                }\n\n                val element = DescriptorToSourceUtils.descriptorToDeclaration(reportOn)\n                if (element is KtDeclaration) {\n                    trace.report(CANNOT_INFER_VISIBILITY.on(element, descriptor))\n                }\n                return\n            }\n        }\n\n        fun getMissingImplementations(classDescriptor: ClassDescriptor): Set<CallableMemberDescriptor> {\n            val collector = CollectMissingImplementationsStrategy()\n            // Note that it is fine to pass default refiner here. Reason:\n            // 1. We bind overrides with proper refiners and [checkInheritedAndDelegatedSignatures] skips all properly-bound overrides,\n            //    so we would consider only unbound overrides\n            // 2. Using default refiner instead of proper one can only increase amount of type mismatches, not decrease it\n            // Putting 1 and 2 together means that using default refiner might make already unbound ov"}
{"code": "errides even \"more unbound\", which\n            // isn't an issue for case of [getMissingImplementations]\n            checkInheritedAndDelegatedSignatures(classDescriptor, collector, null, KotlinTypeRefiner.Default)\n            return collector.shouldImplement\n        }\n\n        private fun checkInheritedAndDelegatedSignatures(\n            classDescriptor: ClassDescriptor,\n            inheritedReportStrategy: CheckInheritedSignaturesReportStrategy,\n            overrideReportStrategyForDelegates: CheckOverrideReportStrategy?,\n            kotlinTypeRefiner: KotlinTypeRefiner\n        ) {\n            for (member in DescriptorUtils.getAllDescriptors(classDescriptor.defaultType.memberScope)) {\n                if (member is CallableMemberDescriptor) {\n                    checkInheritedAndDelegatedSignatures(\n                        member, inheritedReportStrategy, overrideReportStrategyForDelegates, kotlinTypeRefiner\n                    )\n                }\n            }\n        }\n\n        priv"}
{"code": "ate fun CallableMemberDescriptor.computeRelevantDirectlyOverridden(): Set<CallableMemberDescriptor> {\n            val directOverridden = overriddenDescriptors\n\n            // directOverridden may be empty if user tries to delegate implementation of abstract class instead of interface\n            if (directOverridden.isEmpty()) return emptySet()\n\n            // collects map from the directly overridden descriptor to the set of declarations:\n            // -- if directly overridden is not fake, the set consists of one element: this directly overridden\n            // -- if it's fake, overridden declarations (non-fake) of this descriptor are collected\n            val overriddenDeclarationsByDirectParent = collectOverriddenDeclarations(directOverridden)\n\n            val allOverriddenDeclarations = ContainerUtil.flatten(overriddenDeclarationsByDirectParent.values)\n            val allFilteredOverriddenDeclarations = OverridingUtil.filterOutOverridden(\n                Sets.newLinkedHashSet(all"}
{"code": "OverriddenDeclarations)\n            )\n\n            return getRelevantDirectlyOverridden(overriddenDeclarationsByDirectParent, allFilteredOverriddenDeclarations)\n        }\n\n        private fun checkInheritedAndDelegatedSignatures(\n            descriptor: CallableMemberDescriptor,\n            reportingStrategy: CheckInheritedSignaturesReportStrategy,\n            overrideReportStrategyForDelegates: CheckOverrideReportStrategy?,\n            kotlinTypeRefiner: KotlinTypeRefiner\n        ) {\n            val kind = descriptor.kind\n            if (kind != FAKE_OVERRIDE && kind != DELEGATION) return\n\n            val relevantDirectlyOverridden = descriptor.computeRelevantDirectlyOverridden()\n            if (relevantDirectlyOverridden.isEmpty()) return\n\n            if (descriptor.visibility === DescriptorVisibilities.INVISIBLE_FAKE) {\n                checkInvisibleFakeOverride(descriptor, relevantDirectlyOverridden, reportingStrategy)\n                return\n            }\n\n            checkInherite"}
{"code": "dDescriptorsGroup(descriptor, relevantDirectlyOverridden, reportingStrategy, kotlinTypeRefiner)\n\n            if (kind == DELEGATION && overrideReportStrategyForDelegates != null) {\n                checkOverridesForMember(descriptor, relevantDirectlyOverridden, overrideReportStrategyForDelegates, kotlinTypeRefiner)\n            }\n\n            if (kind != DELEGATION) {\n                checkMissingOverridesByJava8Restrictions(relevantDirectlyOverridden, reportingStrategy)\n            }\n\n            val (concreteOverridden, abstractOverridden) = relevantDirectlyOverridden\n                .filter { !isOrOverridesSynthesized(it) }\n                .partition { it.modality != Modality.ABSTRACT }\n\n            when (concreteOverridden.size) {\n                0 ->\n                    if (kind != DELEGATION) {\n                        abstractOverridden.forEach {\n                            reportingStrategy.abstractMemberNotImplemented(it)\n                        }\n                    }\n           "}
{"code": "     1 ->\n                    if (kind != DELEGATION) {\n                        val implementation = concreteOverridden.first()\n                        collectAbstractMethodsWithMoreSpecificReturnType(abstractOverridden, implementation, kotlinTypeRefiner).forEach {\n                            reportingStrategy.abstractMemberWithMoreSpecificType(it, implementation)\n                        }\n                    }\n                else ->\n                    concreteOverridden.forEach {\n                        reportingStrategy.multipleImplementationsMemberNotImplemented(it)\n                    }\n            }\n        }\n\n        private fun checkInvisibleFakeOverride(\n            descriptor: CallableMemberDescriptor,\n            overriddenDescriptors: Collection<CallableMemberDescriptor>,\n            reportingStrategy: CheckInheritedSignaturesReportStrategy\n        ) {\n            // the checks below are only relevant for non-abstract classes or objects\n            if ((descriptor.containi"}
{"code": "ngDeclaration as? ClassDescriptor)?.modality === Modality.ABSTRACT) return\n\n            val abstractOverrides = overriddenDescriptors.filter { it.modality === Modality.ABSTRACT }\n\n            if (abstractOverrides.size != overriddenDescriptors.size) return // has non-abstract override\n\n            for (override in abstractOverrides) {\n                reportingStrategy.abstractInvisibleMember(override)\n            }\n        }\n\n        private fun checkMissingOverridesByJava8Restrictions(\n            relevantDirectlyOverridden: Set<CallableMemberDescriptor>,\n            reportingStrategy: CheckInheritedSignaturesReportStrategy,\n            onlyBaseClassMembers: Boolean = false,\n            overriddenInterfaceMembers: MutableList<CallableMemberDescriptor> = SmartList()\n        ) {\n            // Java 8:\n            // -- class should implement an abstract member of a super-class,\n            //    even if relevant default implementation is provided in one of the super-interfaces;\n        "}
{"code": "    // -- inheriting multiple override equivalent methods from an interface is a conflict\n            //    regardless of 'default' vs 'abstract'.\n\n            var overridesClassMember = false\n            var overridesNonAbstractInterfaceMember = false\n            var overridesAbstractInBaseClass: CallableMemberDescriptor? = null\n            var overridesNonAbstractInBaseClass: CallableMemberDescriptor? = null\n            var fakeOverrideInBaseClass: CallableMemberDescriptor? = null\n            for (overridden in relevantDirectlyOverridden) {\n                val containingDeclaration = overridden.containingDeclaration as? ClassDescriptor ?: continue\n                if (containingDeclaration.kind == ClassKind.CLASS) {\n                    if (overridden.kind == FAKE_OVERRIDE && !containingDeclaration.isExpect) {\n                        // Fake override in a class in fact can mean an interface member\n                        // We will process it at the end\n                        // Note:"}
{"code": " with expect containing class, the situation is unclear, so we miss this case\n                        // See extendExpectedClassWithAbstractMember.kt (BaseA, BaseAImpl, DerivedA1)\n                        fakeOverrideInBaseClass = overridden\n                    }\n                    overridesClassMember = true\n                    if (overridden.modality === Modality.ABSTRACT) {\n                        overridesAbstractInBaseClass = overridden\n                    } else {\n                        overridesNonAbstractInBaseClass = overridden\n                    }\n                } else if (containingDeclaration.kind == ClassKind.INTERFACE) {\n                    overriddenInterfaceMembers.add(overridden)\n                    if (overridden.modality !== Modality.ABSTRACT) {\n                        overridesNonAbstractInterfaceMember = true\n                    }\n                }\n            }\n\n            if (overridesAbstractInBaseClass != null && overridesNonAbstractInBaseClass == null) {\n "}
{"code": "               reportingStrategy.abstractBaseClassMemberNotImplemented(overridesAbstractInBaseClass)\n            } else if (!onlyBaseClassMembers && !overridesClassMember &&\n                overridesNonAbstractInterfaceMember && overriddenInterfaceMembers.size > 1\n            ) {\n                for (member in overriddenInterfaceMembers) {\n                    reportingStrategy.conflictingInterfaceMemberNotImplemented(member)\n                }\n            } else if (fakeOverrideInBaseClass != null) {\n                val newReportingStrategy = if (reportingStrategy is CollectErrorInformationForInheritedMembersStrategy) {\n                    reportingStrategy.toDeprecationStrategy()\n                } else reportingStrategy\n                checkMissingOverridesByJava8Restrictions(\n                    fakeOverrideInBaseClass.computeRelevantDirectlyOverridden(),\n                    reportingStrategy = newReportingStrategy,\n                    // Note: we don't report MANY_INTERFACES_MEMBER_N"}
{"code": "OT_IMPLEMENTED_WARNING\n                    // in case all interface members are derived from fakeOverrideInClass\n                    // (in this case we already have warning or error on its container)\n                    onlyBaseClassMembers = overriddenInterfaceMembers.isEmpty(),\n                    overriddenInterfaceMembers\n                )\n                if (newReportingStrategy is CollectWarningInformationForInheritedMembersStrategy) {\n                    newReportingStrategy.doReportErrors()\n                }\n            }\n        }\n\n        private fun collectAbstractMethodsWithMoreSpecificReturnType(\n            abstractOverridden: List<CallableMemberDescriptor>,\n            implementation: CallableMemberDescriptor,\n            kotlinTypeRefiner: KotlinTypeRefiner\n        ): List<CallableMemberDescriptor> =\n            abstractOverridden.filter { abstractMember -> !isReturnTypeOkForOverride(abstractMember, implementation, kotlinTypeRefiner) }\n\n        private fun getRelevantD"}
{"code": "irectlyOverridden(\n            overriddenByParent: MutableMap<CallableMemberDescriptor, Set<CallableMemberDescriptor>>,\n            allFilteredOverriddenDeclarations: Set<CallableMemberDescriptor>\n        ): Set<CallableMemberDescriptor> {\n            \n\n            val iterator = overriddenByParent.entries.iterator()\n            while (iterator.hasNext()) {\n                if (!isRelevant(iterator.next().value, overriddenByParent.values, allFilteredOverriddenDeclarations)) {\n                    iterator.remove()\n                }\n            }\n            return overriddenByParent.keys\n        }\n\n        private fun isRelevant(\n            declarationSet: Set<CallableMemberDescriptor>,\n            allDeclarationSets: Collection<Set<CallableMemberDescriptor>>,\n            allFilteredOverriddenDeclarations: Set<CallableMemberDescriptor>\n        ): Boolean {\n            for (otherSet in allDeclarationSets) {\n                if (otherSet === declarationSet) continue\n                if (oth"}
{"code": "erSet.containsAll(declarationSet)) return false\n                if (Collections.disjoint(allFilteredOverriddenDeclarations, declarationSet)) return false\n            }\n            return true\n        }\n\n        private fun collectOverriddenDeclarations(\n            directOverriddenDescriptors: Collection<CallableMemberDescriptor>\n        ): MutableMap<CallableMemberDescriptor, Set<CallableMemberDescriptor>> {\n            val overriddenDeclarationsByDirectParent = Maps.newLinkedHashMap<CallableMemberDescriptor, Set<CallableMemberDescriptor>>()\n            for (descriptor in directOverriddenDescriptors) {\n                val overriddenDeclarations = OverridingUtil.getOverriddenDeclarations(descriptor)\n                val filteredOverrides = OverridingUtil.filterOutOverridden(overriddenDeclarations)\n                overriddenDeclarationsByDirectParent[descriptor] = LinkedHashSet(filteredOverrides)\n            }\n            return overriddenDeclarationsByDirectParent\n        }\n\n        pri"}
{"code": "vate fun checkInheritedDescriptorsGroup(\n            descriptor: CallableMemberDescriptor,\n            overriddenDescriptors: Collection<CallableMemberDescriptor>,\n            reportingStrategy: CheckInheritedSignaturesReportStrategy,\n            kotlinTypeRefiner: KotlinTypeRefiner\n        ) {\n            if (overriddenDescriptors.size <= 1) return\n\n            for (overriddenDescriptor in overriddenDescriptors) {\n                require(descriptor !is PropertyDescriptor || overriddenDescriptor is PropertyDescriptor) {\n                    \"$overriddenDescriptor is not a property\"\n                }\n\n                if (!isReturnTypeOkForOverride(overriddenDescriptor, descriptor, kotlinTypeRefiner)) {\n                    reportingStrategy.typeMismatchOnInheritance(descriptor, overriddenDescriptor)\n                }\n            }\n        }\n\n        private fun checkOverridesForMemberMarkedOverride(\n            declared: CallableMemberDescriptor,\n            kotlinTypeRefiner: KotlinTypeR"}
{"code": "efiner,\n            reportError: CheckOverrideReportForDeclaredMemberStrategy,\n            languageVersionSettings: LanguageVersionSettings\n        ) {\n            val overriddenDescriptors = declared.overriddenDescriptors\n\n            checkOverridesForMember(declared, overriddenDescriptors, reportError, kotlinTypeRefiner)\n\n            if (overriddenDescriptors.isEmpty()) {\n                val containingDeclaration = declared.containingDeclaration\n                val declaringClass = containingDeclaration as? ClassDescriptor\n                    ?: error(\"Overrides may only be resolved in a class, but $declared comes from $containingDeclaration\")\n\n                val invisibleOverriddenDescriptor =\n                    findInvisibleOverriddenDescriptor(\n                        declared, declaringClass, kotlinTypeRefiner, languageVersionSettings\n                    )\n                if (invisibleOverriddenDescriptor != null) {\n                    reportError.cannotOverrideInvisibleMember("}
{"code": "declared, invisibleOverriddenDescriptor)\n                } else {\n                    reportError.nothingToOverride(declared)\n                }\n            }\n        }\n\n        private fun checkOverridesForMember(\n            memberDescriptor: CallableMemberDescriptor,\n            overriddenDescriptors: Collection<CallableMemberDescriptor>,\n            reportError: CheckOverrideReportStrategy,\n            kotlinTypeRefiner: KotlinTypeRefiner\n        ) {\n            for (overridden in overriddenDescriptors) {\n                if (overridden.modality == Modality.FINAL) {\n                    reportError.overridingFinalMember(memberDescriptor, overridden)\n                }\n\n                if (!isReturnTypeOkForOverride(overridden, memberDescriptor, kotlinTypeRefiner)) {\n                    require(memberDescriptor !is PropertyDescriptor || overridden is PropertyDescriptor) {\n                        \"$overridden is overridden by property $memberDescriptor\"\n                    }\n            "}
{"code": "        reportError.returnTypeMismatchOnOverride(memberDescriptor, overridden)\n                }\n\n                if (checkPropertyKind(overridden, true) && checkPropertyKind(memberDescriptor, false)) {\n                    reportError.varOverriddenByVal(memberDescriptor, overridden)\n                }\n            }\n        }\n\n        private fun isReturnTypeOkForOverride(\n            superDescriptor: CallableDescriptor,\n            subDescriptor: CallableDescriptor,\n            kotlinTypeRefiner: KotlinTypeRefiner,\n        ): Boolean {\n            val typeSubstitutor = prepareTypeSubstitutor(superDescriptor, subDescriptor) ?: return false\n\n            val superReturnType = superDescriptor.returnType!!\n\n            val subReturnType = subDescriptor.returnType!!\n\n            val substitutedSuperReturnType = typeSubstitutor.substitute(superReturnType, Variance.OUT_VARIANCE)!!\n\n            val typeChecker = NewKotlinTypeCheckerImpl(kotlinTypeRefiner)\n            return if (superDescriptor i"}
{"code": "s PropertyDescriptor && superDescriptor.isVar)\n                typeChecker.equalTypes(subReturnType, substitutedSuperReturnType)\n            else\n                typeChecker.isSubtypeOf(subReturnType, substitutedSuperReturnType)\n        }\n\n        private fun prepareTypeSubstitutor(\n            superDescriptor: CallableDescriptor,\n            subDescriptor: CallableDescriptor\n        ): TypeSubstitutor? {\n            val superTypeParameters = superDescriptor.typeParameters\n            val subTypeParameters = subDescriptor.typeParameters\n            if (subTypeParameters.size != superTypeParameters.size) return null\n\n            val arguments = ArrayList<TypeProjection>(subTypeParameters.size)\n            for (i in superTypeParameters.indices) {\n                arguments.add(TypeProjectionImpl(subTypeParameters[i].defaultType))\n            }\n\n            return IndexedParametersSubstitution(superTypeParameters, arguments).buildSubstitutor()\n        }\n\n        private fun findDataModifie"}
{"code": "rForDataClass(dataClass: DeclarationDescriptor): PsiElement {\n            val classDeclaration = DescriptorToSourceUtils.getSourceFromDescriptor(dataClass) as KtClassOrObject?\n            if (classDeclaration?.modifierList != null) {\n                val modifier = classDeclaration.modifierList!!.getModifier(KtTokens.DATA_KEYWORD)\n                if (modifier != null) {\n                    return modifier\n                }\n            }\n\n            throw IllegalStateException(\"No data modifier is found for data class $dataClass\")\n        }\n\n        private fun findInvisibleOverriddenDescriptor(\n            declared: CallableMemberDescriptor,\n            declaringClass: ClassDescriptor,\n            kotlinTypeRefiner: KotlinTypeRefiner,\n            languageVersionSettings: LanguageVersionSettings\n        ): CallableMemberDescriptor? {\n            @OptIn(TypeRefinement::class)\n            for (supertype in kotlinTypeRefiner.refineSupertypes(declaringClass)) {\n                val all = lin"}
{"code": "kedSetOf<CallableMemberDescriptor>()\n                all.addAll(supertype.memberScope.getContributedFunctions(declared.name, NoLookupLocation.WHEN_CHECK_OVERRIDES))\n                all.addAll(supertype.memberScope.getContributedVariables(declared.name, NoLookupLocation.WHEN_CHECK_OVERRIDES))\n                for (fromSuper in all) {\n                    if (OverridingUtil.DEFAULT.isOverridableBy(fromSuper, declared, null).result == OVERRIDABLE) {\n                        if (OverridingUtil.isVisibleForOverride(declared, fromSuper, languageVersionSettings.useSpecialRulesForPrivateSealedConstructors)) {\n                            throw IllegalStateException(\n                                \"Descriptor \" + fromSuper + \" is overridable by \" + declared +\n                                        \" and visible but does not appear in its getOverriddenDescriptors()\"\n                            )\n                        }\n                        return fromSuper\n                    }\n              "}
{"code": "  }\n            }\n            return null\n        }\n\n        fun shouldReportParameterNameOverrideWarning(\n            parameterFromSubclass: ValueParameterDescriptor,\n            parameterFromSuperclass: ValueParameterDescriptor\n        ): Boolean {\n            return parameterFromSubclass.containingDeclaration.hasStableParameterNames() &&\n                    parameterFromSuperclass.containingDeclaration.hasStableParameterNames() &&\n                    parameterFromSuperclass.name != parameterFromSubclass.name\n        }\n\n        private fun checkPropertyKind(descriptor: CallableMemberDescriptor, isVar: Boolean): Boolean {\n            return descriptor is PropertyDescriptor && descriptor.isVar == isVar\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.jvm.checkers.declaration\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.declaration.FirBasicDeclarationChecker\nimport org.jetbrains.kotlin.fir.analysis.checkers.getContainingClassSymbol\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.jvm.FirJvmErrors\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.declarations.utils.isFun\nimport org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.isExtension\nimport org.jetbrains.kotlin.name.Name\n\nobject FirJvmFunctionDelegateMemberNameClashChecker : FirBasicDeclarationChecker(MppCheckerKind.Common) {\n    private val functionDelegateName: Name = Name.identifier(\"functionDelegat"}
{"code": "e\")\n    private val getFunctionDelegateName: Name = Name.identifier(\"getFunctionDelegate\")\n\n    override fun check(declaration: FirDeclaration, context: CheckerContext, reporter: DiagnosticReporter) {\n        if (declaration !is FirCallableDeclaration) return\n        val containingClassSymbol = declaration.getContainingClassSymbol(context.session) as? FirRegularClassSymbol ?: return\n        if (!containingClassSymbol.isFun) return\n        if (declaration.symbol.isExtension || (declaration as? FirFunction)?.valueParameters?.isNotEmpty() == true) return\n\n        if (declaration is FirSimpleFunction && declaration.name == getFunctionDelegateName ||\n            declaration is FirProperty && declaration.name == functionDelegateName\n        ) {\n            reporter.reportOn(declaration.source, FirJvmErrors.FUNCTION_DELEGATE_MEMBER_NAME_CLASH, context)\n        }\n    }\n}\n"}
{"code": "// FILE: main.kt\npackage a.b.c\n\nclass Outer {\n    class Inner {\n        companion object {\n        }\n    }\n}\n\nfun foo(): Class<*> {\n    return <expr>a.b.c.Outer.Inner::class.java</expr>\n}"}
{"code": "interface I<T> {\n    fun i(t: T): Int\n}\n\nclass C<T>(val x: Int): I<T> {\n    <expr>companion object {\n        val K: Int = 58\n    }</expr>\n\n    fun test(): Int {\n        return 45 * K\n    }\n\n    fun count(xs: List<T>): Int {\n        return xs.size\n    }\n\n    override fun i(t: T): Int {\n        return test() + t.hashCode()\n    }\n\n    inner class B() {\n\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.checkers.generator.diagnostics.model\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.diagnostics.Severity\nimport org.jetbrains.kotlin.util.PrivateForInline\nimport kotlin.properties.PropertyDelegateProvider\nimport kotlin.properties.ReadOnlyProperty\nimport kotlin.reflect.typeOf\n\nabstract class AbstractDiagnosticGroup @PrivateForInline constructor(val name: String, internal val containingObjectName: String) {\n    @Suppress(\"PropertyName\")\n    @PrivateForInline\n    val _diagnostics = mutableListOf<DiagnosticData>()\n\n    @OptIn(PrivateForInline::class)\n    val diagnostics: List<DiagnosticData>\n        get() = _diagnostics\n\n    @OptIn(PrivateForInline::class)\n    internal inline fun <reified P : PsiElement> error(\n        positioningStrategy: PositioningStrategy = PositioningStrategy.DEFAULT,\n        crossinline init: DiagnosticBuilder.Regular.() -> Unit = {}\n    ) = diagnosticDelegateProvid"}
{"code": "er<P>(Severity.ERROR, positioningStrategy, init)\n\n\n    @OptIn(PrivateForInline::class)\n    internal inline fun <reified P : PsiElement> warning(\n        positioningStrategy: PositioningStrategy = PositioningStrategy.DEFAULT,\n        crossinline init: DiagnosticBuilder.Regular.() -> Unit = {}\n    ) = diagnosticDelegateProvider<P>(Severity.WARNING, positioningStrategy, init)\n\n    @OptIn(PrivateForInline::class)\n    internal inline fun <reified P : PsiElement> deprecationError(\n        featureForError: LanguageFeature,\n        positioningStrategy: PositioningStrategy = PositioningStrategy.DEFAULT,\n        crossinline init: DiagnosticBuilder.Deprecation.() -> Unit = {}\n    ) = deprecationDiagnosticDelegateProvider<P>(featureForError, positioningStrategy, init)\n\n    @PrivateForInline\n    internal inline fun <reified P : PsiElement> diagnosticDelegateProvider(\n        severity: Severity,\n        positioningStrategy: PositioningStrategy,\n        crossinline init: DiagnosticBuilder.Regular.() "}
{"code": "-> Unit = {}\n    ) = PropertyDelegateProvider<Any?, ReadOnlyProperty<AbstractDiagnosticGroup, RegularDiagnosticData>> { _, property ->\n        val diagnostic = DiagnosticBuilder.Regular(\n            containingObjectName,\n            severity,\n            name = property.name,\n            psiType = typeOf<P>(),\n            positioningStrategy,\n        ).apply(init).build()\n        _diagnostics += diagnostic\n        ReadOnlyProperty { _, _ -> diagnostic }\n    }\n\n    @PrivateForInline\n    internal inline fun <reified P : PsiElement> deprecationDiagnosticDelegateProvider(\n        featureForError: LanguageFeature,\n        positioningStrategy: PositioningStrategy,\n        crossinline init: DiagnosticBuilder.Deprecation.() -> Unit = {}\n    ) = PropertyDelegateProvider<Any?, ReadOnlyProperty<AbstractDiagnosticGroup, DeprecationDiagnosticData>> { _, property ->\n        val diagnostic = DiagnosticBuilder.Deprecation(\n            containingObjectName,\n            featureForError,\n            name"}
{"code": " = property.name,\n            psiType = typeOf<P>(),\n            positioningStrategy,\n        ).apply(init).build()\n        _diagnostics += diagnostic\n        ReadOnlyProperty { _, _ -> diagnostic }\n    }\n\n    @OptIn(PrivateForInline::class)\n    operator fun plus(other: AbstractDiagnosticGroup): AbstractDiagnosticGroup {\n        require(name == other.name)\n\n        val combinedDiagnostics = this.diagnostics + other.diagnostics\n\n        return object : AbstractDiagnosticGroup(name, \"#Stub\") {\n            init {\n                _diagnostics.addAll(combinedDiagnostics)\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.project.structure\n\nimport org.jetbrains.kotlin.utils.topologicalSort\n\n\npublic inline fun <reified M : KtModule> KtModule.directRegularDependenciesOfType(): Sequence<M> =\n    directRegularDependencies.asSequence().filterIsInstance<M>()\n\n\npublic inline fun <reified M : KtModule> KtModule.directFriendDependenciesOfType(): Sequence<M> =\n    directFriendDependencies.asSequence().filterIsInstance<M>()\n\n\npublic inline fun <reified M : KtModule> KtModule.directDependsOnDependenciesOfType(): Sequence<M> =\n    directDependsOnDependencies.asSequence().filterIsInstance<M>()\n\n\npublic fun KtModule.allDirectDependencies(): Sequence<KtModule> =\n    sequence {\n        yieldAll(directRegularDependencies)\n        yieldAll(directDependsOnDependencies)\n        yieldAll(directFriendDependencies)\n    }\n\n\npublic inline fun <reified M : KtModule> KtModule.allDirectDependenciesOfType(): Sequence<M> =\n    allDirectDependencies().filterIsInstance<M>()\n\n\npublic fun computeTr"}
{"code": "ansitiveDependsOnDependencies(directDependsOnDependencies: List<KtModule>): List<KtModule> =\n    topologicalSort(directDependsOnDependencies) { this.directDependsOnDependencies }\n\n\npublic enum class DanglingFileResolutionMode {\n    \n    PREFER_SELF,\n\n    \n    IGNORE_SELF\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.diagnostic.compiler.based\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.LLFirOnlyNonReversedTestSuppressor\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.compiler.based.AbstractLowLevelCompilerBasedTest\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.diagnostic.compiler.based.facades.LLFirAnalyzerFacadeFactoryWithoutPreresolve\nimport org.jetbrains.kotlin.fir.symbols.FirLazyResolveContractViolationException\nimport org.jetbrains.kotlin.test.WrappedException\nimport org.jetbrains.kotlin.test.builders.TestConfigurationBuilder\nimport org.jetbrains.kotlin.test.directives.model.DirectivesContainer\nimport org.jetbrains.kotlin.test.directives.model.SimpleDirectivesContainer\nimport org.jetbrains.kotlin.test.model.AfterAnalysisChecker\nimport org.jetbrains.kotlin.test.runners.baseFirDiagnosticTestConfiguration\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.moduleStruc"}
{"code": "ture\nimport org.jetbrains.kotlin.utils.bind\n\nabstract class AbstractDiagnosticCompilerTestDataTest : AbstractLowLevelCompilerBasedTest() {\n    override fun configureTest(builder: TestConfigurationBuilder) {\n        with(builder) {\n            baseFirDiagnosticTestConfiguration(\n                frontendFacade = ::LowLevelFirFrontendFacade.bind(LLFirAnalyzerFacadeFactoryWithoutPreresolve),\n                testDataConsistencyHandler = ::ReversedFirIdenticalChecker,\n            )\n\n            useAfterAnalysisCheckers(::ContractViolationSuppressor)\n            useAfterAnalysisCheckers(::LLFirOnlyNonReversedTestSuppressor)\n        }\n    }\n}\n\nprivate class ContractViolationSuppressor(testServices: TestServices) : AfterAnalysisChecker(testServices) {\n    override val directiveContainers: List<DirectivesContainer> get() = listOf(Companion)\n\n    override fun suppressIfNeeded(failedAssertions: List<WrappedException>): List<WrappedException> {\n        if (!isDisabled()) {\n            return failed"}
{"code": "Assertions\n        }\n\n        val filteredExceptions = failedAssertions.filterNot { it.cause is FirLazyResolveContractViolationException }\n        return if (filteredExceptions.isEmpty()) {\n            listOf(\n                AssertionError(\n                    \"Test contains $IGNORE_CONTRACT_VIOLATIONS directive but no errors was reported. Please remove directive\",\n                ).wrap()\n            )\n        } else {\n            emptyList()\n        }\n    }\n\n    private fun isDisabled(): Boolean = IGNORE_CONTRACT_VIOLATIONS in testServices.moduleStructure.allDirectives\n\n    companion object : SimpleDirectivesContainer() {\n        val IGNORE_CONTRACT_VIOLATIONS by directive(\"Temporary disables test with contract violation until the issue is fixed\")\n    }\n}\n"}
{"code": "@OptIn(Deprecated::class, Deprecated::class)\n@<expr>SuppressWarnings</expr>([\"unsued\", \"foo\"])\nfun test() {\n\n}"}
{"code": "// MEMBER_NAME_FILTER: copy\npackage one.two\n\nclass MyClass\n\ndata class MyD<caret>ataClass(val prop: MyClass) {\n    class MyClass\n}\n"}
{"code": "interface Base\nclass Inv<K> : Base\n\nfun foo(x: Int): Inv<Int> = TODO()\nfun foo(y: String): Inv<String> = TODO()\n\nfun <T, R : Number> bar(f: (T) -> Inv<R>, p: String = \"\") {}\n\nfun <T, R : Base> bar(f: (T) -> Inv<R>, p: Int = 4) {}\n\nfun test() {\n    bar(::foo)\n}\n"}
{"code": "interface I\n\nclass A(\n    p : Int\n) : I, <expr>Unresolved(p)</expr>\n"}
{"code": "package test\n\nclass Outer<T> {\n    inner class Inner\n}\n\nfun <T> Outer<T>.test(p: <expr>Outer<T>.Inner</expr>) {}"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental\n\nimport com.intellij.util.io.DataExternalizer\nimport org.jetbrains.kotlin.incremental.ClassNodeSnapshotter.snapshotClassExcludingMembers\nimport org.jetbrains.kotlin.incremental.ClassNodeSnapshotter.snapshotMethod\nimport org.jetbrains.kotlin.incremental.ClassNodeSnapshotter.sortClassMembers\nimport org.jetbrains.kotlin.incremental.KotlinClassInfo.ExtraInfo\nimport org.jetbrains.kotlin.incremental.storage.*\nimport org.jetbrains.kotlin.inline.InlineFunctionOrAccessor\nimport org.jetbrains.kotlin.inline.inlineFunctionsAndAccessors\nimport org.jetbrains.kotlin.load.kotlin.header.KotlinClassHeader\nimport org.jetbrains.kotlin.metadata.jvm.deserialization.BitEncoding\nimport org.jetbrains.kotlin.metadata.jvm.deserialization.JvmMemberSignature\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.resolve.jvm.JvmClassName\nimport org.jetbrains.org.objectweb.asm.*\nimport org.jetbrains.org.objectweb.asm.tree."}
{"code": "ClassNode\nimport org.jetbrains.org.objectweb.asm.tree.FieldNode\nimport org.jetbrains.org.objectweb.asm.tree.MethodNode\n\n\nclass KotlinClassInfo(\n    val classId: ClassId,\n    val classKind: KotlinClassHeader.Kind,\n    val classHeaderData: Array<String>, // Can be empty\n    val classHeaderStrings: Array<String>, // Can be empty\n    val multifileClassName: String?, // Not null iff classKind == KotlinClassHeader.Kind.MULTIFILE_CLASS_PART\n    val extraInfo: ExtraInfo\n) {\n\n    \n    class ExtraInfo(\n\n        \n        val classSnapshotExcludingMembers: Long?,\n\n        \n        val constantSnapshots: Map<String, Long>,\n\n        \n        val inlineFunctionOrAccessorSnapshots: Map<InlineFunctionOrAccessor, Long>,\n    )\n\n    val className: JvmClassName by lazy { JvmClassName.byClassId(classId) }\n\n    val protoMapValue: ProtoMapValue by lazy {\n        ProtoMapValue(\n            isPackageFacade = classKind != KotlinClassHeader.Kind.CLASS,\n            BitEncoding.decodeBytes(classHeaderData),\n       "}
{"code": "     classHeaderStrings\n        )\n    }\n\n    \n    val protoData: ProtoData by lazy {\n        check(classKind != KotlinClassHeader.Kind.MULTIFILE_CLASS) {\n            \"Proto data is not available for KotlinClassHeader.Kind.MULTIFILE_CLASS: $classId\"\n        }\n        protoMapValue.toProtoData(classId.packageFqName)\n    }\n\n    \n    val companionObject: ClassId? by lazy {\n        if (classKind == KotlinClassHeader.Kind.CLASS) {\n            (protoData as ClassProtoData).getCompanionObjectName()?.let {\n                classId.createNestedClassId(Name.identifier(it))\n            }\n        } else null\n    }\n\n    \n    val constantsInCompanionObject: List<String>? by lazy {\n        if (classKind == KotlinClassHeader.Kind.CLASS) {\n            val classProtoData = protoData as ClassProtoData\n            if (classProtoData.proto.isCompanionObject) {\n                classProtoData.getConstants()\n            } else null\n        } else null\n    }\n\n    companion object {\n\n        fun createFrom(kotlin"}
{"code": "Class: LocalFileKotlinClass): KotlinClassInfo {\n            return createFrom(kotlinClass.classId, kotlinClass.classHeader, kotlinClass.fileContents)\n        }\n\n        fun createFrom(classId: ClassId, classHeader: KotlinClassHeader, classContents: ByteArray): KotlinClassInfo {\n            return KotlinClassInfo(\n                classId,\n                classHeader.kind,\n                classHeader.data ?: classHeader.incompatibleData ?: emptyArray(),\n                classHeader.strings ?: emptyArray(),\n                classHeader.multifileClassName,\n                extraInfo = getExtraInfo(classHeader, classContents)\n            )\n        }\n    }\n}\n\nprivate fun getExtraInfo(classHeader: KotlinClassHeader, classContents: ByteArray): ExtraInfo {\n    val inlineFunctionsAndAccessors: Map<JvmMemberSignature.Method, InlineFunctionOrAccessor> =\n        inlineFunctionsAndAccessors(classHeader, excludePrivateMembers = true).associateBy { it.jvmMethodSignature }\n\n    // 1. Create a ClassNode th"}
{"code": "at will contain only required info\n    val classNode = ClassNode()\n\n    // 2. Load the class's contents into the ClassNode, keeping only info that is required to compute `ExtraInfo`:\n    //     - Keep only fields that are non-private constants\n    //     - Keep only methods that are non-private inline functions/accessors\n    //        + Do not filter out private methods because a *non-private* inline function/accessor may have a *private* corresponding method\n    //          in the bytecode (see `InlineOnlyKt.isInlineOnlyPrivateInBytecode`)\n    //        + Do not filter out method bodies\n    val classReader = ClassReader(classContents)\n    val selectiveClassVisitor = SelectiveClassVisitor(\n        classNode,\n        shouldVisitField = { _: JvmMemberSignature.Field, isPrivate: Boolean, isConstant: Boolean ->\n            !isPrivate && isConstant\n        },\n        shouldVisitMethod = { method: JvmMemberSignature.Method, _: Boolean ->\n            // Do not filter out private methods (see "}
{"code": "above comment)\n            method in inlineFunctionsAndAccessors.keys\n        }\n    )\n    val parsingOptions = if (inlineFunctionsAndAccessors.isNotEmpty()) {\n        // Do not pass (SKIP_CODE, SKIP_DEBUG) as method bodies and debug info (e.g., line numbers) are important for inline\n        // functions/accessors\n        0\n    } else {\n        // Pass (SKIP_CODE, SKIP_DEBUG) to improve performance as method bodies and debug info are not important when we're not analyzing\n        // inline functions/accessors\n        ClassReader.SKIP_CODE or ClassReader.SKIP_DEBUG\n    }\n    classReader.accept(selectiveClassVisitor, parsingOptions)\n\n    // 3. Sort fields and methods as their order is not important\n    sortClassMembers(classNode)\n\n    // 4. Snapshot the class\n    val classSnapshotExcludingMembers = if (classHeader.kind == KotlinClassHeader.Kind.CLASS) {\n        // Also exclude Kotlin metadata (see `ExtraInfo.classSnapshotExcludingMembers`'s kdoc)\n        snapshotClassExcludingMembers(clas"}
{"code": "sNode, alsoExcludeKotlinMetaData = true)\n    } else null\n\n    val constantSnapshots: Map<String, Long> = classNode.fields.associate { fieldNode ->\n        // Note: `fieldNode` is a constant because we kept only fields that are (non-private) constants in `classNode`\n        fieldNode.name to ConstantValueExternalizer.toByteArray(fieldNode.value!!).hashToLong()\n    }\n\n    val inlineFunctionOrAccessorSnapshots: Map<InlineFunctionOrAccessor, Long> = classNode.methods.associate { methodNode ->\n        // Note:\n        //   - Each of `classNode.methods` (`methodNode`) is an inline function/accessor because we kept only methods that are (non-private)\n        //     inline functions/accessors in `classNode`.\n        //   - Not all inline functions/accessors have a corresponding method in the bytecode (i.e., it's possible that\n        //     `classNode.methods.size < inlineFunctionsAndAccessors.size`). Specifically, internal/private inline functions/accessors may\n        //     be removed from "}
{"code": "the bytecode if code shrinker is used. For example, `kotlin-reflect-1.7.20.jar` contains\n        //     `/kotlin/reflect/jvm/internal/UtilKt.class` in which the internal inline function `reflectionCall` appears in the Kotlin\n        //     class metadata (also in the source file), but not in the bytecode. However, we can safely ignore those\n        //     inline functions/accessors because they are not declared in the bytecode and therefore can't be referenced.\n        val methodSignature = JvmMemberSignature.Method(name = methodNode.name, desc = methodNode.desc)\n        inlineFunctionsAndAccessors[methodSignature]!! to snapshotMethod(methodNode, classNode.version)\n    }\n\n    return ExtraInfo(classSnapshotExcludingMembers, constantSnapshots, inlineFunctionOrAccessorSnapshots)\n}\n\n\nclass SelectiveClassVisitor(\n    cv: ClassVisitor,\n    private val shouldVisitField: (JvmMemberSignature.Field, isPrivate: Boolean, isConstant: Boolean) -> Boolean,\n    private val shouldVisitMethod: (JvmMembe"}
{"code": "rSignature.Method, isPrivate: Boolean) -> Boolean,\n) : ClassVisitor(Opcodes.API_VERSION, cv) {\n\n    override fun visitField(access: Int, name: String, desc: String, signature: String?, value: Any?): FieldVisitor? {\n        // Note: A constant's value must be not-null. A static final field with a `null` value at the bytecode declaration is not a constant\n        // (whether the value is initialized later in the static initializer or not, it won't be inlined by the compiler).\n        val isConstant = access.isStaticFinal() && value != null\n\n        return if (shouldVisitField(JvmMemberSignature.Field(name, desc), access.isPrivate(), isConstant)) {\n            cv.visitField(access, name, desc, signature, value)\n        } else null\n    }\n\n    override fun visitMethod(access: Int, name: String, desc: String, signature: String?, exceptions: Array<out String>?): MethodVisitor? {\n        return if (shouldVisitMethod(JvmMemberSignature.Method(name, desc), access.isPrivate())) {\n            cv.v"}
{"code": "isitMethod(access, name, desc, signature, exceptions)\n        } else null\n    }\n\n    private fun Int.isPrivate() = (this and Opcodes.ACC_PRIVATE) != 0\n\n    private fun Int.isStaticFinal() = (this and (Opcodes.ACC_STATIC or Opcodes.ACC_FINAL)) == (Opcodes.ACC_STATIC or Opcodes.ACC_FINAL)\n\n}\n\n\nobject ClassNodeSnapshotter {\n\n    fun snapshotClass(classNode: ClassNode): Long {\n        val classWriter = ClassWriter(0)\n        classNode.accept(classWriter)\n        return classWriter.toByteArray().hashToLong()\n    }\n\n    fun snapshotClassExcludingMembers(classNode: ClassNode, alsoExcludeKotlinMetaData: Boolean = false): Long {\n        val originalFields = classNode.fields\n        val originalMethods = classNode.methods\n        val originalVisibleAnnotations = classNode.visibleAnnotations\n        classNode.fields = emptyList()\n        classNode.methods = emptyList()\n        if (alsoExcludeKotlinMetaData) {\n            classNode.visibleAnnotations = originalVisibleAnnotations?.filterNot { it.de"}
{"code": "sc == \"Lkotlin/Metadata;\" }\n        }\n        return snapshotClass(classNode).also {\n            classNode.fields = originalFields\n            classNode.methods = originalMethods\n            classNode.visibleAnnotations = originalVisibleAnnotations\n        }\n    }\n\n    fun snapshotField(fieldNode: FieldNode): Long {\n        val classNode = emptyClass()\n        classNode.fields.add(fieldNode)\n        return snapshotClass(classNode)\n    }\n\n    fun snapshotMethod(methodNode: MethodNode, classVersion: Int): Long {\n        val classNode = emptyClass()\n        classNode.version = classVersion // Class version is required when working with methods (without it, ASM may fail -- see KT-38857)\n        classNode.methods.add(methodNode)\n        return snapshotClass(classNode)\n    }\n\n    \n    fun sortClassMembers(classNode: ClassNode) {\n        classNode.fields.sortWith(compareBy({ it.name }, { it.desc }))\n        classNode.methods.sortWith(compareBy({ it.name }, { it.desc }))\n    }\n\n    private fun"}
{"code": " emptyClass() = ClassNode().also {\n        // A name is required\n        it.name = \"SomeClass\"\n    }\n}\n\n\nprivate object ConstantValueExternalizer : DataExternalizer<Any> by DelegateDataExternalizer(\n    listOf(\n        java.lang.Integer::class.java,\n        java.lang.Long::class.java,\n        java.lang.Float::class.java,\n        java.lang.Double::class.java,\n        java.lang.String::class.java\n    ),\n    listOf(IntExternalizer, LongExternalizer, FloatExternalizer, DoubleExternalizer, StringExternalizer)\n)\n\nfun ByteArray.hashToLong(): Long {\n    // Note: The returned type `Long` is 64-bit, but we currently don't have a good 64-bit hash function.\n    // The method below uses `md5` which is 128-bit and converts it to `Long`.\n    return md5()\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.config\n\nimport org.jetbrains.kotlin.fir.analysis.CheckersComponentInternal\nimport org.jetbrains.kotlin.fir.analysis.checkers.LanguageVersionSettingsCheckers\n\nclass ComposedLanguageVersionSettingsCheckers : LanguageVersionSettingsCheckers() {\n\n    override val languageVersionSettingsCheckers: Set<FirLanguageVersionSettingsChecker>\n        get() = _languageVersionSettingsCheckers\n\n    private val _languageVersionSettingsCheckers: MutableSet<FirLanguageVersionSettingsChecker> = mutableSetOf()\n\n    @CheckersComponentInternal\n    fun register(checkers: LanguageVersionSettingsCheckers) {\n        _languageVersionSettingsCheckers += checkers.languageVersionSettingsCheckers\n    }\n\n}"}
{"code": "// FILE: main.kt\nclass A : B {\n    override fun foo(x: Int) {\n    }\n\n    override fun foo<caret>(x: String) {\n    }\n}\n\n// FILE: B.kt\ninterface B: C, D\n\n// FILE: C.kt\ninterface C {\n    fun foo(x: Int)\n    fun foo(x: String)\n}\n\n// FILE: D.kt\ninterface D {\n    fun foo(x: Int)\n    fun foo(x: String)\n}\n\n\n// RESULT\n// ALL:\n// C.foo(x: String): Unit\n// D.foo(x: String): Unit\n\n// DIRECT:\n// C.foo(x: String): Unit\n// D.foo(x: String): Unit\n"}
{"code": "object Delegate {\n    operator fun getValue(instance: Any?, property: Any) : String = \"\"\n    operator fun setValue(instance: Any?, property: Any, value: String) {}\n}\n\n<!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var test: Int\n<!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var kest by Delegate\n\nlateinit var good: String\n\nclass A {\n    <!INAPPLICABLE_LATEINIT_MODIFIER, INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> val fest = \"10\"\n    lateinit var mest: String\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var xest: String?\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var nest: Int\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var west: Char\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var qest: Boolean\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var aest: Short\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var hest: Byte\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var jest: Long\n    <!INAPPLICABLE_LATEINIT_MODIFIER, INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<"}
{"code": "!> val dest: String\n        get() = \"KEKER\"\n}\n\nclass B<T> {\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var best: T\n}\n\nclass C<K : Any> {\n    lateinit var pest: K\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var vest: K?\n}\n\nfun rest() {\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var i: Int\n    lateinit var a: A\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var b: B<String> = B()\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.base\n\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.test.framework.test.configurators.AnalysisApiTestConfigurator\nimport org.jetbrains.kotlin.analysis.utils.printer.prettyPrint\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.assertions\n\nabstract class AbstractSymbolLightClassesStructureTest(\n    configurator: AnalysisApiTestConfigurator,\n    testPrefix: String,\n    stopIfCompilationErrorDirectivePresent: Boolean,\n) : AbstractSymbolLightClassesStructureTestBase(configurator, testPrefix, stopIfCompilationErrorDirectivePresent) {\n\n    override fun doLightClassTest(ktFiles: List<KtFile>, module: KtTestModule, testServices: TestServices) {\n        val result = prettyPrint {\n            for (ktFile in ktFiles.sortedBy(KtFile::getName)) {\n                if (ktFiles.size > 1) {\n    "}
{"code": "                appendLine(\"${ktFile.name}:\")\n                    withIndent {\n                        handleFile(ktFile)\n                    }\n                } else {\n                    handleFile(ktFile)\n                }\n            }\n        }\n\n        testServices.assertions.assertEqualsToTestDataFileSibling(result, testPrefix = testPrefix)\n        doTestInheritors(ktFiles, testServices)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.types\n\nimport org.jetbrains.kotlin.fir.symbols.ConeTypeParameterLookupTag\n\nabstract class ConeTypeParameterType : ConeLookupTagBasedType() {\n    abstract override val lookupTag: ConeTypeParameterLookupTag\n}\n"}
{"code": "object X\n\nclass Y {\n    fun f(op: X.() -> Unit) {\n        X.op()\n\n        val x = X\n        x.op()\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen\n\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.descriptors.annotations.Annotations\nimport org.jetbrains.kotlin.descriptors.impl.PropertyDescriptorImpl\nimport org.jetbrains.kotlin.descriptors.impl.PropertyGetterDescriptorImpl\nimport org.jetbrains.kotlin.descriptors.impl.PropertySetterDescriptorImpl\nimport org.jetbrains.kotlin.descriptors.impl.TypeParameterDescriptorImpl\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.resolve.DescriptorFactory\nimport org.jetbrains.kotlin.resolve.DescriptorUtils\nimport org.jetbrains.kotlin.types.KotlinType\n\nopen class AccessorForPropertyDescriptor private constructor(\n    override val calleeDescriptor: PropertyDescriptor,\n    propertyType: KotlinType,\n    receiverType: KotlinType?,\n    dispatchReceiverParameter: ReceiverParameterDescriptor?,\n    containingDeclaration: DeclarationDescriptor,\n    override val superCallTarget: ClassDescriptor?,\n    val accessorSuffix: String,\n  "}
{"code": "  val isWithSyntheticGetterAccessor: Boolean,\n    val isWithSyntheticSetterAccessor: Boolean,\n    final override val accessorKind: AccessorKind\n) : PropertyDescriptorImpl(\n    containingDeclaration,\n    null,\n    Annotations.EMPTY,\n    Modality.FINAL,\n    DescriptorVisibilities.LOCAL,\n    calleeDescriptor.isVar,\n    Name.identifier(\"access$$accessorSuffix\"),\n    CallableMemberDescriptor.Kind.DECLARATION,\n    SourceElement.NO_SOURCE,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false\n), AccessorForCallableDescriptor<PropertyDescriptor> {\n\n    constructor(\n        property: PropertyDescriptor,\n        containingDeclaration: DeclarationDescriptor,\n        superCallTarget: ClassDescriptor?,\n        nameSuffix: String,\n        getterAccessorRequired: Boolean,\n        setterAccessorRequired: Boolean,\n        accessorKind: AccessorKind\n    ) : this(\n        property, property.type, DescriptorUtils.getReceiverParameterType(property.extensionReceiverParameter),\n        \n        if"}
{"code": " (property.isJvmStaticInObjectOrClassOrInterface()) null else property.dispatchReceiverParameter,\n        containingDeclaration, superCallTarget, nameSuffix,\n        getterAccessorRequired, setterAccessorRequired,\n        accessorKind\n    )\n\n    protected constructor(\n        original: PropertyDescriptor,\n        propertyType: KotlinType,\n        receiverType: KotlinType?,\n        dispatchReceiverParameter: ReceiverParameterDescriptor?,\n        containingDeclaration: DeclarationDescriptor,\n        superCallTarget: ClassDescriptor?,\n        nameSuffix: String,\n        accessorKind: AccessorKind\n    ) : this(\n        original,\n        propertyType,\n        receiverType,\n        dispatchReceiverParameter,\n        containingDeclaration,\n        superCallTarget,\n        nameSuffix,\n        true,\n        true,\n        accessorKind\n    )\n\n    init {\n        setType(\n            propertyType,\n            emptyList<TypeParameterDescriptorImpl>(),\n            dispatchReceiverParameter,\n         "}
{"code": "   DescriptorFactory.createExtensionReceiverParameterForCallable(this, receiverType, Annotations.EMPTY),\n            original.contextReceiverParameters\n        )\n\n        val getterDescriptor =\n            if (isWithSyntheticGetterAccessor) Getter(this, accessorKind) else calleeDescriptor.getter as PropertyGetterDescriptorImpl?\n        val setterDescriptor = if (isWithSyntheticSetterAccessor) Setter(this, accessorKind) else calleeDescriptor.setter\n        initialize(getterDescriptor, setterDescriptor)\n    }\n\n    class Getter(property: AccessorForPropertyDescriptor, override val accessorKind: AccessorKind) : PropertyGetterDescriptorImpl(\n        property,\n        Annotations.EMPTY,\n        Modality.FINAL,\n        DescriptorVisibilities.LOCAL,\n        false,\n        false,\n        false,\n        CallableMemberDescriptor.Kind.DECLARATION,\n        null,\n        SourceElement.NO_SOURCE\n    ), AccessorForCallableDescriptor<PropertyGetterDescriptor> {\n\n        override val calleeDescriptor: P"}
{"code": "ropertyGetterDescriptor\n            get() = (correspondingProperty as AccessorForPropertyDescriptor).calleeDescriptor.getter!!\n\n        override val superCallTarget: ClassDescriptor?\n            get() = (correspondingProperty as AccessorForPropertyDescriptor).superCallTarget\n\n        init {\n            initialize(property.type)\n        }\n\n    }\n\n    class Setter(property: AccessorForPropertyDescriptor, override val accessorKind: AccessorKind) : PropertySetterDescriptorImpl(\n        property,\n        Annotations.EMPTY,\n        Modality.FINAL,\n        DescriptorVisibilities.LOCAL,\n        false,\n        false,\n        false,\n        CallableMemberDescriptor.Kind.DECLARATION,\n        null,\n        SourceElement.NO_SOURCE\n    ), AccessorForCallableDescriptor<PropertySetterDescriptor> {\n\n        override val calleeDescriptor: PropertySetterDescriptor\n            get() = (correspondingProperty as AccessorForPropertyDescriptor).calleeDescriptor.setter!!\n\n        override val superCallTarget: "}
{"code": "ClassDescriptor?\n            get() = (correspondingProperty as AccessorForPropertyDescriptor).superCallTarget\n\n        init {\n            initializeDefault()\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.asJava.elements\n\nimport com.intellij.navigation.ItemPresentationProviders\nimport com.intellij.openapi.util.TextRange\nimport com.intellij.psi.PsiElement\nimport com.intellij.psi.impl.light.LightElement\nimport org.jetbrains.kotlin.idea.KotlinLanguage\nimport org.jetbrains.kotlin.psi.KtElement\n\nabstract class KtLightElementBase(private var parent: PsiElement) : LightElement(parent.manager, KotlinLanguage.INSTANCE) {\n    override fun toString() = \"${this.javaClass.simpleName} of $parent\"\n    override fun getParent(): PsiElement = parent\n\n    abstract val kotlinOrigin: KtElement?\n\n    @Deprecated(\"Hack for ULC\", level = DeprecationLevel.ERROR)\n    fun setParent(newParent: PsiElement) {\n        parent = newParent\n    }\n\n    override fun getText() = kotlinOrigin?.text ?: \"\"\n    override fun getTextRange() = kotlinOrigin?.textRange ?: TextRange.EMPTY_RANGE\n    override fun getTextOffset() = kotlinOrigin?.textOffset ?: 0\n    override fun getStartOffsetInParent() = k"}
{"code": "otlinOrigin?.startOffsetInParent ?: 0\n    override fun isWritable() = kotlinOrigin?.isWritable ?: false\n    override fun getNavigationElement() = kotlinOrigin?.navigationElement ?: this\n    override fun getUseScope() = kotlinOrigin?.useScope ?: super.getUseScope()\n    override fun getContainingFile() = parent.containingFile\n    override fun getPresentation() = (kotlinOrigin ?: this).let { ItemPresentationProviders.getItemPresentation(it) }\n    override fun isValid() = parent.isValid && (kotlinOrigin?.isValid != false)\n    override fun findElementAt(offset: Int) = kotlinOrigin?.findElementAt(offset)\n    override fun isEquivalentTo(another: PsiElement?): Boolean {\n        if (super.isEquivalentTo(another)) {\n            return true\n        }\n\n        val origin = kotlinOrigin ?: return false\n        return origin.isEquivalentTo(another) ||\n                (another is KtLightElementBase && origin.isEquivalentTo(another.kotlinOrigin))\n    }\n}"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\")\n\npackage org.jetbrains.kotlin.fir.expressions.impl\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.MutableOrEmptyList\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.fir.visitors.transformInplace\n\n@OptIn(UnresolvedExpressionTypeAccess::class)\ninternal class FirTypeOperatorCallImpl(\n    override val source: KtSourceElement?,\n    @property:UnresolvedExpressionTypeAccess\n    override var coneTypeOrNull: ConeKotlinType?,\n    override var annotations: MutableOrEmptyList<FirAnnotation>,\n    override var argumentList: FirAr"}
{"code": "gumentList,\n    override val operation: FirOperation,\n    override var conversionTypeRef: FirTypeRef,\n) : FirTypeOperatorCall() {\n    override var argFromStubType: Boolean = false\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {\n        annotations.forEach { it.accept(visitor, data) }\n        argumentList.accept(visitor, data)\n        conversionTypeRef.accept(visitor, data)\n    }\n\n    override fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirTypeOperatorCallImpl {\n        transformConversionTypeRef(transformer, data)\n        transformOtherChildren(transformer, data)\n        return this\n    }\n\n    override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirTypeOperatorCallImpl {\n        annotations.transformInplace(transformer, data)\n        return this\n    }\n\n    override fun <D> transformConversionTypeRef(transformer: FirTransformer<D>, data: D): FirTypeOperatorCallImpl {\n        conversionTypeRef = conversionTy"}
{"code": "peRef.transform(transformer, data)\n        return this\n    }\n\n    override fun <D> transformOtherChildren(transformer: FirTransformer<D>, data: D): FirTypeOperatorCallImpl {\n        transformAnnotations(transformer, data)\n        argumentList = argumentList.transform(transformer, data)\n        return this\n    }\n\n    override fun replaceConeTypeOrNull(newConeTypeOrNull: ConeKotlinType?) {\n        coneTypeOrNull = newConeTypeOrNull\n    }\n\n    override fun replaceAnnotations(newAnnotations: List<FirAnnotation>) {\n        annotations = newAnnotations.toMutableOrEmpty()\n    }\n\n    override fun replaceArgumentList(newArgumentList: FirArgumentList) {\n        argumentList = newArgumentList\n    }\n\n    override fun replaceArgFromStubType(newArgFromStubType: Boolean) {\n        argFromStubType = newArgFromStubType\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.sessions\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators.AnalysisApiFirSourceTestConfigurator\nimport org.jetbrains.kotlin.analysis.project.structure.KtModule\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.analysis.test.framework.directives.ModificationEventKind\nimport org.jetbrains.kotlin.analysis.test.framework.directives.publishWildcardModificationEventsByDirective\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.ktTestModuleStructure\nimport org.jetbrains.kotlin.analysis.test.framework.test.configurators.AnalysisApiTestConfigurator\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.assertions\nimport org.jetbrains.kotlin.test.services.moduleStructure\n\n\nabstract class AbstractSessionInvalidationTest : AbstractAnalysisApiBasedTest() {\n    protected abstract val modificati"}
{"code": "onEventKind: ModificationEventKind\n\n    override fun doTest(testServices: TestServices) {\n        val allKtModules = testServices.ktTestModuleStructure.mainModules.map { it.ktModule }\n\n        val sessionsBeforeModification = getSessionsFor(allKtModules)\n        testServices.ktTestModuleStructure.publishWildcardModificationEventsByDirective(modificationEventKind)\n        val sessionsAfterModification = getSessionsFor(allKtModules)\n\n        val invalidatedSessions = buildSet {\n            addAll(sessionsBeforeModification)\n            removeAll(sessionsAfterModification)\n        }\n\n        checkInvalidatedModules(invalidatedSessions, testServices)\n        checkSessionsMarkedInvalid(invalidatedSessions, testServices)\n    }\n\n    private fun getSessionsFor(modules: List<KtModule>): List<LLFirSession> {\n        val project = modules.first().project\n        val sessionCache = LLFirSessionCache.getInstance(project)\n        return modules.map { sessionCache.getSession(it) }\n    }\n\n    private "}
{"code": "fun checkInvalidatedModules(\n        invalidatedSessions: Set<LLFirSession>,\n        testServices: TestServices,\n    ) {\n        val testModuleNames = testServices.moduleStructure.modules.map { it.name }\n\n        val invalidatedModuleDescriptions = invalidatedSessions\n            .map { it.ktModule.toString() }\n            .filter {\n                // We only want to include test modules in the output. Otherwise, it might include libraries from the test infrastructure.\n                it in testModuleNames\n            }\n            .distinct()\n            .sorted()\n\n        val actualText = buildString {\n            appendLine(\"Module names of invalidated sessions:\")\n            invalidatedModuleDescriptions.forEach { appendLine(it) }\n        }\n\n        testServices.assertions.assertEqualsToTestDataFileSibling(actualText, extension = \".${modificationEventKind.name.lowercase()}.txt\")\n    }\n\n    private fun checkSessionsMarkedInvalid(\n        invalidatedSessions: Set<LLFirSession>,\n     "}
{"code": "   testServices: TestServices,\n    ) {\n        invalidatedSessions.forEach { session ->\n            testServices.assertions.assertFalse(session.isValid) {\n                \"The invalidated session `${session}` should have been marked invalid.\"\n            }\n        }\n    }\n\n    override val configurator: AnalysisApiTestConfigurator = AnalysisApiFirSourceTestConfigurator(analyseInDependentSession = false)\n}\n\nabstract class AbstractModuleStateModificationSessionInvalidationTest : AbstractSessionInvalidationTest() {\n    override val modificationEventKind: ModificationEventKind\n        get() = ModificationEventKind.MODULE_STATE_MODIFICATION\n}\n\nabstract class AbstractModuleOutOfBlockModificationSessionInvalidationTest : AbstractSessionInvalidationTest() {\n    override val modificationEventKind: ModificationEventKind\n        get() = ModificationEventKind.MODULE_OUT_OF_BLOCK_MODIFICATION\n}\n\nabstract class AbstractGlobalModuleStateModificationSessionInvalidationTest : AbstractSessionInvalidatio"}
{"code": "nTest() {\n    override val modificationEventKind: ModificationEventKind\n        get() = ModificationEventKind.GLOBAL_MODULE_STATE_MODIFICATION\n}\n\nabstract class AbstractGlobalSourceModuleStateModificationSessionInvalidationTest : AbstractSessionInvalidationTest() {\n    override val modificationEventKind: ModificationEventKind\n        get() = ModificationEventKind.GLOBAL_SOURCE_MODULE_STATE_MODIFICATION\n}\n\nabstract class AbstractGlobalSourceOutOfBlockModificationSessionInvalidationTest : AbstractSessionInvalidationTest() {\n    override val modificationEventKind: ModificationEventKind\n        get() = ModificationEventKind.GLOBAL_SOURCE_OUT_OF_BLOCK_MODIFICATION\n}\n"}
{"code": "// FIR_IDENTICAL\n\n// KNM_K2_IGNORE\n\npackage test\n\npublic class OuterClassesWithFlexibleArgs<K, L>(k: K, l: L) {\n    val baz = d.JavaClass.baz(k, l)\n}"}
{"code": "enum class SomeEnum {\n    A, B\n}\n\nfun test_1(enum: SomeEnum) {\n    val x = <!NO_ELSE_IN_WHEN!>when<!> (enum) {\n        SomeEnum.A -> 1\n    }\n\n    val y = when (enum) {\n        SomeEnum.A -> 1\n        SomeEnum.B -> 2\n    }\n}\n\nfun test_2(enum: SomeEnum?) {\n    val x = <!NO_ELSE_IN_WHEN!>when<!> (enum) {\n        SomeEnum.A -> 1\n        SomeEnum.B -> 2\n    }\n\n    val y = when (enum) {\n        SomeEnum.A -> 1\n        SomeEnum.B -> 2\n        null -> 3\n    }\n}\n\nfun test_3(enum: SomeEnum) {\n    <!NO_ELSE_IN_WHEN!>when<!> (enum) {\n        SomeEnum.A -> 1\n    }\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\", \"unused\")\n\npackage org.jetbrains.kotlin.fir.declarations.builder\n\nimport kotlin.contracts.*\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirImplementationDetail\nimport org.jetbrains.kotlin.fir.FirModuleData\nimport org.jetbrains.kotlin.fir.builder.FirAnnotationContainerBuilder\nimport org.jetbrains.kotlin.fir.builder.FirBuilderDsl\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.contracts.FirContractDescription\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.declarations.impl.FirPrimaryConstructor\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirBlock\nimport org.jetbrains.kotlin.fir.expressions.FirDelegatedConstructorCall\nimport org.jetbrains.kotlin.fir.references.FirControlFlowG"}
{"code": "raphReference\nimport org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol\nimport org.jetbrains.kotlin.fir.types.ConeSimpleKotlinType\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedContainerSource\n\n@FirBuilderDsl\nclass FirPrimaryConstructorBuilder : FirAbstractConstructorBuilder, FirAnnotationContainerBuilder {\n    override var source: KtSourceElement? = null\n    override var resolvePhase: FirResolvePhase = FirResolvePhase.RAW_FIR\n    override lateinit var moduleData: FirModuleData\n    override lateinit var origin: FirDeclarationOrigin\n    override var attributes: FirDeclarationAttributes = FirDeclarationAttributes()\n    override val typeParameters: MutableList<FirTypeParameterRef> = mutableListOf()\n    override lateinit var status: FirDeclarationStatus\n    override lateinit var returnTypeRef: FirTypeRef\n    override var receiverParameter: FirReceiverParameter? = null\n    override var deprecationsP"}
{"code": "rovider: DeprecationsProvider = UnresolvedDeprecationProvider\n    override var containerSource: DeserializedContainerSource? = null\n    override var dispatchReceiverType: ConeSimpleKotlinType? = null\n    override val contextReceivers: MutableList<FirContextReceiver> = mutableListOf()\n    override val valueParameters: MutableList<FirValueParameter> = mutableListOf()\n    override var contractDescription: FirContractDescription? = null\n    override val annotations: MutableList<FirAnnotation> = mutableListOf()\n    override lateinit var symbol: FirConstructorSymbol\n    override var delegatedConstructor: FirDelegatedConstructorCall? = null\n    override var body: FirBlock? = null\n\n    @OptIn(FirImplementationDetail::class)\n    override fun build(): FirConstructor {\n        return FirPrimaryConstructor(\n            source,\n            resolvePhase,\n            moduleData,\n            origin,\n            attributes,\n            typeParameters,\n            status,\n            returnTypeRef,\n    "}
{"code": "        receiverParameter,\n            deprecationsProvider,\n            containerSource,\n            dispatchReceiverType,\n            contextReceivers.toMutableOrEmpty(),\n            valueParameters,\n            contractDescription,\n            annotations.toMutableOrEmpty(),\n            symbol,\n            delegatedConstructor,\n            body,\n        )\n    }\n\n\n    @Deprecated(\"Modification of 'controlFlowGraphReference' has no impact for FirPrimaryConstructorBuilder\", level = DeprecationLevel.HIDDEN)\n    override var controlFlowGraphReference: FirControlFlowGraphReference?\n        get() = throw IllegalStateException()\n        set(_) {\n            throw IllegalStateException()\n        }\n}\n\n@OptIn(ExperimentalContracts::class)\ninline fun buildPrimaryConstructor(init: FirPrimaryConstructorBuilder.() -> Unit): FirConstructor {\n    contract {\n        callsInPlace(init, InvocationKind.EXACTLY_ONCE)\n    }\n    return FirPrimaryConstructorBuilder().apply(init).build()\n}\n"}
{"code": "val a = 10\n<expr>val x = 1</expr>\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.scopes\n\nimport org.jetbrains.kotlin.fir.scopes.FirContainingNamesAwareScope\nimport org.jetbrains.kotlin.fir.scopes.processAllCallables\nimport org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirVariableSymbol\nimport org.jetbrains.kotlin.name.Name\n\n\ninternal abstract class FirCallableFilteringScope(private val baseScope: FirContainingNamesAwareScope) : FirContainingNamesAwareScope() {\n    protected abstract fun isTargetCallable(callable: FirCallableSymbol<*>): Boolean\n\n    private val cachedCallableNames by lazy(LazyThreadSafetyMode.NONE) {\n        buildSet {\n            baseScope.processAllCallables { callable ->\n                if (isTargetCallable(callable)) {\n                    add(callable.name)\n                }\n            }\n        }\n    }\n\n    override fun getCallableNames(): Set<Name> = cachedCallableNames\n\n   "}
{"code": " override fun processFunctionsByName(name: Name, processor: (FirNamedFunctionSymbol) -> Unit) {\n        if (!cachedCallableNames.contains(name)) return\n\n        baseScope.processFunctionsByName(name) { function ->\n            if (isTargetCallable(function)) {\n                processor(function)\n            }\n        }\n    }\n\n    override fun processPropertiesByName(name: Name, processor: (FirVariableSymbol<*>) -> Unit) {\n        if (!cachedCallableNames.contains(name)) return\n\n        baseScope.processPropertiesByName(name) { property ->\n            if (isTargetCallable(property)) {\n                processor(property)\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.calls.tasks\n\nimport org.jetbrains.kotlin.builtins.KotlinBuiltIns\nimport org.jetbrains.kotlin.builtins.createFunctionType\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.descriptors.annotations.Annotations\nimport org.jetbrains.kotlin.descriptors.impl.*\nimport org.jetbrains.kotlin.incremental.components.LookupLocation\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.resolve.DescriptorFactory\nimport org.jetbrains.kotlin.resolve.calls.util.isConventionCall\nimport org.jetbrains.kotlin.resolve.descriptorUtil.builtIns\nimport org.jetbrains.kotlin.resolve.scopes.MemberScopeImpl\nimport org.jetbrains.kotlin.resolve.scopes.receivers.TransientReceiver\nimport org.jetbrains.kotlin.storage.StorageManager\nimport org.jetbrains.kotlin.storage.getValue\nimport org.jetbrains.kotlin.types.*\nimport org.jetbrains.kotlin.types.expressions.OperatorConventions\n"}
{"code": "import org.jetbrains.kotlin.utils.Printer\nimport java.util.*\n\nclass DynamicCallableDescriptors(private val storageManager: StorageManager, builtIns: KotlinBuiltIns) {\n\n    val dynamicType by storageManager.createLazyValue {\n        createDynamicType(builtIns)\n    }\n\n    fun createDynamicDescriptorScope(call: Call, owner: DeclarationDescriptor) = object : MemberScopeImpl() {\n        override fun printScopeStructure(p: Printer) {\n            p.println(this::class.java.simpleName, \": dynamic candidates for \" + call)\n        }\n\n        override fun getContributedFunctions(name: Name, location: LookupLocation): Collection<SimpleFunctionDescriptor> {\n            if (isAugmentedAssignmentConvention(name)) return listOf()\n            if (call.callType == Call.CallType.INVOKE\n                && call.valueArgumentList == null && call.functionLiteralArguments.isEmpty()\n            ) {\n                // this means that we are looking for \"imaginary\" invokes,\n                // e.g. in `+d` we are"}
{"code": " looking for property \"plus\" with member \"invoke\"\n                return listOf()\n            }\n            return listOf(createDynamicFunction(owner, name, call))\n        }\n\n        \n        private fun isAugmentedAssignmentConvention(name: Name): Boolean {\n            val callee = call.calleeExpression\n            if (callee is KtOperationReferenceExpression) {\n                val token = callee.getReferencedNameElementType()\n                if (token in KtTokens.AUGMENTED_ASSIGNMENTS && OperatorConventions.ASSIGNMENT_OPERATIONS[token] != name) {\n                    return true\n                }\n            }\n            return false\n        }\n\n        override fun getContributedVariables(name: Name, location: LookupLocation): Collection<PropertyDescriptor> {\n            return if (call.valueArgumentList == null && call.valueArguments.isEmpty()) {\n                listOf(createDynamicProperty(owner, name, call))\n            } else listOf()\n        }\n    }\n\n    private fun createDynami"}
{"code": "cProperty(owner: DeclarationDescriptor, name: Name, call: Call): PropertyDescriptorImpl {\n        val propertyDescriptor = PropertyDescriptorImpl.create(\n            owner,\n            Annotations.EMPTY,\n            Modality.FINAL,\n            DescriptorVisibilities.PUBLIC,\n            true,\n            name,\n            CallableMemberDescriptor.Kind.DECLARATION,\n            SourceElement.NO_SOURCE,\n             false,\n             false,\n             false,\n             false,\n             false,\n             false\n        )\n        propertyDescriptor.setType(\n            dynamicType,\n            createTypeParameters(propertyDescriptor, call),\n            createDynamicDispatchReceiverParameter(propertyDescriptor),\n            null,\n            emptyList()\n        )\n\n        val getter = DescriptorFactory.createDefaultGetter(propertyDescriptor, Annotations.EMPTY)\n        getter.initialize(propertyDescriptor.type)\n        val setter = DescriptorFactory.createDefaultSetter(propertyDescri"}
{"code": "ptor, Annotations.EMPTY, Annotations.EMPTY)\n\n        propertyDescriptor.initialize(getter, setter)\n\n        return propertyDescriptor\n    }\n\n    private fun createDynamicFunction(owner: DeclarationDescriptor, name: Name, call: Call): SimpleFunctionDescriptorImpl {\n        val functionDescriptor = SimpleFunctionDescriptorImpl.create(\n            owner,\n            Annotations.EMPTY,\n            name,\n            CallableMemberDescriptor.Kind.DECLARATION,\n            SourceElement.NO_SOURCE\n        )\n        functionDescriptor.initialize(\n            null,\n            createDynamicDispatchReceiverParameter(functionDescriptor),\n            emptyList(),\n            createTypeParameters(functionDescriptor, call),\n            createValueParameters(functionDescriptor, call),\n            dynamicType,\n            Modality.FINAL,\n            DescriptorVisibilities.PUBLIC\n        )\n        functionDescriptor.setHasSynthesizedParameterNames(true)\n        functionDescriptor.isOperator = isConventio"}
{"code": "nCall(call)\n        return functionDescriptor\n    }\n\n    private fun createDynamicDispatchReceiverParameter(owner: CallableDescriptor): ReceiverParameterDescriptorImpl {\n        return ReceiverParameterDescriptorImpl(owner, TransientReceiver(dynamicType), Annotations.EMPTY)\n    }\n\n    private fun createTypeParameters(owner: DeclarationDescriptor, call: Call): List<TypeParameterDescriptor> =\n        call.typeArguments.indices.map { index\n            ->\n            TypeParameterDescriptorImpl.createWithDefaultBound(\n                owner,\n                Annotations.EMPTY,\n                false,\n                Variance.INVARIANT,\n                Name.identifier(\"T$index\"),\n                index,\n                storageManager\n            )\n        }\n\n    private fun createValueParameters(owner: FunctionDescriptor, call: Call): List<ValueParameterDescriptor> {\n        val parameters = ArrayList<ValueParameterDescriptor>()\n\n        fun addParameter(arg: ValueArgument, outType: KotlinType,"}
{"code": " varargElementType: KotlinType?) {\n            val index = parameters.size\n\n            parameters.add(\n                ValueParameterDescriptorImpl(\n                    owner,\n                    null,\n                    index,\n                    Annotations.EMPTY,\n                    arg.getArgumentName()?.asName ?: Name.identifier(\"p$index\"),\n                    outType,\n                     false,\n                     false,\n                     false,\n                    varargElementType,\n                    SourceElement.NO_SOURCE\n                )\n            )\n        }\n\n        fun getFunctionType(funLiteralExpr: KtLambdaExpression): KotlinType {\n            val funLiteral = funLiteralExpr.functionLiteral\n\n            val receiverType = funLiteral.receiverTypeReference?.let { dynamicType }\n            val contextReceiversTypes = funLiteral.contextReceivers.map { dynamicType }\n\n            val parameterTypes = funLiteral.valueParameters.map { dynamicType }\n\n            retur"}
{"code": "n createFunctionType(owner.builtIns, Annotations.EMPTY, receiverType, contextReceiversTypes, parameterTypes, null, dynamicType)\n        }\n\n        for (arg in call.valueArguments) {\n            val outType: KotlinType\n            val varargElementType: KotlinType?\n            var hasSpreadOperator = false\n\n            val argExpression = KtPsiUtil.deparenthesize(arg.getArgumentExpression())\n\n            when {\n                argExpression is KtLambdaExpression -> {\n                    outType = getFunctionType(argExpression)\n                    varargElementType = null\n                }\n\n                arg.getSpreadElement() != null -> {\n                    hasSpreadOperator = true\n                    outType = owner.builtIns.getArrayType(Variance.OUT_VARIANCE, dynamicType)\n                    varargElementType = dynamicType\n                }\n\n                else -> {\n                    outType = dynamicType\n                    varargElementType = null\n                }\n           "}
{"code": " }\n\n            addParameter(arg, outType, varargElementType)\n\n            if (hasSpreadOperator) {\n                for (funLiteralArg in call.functionLiteralArguments) {\n                    addParameter(\n                        funLiteralArg,\n                        funLiteralArg.getLambdaExpression()?.let { getFunctionType(it) } ?: TypeUtils.CANNOT_INFER_FUNCTION_PARAM_TYPE,\n                        null)\n                }\n\n                break\n            }\n        }\n\n        return parameters\n    }\n}\n\nfun DeclarationDescriptor.isDynamic(): Boolean {\n    if (this !is CallableDescriptor) return false\n    val dispatchReceiverParameter = dispatchReceiverParameter\n    return dispatchReceiverParameter != null && dispatchReceiverParameter.type.isDynamic()\n}\n"}
{"code": "package test\n\nenum class E {\n    A {\n        val x: String = \"\"\n    },\n    B;\n\n    val foo: Int = 5\n\n    fun bar() {\n        println(foo)\n    }\n}\n\n// class: test/E\n"}
{"code": "\n\npackage org.jetbrains.kotlin.benchmarks\n\nimport org.openjdk.jmh.annotations.*\nimport org.openjdk.jmh.infra.Blackhole\nimport java.util.concurrent.TimeUnit\n\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class IntArrayPlusBenchmark : AbstractSimpleFileBenchmark() {\n\n    @Param(\"1\", \"10\", \"100\", \"1000\", \"3000\", \"5000\", \"7000\", \"10000\")\n    private var size: Int = 0\n\n    @Benchmark\n    //@Fork(jvmArgsAppend = [\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005\"])\n    fun benchmark(bh: Blackhole) {\n        if (!isIR) error(\"Doesn't make sense to run it on old frontend on buildserver\")\n        analyzeGreenFile(bh)\n    }\n\n    override fun buildText() =\n            \"\"\"\n            |fun bar(x: IntArray, y: IntArray) {\n            |${(1..size).joinToString(\"\\n\") { \"    x + y\" }}\n            |}\n            \"\"\".trimMargin()\n}"}
{"code": "\n\n@file:OptIn(KtAnalysisApiInternals::class)\n\npackage org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base\n\nimport org.jetbrains.kotlin.analysis.api.*\nimport org.jetbrains.kotlin.analysis.api.annotations.*\nimport org.jetbrains.kotlin.analysis.api.base.KtConstantValue\nimport org.jetbrains.kotlin.analysis.api.base.KtContextReceiver\nimport org.jetbrains.kotlin.analysis.api.descriptors.Fe10AnalysisContext\nimport org.jetbrains.kotlin.analysis.api.descriptors.symbols.KtFe10FileSymbol\nimport org.jetbrains.kotlin.analysis.api.descriptors.symbols.KtFe10PackageSymbol\nimport org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.*\nimport org.jetbrains.kotlin.analysis.api.descriptors.symbols.psiBased.*\nimport org.jetbrains.kotlin.analysis.api.descriptors.symbols.psiBased.KtFe10PsiDefaultPropertyGetterSymbol\nimport org.jetbrains.kotlin.analysis.api.descriptors.symbols.psiBased.KtFe10PsiDefaultPropertySetterSymbol\nimport org.jetbrains.kotlin.analysis.api.descript"}
{"code": "ors.symbols.psiBased.KtFe10PsiDefaultSetterParameterSymbol\nimport org.jetbrains.kotlin.analysis.api.descriptors.symbols.psiBased.base.KtFe10PsiSymbol\nimport org.jetbrains.kotlin.analysis.api.descriptors.types.*\nimport org.jetbrains.kotlin.analysis.api.impl.base.KtContextReceiverImpl\nimport org.jetbrains.kotlin.analysis.api.symbols.*\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolKind\nimport org.jetbrains.kotlin.analysis.api.types.KtType\nimport org.jetbrains.kotlin.analysis.api.types.KtTypeNullability\nimport org.jetbrains.kotlin.analysis.utils.errors.unexpectedElementError\nimport org.jetbrains.kotlin.builtins.KotlinBuiltIns\nimport org.jetbrains.kotlin.builtins.StandardNames\nimport org.jetbrains.kotlin.builtins.functions.FunctionClassDescriptor\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget\nimport org.jetbrains.kotlin.descriptor"}
{"code": "s.impl.*\nimport org.jetbrains.kotlin.idea.KotlinLanguage\nimport org.jetbrains.kotlin.load.java.descriptors.JavaCallableMemberDescriptor\nimport org.jetbrains.kotlin.load.java.descriptors.JavaClassDescriptor\nimport org.jetbrains.kotlin.load.java.descriptors.JavaForKotlinOverridePropertyDescriptor\nimport org.jetbrains.kotlin.load.java.descriptors.JavaPropertyDescriptor\nimport org.jetbrains.kotlin.load.java.sources.JavaSourceElement\nimport org.jetbrains.kotlin.load.kotlin.toSourceElement\nimport org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.psi.KtCallElement\nimport org.jetbrains.kotlin.psi.KtClassOrObject\nimport org.jetbrains.kotlin.psi.KtExpression\nimport org.jetbrains.kotlin.renderer.DescriptorRenderer\nimport org.jetbrains.kotlin.resolve.DescriptorUtils\nimport org.jetbrains.kotlin.resolve.calls.inference.CapturedType\nimport org.jetbrains.kotlin.resolve.calls.tasks.isDynamic\nimport org.jetbr"}
{"code": "ains.kotlin.resolve.constants.*\nimport org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator\nimport org.jetbrains.kotlin.resolve.descriptorUtil.annotationClass\nimport org.jetbrains.kotlin.resolve.descriptorUtil.builtIns\nimport org.jetbrains.kotlin.resolve.lazy.descriptors.LazyAnnotationDescriptor\nimport org.jetbrains.kotlin.resolve.sam.SamConstructorDescriptor\nimport org.jetbrains.kotlin.resolve.scopes.receivers.ImplicitContextReceiver\nimport org.jetbrains.kotlin.resolve.source.PsiSourceElement\nimport org.jetbrains.kotlin.resolve.source.getPsi\nimport org.jetbrains.kotlin.synthetic.SyntheticJavaPropertyDescriptor\nimport org.jetbrains.kotlin.types.*\nimport org.jetbrains.kotlin.types.checker.NewCapturedType\nimport org.jetbrains.kotlin.types.checker.NewTypeVariableConstructor\nimport org.jetbrains.kotlin.types.error.ErrorType\nimport org.jetbrains.kotlin.types.error.ErrorTypeKind\nimport org.jetbrains.kotlin.types.error.ErrorUtils\n\ninternal val MemberDescriptor.ktSymbolK"}
{"code": "ind: KtSymbolKind\n    get() {\n        return when (this) {\n            is PropertyAccessorDescriptor -> KtSymbolKind.ACCESSOR\n            is SamConstructorDescriptor -> KtSymbolKind.SAM_CONSTRUCTOR\n            else -> when (containingDeclaration) {\n                is PackageFragmentDescriptor -> KtSymbolKind.TOP_LEVEL\n                is ClassDescriptor -> KtSymbolKind.CLASS_MEMBER\n                else -> KtSymbolKind.LOCAL\n            }\n        }\n    }\n\ninternal val CallableMemberDescriptor.isExplicitOverride: Boolean\n    get() {\n        return (this !is PropertyAccessorDescriptor\n                && kind != CallableMemberDescriptor.Kind.FAKE_OVERRIDE\n                && overriddenDescriptors.isNotEmpty())\n    }\n\ninternal val ClassDescriptor.isInterfaceLike: Boolean\n    get() = when (kind) {\n        ClassKind.CLASS, ClassKind.ENUM_CLASS, ClassKind.OBJECT, ClassKind.ENUM_ENTRY -> false\n        else -> true\n    }\n\ninternal fun DeclarationDescriptor.toKtSymbol(analysisContext: Fe10AnalysisC"}
{"code": "ontext): KtSymbol? {\n    if (this is ClassDescriptor && kind == ClassKind.ENUM_ENTRY) {\n        return KtFe10DescEnumEntrySymbol(this, analysisContext)\n    }\n\n    return when (this) {\n        is ClassifierDescriptor -> toKtClassifierSymbol(analysisContext)\n        is ReceiverParameterDescriptor -> toKtReceiverParameterSymbol(analysisContext)\n        is CallableDescriptor -> toKtCallableSymbol(analysisContext)\n        is PackageViewDescriptor -> toKtPackageSymbol(analysisContext)\n        else -> null\n    }\n}\n\ninternal fun ClassifierDescriptor.toKtClassifierSymbol(analysisContext: Fe10AnalysisContext): KtClassifierSymbol? {\n    return when (this) {\n        is TypeAliasDescriptor -> KtFe10DescTypeAliasSymbol(this, analysisContext)\n        is TypeParameterDescriptor -> KtFe10DescTypeParameterSymbol(this, analysisContext)\n        is ClassDescriptor -> toKtClassSymbol(analysisContext)\n        else -> null\n    }\n}\n\ninternal fun ClassDescriptor.toKtClassSymbol(analysisContext: Fe10AnalysisCont"}
{"code": "ext): KtClassOrObjectSymbol {\n    return if (DescriptorUtils.isAnonymousObject(this)) {\n        KtFe10DescAnonymousObjectSymbol(this, analysisContext)\n    } else {\n        KtFe10DescNamedClassOrObjectSymbol(this, analysisContext)\n    }\n}\n\ninternal fun PackageViewDescriptor.toKtPackageSymbol(analysisContext: Fe10AnalysisContext): KtPackageSymbol {\n    return KtFe10PackageSymbol(fqName, analysisContext)\n}\n\ninternal fun ReceiverParameterDescriptor.toKtReceiverParameterSymbol(analysisContext: Fe10AnalysisContext): KtReceiverParameterSymbol {\n    return KtFe10ReceiverParameterSymbol(this, analysisContext)\n}\n\ninternal fun KtSymbol.getDescriptor(): DeclarationDescriptor? {\n    return when (this) {\n        is KtFe10PsiSymbol<*, *> -> descriptor\n        is KtFe10DescSymbol<*> -> descriptor\n        is KtFe10DescSyntheticFieldSymbol -> descriptor\n        is KtFe10PsiDefaultPropertyGetterSymbol -> descriptor\n        is KtFe10PsiDefaultPropertySetterSymbol -> descriptor\n        is KtFe10PsiDefaultS"}
{"code": "etterParameterSymbol -> descriptor\n        is KtFe10DescDefaultPropertySetterSymbol -> null\n        is KtFe10DynamicFunctionDescValueParameterSymbol -> null\n        is KtFe10FileSymbol -> null\n        is KtFe10DescDefaultPropertySetterSymbol.DefaultKtValueParameterSymbol -> descriptor\n        is KtFe10PsiDefaultPropertySetterSymbol.DefaultKtValueParameterSymbol -> descriptor\n        is KtFe10DescDefaultBackingFieldSymbol, is KtFe10PsiDefaultBackingFieldSymbol -> null\n        is KtFe10PsiClassInitializerSymbol -> null\n        else -> unexpectedElementError(\"KtSymbol\", this)\n    }\n}\n\n\ninternal fun ConstructorDescriptor.toKtConstructorSymbol(analysisContext: Fe10AnalysisContext): KtConstructorSymbol {\n    if (this is TypeAliasConstructorDescriptor) {\n        return this.underlyingConstructorDescriptor.toKtConstructorSymbol(analysisContext)\n    }\n\n    return KtFe10DescConstructorSymbol(this, analysisContext)\n}\n\ninternal val CallableMemberDescriptor.ktHasStableParameterNames: Boolean\n    ge"}
{"code": "t() = when {\n        this is ConstructorDescriptor && isPrimary && constructedClass.kind == ClassKind.ANNOTATION_CLASS -> true\n        isExpect -> false\n        else -> when (this) {\n            is JavaCallableMemberDescriptor -> false\n            else -> hasStableParameterNames()\n        }\n    }\n\ninternal fun CallableDescriptor.toKtCallableSymbol(analysisContext: Fe10AnalysisContext): KtCallableSymbol? {\n    return when (val unwrapped = unwrapFakeOverrideIfNeeded()) {\n        is PropertyGetterDescriptor -> KtFe10DescPropertyGetterSymbol(unwrapped, analysisContext)\n        is PropertySetterDescriptor -> KtFe10DescPropertySetterSymbol(unwrapped, analysisContext)\n        is SamConstructorDescriptor -> KtFe10DescSamConstructorSymbol(unwrapped, analysisContext)\n        is ConstructorDescriptor -> unwrapped.toKtConstructorSymbol(analysisContext)\n        is FunctionDescriptor -> {\n            if (DescriptorUtils.isAnonymousFunction(unwrapped)) {\n                KtFe10DescAnonymousFunctionSym"}
{"code": "bol(unwrapped, analysisContext)\n            } else {\n                KtFe10DescFunctionSymbol.build(unwrapped, analysisContext)\n            }\n        }\n        is SyntheticFieldDescriptor -> KtFe10DescSyntheticFieldSymbol(unwrapped, analysisContext)\n        is LocalVariableDescriptor -> KtFe10DescLocalVariableSymbol(unwrapped, analysisContext)\n        is ValueParameterDescriptor -> KtFe10DescValueParameterSymbol(unwrapped, analysisContext)\n        is SyntheticJavaPropertyDescriptor -> KtFe10DescSyntheticJavaPropertySymbol(unwrapped, analysisContext)\n        is JavaForKotlinOverridePropertyDescriptor -> KtFe10DescSyntheticJavaPropertySymbolForOverride(unwrapped, analysisContext)\n        is JavaPropertyDescriptor -> KtFe10DescJavaFieldSymbol(unwrapped, analysisContext)\n        is PropertyDescriptorImpl -> KtFe10DescKotlinPropertySymbol(unwrapped, analysisContext)\n        else -> null\n    }\n}\n\n\ninternal fun CallableDescriptor.unwrapFakeOverrideIfNeeded(): CallableDescriptor {\n    val useS"}
{"code": "iteUnwrapped = unwrapUseSiteSubstitutionOverride()\n    if (useSiteUnwrapped !is CallableMemberDescriptor) return useSiteUnwrapped\n    if (useSiteUnwrapped.kind.isReal) return useSiteUnwrapped\n    val overriddenDescriptor = useSiteUnwrapped.overriddenDescriptors.singleOrNull()?.unwrapUseSiteSubstitutionOverride()\n        ?: return useSiteUnwrapped\n    if (hasTypeReferenceAffectingSignature(useSiteUnwrapped, overriddenDescriptor)) {\n        return useSiteUnwrapped\n    }\n    return overriddenDescriptor.unwrapFakeOverrideIfNeeded()\n}\n\nprivate fun hasTypeReferenceAffectingSignature(\n    descriptor: CallableMemberDescriptor,\n    overriddenDescriptor: CallableMemberDescriptor\n): Boolean {\n    val containingClass = (descriptor.containingDeclaration as? ClassifierDescriptorWithTypeParameters)\n    val typeParametersFromOuterClass = buildList { containingClass?.let { collectTypeParameters(it) } }\n    val allowedTypeParameters = (overriddenDescriptor.typeParameters + typeParametersFromOuterClass)."}
{"code": "toSet()\n    return overriddenDescriptor.returnType?.hasReferenceOtherThan(allowedTypeParameters) == true ||\n            overriddenDescriptor.extensionReceiverParameter?.type?.hasReferenceOtherThan(allowedTypeParameters) == true ||\n            overriddenDescriptor.valueParameters.any { it.type.hasReferenceOtherThan(allowedTypeParameters) }\n}\n\nprivate fun MutableList<TypeParameterDescriptor>.collectTypeParameters(innerClass: ClassifierDescriptorWithTypeParameters) {\n    if (!innerClass.isInner) return\n    val outerClass = innerClass.containingDeclaration as? ClassifierDescriptorWithTypeParameters ?: return\n    addAll(outerClass.declaredTypeParameters)\n    collectTypeParameters(outerClass)\n}\n\nprivate fun KotlinType.hasReferenceOtherThan(allowedTypeParameterDescriptors: Set<TypeParameterDescriptor>): Boolean {\n    return when (this) {\n        is SimpleType -> {\n            val declarationDescriptor = constructor.declarationDescriptor\n            if (declarationDescriptor !is AbstractTypePa"}
{"code": "rameterDescriptor) return false\n            declarationDescriptor !in allowedTypeParameterDescriptors ||\n                    declarationDescriptor.upperBounds.any { it.hasReferenceOtherThan(allowedTypeParameterDescriptors) }\n        }\n        else -> arguments.any { typeProjection ->\n            // A star projection type (lazily) built by type parameter will be yet another type with a star projection,\n            // resulting in stack overflow if we keep checking allowed type parameter descriptors\n            !typeProjection.isStarProjection &&\n                    typeProjection.type.hasReferenceOtherThan(allowedTypeParameterDescriptors)\n        }\n    }\n}\n\n\n@Suppress(\"UNCHECKED_CAST\")\nprivate fun <T : CallableDescriptor> T.unwrapUseSiteSubstitutionOverride(): T {\n    var current: CallableDescriptor = this\n    while (original != current) {\n        current = current.original\n    }\n    return current as T\n}\n\ninternal fun KotlinType.toKtType(analysisContext: Fe10AnalysisContext): KtType {\n"}
{"code": "    return when (val unwrappedType = unwrap()) {\n        is DynamicType -> KtFe10DynamicType(unwrappedType, analysisContext)\n        is FlexibleType -> KtFe10FlexibleType(unwrappedType, analysisContext)\n        is DefinitelyNotNullType -> KtFe10DefinitelyNotNullType(unwrappedType, analysisContext)\n        is ErrorType -> {\n            if (unwrappedType.kind.isUnresolved)\n                KtFe10ClassErrorType(unwrappedType, analysisContext)\n            else\n                KtFe10TypeErrorType(unwrappedType, analysisContext)\n        }\n        is CapturedType -> KtFe10CapturedType(unwrappedType, analysisContext)\n        is NewCapturedType -> KtFe10NewCapturedType(unwrappedType, analysisContext)\n        is SimpleType -> {\n            val typeParameterDescriptor = TypeUtils.getTypeParameterDescriptorOrNull(unwrappedType)\n            if (typeParameterDescriptor != null) {\n                return KtFe10TypeParameterType(unwrappedType, typeParameterDescriptor, analysisContext)\n            }\n\n   "}
{"code": "         val typeConstructor = unwrappedType.constructor\n\n            if (typeConstructor is NewTypeVariableConstructor) {\n                val newTypeParameterDescriptor = typeConstructor.originalTypeParameter\n                return if (newTypeParameterDescriptor != null) {\n                    KtFe10TypeParameterType(unwrappedType, newTypeParameterDescriptor, analysisContext)\n                } else {\n                    KtFe10ClassErrorType(ErrorUtils.createErrorType(ErrorTypeKind.UNRESOLVED_TYPE_PARAMETER_TYPE), analysisContext)\n                }\n            }\n\n            if (typeConstructor is IntersectionTypeConstructor) {\n                return KtFe10IntersectionType(unwrappedType, typeConstructor.supertypes, analysisContext)\n            }\n\n            return when (val typeDeclaration = typeConstructor.declarationDescriptor) {\n                is FunctionClassDescriptor -> KtFe10FunctionalType(unwrappedType, typeDeclaration, analysisContext)\n                is ClassDescriptor -> Kt"}
{"code": "Fe10UsualClassType(unwrappedType, typeDeclaration, analysisContext)\n                else -> {\n                    val errorType =\n                        ErrorUtils.createErrorType(ErrorTypeKind.UNRESOLVED_CLASS_TYPE, typeConstructor, typeDeclaration.toString())\n                    KtFe10ClassErrorType(errorType, analysisContext)\n                }\n            }\n\n        }\n        else -> error(\"Unexpected type $this\")\n    }\n}\n\ninternal fun TypeProjection.toKtTypeProjection(analysisContext: Fe10AnalysisContext): KtTypeProjection {\n    return if (isStarProjection) {\n        KtStarTypeProjection(analysisContext.token)\n    } else {\n        KtTypeArgumentWithVariance(type.toKtType(analysisContext), this.projectionKind, analysisContext.token)\n    }\n}\n\ninternal fun TypeParameterDescriptor.toKtTypeParameter(analysisContext: Fe10AnalysisContext): KtTypeParameterSymbol {\n    return KtFe10DescTypeParameterSymbol(this, analysisContext)\n}\n\ninternal fun DeclarationDescriptor.getSymbolOrigin(analysis"}
{"code": "Context: Fe10AnalysisContext): KtSymbolOrigin {\n    when (this) {\n        is SyntheticJavaPropertyDescriptor -> return KtSymbolOrigin.JAVA_SYNTHETIC_PROPERTY\n        is SyntheticFieldDescriptor -> return KtSymbolOrigin.PROPERTY_BACKING_FIELD\n        is SamConstructorDescriptor -> return KtSymbolOrigin.SAM_CONSTRUCTOR\n        is JavaClassDescriptor, is JavaCallableMemberDescriptor -> return KtSymbolOrigin.JAVA\n        is DeserializedDescriptor -> return KtSymbolOrigin.LIBRARY\n        is EnumEntrySyntheticClassDescriptor -> return containingDeclaration.getSymbolOrigin(analysisContext)\n        is CallableMemberDescriptor -> when (kind) {\n            CallableMemberDescriptor.Kind.DELEGATION -> return KtSymbolOrigin.DELEGATED\n            CallableMemberDescriptor.Kind.SYNTHESIZED -> return KtSymbolOrigin.SOURCE_MEMBER_GENERATED\n            else -> {\n                if (isDynamic()) {\n                    return KtSymbolOrigin.JS_DYNAMIC\n                }\n            }\n        }\n    }\n\n    val"}
{"code": " sourceElement = this.toSourceElement\n    if (sourceElement is JavaSourceElement) {\n        return KtSymbolOrigin.JAVA\n    }\n\n    val psi = sourceElement.getPsi()\n    if (psi != null) {\n        if (psi.language != KotlinLanguage.INSTANCE) {\n            return KtSymbolOrigin.JAVA\n        }\n\n        val virtualFile = psi.containingFile.virtualFile\n        return analysisContext.getOrigin(virtualFile)\n    } else { // psi == null\n        // Implicit lambda parameter\n        if (this is ValueParameterDescriptor && this.name == StandardNames.IMPLICIT_LAMBDA_PARAMETER_NAME) {\n            return KtSymbolOrigin.SOURCE_MEMBER_GENERATED\n        }\n    }\n\n    return KtSymbolOrigin.SOURCE\n}\n\ninternal val KotlinType.ktNullability: KtTypeNullability\n    get() = when {\n        this.isNullabilityFlexible() -> KtTypeNullability.UNKNOWN\n        this.isMarkedNullable -> KtTypeNullability.NULLABLE\n        else -> KtTypeNullability.NON_NULLABLE\n    }\n\ninternal val DeclarationDescriptorWithVisibility.ktVisibi"}
{"code": "lity: Visibility\n    get() = when (visibility) {\n        DescriptorVisibilities.PUBLIC -> Visibilities.Public\n        DescriptorVisibilities.PROTECTED -> Visibilities.Protected\n        DescriptorVisibilities.INTERNAL -> Visibilities.Internal\n        DescriptorVisibilities.PRIVATE -> Visibilities.Private\n        DescriptorVisibilities.PRIVATE_TO_THIS -> Visibilities.PrivateToThis\n        DescriptorVisibilities.LOCAL -> Visibilities.Local\n        DescriptorVisibilities.INVISIBLE_FAKE -> Visibilities.InvisibleFake\n        DescriptorVisibilities.INHERITED -> Visibilities.Inherited\n        else -> Visibilities.Unknown\n    }\n\ninternal val MemberDescriptor.ktModality: Modality\n    get() {\n        val selfModality = this.modality\n\n        if (selfModality == Modality.OPEN) {\n            val containingDeclaration = this.containingDeclaration\n            if (containingDeclaration is ClassDescriptor && containingDeclaration.modality == Modality.FINAL) {\n                if (this !is CallableMember"}
{"code": "Descriptor || dispatchReceiverParameter != null) {\n                    // Non-static open callables in final class are counted as final (to match FIR)\n                    return Modality.FINAL\n                }\n            }\n        }\n\n        return this.modality\n    }\n\ninternal fun ConstantValue<*>.toKtConstantValue(): KtConstantValue {\n    return when (this) {\n        is ErrorValue.ErrorValueWithMessage -> KtConstantValue.KtErrorConstantValue(message, sourcePsi = null)\n        is BooleanValue -> KtConstantValue.KtBooleanConstantValue(value, sourcePsi = null)\n        is DoubleValue -> KtConstantValue.KtDoubleConstantValue(value, sourcePsi = null)\n        is FloatValue -> KtConstantValue.KtFloatConstantValue(value, sourcePsi = null)\n        is NullValue -> KtConstantValue.KtNullConstantValue(sourcePsi = null)\n        is StringValue -> KtConstantValue.KtStringConstantValue(value, sourcePsi = null)\n        is ByteValue -> KtConstantValue.KtByteConstantValue(value, sourcePsi = null)\n    "}
{"code": "    is CharValue -> KtConstantValue.KtCharConstantValue(value, sourcePsi = null)\n        is IntValue -> KtConstantValue.KtIntConstantValue(value, sourcePsi = null)\n        is LongValue -> KtConstantValue.KtLongConstantValue(value, sourcePsi = null)\n        is ShortValue -> KtConstantValue.KtShortConstantValue(value, sourcePsi = null)\n        is UByteValue -> KtConstantValue.KtUnsignedByteConstantValue(value.toUByte(), sourcePsi = null)\n        is UIntValue -> KtConstantValue.KtUnsignedIntConstantValue(value.toUInt(), sourcePsi = null)\n        is ULongValue -> KtConstantValue.KtUnsignedLongConstantValue(value.toULong(), sourcePsi = null)\n        is UShortValue -> KtConstantValue.KtUnsignedShortConstantValue(value.toUShort(), sourcePsi = null)\n        else -> error(\"Unexpected constant value $value\")\n    }\n}\n\ninternal tailrec fun KotlinBuiltIns.areSameArrayTypeIgnoringProjections(left: KotlinType, right: KotlinType): Boolean {\n    val leftIsArray = KotlinBuiltIns.isArrayOrPrimitiveArray("}
{"code": "left)\n    val rightIsArray = KotlinBuiltIns.isArrayOrPrimitiveArray(right)\n\n    return when {\n        leftIsArray && rightIsArray -> areSameArrayTypeIgnoringProjections(getArrayElementType(left), getArrayElementType(right))\n        !leftIsArray && !rightIsArray -> left == right\n        else -> false\n    }\n}\n\n\ninternal fun List<ConstantValue<*>>.expandArrayAnnotationValue(\n    containingArrayType: KotlinType,\n    analysisContext: Fe10AnalysisContext,\n): List<KtAnnotationValue> = flatMap { constantValue: ConstantValue<*> ->\n    val constantType = constantValue.getType(analysisContext.resolveSession.moduleDescriptor)\n    if (analysisContext.builtIns.areSameArrayTypeIgnoringProjections(containingArrayType, constantType)) {\n        // If an element in the array has the same type as the containing array, it's a spread component that needs\n        // to be expanded here. (It should have the array element type instead.)\n        (constantValue as ArrayValue).value.expandArrayAnnotationValue(con"}
{"code": "tainingArrayType, analysisContext)\n    } else {\n        listOf(constantValue.toKtAnnotationValue(analysisContext))\n    }\n}\n\ninternal fun ConstantValue<*>.toKtAnnotationValue(analysisContext: Fe10AnalysisContext): KtAnnotationValue {\n    return when (this) {\n        is ArrayValue -> {\n            val arrayType = getType(analysisContext.resolveSession.moduleDescriptor)\n            KtArrayAnnotationValue(value.expandArrayAnnotationValue(arrayType, analysisContext), sourcePsi = null)\n        }\n        is EnumValue -> KtEnumEntryAnnotationValue(CallableId(enumClassId, enumEntryName), sourcePsi = null)\n        is KClassValue -> when (val value = value) {\n            is KClassValue.Value.LocalClass -> {\n                val descriptor = value.type.constructor.declarationDescriptor as ClassDescriptor\n                KtKClassAnnotationValue.KtLocalKClassAnnotationValue(descriptor.source.getPsi() as KtClassOrObject, sourcePsi = null)\n            }\n            is KClassValue.Value.NormalClass -> K"}
{"code": "tKClassAnnotationValue.KtNonLocalKClassAnnotationValue(value.classId, sourcePsi = null)\n        }\n\n        is AnnotationValue -> {\n            KtAnnotationApplicationValue(\n                KtAnnotationApplicationWithArgumentsInfo(\n                    value.annotationClass?.classId,\n                    psi = null,\n                    useSiteTarget = null,\n                    arguments = value.getKtNamedAnnotationArguments(analysisContext),\n                    index = null,\n                    constructorSymbolPointer = null,\n                )\n            )\n        }\n        else -> {\n            KtConstantAnnotationValue(toKtConstantValue())\n        }\n    }\n}\n\ninternal val CallableMemberDescriptor.callableIdIfNotLocal: CallableId?\n    get() = calculateCallableId(allowLocal = false)\n\ninternal fun CallableMemberDescriptor.calculateCallableId(allowLocal: Boolean): CallableId? {\n    if (this is SyntheticJavaPropertyDescriptor) {\n        return getMethod.calculateCallableId(allowLocal)?.copy"}
{"code": "(callableName = name)\n    }\n    var current: DeclarationDescriptor = containingDeclaration\n\n    val localName = mutableListOf<String>()\n    val className = mutableListOf<String>()\n\n    while (true) {\n        when (current) {\n            is PackageFragmentDescriptor -> {\n                return CallableId(\n                    packageName = current.fqName,\n                    className = if (className.isNotEmpty()) FqName.fromSegments(className.asReversed()) else null,\n                    callableName = name,\n                    pathToLocal = if (localName.isNotEmpty()) FqName.fromSegments(localName.asReversed()) else null\n                )\n            }\n            is ModuleDescriptor -> {\n                return CallableId(\n                    packageName = FqName.ROOT,\n                    className = if (className.isNotEmpty()) FqName.fromSegments(className.asReversed()) else null,\n                    callableName = name,\n                    pathToLocal = if (localName.isNotEmpty()) FqN"}
{"code": "ame.fromSegments(localName.asReversed()) else null\n                )\n            }\n            is ClassDescriptor -> {\n                if (current.kind == ClassKind.ENUM_ENTRY) {\n                    if (!allowLocal) {\n                        return null\n                    }\n\n                    localName += current.name.asString()\n                } else {\n                    className += current.name.asString()\n                }\n            }\n            is PropertyAccessorDescriptor -> {} // Filter out property accessors\n            is CallableDescriptor -> {\n                if (!allowLocal) {\n                    return null\n                }\n\n                localName += current.name.asString()\n            }\n        }\n\n        current = current.containingDeclaration ?: return null\n    }\n}\n\ninternal val PropertyDescriptor.getterCallableIdIfNotLocal: CallableId?\n    get() {\n        if (this is SyntheticPropertyDescriptor) {\n            return getMethod.callableIdIfNotLocal\n        }\n\n"}
{"code": "        return null\n    }\n\ninternal val PropertyDescriptor.setterCallableIdIfNotLocal: CallableId?\n    get() {\n        if (this is SyntheticPropertyDescriptor) {\n            val setMethod = this.setMethod\n            if (setMethod != null) {\n                return setMethod.callableIdIfNotLocal\n            }\n        }\n\n        return null\n    }\n\ninternal fun getSymbolDescriptor(symbol: KtSymbol): DeclarationDescriptor? {\n    return when (symbol) {\n        is KtFe10DescSymbol<*> -> symbol.descriptor\n        is KtFe10PsiSymbol<*, *> -> symbol.descriptor\n        is KtFe10DescSyntheticFieldSymbol -> symbol.descriptor\n        else -> null\n    }\n}\n\ninternal val ClassifierDescriptor.classId: ClassId?\n    get() = when (val owner = containingDeclaration) {\n        is PackageFragmentDescriptor -> ClassId(owner.fqName, name)\n        is ClassifierDescriptorWithTypeParameters -> owner.classId?.createNestedClassId(name)\n        else -> null\n    }\n\ninternal val ClassifierDescriptor.maybeLocalClassId:"}
{"code": " ClassId\n    get() = classId ?: ClassId(containingPackage() ?: FqName.ROOT, FqName.topLevel(this.name), isLocal = true)\n\ninternal fun ClassDescriptor.getSupertypesWithAny(): Collection<KotlinType> {\n    val supertypes = typeConstructor.supertypes\n    if (isInterfaceLike) {\n        return supertypes\n    }\n\n    val hasClassSupertype = supertypes.any { (it.constructor.declarationDescriptor as? ClassDescriptor)?.kind == ClassKind.CLASS }\n    return if (hasClassSupertype) supertypes else listOf(builtIns.anyType) + supertypes\n}\n\n\ninternal fun CallableMemberDescriptor.getSymbolPointerSignature(): String {\n    return DescriptorRenderer.FQ_NAMES_IN_TYPES.render(this)\n}\n\ninternal fun createKtInitializerValue(\n    initializer: KtExpression?,\n    propertyDescriptor: PropertyDescriptor?,\n    analysisContext: Fe10AnalysisContext,\n): KtInitializerValue? {\n    if (initializer == null && propertyDescriptor?.compileTimeInitializer == null) {\n        return null\n    }\n\n    val compileTimeInitializer = pr"}
{"code": "opertyDescriptor?.compileTimeInitializer\n    if (compileTimeInitializer != null) {\n        return KtConstantInitializerValue(compileTimeInitializer.toKtConstantValue(), initializer)\n    }\n    if (initializer != null) {\n        val bindingContext = analysisContext.analyze(initializer)\n        val constantValue = ConstantExpressionEvaluator.getConstant(initializer, bindingContext)\n        if (constantValue != null) {\n            val evaluated = constantValue.toConstantValue(propertyDescriptor?.type ?: TypeUtils.NO_EXPECTED_TYPE).toKtConstantValue()\n            return KtConstantInitializerValue(evaluated, initializer)\n        }\n    }\n\n    return KtNonConstantInitializerValue(initializer)\n}\n\ninternal fun AnnotationDescriptor.toKtAnnotationApplication(\n    analysisContext: Fe10AnalysisContext,\n    index: Int,\n): KtAnnotationApplicationWithArgumentsInfo {\n    return KtAnnotationApplicationWithArgumentsInfo(\n        classId = classIdForAnnotation,\n        psi = psi,\n        useSiteTarget = us"}
{"code": "eSiteTarget,\n        arguments = getKtNamedAnnotationArguments(analysisContext),\n        index = index,\n        constructorSymbolPointer = null,\n    )\n}\n\ninternal fun AnnotationDescriptor.toKtAnnotationInfo(index: Int): KtAnnotationApplicationInfo = KtAnnotationApplicationInfo(\n    classId = classIdForAnnotation,\n    psi = psi,\n    useSiteTarget = useSiteTarget,\n    isCallWithArguments = allValueArguments.isNotEmpty(),\n    index = index,\n)\n\nprivate val AnnotationDescriptor.psi: KtCallElement? get() = (source as? PsiSourceElement)?.psi as? KtCallElement\ninternal val AnnotationDescriptor.classIdForAnnotation: ClassId? get() = annotationClass?.maybeLocalClassId\ninternal val AnnotationDescriptor.useSiteTarget: AnnotationUseSiteTarget?\n    get() = (this as? LazyAnnotationDescriptor)?.annotationEntry?.useSiteTarget?.getAnnotationUseSiteTarget()\n\ninternal fun AnnotationDescriptor.getKtNamedAnnotationArguments(analysisContext: Fe10AnalysisContext): List<KtNamedAnnotationValue> =\n    allValueAr"}
{"code": "guments.map { (name, value) ->\n        KtNamedAnnotationValue(name, value.toKtAnnotationValue(analysisContext))\n    }\n\ninternal fun CallableDescriptor.createContextReceivers(\n    analysisContext: Fe10AnalysisContext\n): List<KtContextReceiver> {\n    return contextReceiverParameters.map { createContextReceiver(it, analysisContext) }\n}\n\ninternal fun ClassDescriptor.createContextReceivers(\n    analysisContext: Fe10AnalysisContext\n): List<KtContextReceiver> {\n    return contextReceivers.map { createContextReceiver(it, analysisContext) }\n}\n\nprivate fun createContextReceiver(\n    contextReceiver: ReceiverParameterDescriptor,\n    analysisContext: Fe10AnalysisContext\n): KtContextReceiverImpl {\n    return KtContextReceiverImpl(\n        contextReceiver.value.type.toKtType(analysisContext),\n        (contextReceiver.value as ImplicitContextReceiver).customLabelName,\n        analysisContext.token\n    )\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.lazy.declarations\n\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtDestructuringDeclarationEntry\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter\n\nclass CombinedPackageMemberDeclarationProvider(\n    val providers: Collection<PackageMemberDeclarationProvider>\n) : PackageMemberDeclarationProvider {\n    override fun getAllDeclaredSubPackages(nameFilter: (Name) -> Boolean) = providers.flatMap { it.getAllDeclaredSubPackages(nameFilter) }\n\n    override fun getPackageFiles() = providers.flatMap { it.getPackageFiles() }\n\n    override fun containsFile(file: KtFile) = providers.any { it.containsFile(file) }\n\n    override fun getDeclarations(kindFilter: DescriptorKindFilter, nameFilter: (Name) -> Boolean) =\n        providers.flatMap { it.getDeclarations(kindFilter, nameFilter) }\n\n    override fun getFunctionDeclarations(name: Name) = providers.flatMap { it.getFunctionDeclarations(n"}
{"code": "ame) }\n\n    override fun getPropertyDeclarations(name: Name) = providers.flatMap { it.getPropertyDeclarations(name) }\n\n    override fun getDestructuringDeclarationsEntries(name: Name): Collection<KtDestructuringDeclarationEntry> {\n        return providers.flatMap { it.getDestructuringDeclarationsEntries(name) }\n    }\n\n    override fun getClassOrObjectDeclarations(name: Name) = providers.flatMap { it.getClassOrObjectDeclarations(name) }\n\n    override fun getScriptDeclarations(name: Name) = providers.flatMap { it.getScriptDeclarations(name) }\n\n    override fun getTypeAliasDeclarations(name: Name) = providers.flatMap { it.getTypeAliasDeclarations(name) }\n\n    override fun getDeclarationNames(): Set<Name> = providers.flatMapTo(HashSet()) { it.getDeclarationNames() }\n}\n"}
{"code": "// MODULE: context\n\n// FILE: context.kt\nfun test() {\n    with(\"Hello, world!\") {\n        with(Foo()) {\n            <caret_context>val x = 0\n        }\n    }\n}\n\nclass Foo {\n    val foo: String = \"foo\"\n}\n\n// MODULE: main\n// MODULE_KIND: CodeFragment\n// CONTEXT_MODULE: context\n\n// FILE: fragment.kt\n// CODE_FRAGMENT_KIND: EXPRESSION\nlength + foo.length"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.transformers\n\nimport kotlinx.collections.immutable.PersistentList\nimport kotlinx.collections.immutable.persistentListOf\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.targets.LLFirResolveTarget\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.targets.LLFirSingleResolveTarget\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.targets.asResolveTarget\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.tryCollectDesignation\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.sessions.LLFirSession\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.sessions.llFirSession\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.util.checkTypeRefIsResolved\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.util.errorWithFirSpecificEntries\nimport org.jetbrains.kotlin.fir.FirElementWithResolveState\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.java.declarations"}
{"code": ".FirJavaClass\nimport org.jetbrains.kotlin.fir.resolve.defaultType\nimport org.jetbrains.kotlin.fir.resolve.providers.symbolProvider\nimport org.jetbrains.kotlin.fir.resolve.transformers.FirSupertypeResolverVisitor\nimport org.jetbrains.kotlin.fir.resolve.transformers.SupertypeComputationSession\nimport org.jetbrains.kotlin.fir.resolve.transformers.SupertypeComputationStatus\nimport org.jetbrains.kotlin.fir.resolve.transformers.platformSupertypeUpdater\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassifierSymbol\nimport org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.fir.utils.exceptions.withFirEntry\n\ninternal object LLFirSupertypeLazyResolver : LLFirLazyResolver(FirResolvePhase.SUPER_TYPES) {\n    override fun createTargetResolver(target: LLFirResolveTarget): LLFirTargetResolver = LLFirSuperTypeTargetResolver(target)\n\n    override fun phaseSpecificCheckIsResolved(target: FirElementWithResolveState) {\n        when (tar"}
{"code": "get) {\n            is FirClass -> {\n                for (superTypeRef in target.superTypeRefs) {\n                    checkTypeRefIsResolved(superTypeRef, \"class super type\", target)\n                }\n            }\n\n            is FirTypeAlias -> {\n                checkTypeRefIsResolved(target.expandedTypeRef, typeRefName = \"type alias expanded type\", target)\n            }\n        }\n    }\n}\n\n\nprivate class LLFirSuperTypeTargetResolver(\n    target: LLFirResolveTarget,\n    private val supertypeComputationSession: LLFirSupertypeComputationSession = LLFirSupertypeComputationSession(),\n    private val visitedElements: MutableSet<FirElementWithResolveState> = hashSetOf(),\n) : LLFirTargetResolver(target, FirResolvePhase.SUPER_TYPES) {\n    private val supertypeResolver = object : FirSupertypeResolverVisitor(\n        session = resolveTargetSession,\n        supertypeComputationSession = supertypeComputationSession,\n        scopeSession = resolveTargetScopeSession,\n    ) {\n        \n        overrid"}
{"code": "e fun resolveAllSupertypesForOuterClass(outerClass: FirClass) {\n            // We can get into this function during a loop calculation, so it is possible that the result for [outerClass]\n            // is not yet published, so we expect that this class was already visited or resolved\n            if (outerClass !in visitedElements) {\n                outerClass.asResolveTarget()?.let { resolveTarget ->\n                    // It is possible in case of declaration collision,\n                    // so we need this logic only to be sure that [outerClass] is resolved\n                    resolveToSupertypePhase(resolveTarget)\n                }\n\n                LLFirSupertypeLazyResolver.checkIsResolved(outerClass)\n            }\n        }\n    }\n\n    @Deprecated(\"Should never be called directly, only for override purposes, please use withRegularClass\", level = DeprecationLevel.ERROR)\n    override fun withContainingRegularClass(firClass: FirRegularClass, action: () -> Unit) {\n        supertypeRes"}
{"code": "olver.withClass(firClass) {\n            doResolveWithoutLock(firClass)\n            action()\n        }\n    }\n\n    override fun doResolveWithoutLock(target: FirElementWithResolveState): Boolean {\n        val isVisited = !visitedElements.add(target)\n        if (isVisited) return true\n\n        when (target) {\n            is FirRegularClass -> performResolve(\n                declaration = target,\n                superTypeRefsForTransformation = {\n                    // We should create a copy of the original collection\n                    // to avoid [ConcurrentModificationException] during another thread publication\n                    ArrayList(target.superTypeRefs)\n                },\n                resolver = { supertypeResolver.resolveSpecificClassLikeSupertypes(target, it) },\n                superTypeUpdater = {\n                    target.replaceSuperTypeRefs(it)\n                    resolveTargetSession.platformSupertypeUpdater?.updateSupertypesIfNeeded(target, resolveTargetScopeSessi"}
{"code": "on)\n                },\n            )\n            is FirTypeAlias -> performResolve(\n                declaration = target,\n                superTypeRefsForTransformation = { target.expandedTypeRef },\n                resolver = { supertypeResolver.resolveTypeAliasSupertype(target, it, resolveRecursively = false) },\n                superTypeUpdater = { target.replaceExpandedTypeRef(it.single()) },\n            )\n            else -> {\n                performCustomResolveUnderLock(target) {\n                    // just update the phase\n                }\n            }\n        }\n\n        return true\n    }\n\n    \n    private inline fun <T : FirClassLikeDeclaration, S> performResolve(\n        declaration: T,\n        superTypeRefsForTransformation: () -> S,\n        resolver: (S) -> List<FirResolvedTypeRef>,\n        crossinline superTypeUpdater: (List<FirTypeRef>) -> Unit,\n    ) {\n        // To avoid redundant work, because a publication won't be executed\n        if (declaration.resolvePhase >= reso"}
{"code": "lverPhase) return\n\n        declaration.lazyResolveToPhase(resolverPhase.previous)\n\n        var superTypeRefs: S? = null\n        withReadLock(declaration) {\n            superTypeRefs = superTypeRefsForTransformation()\n        }\n\n        // \"null\" means that some other thread is already resolved [declaration] to [resolverPhase]\n        if (superTypeRefs == null) return\n\n        // 1. Resolve declaration super type refs\n        @Suppress(\"UNCHECKED_CAST\")\n        val resolvedSuperTypeRefs = resolver(superTypeRefs as S)\n\n        // 2. Resolve super declarations\n        val status = supertypeComputationSession.getSupertypesComputationStatus(declaration)\n        if (status is SupertypeComputationStatus.Computed) {\n            supertypeComputationSession.withDeclarationSession(declaration) {\n                for (computedType in status.supertypeRefs) {\n                    crawlSupertype(computedType.type)\n                }\n            }\n        }\n\n        // 3. Find loops\n        val loopedSup"}
{"code": "erTypeRefs = supertypeComputationSession.findLoopFor(declaration)\n\n        // 4. Get error type refs or already resolved\n        val resultedTypeRefs = loopedSuperTypeRefs ?: resolvedSuperTypeRefs\n\n        // 5. Publish the result\n        performCustomResolveUnderLock(declaration) {\n            superTypeUpdater(resultedTypeRefs)\n        }\n    }\n\n    private fun FirClassLikeDeclaration.asResolveTarget(): LLFirSingleResolveTarget? = tryCollectDesignation()?.asResolveTarget()\n\n    private fun resolveToSupertypePhase(target: LLFirSingleResolveTarget) {\n        LLFirSuperTypeTargetResolver(\n            target = target,\n            supertypeComputationSession = supertypeComputationSession,\n            visitedElements = visitedElements,\n        ).resolveDesignation()\n\n        LLFirSupertypeLazyResolver.checkIsResolved(target.target)\n    }\n\n    \n    private fun crawlSupertype(type: ConeKotlinType) {\n        // Resolution order: from declaration site to use site\n        for (session in supertyp"}
{"code": "eComputationSession.useSiteSessions.asReversed()) {\n            \n            type.toSymbol(session)?.let(::crawlSupertype)\n        }\n\n        if (type is ConeClassLikeType) {\n            // The `classLikeDeclaration` is not associated with a file, and thus there is no need to resolve it, but it may still point\n            // to declarations via its type arguments which need to be collected and have a containing file.\n            // For example, a `Function1` could point to a type alias.\n            type.typeArguments.forEach { it.type?.let { crawlSupertype(it) } }\n        }\n    }\n\n    private fun crawlSupertype(symbol: FirClassifierSymbol<*>) {\n        val classLikeDeclaration = symbol.fir\n        if (classLikeDeclaration !is FirClassLikeDeclaration) return\n        if (classLikeDeclaration in visitedElements) return\n\n        if (classLikeDeclaration.resolvePhase >= resolverPhase) {\n            visitedElements += classLikeDeclaration\n            if (classLikeDeclaration is FirJavaClass)"}
{"code": " {\n                // We do not have phases guarantees for Java classes, so we should process them with an assumption\n                // that there are some unresolved supertypes from the declaration site point of view\n                supertypeComputationSession.withDeclarationSession(classLikeDeclaration) {\n                    crawlSupertypeFromResolvedDeclaration(classLikeDeclaration)\n                }\n            } else {\n                crawlSupertypeFromResolvedDeclaration(classLikeDeclaration)\n            }\n\n            return\n        }\n\n        val resolveTarget = classLikeDeclaration.asResolveTarget()\n        if (resolveTarget != null) {\n            resolveToSupertypePhase(resolveTarget)\n        }\n    }\n\n    private fun crawlSupertypeFromResolvedDeclaration(classLikeDeclaration: FirClassLikeDeclaration) {\n        val parentClass = classLikeDeclaration.outerClass()\n        if (parentClass != null) {\n            crawlSupertype(parentClass.defaultType())\n        }\n\n        val sup"}
{"code": "erTypeRefs = when (classLikeDeclaration) {\n            is FirTypeAlias -> listOf(classLikeDeclaration.expandedTypeRef)\n            is FirClass -> classLikeDeclaration.superTypeRefs\n        }\n\n        for (typeRef in superTypeRefs) {\n            val coneType = typeRef.coneTypeOrNull ?: errorWithFirSpecificEntries(\n                \"The declaration super type must be resolved, but the actual type reference is not resolved\",\n                fir = classLikeDeclaration,\n            ) {\n                withFirEntry(\"typeRef\", typeRef)\n            }\n\n            crawlSupertype(coneType)\n        }\n    }\n\n    override fun doLazyResolveUnderLock(target: FirElementWithResolveState) {\n        error(\"Should be resolved without lock in ${::doResolveWithoutLock.name}\")\n    }\n}\n\nprivate fun FirClassLikeDeclaration.outerClass(): FirRegularClass? = symbol.classId.parentClassId?.let { parentClassId ->\n    llFirSession.symbolProvider.getClassLikeSymbolByClassId(parentClassId)?.fir as? FirRegularClass\n}\n\npr"}
{"code": "ivate class LLFirSupertypeComputationSession : SupertypeComputationSession() {\n    var useSiteSessions: PersistentList<LLFirSession> = persistentListOf<LLFirSession>()\n        private set\n\n    inline fun withDeclarationSession(declaration: FirClassLikeDeclaration, action: () -> Unit) {\n        val newSession = declaration.llFirSession.takeUnless { it == useSiteSessions.lastOrNull() }\n        try {\n            newSession?.let { useSiteSessions = useSiteSessions.add(it) }\n            action()\n        } finally {\n            newSession?.let { useSiteSessions = useSiteSessions.removeAt(useSiteSessions.lastIndex) }\n        }\n    }\n\n    \n    private val visited: MutableSet<FirClassLikeDeclaration> = hashSetOf()\n    private val looped: MutableSet<FirClassLikeDeclaration> = hashSetOf()\n    private val pathSet: MutableSet<FirClassLikeDeclaration> = hashSetOf()\n    private val path: MutableList<FirClassLikeDeclaration> = mutableListOf()\n    // ---------------\n\n    \n    private val updatedTypesFo"}
{"code": "rDeclarationsWithLoop: MutableMap<FirClassLikeDeclaration, List<FirResolvedTypeRef>> = hashMapOf()\n\n    \n    fun findLoopFor(declaration: FirClassLikeDeclaration): List<FirResolvedTypeRef>? {\n        breakLoopFor(\n            declaration = declaration,\n            // Only loops from the declaration site point of view should be processed\n            session = declaration.llFirSession,\n            visited = visited,\n            looped = looped,\n            pathSet = pathSet,\n            path = path,\n        )\n\n        require(path.isEmpty()) { \"Path should be empty\" }\n        require(pathSet.isEmpty()) { \"Path set should be empty\" }\n        visited.clear()\n        looped.clear()\n        return updatedTypesForDeclarationsWithLoop[declaration]\n    }\n\n    \n    override fun getResolvedSuperTypeRefsForOutOfSessionDeclaration(classLikeDeclaration: FirClassLikeDeclaration): List<FirResolvedTypeRef>? {\n        if (classLikeDeclaration.resolvePhase < FirResolvePhase.SUPER_TYPES) return emptyList("}
{"code": ")\n\n        return super.getResolvedSuperTypeRefsForOutOfSessionDeclaration(classLikeDeclaration)\n    }\n\n    \n    override fun reportLoopErrorRefs(classLikeDeclaration: FirClassLikeDeclaration, supertypeRefs: List<FirResolvedTypeRef>) {\n        updatedTypesForDeclarationsWithLoop.merge(classLikeDeclaration, supertypeRefs) { oldRefs, newRefs ->\n            buildList<FirResolvedTypeRef>(oldRefs.size) {\n                for ((old, new) in oldRefs.zip(newRefs)) {\n                    if (old is FirErrorTypeRef) {\n                        add(old)\n                    } else {\n                        add(new)\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"code": "interface EmptyI<caret>nterface : InterfaceWithMembers {\n    val newProperty: String\n}\n\ninterface InterfaceWithMembers : AnotherSuperInterface {\n    val property: Int\n\n    fun functionWithDefaultImplementation(i: Int): Int = i\n\n    override fun baseFunction()\n\n    override fun baz() {\n        // default implementation\n    }\n}\n\ninterface AnotherSuperInterface {\n    fun baz()\n\n    fun baseFunction()\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.impl.base.components\n\nimport org.jetbrains.kotlin.analysis.api.calls.KtCompoundAccess\nimport org.jetbrains.kotlin.analysis.api.calls.KtExplicitReceiverValue\nimport org.jetbrains.kotlin.analysis.api.components.KtCallResolver\nimport org.jetbrains.kotlin.analysis.api.types.KtType\nimport org.jetbrains.kotlin.analysis.utils.printer.parentOfType\nimport org.jetbrains.kotlin.lexer.KtSingleValueToken\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.psi.*\n\nabstract class AbstractKtCallResolver : KtCallResolver() {\n\n    protected fun KtBinaryExpression.getCompoundAssignKind(): KtCompoundAccess.CompoundAssign.Kind {\n        val compoundAssignKind = when (operationToken) {\n            KtTokens.PLUSEQ -> KtCompoundAccess.CompoundAssign.Kind.PLUS_ASSIGN\n            KtTokens.MINUSEQ -> KtCompoundAccess.CompoundAssign.Kind.MINUS_ASSIGN\n            KtTokens.MULTEQ -> KtCompoundAccess.CompoundAssign.Kind.TIMES_ASSIGN\n            KtTokens.P"}
{"code": "ERCEQ -> KtCompoundAccess.CompoundAssign.Kind.REM_ASSIGN\n            KtTokens.DIVEQ -> KtCompoundAccess.CompoundAssign.Kind.DIV_ASSIGN\n            else -> error(\"unexpected operator $operationToken\")\n        }\n        return compoundAssignKind\n    }\n\n    protected fun KtUnaryExpression.getInOrDecOperationKind(): KtCompoundAccess.IncOrDecOperation.Kind {\n        val incOrDecOperationKind = when (operationToken) {\n            KtTokens.PLUSPLUS -> KtCompoundAccess.IncOrDecOperation.Kind.INC\n            KtTokens.MINUSMINUS -> KtCompoundAccess.IncOrDecOperation.Kind.DEC\n            else -> error(\"unexpected operator $operationToken\")\n        }\n        return incOrDecOperationKind\n    }\n\n    protected fun KtExpression.toExplicitReceiverValue(type: KtType): KtExplicitReceiverValue =\n        KtExplicitReceiverValue(this, type, isReceiverOfKtSafeQualifiedExpression(), token)\n\n    private fun KtExpression.isReceiverOfKtSafeQualifiedExpression(): Boolean {\n        val safeQualifiedExpression = pa"}
{"code": "rentOfType<KtSafeQualifiedExpression>() ?: return false\n        return KtPsiUtil.deparenthesize(safeQualifiedExpression.receiverExpression) == KtPsiUtil.deparenthesize(this)\n    }\n\n    protected fun canBeResolvedAsCall(ktElement: KtElement): Boolean = when (ktElement) {\n        is KtBinaryExpression -> ktElement.operationToken !in nonCallBinaryOperator\n        is KtOperationReferenceExpression -> ktElement.operationSignTokenType !in nonCallBinaryOperator\n        is KtCallElement -> true\n        is KtConstructorCalleeExpression -> true\n        is KtDotQualifiedExpression -> true\n        is KtNameReferenceExpression -> true\n        is KtOperationExpression -> true\n        is KtArrayAccessExpression -> true\n        is KtCallableReferenceExpression -> true\n        else -> false\n    }\n\n    protected companion object {\n        private val nonCallBinaryOperator: Set<KtSingleValueToken> = setOf(KtTokens.ELVIS, KtTokens.EQEQEQ, KtTokens.EXCLEQEQEQ)\n    }\n}"}
{"code": "fun foo(x: (String) -> Int) {}\nfun foo(x: () -> Int) {}\n\n\nfun bar(): Int = 1\nfun bar(x: Double): Int = 1\n\nfun main() {\n    foo(::bar)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cfg.pseudocode.instructions.eval\n\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.KtElementInstruction\nimport org.jetbrains.kotlin.cfg.pseudocode.PseudoValue\n\ninterface InstructionWithValue : KtElementInstruction {\n    val outputValue: PseudoValue?\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.sessions\n\nimport com.intellij.openapi.Disposable\nimport com.intellij.openapi.application.ApplicationManager\nimport com.intellij.openapi.project.Project\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.LLFirInternals\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.caches.CleanableSoftValueCache\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.util.checkCanceled\nimport org.jetbrains.kotlin.analysis.project.structure.*\nimport org.jetbrains.kotlin.fir.FirModuleDataImpl\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.PrivateSessionConstructor\nimport org.jetbrains.kotlin.fir.session.registerModuleData\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.platform.JsPlatform\nimport org.jetbrains.kotlin.platform.jvm.JvmPlatform\nimport org.jetbrains.kotlin.platform.jvm.JvmPlatforms\nimport org.jetbrains.kotlin.platform.konan.NativePlatform\n\nprivate typealias SessionStorage = Cleana"}
{"code": "bleSoftValueCache<KtModule, LLFirSession>\n\n@LLFirInternals\nclass LLFirSessionCache(private val project: Project) : Disposable {\n    companion object {\n        fun getInstance(project: Project): LLFirSessionCache {\n            return project.getService(LLFirSessionCache::class.java)\n        }\n    }\n\n    // Removal from the session storage invokes the `LLFirSession`'s cleaner, which marks the session as invalid and disposes any\n    // disposables registered with the `LLFirSession`'s disposable.\n    private val sourceCache: SessionStorage = CleanableSoftValueCache(LLFirSession::createCleaner)\n    private val binaryCache: SessionStorage = CleanableSoftValueCache(LLFirSession::createCleaner)\n    private val danglingFileSessionCache: SessionStorage = CleanableSoftValueCache(LLFirSession::createCleaner)\n    private val unstableDanglingFileSessionCache: SessionStorage = CleanableSoftValueCache(LLFirSession::createCleaner)\n\n    \n    fun getSession(module: KtModule, preferBinary: Boolean = false"}
{"code": "): LLFirSession {\n        if (module is KtBinaryModule && (preferBinary || module is KtSdkModule)) {\n            return getCachedSession(module, binaryCache) {\n                createPlatformAwareSessionFactory(module).createBinaryLibrarySession(module)\n            }\n        }\n\n        if (module is KtDanglingFileModule) {\n            return getDanglingFileCachedSession(module)\n        }\n\n        return getCachedSession(module, sourceCache, factory = ::createSession)\n    }\n\n    \n    internal fun getSessionNoCaching(module: KtModule): LLFirSession {\n        return createSession(module)\n    }\n\n    private fun getDanglingFileCachedSession(module: KtDanglingFileModule): LLFirSession {\n        if (module.isStable) {\n            return getCachedSession(module, danglingFileSessionCache, ::createSession)\n        }\n\n        checkCanceled()\n\n        val session = unstableDanglingFileSessionCache.compute(module) { _, existingSession ->\n            if (existingSession is LLFirDanglingFileSession &&"}
{"code": " existingSession.modificationStamp == module.file.modificationStamp) {\n                existingSession\n            } else {\n                createSession(module)\n            }\n        }\n\n        requireNotNull(session)\n        checkSessionValidity(session)\n\n        return session\n    }\n\n    private fun <T : KtModule> getCachedSession(module: T, storage: SessionStorage, factory: (T) -> LLFirSession): LLFirSession {\n        checkCanceled()\n\n        val session = if (module.supportsIsolatedSessionCreation) {\n            storage.computeIfAbsent(module) { factory(module) }\n        } else {\n            // Non-isolated session creation may need to access other sessions, so we should create the session outside `computeIfAbsent` to\n            // avoid recursive update exceptions.\n            storage[module] ?: run {\n                val danglingSession = factory(module)\n                storage.computeIfAbsent(module) { danglingSession }\n            }\n        }\n\n        checkSessionValidity(sess"}
{"code": "ion)\n        return session\n    }\n\n    private fun checkSessionValidity(session: LLFirSession) {\n        require(session.isValid) { \"A session acquired via `getSession` should always be valid. Module: ${session.ktModule}\" }\n    }\n\n    \n    fun removeSession(module: KtModule): Boolean {\n        ApplicationManager.getApplication().assertWriteAccessAllowed()\n\n        val didSourceSessionExist = removeSessionFrom(module, sourceCache)\n        val didBinarySessionExist = module is KtBinaryModule && removeSessionFrom(module, binaryCache)\n        val didDanglingFileSessionExist = module is KtDanglingFileModule && removeSessionFrom(module, danglingFileSessionCache)\n        val didUnstableDanglingFileSessionExist = module is KtDanglingFileModule && removeSessionFrom(module, unstableDanglingFileSessionCache)\n\n        return didSourceSessionExist || didBinarySessionExist || didDanglingFileSessionExist || didUnstableDanglingFileSessionExist\n    }\n\n    private fun removeSessionFrom(module: KtModule,"}
{"code": " storage: SessionStorage): Boolean = storage.remove(module) != null\n\n    \n    fun removeAllSessions(includeLibraryModules: Boolean) {\n        ApplicationManager.getApplication().assertWriteAccessAllowed()\n\n        if (includeLibraryModules) {\n            removeAllSessionsFrom(sourceCache)\n            removeAllSessionsFrom(binaryCache)\n        } else {\n            // `binaryCache` can only contain library modules, so we only need to remove sessions from `sourceCache`.\n            removeAllMatchingSessionsFrom(sourceCache) { it !is KtBinaryModule && it !is KtLibrarySourceModule }\n        }\n\n        removeAllDanglingFileSessions()\n    }\n\n    fun removeUnstableDanglingFileSessions() {\n        removeAllSessionsFrom(unstableDanglingFileSessionCache)\n    }\n\n    fun removeContextualDanglingFileSessions(contextModule: KtModule) {\n        removeUnstableDanglingFileSessions()\n\n        if (contextModule is KtDanglingFileModule) {\n            removeAllMatchingSessionsFrom(danglingFileSessionCache) "}
{"code": "{ it is KtDanglingFileModule && hasContextModule(it, contextModule) }\n        } else {\n            // Only code fragments can have a dangling file context\n            removeAllMatchingSessionsFrom(danglingFileSessionCache) { it is KtDanglingFileModule && it.isCodeFragment }\n        }\n    }\n\n    private tailrec fun hasContextModule(module: KtDanglingFileModule, contextModule: KtModule): Boolean {\n        return when (val candidate = module.contextModule) {\n            contextModule -> true\n            is KtDanglingFileModule -> hasContextModule(candidate, contextModule)\n            else -> false\n        }\n    }\n\n    fun removeAllDanglingFileSessions() {\n        removeAllSessionsFrom(danglingFileSessionCache)\n        removeAllSessionsFrom(unstableDanglingFileSessionCache)\n    }\n\n    // Removing script sessions is only needed temporarily until KTIJ-25620 has been implemented.\n    fun removeAllScriptSessions() {\n        ApplicationManager.getApplication().assertWriteAccessAllowed()\n\n      "}
{"code": "  removeAllScriptSessionsFrom(sourceCache)\n        removeAllScriptSessionsFrom(binaryCache)\n    }\n\n    private fun removeAllScriptSessionsFrom(storage: SessionStorage) {\n        removeAllMatchingSessionsFrom(storage) { it is KtScriptModule || it is KtScriptDependencyModule }\n    }\n\n    private fun removeAllSessionsFrom(storage: SessionStorage) {\n        storage.clear()\n    }\n\n    private inline fun removeAllMatchingSessionsFrom(storage: SessionStorage, shouldBeRemoved: (KtModule) -> Boolean) {\n        // Because this function is executed in a write action, we do not need concurrency guarantees to remove all matching sessions, so a\n        // \"collect and remove\" approach also works.\n        storage.keys.forEach { module ->\n            if (shouldBeRemoved(module)) {\n                storage.remove(module)\n            }\n        }\n    }\n\n    \n    private val KtModule.supportsIsolatedSessionCreation: Boolean\n        get() = this !is KtDanglingFileModule\n\n    private fun createSession(module"}
{"code": ": KtModule): LLFirSession {\n        val sessionFactory = createPlatformAwareSessionFactory(module)\n        return when (module) {\n            is KtSourceModule -> sessionFactory.createSourcesSession(module)\n            is KtLibraryModule, is KtLibrarySourceModule -> sessionFactory.createLibrarySession(module)\n            is KtSdkModule -> sessionFactory.createBinaryLibrarySession(module)\n            is KtScriptModule -> sessionFactory.createScriptSession(module)\n            is KtDanglingFileModule -> {\n                //  Dangling file context must have an analyzable session, so we can properly compile code against it.\n                val contextSession = getSession(module.contextModule, preferBinary = false)\n                sessionFactory.createDanglingFileSession(module, contextSession)\n            }\n            is KtNotUnderContentRootModule -> sessionFactory.createNotUnderContentRootResolvableSession(module)\n            else -> error(\"Unexpected module kind: ${module::class.simpleN"}
{"code": "ame}\")\n        }\n    }\n\n    private fun createPlatformAwareSessionFactory(module: KtModule): LLFirAbstractSessionFactory {\n        val targetPlatform = module.platform\n        return when {\n            targetPlatform.all { it is JvmPlatform } -> LLFirJvmSessionFactory(project)\n            targetPlatform.all { it is JsPlatform } -> LLFirJsSessionFactory(project)\n            targetPlatform.all { it is NativePlatform } -> LLFirNativeSessionFactory(project)\n            else -> LLFirCommonSessionFactory(project)\n        }\n    }\n\n    override fun dispose() {\n    }\n}\n\ninternal fun LLFirSessionConfigurator.Companion.configure(session: LLFirSession) {\n    val project = session.project\n    for (extension in extensionPointName.getExtensionList(project)) {\n        extension.configure(session)\n    }\n}\n\n@Deprecated(\n    \"This is a dirty hack used only for one usage (building fir for psi from stubs) and it should be removed after fix of that usage\",\n    level = DeprecationLevel.ERROR\n)\n@OptIn(Private"}
{"code": "SessionConstructor::class)\nfun createEmptySession(): FirSession {\n    return object : FirSession(null, Kind.Source) {}.apply {\n        val moduleData = FirModuleDataImpl(\n            Name.identifier(\"<stub module>\"),\n            dependencies = emptyList(),\n            dependsOnDependencies = emptyList(),\n            friendDependencies = emptyList(),\n            platform = JvmPlatforms.unspecifiedJvmPlatform,\n        )\n        registerModuleData(moduleData)\n        moduleData.bindSession(this)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.inline\n\nimport org.jetbrains.kotlin.codegen.StackValue\n\nclass CapturedParamInfo : ParameterInfo {\n    val desc: CapturedParamDesc\n    val newFieldName: String\n    val isSkipInConstructor: Boolean\n\n    //Now used only for bound function reference receiver\n    var isSynthetic: Boolean = false\n\n    val originalFieldName: String\n        get() = desc.fieldName\n\n    val containingLambdaName: String\n        get() = desc.containingLambdaName\n\n    constructor(\n        desc: CapturedParamDesc,\n        newFieldName: String,\n        skipped: Boolean,\n        index: Int,\n        remapIndex: Int,\n        skipInConstructor: Boolean\n    ) : super(\n        desc.type,\n        skipped,\n        index,\n        remapIndex,\n        -1\n    ) {\n        this.desc = desc\n        this.newFieldName = newFieldName\n        this.isSkipInConstructor = skipInConstructor\n    }\n\n    private constructor(\n        desc: CapturedParamDesc,\n        newFieldName: String,\n        skipped: "}
{"code": "Boolean,\n        index: Int,\n        remapIndex: StackValue?,\n        skipInConstructor: Boolean,\n        declarationIndex: Int\n    ) : super(desc.type, skipped, index, remapIndex, declarationIndex) {\n        this.desc = desc\n        this.newFieldName = newFieldName\n        this.isSkipInConstructor = skipInConstructor\n    }\n\n    fun cloneWithNewDeclarationIndex(newDeclarationIndex: Int): CapturedParamInfo {\n        val result = CapturedParamInfo(\n            desc, newFieldName, isSkipped, index, remapValue, isSkipInConstructor, newDeclarationIndex\n        )\n        result.functionalArgument = functionalArgument\n        result.isSynthetic = isSynthetic\n        return result\n    }\n\n    companion object {\n\n        fun isSynthetic(info: ParameterInfo): Boolean {\n            return info is CapturedParamInfo && info.isSynthetic\n        }\n    }\n}\n"}
{"code": "fun test(b: Boolean) {\n    <expr>when(b) {\n        true -> 5\n        else -> 0\n    }</expr>\n}"}
{"code": "fun sum(aa: Int, bb: Int) = aa + bb\n\nfun main() {\n    println(sum(b<caret>b = 1, aa = 2))\n}\n\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.types\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\n\nabstract class FirIntersectionTypeRef : FirTypeRefWithNullability() {\n    abstract override val source: KtSourceElement?\n    abstract override val annotations: List<FirAnnotation>\n    abstract override val isMarkedNullable: Boolean\n    abstract val leftType: FirTypeRef\n    abstract val rightType: FirTypeRef\n\n    override fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitIntersectionTypeRef(this, data)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transformer.t"}
{"code": "ransformIntersectionTypeRef(this, data) as E\n\n    abstract override fun replaceAnnotations(newAnnotations: List<FirAnnotation>)\n\n    abstract override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirIntersectionTypeRef\n}\n"}
{"code": "fun test(b: Boolean): Int {\n    val (one, two) = b to <expr>!b</expr>\n    return if (one && two) {\n        54\n    } else {\n        45\n    }\n}"}
{"code": "package foo\n\nclass CC<T>\nclass DD<T, T2>\n\nval v1 = D<caret>D<CC>\n\n\n\n"}
{"code": "fun function(a: Char) {}\nfun function(b: Boolean) {}\nfun function(c: String) {}\n\nfun call() {\n    <expr>function(1)</expr>\n}\n"}
{"code": "interface A<T> {\n   fun <R> foo(r: R)\n}\n\nfun call(a: A<String>) {\n   a.<expr>foo(1)</expr>\n}\n"}
{"code": "fun x(a: List<Int>) {\n    <expr>a.size</expr>\n}"}
{"code": "\n\n@file:Suppress(\"DEPRECATION\")\n\npackage org.jetbrains.kotlin.cli.common\n\nimport com.intellij.openapi.Disposable\nimport com.intellij.openapi.util.Disposer\nimport org.jetbrains.kotlin.analyzer.CompilationErrorException\nimport org.jetbrains.kotlin.cli.common.CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY\nimport org.jetbrains.kotlin.cli.common.ExitCode.*\nimport org.jetbrains.kotlin.cli.common.arguments.CommonCompilerArguments\nimport org.jetbrains.kotlin.cli.common.environment.setIdeaIoUseFallback\nimport org.jetbrains.kotlin.cli.common.messages.*\nimport org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.*\nimport org.jetbrains.kotlin.cli.jvm.plugins.PluginCliParser\nimport org.jetbrains.kotlin.cli.plugins.extractPluginClasspathAndOptions\nimport org.jetbrains.kotlin.cli.plugins.processCompilerPluginsOptions\nimport org.jetbrains.kotlin.compiler.plugin.CommandLineProcessor\nimport org.jetbrains.kotlin.compiler.plugin.CompilerPluginRegistrar\nimport org.jetbrains.kotlin.compiler.plugin.C"}
{"code": "omponentRegistrar\nimport org.jetbrains.kotlin.config.*\nimport org.jetbrains.kotlin.ir.util.IrMessageLogger\nimport org.jetbrains.kotlin.metadata.deserialization.BinaryVersion\nimport org.jetbrains.kotlin.progress.CompilationCanceledException\nimport org.jetbrains.kotlin.progress.CompilationCanceledStatus\nimport org.jetbrains.kotlin.progress.IncrementalNextRoundException\nimport org.jetbrains.kotlin.progress.ProgressIndicatorAndCompilationCanceledStatus\nimport org.jetbrains.kotlin.utils.KotlinPaths\nimport org.jetbrains.kotlin.utils.PathUtil\nimport java.io.File\nimport java.io.PrintStream\n\nabstract class CLICompiler<A : CommonCompilerArguments> : CLITool<A>() {\n    companion object {\n        const val SCRIPT_PLUGIN_REGISTRAR_NAME =\n            \"org.jetbrains.kotlin.scripting.compiler.plugin.ScriptingCompilerConfigurationComponentRegistrar\"\n        const val SCRIPT_PLUGIN_COMMANDLINE_PROCESSOR_NAME = \"org.jetbrains.kotlin.scripting.compiler.plugin.ScriptingCommandLineProcessor\"\n        const v"}
{"code": "al SCRIPT_PLUGIN_K2_REGISTRAR_NAME =\n            \"org.jetbrains.kotlin.scripting.compiler.plugin.ScriptingK2CompilerPluginRegistrar\"\n    }\n\n    abstract val defaultPerformanceManager: CommonCompilerPerformanceManager\n\n    protected open fun createPerformanceManager(arguments: A, services: Services): CommonCompilerPerformanceManager =\n        defaultPerformanceManager\n\n    // Used in CompilerRunnerUtil#invokeExecMethod, in Eclipse plugin (KotlinCLICompiler) and in kotlin-gradle-plugin (GradleCompilerRunner)\n    fun execAndOutputXml(errStream: PrintStream, services: Services, vararg args: String): ExitCode {\n        return exec(errStream, services, MessageRenderer.XML, args)\n    }\n\n    // Used via reflection in KotlinCompilerBaseTask\n    fun execFullPathsInMessages(errStream: PrintStream, args: Array<String>): ExitCode {\n        return exec(errStream, Services.EMPTY, MessageRenderer.PLAIN_FULL_PATHS, args)\n    }\n\n    public override fun execImpl(messageCollector: MessageCollector, servic"}
{"code": "es: Services, arguments: A): ExitCode {\n        val performanceManager = createPerformanceManager(arguments, services)\n        if (arguments.reportPerf || arguments.dumpPerf != null) {\n            performanceManager.enableCollectingPerformanceStatistics()\n        }\n\n        val configuration = CompilerConfiguration()\n\n        configuration.put(CLIConfigurationKeys.ORIGINAL_MESSAGE_COLLECTOR_KEY, messageCollector)\n\n        val collector = GroupingMessageCollector(messageCollector, arguments.allWarningsAsErrors, arguments.reportAllWarnings).also {\n            configuration.put(MESSAGE_COLLECTOR_KEY, it)\n        }\n\n        configuration.put(IrMessageLogger.IR_MESSAGE_LOGGER, IrMessageCollector(collector))\n\n        configuration.put(CLIConfigurationKeys.PERF_MANAGER, performanceManager)\n        try {\n            setupCommonArguments(configuration, arguments)\n            setupPlatformSpecificArgumentsAndServices(configuration, arguments, services)\n            val paths = computeKotlinPaths("}
{"code": "collector, arguments)\n            if (collector.hasErrors()) {\n                return COMPILATION_ERROR\n            }\n\n            val canceledStatus = services[CompilationCanceledStatus::class.java]\n            ProgressIndicatorAndCompilationCanceledStatus.setCompilationCanceledStatus(canceledStatus)\n\n            val rootDisposable = Disposer.newDisposable(\"Disposable for ${CLICompiler::class.simpleName}.execImpl\")\n            try {\n                setIdeaIoUseFallback()\n\n                val code = doExecute(arguments, configuration, rootDisposable, paths)\n\n                performanceManager.notifyCompilationFinished()\n                if (arguments.reportPerf) {\n                    collector.report(LOGGING, \"PERF: \" + performanceManager.getTargetInfo())\n                    for (measurement in performanceManager.getMeasurementResults()) {\n                        collector.report(LOGGING, \"PERF: \" + measurement.render(), null)\n                    }\n                }\n\n                if "}
{"code": "(arguments.dumpPerf != null) {\n                    performanceManager.dumpPerformanceReport(File(arguments.dumpPerf!!))\n                }\n\n                return if (collector.hasErrors()) COMPILATION_ERROR else code\n            } catch (e: CompilationCanceledException) {\n                collector.reportCompilationCancelled(e)\n                return OK\n            } catch (e: RuntimeException) {\n                val cause = e.cause\n                if (cause is CompilationCanceledException) {\n                    collector.reportCompilationCancelled(cause)\n                    return OK\n                } else {\n                    throw e\n                }\n            } finally {\n                Disposer.dispose(rootDisposable)\n            }\n        } catch (e: CompilationErrorException) {\n            return COMPILATION_ERROR\n        } catch (t: Throwable) {\n            MessageCollectorUtil.reportException(collector, t)\n            return if (t is OutOfMemoryError || t.hasOOMCause()) OOM_E"}
{"code": "RROR else INTERNAL_ERROR\n        } finally {\n            collector.flush()\n        }\n    }\n\n    private fun Throwable.hasOOMCause(): Boolean = when (cause) {\n        is OutOfMemoryError -> true\n        else -> cause?.hasOOMCause() ?: false\n    }\n\n    private fun MessageCollector.reportCompilationCancelled(e: CompilationCanceledException) {\n        if (e !is IncrementalNextRoundException) {\n            report(INFO, \"Compilation was canceled\", null)\n        }\n    }\n\n    private fun setupCommonArguments(configuration: CompilerConfiguration, arguments: A) {\n        configuration.setupCommonArguments(arguments, this::createMetadataVersion)\n    }\n\n    protected abstract fun createMetadataVersion(versionArray: IntArray): BinaryVersion\n\n    protected abstract fun setupPlatformSpecificArgumentsAndServices(\n        configuration: CompilerConfiguration, arguments: A, services: Services\n    )\n\n    protected abstract fun doExecute(\n        arguments: A,\n        configuration: CompilerConfiguration,"}
{"code": "\n        rootDisposable: Disposable,\n        paths: KotlinPaths?\n    ): ExitCode\n\n    protected abstract fun MutableList<String>.addPlatformOptions(arguments: A)\n\n    protected fun loadPlugins(paths: KotlinPaths?, arguments: A, configuration: CompilerConfiguration): ExitCode {\n        val pluginClasspaths = arguments.pluginClasspaths.orEmpty().toMutableList()\n        val pluginOptions = arguments.pluginOptions.orEmpty().toMutableList()\n        val pluginConfigurations = arguments.pluginConfigurations.orEmpty().toMutableList()\n        val messageCollector = configuration.getNotNull(MESSAGE_COLLECTOR_KEY)\n\n        val useK2 = configuration.get(CommonConfigurationKeys.USE_FIR) == true\n\n        val scriptingPluginClasspath = mutableListOf<String>()\n        val scriptingPluginOptions = mutableListOf<String>()\n\n        if (!arguments.disableDefaultScriptingPlugin) {\n            scriptingPluginOptions.addPlatformOptions(arguments)\n            val explicitScriptingPlugin =\n                extr"}
{"code": "actPluginClasspathAndOptions(pluginConfigurations).any { (_, classpath, _) ->\n                    classpath.any { File(it).name.startsWith(PathUtil.KOTLIN_SCRIPTING_COMPILER_PLUGIN_NAME) }\n                } || pluginClasspaths.any { File(it).name.startsWith(PathUtil.KOTLIN_SCRIPTING_COMPILER_PLUGIN_NAME) }\n            val explicitOrLoadedScriptingPlugin = explicitScriptingPlugin ||\n                    tryLoadScriptingPluginFromCurrentClassLoader(configuration, pluginOptions, useK2)\n            if (!explicitOrLoadedScriptingPlugin) {\n                val kotlinPaths = paths ?: PathUtil.kotlinPathsForCompiler\n                val libPath = kotlinPaths.libPath.takeIf { it.exists() && it.isDirectory } ?: File(\".\")\n                val (jars, missingJars) =\n                    PathUtil.KOTLIN_SCRIPTING_PLUGIN_CLASSPATH_JARS.map { File(libPath, it) }.partition { it.exists() }\n                if (missingJars.isEmpty()) {\n                    scriptingPluginClasspath.addAll(0, jars.map { it.canoni"}
{"code": "calPath })\n                } else {\n                    messageCollector.report(\n                        LOGGING,\n                        \"Scripting plugin will not be loaded: not all required jars are present in the classpath (missing files: $missingJars)\"\n                    )\n                }\n            }\n        } else {\n            scriptingPluginOptions.add(\"plugin:kotlin.scripting:disable=true\")\n        }\n\n        pluginClasspaths.addAll(scriptingPluginClasspath)\n        pluginOptions.addAll(scriptingPluginOptions)\n\n        if (!checkPluginsArguments(messageCollector, useK2, pluginClasspaths, pluginOptions, pluginConfigurations)) {\n            return INTERNAL_ERROR\n        }\n\n        return PluginCliParser.loadPluginsSafe(pluginClasspaths, pluginOptions, pluginConfigurations, configuration)\n    }\n\n    private fun tryLoadScriptingPluginFromCurrentClassLoader(\n        configuration: CompilerConfiguration,\n        pluginOptions: List<String>,\n        useK2: Boolean\n    ): Boolean"}
{"code": " =\n        try {\n            val pluginRegistrarClass = PluginCliParser::class.java.classLoader.loadClass(SCRIPT_PLUGIN_REGISTRAR_NAME)\n            val pluginRegistrar = (pluginRegistrarClass.getDeclaredConstructor().newInstance() as? ComponentRegistrar)?.also {\n                configuration.add(ComponentRegistrar.PLUGIN_COMPONENT_REGISTRARS, it)\n            }\n            val pluginK2Registrar = if (useK2) {\n                val pluginK2RegistrarClass = PluginCliParser::class.java.classLoader.loadClass(SCRIPT_PLUGIN_K2_REGISTRAR_NAME)\n                (pluginK2RegistrarClass.getDeclaredConstructor().newInstance() as? CompilerPluginRegistrar)?.also {\n                    configuration.add(CompilerPluginRegistrar.COMPILER_PLUGIN_REGISTRARS, it)\n                }\n            } else null\n            if (pluginRegistrar != null || pluginK2Registrar != null) {\n                processScriptPluginCliOptions(pluginOptions, configuration)\n                true\n            } else false\n        } catc"}
{"code": "h (e: Throwable) {\n            val messageCollector = configuration.getNotNull(MESSAGE_COLLECTOR_KEY)\n            messageCollector.report(LOGGING, \"Exception on loading scripting plugin: $e\")\n            false\n        }\n\n    private fun processScriptPluginCliOptions(pluginOptions: List<String>, configuration: CompilerConfiguration) {\n        val cmdlineProcessorClass =\n            if (pluginOptions.isEmpty()) null\n            else PluginCliParser::class.java.classLoader.loadClass(SCRIPT_PLUGIN_COMMANDLINE_PROCESSOR_NAME)!!\n        val cmdlineProcessor = cmdlineProcessorClass?.getDeclaredConstructor()?.newInstance() as? CommandLineProcessor\n        if (cmdlineProcessor != null) {\n            processCompilerPluginsOptions(configuration, pluginOptions, listOf(cmdlineProcessor))\n        }\n    }\n}\n\nfun checkPluginsArguments(\n    messageCollector: MessageCollector,\n    useK2: Boolean,\n    pluginClasspaths: List<String>,\n    pluginOptions: List<String>,\n    pluginConfigurations: List<String>\n"}
{"code": "): Boolean {\n    var hasErrors = false\n\n    for (classpath in pluginClasspaths) {\n        if (!File(classpath).exists()) {\n            messageCollector.report(ERROR, \"Plugin classpath entry points to a non-existent location: $classpath\")\n        }\n    }\n\n    if (pluginConfigurations.isNotEmpty()) {\n        messageCollector.report(WARNING, \"Argument -Xcompiler-plugin is experimental\")\n        if (!useK2) {\n            hasErrors = true\n            messageCollector.report(\n                ERROR,\n                \"-Xcompiler-plugin argument is allowed only for language version 2.0. Please use -Xplugin argument for language version 1.9 and below\"\n            )\n        }\n        if (pluginClasspaths.isNotEmpty() || pluginOptions.isNotEmpty()) {\n            hasErrors = true\n            val message = buildString {\n                appendLine(\"Mixing legacy and modern plugin arguments is prohibited. Please use only one syntax\")\n                appendLine(\"Legacy arguments:\")\n                if (p"}
{"code": "luginClasspaths.isNotEmpty()) {\n                    appendLine(\"  -Xplugin=${pluginClasspaths.joinToString(\",\")}\")\n                }\n                pluginOptions.forEach {\n                    appendLine(\"  -P $it\")\n                }\n                appendLine(\"Modern arguments:\")\n                pluginConfigurations.forEach {\n                    appendLine(\"  -Xcompiler-plugin=$it\")\n                }\n            }\n            messageCollector.report(ERROR, message)\n        }\n    }\n    return !hasErrors\n}\n\n"}
{"code": "class Foo<T>(val t: T, val i: Int)"}
{"code": "val x : Int <caret>by Baz()\n\ninterface Foo {\n  operator fun getValue(p1: Any?, p2: Any?): Int = 1\n}\n\nclass Baz: Foo\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.optimization.boxing\n\nimport org.jetbrains.kotlin.codegen.optimization.OptimizationMethodVisitor\nimport org.jetbrains.kotlin.codegen.optimization.common.FastMethodAnalyzer\nimport org.jetbrains.kotlin.codegen.optimization.common.isLoadOperation\nimport org.jetbrains.kotlin.codegen.optimization.fixStack.peekWords\nimport org.jetbrains.kotlin.codegen.optimization.fixStack.top\nimport org.jetbrains.kotlin.codegen.optimization.transformer.MethodTransformer\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode\nimport org.jetbrains.org.objectweb.asm.tree.FieldInsnNode\nimport org.jetbrains.org.objectweb.asm.tree.InsnNode\nimport org.jetbrains.org.objectweb.asm.tree.MethodNode\nimport org.jetbrains.org.objectweb.asm.tree.analysis.Frame\nimport org.jetbrains.org.objectweb.asm.tree.analysis.SourceInterpreter\nimport org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue\nimport java.util.*\n\nprivate typealias Tr"}
{"code": "ansformation = (AbstractInsnNode) -> Unit\n\nclass PopBackwardPropagationTransformer : MethodTransformer() {\n    override fun transform(internalClassName: String, methodNode: MethodNode) {\n        if (!OptimizationMethodVisitor.canBeOptimizedUsingSourceInterpreter(methodNode)) return\n        if (methodNode.instructions.any { it.isPop() || it.isPurePush() }) {\n            Transformer(methodNode).transform()\n        }\n    }\n\n    private class Transformer(val methodNode: MethodNode) {\n        private val REPLACE_WITH_NOP: Transformation = { insnList.set(it, InsnNode(Opcodes.NOP)) }\n        private val REPLACE_WITH_POP1: Transformation = { insnList.set(it, InsnNode(Opcodes.POP)) }\n        private val REPLACE_WITH_POP2: Transformation = { insnList.set(it, InsnNode(Opcodes.POP2)) }\n        private val INSERT_POP1_AFTER: Transformation = { insnList.insert(it, InsnNode(Opcodes.POP)) }\n        private val INSERT_POP2_AFTER: Transformation = { insnList.insert(it, InsnNode(Opcodes.POP2)) }\n\n       "}
{"code": " private val insnList = methodNode.instructions\n        private val insns = insnList.toArray()\n\n        private val dontTouchInsnIndices = BitSet(insns.size)\n\n        fun transform() {\n            val frames = FastMethodAnalyzer(\"fake\", methodNode, HazardsTrackingInterpreter()).analyze()\n            for ((i, insn) in insns.withIndex()) {\n                val frame = frames[i] ?: continue\n                when (insn.opcode) {\n                    Opcodes.POP ->\n                        frame.top()?.let { input ->\n                            // If this POP won't be removed, other POPs that touch the same values have to stay as well.\n                            if (input.insns.any { it.shouldKeep() } || input.longerWhenFusedWithPop()) {\n                                input.insns.markAsDontTouch()\n                            }\n                        }\n                    Opcodes.POP2 -> frame.peekWords(2)?.forEach { it.insns.markAsDontTouch() }\n                    Opcodes.DUP_X1 -> frame.pee"}
{"code": "kWords(1, 1)?.forEach { it.insns.markAsDontTouch() }\n                    Opcodes.DUP2_X1 -> frame.peekWords(2, 1)?.forEach { it.insns.markAsDontTouch() }\n                    Opcodes.DUP_X2 -> frame.peekWords(1, 2)?.forEach { it.insns.markAsDontTouch() }\n                    Opcodes.DUP2_X2 -> frame.peekWords(2, 2)?.forEach { it.insns.markAsDontTouch() }\n                }\n            }\n\n            val transformations = hashMapOf<AbstractInsnNode, Transformation>()\n            for ((i, insn) in insns.withIndex()) {\n                val frame = frames[i] ?: continue\n                if (insn.opcode == Opcodes.POP) {\n                    val input = frame.top() ?: continue\n                    if (input.insns.none { it.shouldKeep() }) {\n                        transformations[insn] = REPLACE_WITH_NOP\n                        input.insns.forEach {\n                            if (it !in transformations) {\n                                transformations[it] = it.combineWithPop(frames, input.size)\n"}
{"code": "                            }\n                        }\n                    }\n                }\n            }\n            for ((insn, transformation) in transformations.entries) {\n                transformation(insn)\n            }\n        }\n\n        private inner class HazardsTrackingInterpreter : SourceInterpreter(Opcodes.API_VERSION) {\n            override fun naryOperation(insn: AbstractInsnNode, values: MutableList<out SourceValue>): SourceValue {\n                for (value in values) {\n                    value.insns.markAsDontTouch()\n                }\n                return super.naryOperation(insn, values)\n            }\n\n            override fun copyOperation(insn: AbstractInsnNode, value: SourceValue): SourceValue {\n                value.insns.markAsDontTouch()\n                return super.copyOperation(insn, value)\n            }\n\n            override fun unaryOperation(insn: AbstractInsnNode, value: SourceValue): SourceValue {\n                value.insns.markAsDontTouch()\n    "}
{"code": "            return super.unaryOperation(insn, value)\n            }\n\n            override fun binaryOperation(insn: AbstractInsnNode, value1: SourceValue, value2: SourceValue): SourceValue {\n                value1.insns.markAsDontTouch()\n                value2.insns.markAsDontTouch()\n                return super.binaryOperation(insn, value1, value2)\n            }\n\n            override fun ternaryOperation(\n                insn: AbstractInsnNode,\n                value1: SourceValue,\n                value2: SourceValue,\n                value3: SourceValue\n            ): SourceValue {\n                value1.insns.markAsDontTouch()\n                value2.insns.markAsDontTouch()\n                value3.insns.markAsDontTouch()\n                return super.ternaryOperation(insn, value1, value2, value3)\n            }\n        }\n\n        private fun Collection<AbstractInsnNode>.markAsDontTouch() {\n            forEach {\n                dontTouchInsnIndices[insnList.indexOf(it)] = true\n            }"}
{"code": "\n        }\n\n        private fun SourceValue.longerWhenFusedWithPop() = insns.fold(0) { x, insn ->\n            when {\n                insn.isPurePush() -> x - 1\n                insn.isPrimitiveBoxing() || insn.isPrimitiveTypeConversion() -> x\n                else -> x + 1\n            }\n        } > 0\n\n        private fun AbstractInsnNode.combineWithPop(frames: Array<out Frame<SourceValue>?>, resultSize: Int): Transformation =\n            when {\n                isPurePush() -> REPLACE_WITH_NOP\n                isPrimitiveBoxing() || isPrimitiveTypeConversion() -> {\n                    val index = insnList.indexOf(this)\n                    val frame = frames[index] ?: throw AssertionError(\"dead instruction #$index used by non-dead instruction\")\n                    val input = frame.top() ?: throw AssertionError(\"coercion instruction at #$index has no input\")\n                    when (input.size) {\n                        1 -> REPLACE_WITH_POP1\n                        2 -> REPLACE_WITH_POP2\n"}
{"code": "                        else -> throw AssertionError(\"Unexpected pop value size: ${input.size}\")\n                    }\n                }\n                else ->\n                    when (resultSize) {\n                        1 -> INSERT_POP1_AFTER\n                        2 -> INSERT_POP2_AFTER\n                        else -> throw AssertionError(\"Unexpected pop value size: $resultSize\")\n                    }\n            }\n\n        private fun AbstractInsnNode.shouldKeep() =\n            dontTouchInsnIndices[insnList.indexOf(this)]\n    }\n}\n\nfun AbstractInsnNode.isPurePush() =\n    isLoadOperation() || opcode in Opcodes.ACONST_NULL..Opcodes.LDC + 2 || isUnitInstance()\n\nfun AbstractInsnNode.isPop() =\n    opcode == Opcodes.POP || opcode == Opcodes.POP2\n\nfun AbstractInsnNode.isUnitInstance() =\n    opcode == Opcodes.GETSTATIC && this is FieldInsnNode && owner == \"kotlin/Unit\" && name == \"INSTANCE\"\n\nfun AbstractInsnNode.isPrimitiveTypeConversion() =\n    opcode in Opcodes.I2L..Opcodes.I2S\n"}
{"code": "\n\npackage org.jetbrains.kotlin.build.report\n\ninterface RemoteICReporter : ICReporter,\n    RemoteReporter"}
{"code": "// LANGUAGE: +ContractSyntaxV2\n\nfun <caret>foo(bool: Boolean) contract [\n    returns() implies bool\n] = bool\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.declarations.renderers.classifiers\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.renderer.declarations.KtDeclarationRenderer\nimport org.jetbrains.kotlin.analysis.api.renderer.declarations.renderAnnotationsModifiersAndContextReceivers\nimport org.jetbrains.kotlin.analysis.api.symbols.KtClassKind\nimport org.jetbrains.kotlin.analysis.api.symbols.KtConstructorSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtNamedClassOrObjectSymbol\nimport org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter\nimport org.jetbrains.kotlin.lexer.KtTokens\n\npublic interface KtNamedClassOrObjectSymbolRenderer {\n    context(KtAnalysisSession, KtDeclarationRenderer)\n    public fun renderSymbol(symbol: KtNamedClassOrObjectSymbol, printer: PrettyPrinter)\n\n    public object AS_SOURCE: AsSourceRenderer(true)\n    public object AS_SOURCE_WITHOUT_PRIMARY_CONSTRUCTOR: AsSourceRenderer(false)\n\n    public o"}
{"code": "pen class AsSourceRenderer(private val withPrimaryConstructor: Boolean) : KtNamedClassOrObjectSymbolRenderer {\n        context(KtAnalysisSession, KtDeclarationRenderer)\n        override fun renderSymbol(symbol: KtNamedClassOrObjectSymbol, printer: PrettyPrinter): Unit = printer {\n            val keywords = when (symbol.classKind) {\n                KtClassKind.CLASS -> listOf(KtTokens.CLASS_KEYWORD)\n                KtClassKind.ENUM_CLASS -> listOf(KtTokens.ENUM_KEYWORD, KtTokens.CLASS_KEYWORD)\n                KtClassKind.ANNOTATION_CLASS -> listOf(KtTokens.ANNOTATION_KEYWORD, KtTokens.CLASS_KEYWORD)\n                KtClassKind.OBJECT -> listOf(KtTokens.OBJECT_KEYWORD)\n                KtClassKind.COMPANION_OBJECT -> listOf(KtTokens.COMPANION_KEYWORD, KtTokens.OBJECT_KEYWORD)\n                KtClassKind.INTERFACE -> listOf(KtTokens.INTERFACE_KEYWORD)\n                KtClassKind.ANONYMOUS_OBJECT -> error(\"KtNamedClassOrObjectSymbol cannot be KtAnonymousObjectSymbol\")\n            }\n\n       "}
{"code": "     \" \".separated(\n                { renderAnnotationsModifiersAndContextReceivers(symbol, printer, keywords) },\n                {\n                    val primaryConstructor = if (withPrimaryConstructor)\n                        bodyMemberScopeProvider.getMemberScope(symbol).filterIsInstance<KtConstructorSymbol>()\n                            .firstOrNull { it.isPrimary }\n                    else null\n\n                    nameRenderer.renderName(symbol, printer)\n                    typeParametersRenderer.renderTypeParameters(symbol, printer)\n                    if (primaryConstructor != null) {\n                        val annotationsPrinted = checkIfPrinted { renderAnnotationsModifiersAndContextReceivers(primaryConstructor, printer) }\n                        if (annotationsPrinted) {\n                            withPrefix(\" \") {\n                                keywordsRenderer.renderKeyword(KtTokens.CONSTRUCTOR_KEYWORD, primaryConstructor, printer)\n                            }\n        "}
{"code": "                }\n                        if (primaryConstructor.valueParameters.isNotEmpty()) {\n                            valueParametersRenderer.renderValueParameters(primaryConstructor, printer)\n                        }\n                    }\n                },\n                { typeParametersRenderer.renderWhereClause(symbol, printer) },\n                { withPrefix(\": \") { superTypeListRenderer.renderSuperTypes(symbol, printer) } },\n                { classifierBodyRenderer.renderBody(symbol, printer) }\n            )\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.parameters\n\nimport com.intellij.psi.PsiModifierList\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.symbols.KtValueParameterSymbol\nimport org.jetbrains.kotlin.asJava.classes.lazyPub\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget\nimport org.jetbrains.kotlin.light.classes.symbol.annotations.GranularAnnotationsBox\nimport org.jetbrains.kotlin.light.classes.symbol.annotations.NullabilityAnnotationsProvider\nimport org.jetbrains.kotlin.light.classes.symbol.annotations.SymbolAnnotationsProvider\nimport org.jetbrains.kotlin.light.classes.symbol.annotations.toOptionalFilter\nimport org.jetbrains.kotlin.light.classes.symbol.methods.SymbolLightMethodBase\nimport org.jetbrains.kotlin.light.classes.symbol.modifierLists.SymbolLightClassModifierList\nimport org.jetbrains.kotlin.utils.addToStdlib.ifTrue\n\ninternal class SymbolLightParameter(\n    ktAnalysisSession: KtAnalysisSe"}
{"code": "ssion,\n    parameterSymbol: KtValueParameterSymbol,\n    containingMethod: SymbolLightMethodBase\n) : SymbolLightParameterCommon(ktAnalysisSession, parameterSymbol, containingMethod) {\n    private val isConstructorParameterSymbol = containingMethod.isConstructor\n\n    override fun getModifierList(): PsiModifierList = _modifierList\n\n    private val _modifierList: PsiModifierList by lazyPub {\n        SymbolLightClassModifierList(\n            containingDeclaration = this,\n            annotationsBox = GranularAnnotationsBox(\n                annotationsProvider = SymbolAnnotationsProvider(\n                    ktModule = ktModule,\n                    annotatedSymbolPointer = parameterSymbolPointer,\n                    annotationUseSiteTargetFilter = isConstructorParameterSymbol.ifTrue {\n                        AnnotationUseSiteTarget.CONSTRUCTOR_PARAMETER\n                    }.toOptionalFilter(),\n                ),\n                additionalAnnotationsProvider = NullabilityAnnotationsProvider(:"}
{"code": ":typeNullability),\n            ),\n        )\n    }\n}"}
{"code": "import a.b.c.<expr>e</expr>\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.inline\n\nimport org.jetbrains.kotlin.codegen.inline.ReifiedTypeInliner.Companion.isNeedClassReificationMarker\nimport org.jetbrains.kotlin.codegen.optimization.common.InsnSequence\nimport org.jetbrains.kotlin.codegen.optimization.common.asSequence\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes\nimport org.jetbrains.kotlin.util.OperatorNameConventions\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.commons.Method\nimport org.jetbrains.org.objectweb.asm.tree.*\nimport kotlin.math.max\n\nprivate data class Condition(\n    val mask: Int, val constant: Int,\n    val maskInstruction: VarInsnNode,\n    val jumpInstruction: JumpInsnNode,\n    val varInsNode: VarInsnNode?\n) {\n    val expandNotDelete = mask and constant != 0\n    val varIndex = varInsNode?.`var` ?: 0\n}\n\nclass ExtractedDefaultLambda(val type: Type, val capturedArgs: Array<Type>, val offset: Int, val needReification: Boole"}
{"code": "an)\n\nfun expandMaskConditionsAndUpdateVariableNodes(\n    node: MethodNode,\n    maskStartIndex: Int,\n    masks: List<Int>,\n    methodHandlerIndex: Int,\n    validOffsets: Collection<Int>\n): List<ExtractedDefaultLambda> {\n    fun isMaskIndex(varIndex: Int): Boolean {\n        return maskStartIndex <= varIndex && varIndex < maskStartIndex + masks.size\n    }\n\n    val maskProcessingHeader = node.instructions.asSequence().takeWhile {\n        if (it is VarInsnNode) {\n            if (isMaskIndex(it.`var`)) {\n                \n                return@takeWhile it.opcode == Opcodes.ILOAD\n            } else if (methodHandlerIndex == it.`var`) {\n                return@takeWhile it.opcode == Opcodes.ALOAD\n            }\n        }\n        true\n    }\n\n    val conditions = maskProcessingHeader.filterIsInstance<VarInsnNode>().mapNotNull {\n        if (isMaskIndex(it.`var`) &&\n            it.next?.next?.opcode == Opcodes.IAND &&\n            it.next.next.next?.opcode == Opcodes.IFEQ\n        ) {\n            val"}
{"code": " jumpInstruction = it.next?.next?.next as JumpInsnNode\n            Condition(\n                masks[it.`var` - maskStartIndex],\n                getConstant(it.next),\n                it,\n                jumpInstruction,\n                jumpInstruction.label.previous as VarInsnNode\n            )\n        } else if (methodHandlerIndex == it.`var` &&\n            it.next?.opcode == Opcodes.IFNULL &&\n            it.next.next?.opcode == Opcodes.NEW\n        ) {\n            //Always delete method handle for now\n            //This logic should be updated when method handles would be supported\n            Condition(0, 0, it, it.next as JumpInsnNode, null)\n        } else null\n    }.toList()\n\n    val toDelete = linkedSetOf<AbstractInsnNode>()\n    val toInsert = arrayListOf<Pair<AbstractInsnNode, AbstractInsnNode>>()\n\n    val extractable = conditions.filter { it.expandNotDelete && it.varIndex in validOffsets }\n    val defaultLambdasInfo = extractDefaultLambdasInfo(extractable, toDelete, toInsert)\n\n  "}
{"code": "  val indexToVarNode = node.localVariables?.filter { it.index < maskStartIndex }?.associateBy { it.index } ?: emptyMap()\n    conditions.forEach {\n        val jumpInstruction = it.jumpInstruction\n        InsnSequence(it.maskInstruction, (if (it.expandNotDelete) jumpInstruction.next else jumpInstruction.label)).forEach {\n            toDelete.add(it)\n        }\n        if (it.expandNotDelete) {\n            indexToVarNode[it.varIndex]?.let { varNode ->\n                varNode.start = it.jumpInstruction.label\n            }\n        }\n    }\n\n    toInsert.forEach { (position, newInsn) ->\n        node.instructions.insert(position, newInsn)\n    }\n\n    node.localVariables.removeIf {\n        (it.start in toDelete && it.end in toDelete) || validOffsets.contains(it.index)\n    }\n\n    node.tryCatchBlocks.removeIf {\n        toDelete.contains(it.start) && toDelete.contains(it.end)\n    }\n\n    node.remove(toDelete)\n\n    return defaultLambdasInfo\n}\n\nprivate fun extractDefaultLambdasInfo(\n    conditions: Lis"}
{"code": "t<Condition>,\n    toDelete: MutableCollection<AbstractInsnNode>,\n    toInsert: MutableList<Pair<AbstractInsnNode, AbstractInsnNode>>\n): List<ExtractedDefaultLambda> {\n    return conditions.map {\n        val varAssignmentInstruction = it.varInsNode!!\n        var instanceInstuction = varAssignmentInstruction.previous\n        if (instanceInstuction is TypeInsnNode && instanceInstuction.opcode == Opcodes.CHECKCAST) {\n            instanceInstuction = instanceInstuction.previous\n        }\n\n        val (owner, argTypes, needReification) = when (instanceInstuction) {\n            is MethodInsnNode -> {\n                assert(instanceInstuction.name == \"<init>\") { \"Expected constructor call for default lambda, but $instanceInstuction\" }\n                val ownerInternalName = instanceInstuction.owner\n                val instanceCreation = InsnSequence(it.jumpInstruction, it.jumpInstruction.label).filter {\n                    it.opcode == Opcodes.NEW && (it as TypeInsnNode).desc == ownerInternalN"}
{"code": "ame\n                }.single()\n\n                assert(instanceCreation.next?.opcode == Opcodes.DUP) {\n                    \"Dup should follow default lambda instanceInstruction creation but ${instanceCreation.next}\"\n                }\n\n                toDelete.apply {\n                    addAll(listOf(instanceCreation, instanceCreation.next))\n                    addAll(InsnSequence(instanceInstuction, varAssignmentInstruction.next).toList())\n                }\n\n                val needReification =\n                    instanceCreation.previous.takeIf { isNeedClassReificationMarker(it) }?.let { toDelete.add(it) } != null\n                Triple(Type.getObjectType(instanceInstuction.owner), Type.getArgumentTypes(instanceInstuction.desc), needReification)\n            }\n\n            is FieldInsnNode -> {\n                toDelete.addAll(InsnSequence(instanceInstuction, varAssignmentInstruction.next).toList())\n\n                val needReification =\n                    instanceInstuction.previou"}
{"code": "s.takeIf { isNeedClassReificationMarker(it) }?.let { toDelete.add(it) } != null\n\n                Triple(Type.getObjectType(instanceInstuction.owner), emptyArray<Type>(), needReification)\n            }\n            else -> throw RuntimeException(\"Can't extract default lambda info $it.\\n Unknown instruction: ${instanceInstuction.insnText}\")\n        }\n\n        toInsert.add(varAssignmentInstruction to defaultLambdaFakeCallStub(argTypes, it.varIndex))\n\n        ExtractedDefaultLambda(owner, argTypes, it.varIndex, needReification)\n    }\n}\n\n//marker that removes captured parameters from stack\n//at inlining it would be substituted with parameters store\nprivate fun defaultLambdaFakeCallStub(args: Array<Type>, lambdaOffset: Int): MethodInsnNode {\n    return MethodInsnNode(\n        Opcodes.INVOKESTATIC,\n        DEFAULT_LAMBDA_FAKE_CALL,\n        DEFAULT_LAMBDA_FAKE_CALL + lambdaOffset,\n        Type.getMethodDescriptor(Type.VOID_TYPE, *args),\n        false\n    )\n}\n\nfun loadDefaultLambdaBody(classByte"}
{"code": "s: ByteArray, classType: Type, isPropertyReference: Boolean): SMAPAndMethodNode {\n    // In general we can't know what the correct unboxed `invoke` is, and what Kotlin types its arguments have,\n    // as the type of this object may be any subtype of the parameter's type. All we know is that Function<N>\n    // has to have a `invoke` that takes `Object`s and returns an `Object`; everything else needs to be figured\n    // out from its contents. TODO: for > 22 arguments, the only argument is an array. `MethodInliner` can't do that.\n    val invokeName = if (isPropertyReference) OperatorNameConventions.GET.asString() else OperatorNameConventions.INVOKE.asString()\n    val invokeNode = getMethodNode(classBytes, classType) {\n        it.name == invokeName && it.returnType == AsmTypes.OBJECT_TYPE && it.argumentTypes.all { arg -> arg == AsmTypes.OBJECT_TYPE }\n    } ?: error(\"can't find erased invoke '$invokeName(Object...): Object' in default lambda '${classType.internalName}'\")\n    return if (inv"}
{"code": "okeNode.node.access.and(Opcodes.ACC_BRIDGE) == 0)\n        invokeNode\n    else\n        invokeNode.node.inlineBridge(classBytes, classType)\n}\n\nprivate fun MethodNode.inlineBridge(classBytes: ByteArray, classType: Type): SMAPAndMethodNode {\n    // If the erased invoke is a bridge, we need to locate the unboxed invoke and inline it. As mentioned above,\n    // we don't know what the Kotlin types of its arguments/returned value are, so we can't generate our own\n    // boxing/unboxing code; luckily, the bridge already has that.\n    val invokeInsn = instructions.singleOrNull { it is MethodInsnNode && it.owner == classType.internalName } as MethodInsnNode?\n        ?: error(\"no single invoke of method on this in '${name}${desc}' of default lambda '${classType.internalName}'\")\n    val targetMethod = Method(invokeInsn.name, invokeInsn.desc)\n    val target = getMethodNode(classBytes, classType, targetMethod)\n        ?: error(\"can't find non-bridge invoke '$targetMethod' in default lambda '${classTy"}
{"code": "pe.internalName}\")\n\n    // Store unboxed/casted arguments in the correct variable slots\n    val targetArgs = targetMethod.argumentTypes\n    val targetArgsSize = targetArgs.sumOf { it.size } + if (target.node.access.and(Opcodes.ACC_STATIC) == 0) 1 else 0\n    var offset = targetArgsSize\n    for (type in targetArgs.reversed()) {\n        offset -= type.size\n        instructions.insertBefore(invokeInsn, VarInsnNode(type.getOpcode(Opcodes.ISTORE), offset))\n    }\n    if (target.node.access.and(Opcodes.ACC_STATIC) == 0) {\n        instructions.insertBefore(invokeInsn, InsnNode(Opcodes.POP)) // this\n    }\n\n    // Remap returns and ranges for arguments' LVT entries\n    val invokeLabel = LabelNode()\n    val returnLabel = LabelNode()\n    instructions.insertBefore(invokeInsn, invokeLabel)\n    instructions.insert(invokeInsn, returnLabel)\n    for (insn in target.node.instructions) {\n        if (insn.opcode in Opcodes.IRETURN..Opcodes.RETURN) {\n            target.node.instructions.set(insn, JumpInsnNod"}
{"code": "e(Opcodes.GOTO, returnLabel))\n        }\n    }\n    for (local in target.node.localVariables) {\n        if (local.index < targetArgsSize) {\n            local.start = invokeLabel\n            local.end = returnLabel\n        }\n    }\n\n    // Insert contents of the method into the bridge\n    instructions.filterIsInstance<LineNumberNode>().forEach { instructions.remove(it) } // those are not meaningful\n    instructions.insertBefore(invokeInsn, target.node.instructions)\n    instructions.remove(invokeInsn)\n    localVariables = target.node.localVariables\n    tryCatchBlocks = target.node.tryCatchBlocks\n    maxLocals = max(maxLocals, target.node.maxLocals)\n    maxStack = max(maxStack, target.node.maxStack)\n    return SMAPAndMethodNode(this, target.classSMAP)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.web.common.checkers.expression\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.expression.FirFunctionCallChecker\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.web.common.FirWebCommonErrors\nimport org.jetbrains.kotlin.fir.analysis.web.common.checkers.FirAbstractWebCheckerUtils\nimport org.jetbrains.kotlin.fir.expressions.FirFunctionCall\nimport org.jetbrains.kotlin.fir.expressions.forAllReifiedTypeParameters\nimport org.jetbrains.kotlin.fir.types.toSymbol\n\nabstract class FirAbstractReifiedExternalChecker(\n    private val webCheckerUtils: FirAbstractWebCheckerUtils\n) : FirFunctionCallChecker(MppCheckerKind.Common) {\n    override fun check(expression: FirFunctionCall, context: CheckerContext, repo"}
{"code": "rter: DiagnosticReporter) {\n        expression.forAllReifiedTypeParameters { type, typeArgument ->\n            val typeSymbol = type.toSymbol(context.session)\n            if (typeSymbol != null && webCheckerUtils.isNativeOrExternalInterface(typeSymbol, context.session)) {\n                reporter.reportOn(\n                    typeArgument.source ?: expression.source,\n                    FirWebCommonErrors.EXTERNAL_INTERFACE_AS_REIFIED_TYPE_ARGUMENT,\n                    type,\n                    context\n                )\n            }\n        }\n    }\n}\n"}
{"code": "fun <A> foo(): A {}\n\nfun <A> A.foo1() {}\n\nfun <A> foo2(a: A) {}\n\nfun <A, B: Number> foo3(a: A): Map<B, List<A>> {}\n\nfun <A, B: Collection<A>, C : A> foo4(a: A): B {}\n\nval <A> A.bar1: Int get() = 10\n\nval <A> A.bar2: List<A> get() = listOf(this)"}
{"code": "package test\n\ninterface MyInterface\n\nopen class Base {\n    class Nested : MyInterface\n}\n\nclass Child(constructorParam: MyInterface) : Base(), MyInterface by <expr>Nested()</expr>"}
{"code": "\n\npackage org.jetbrains.kotlin.cli.common.repl\n\nimport java.util.concurrent.locks.ReentrantReadWriteLock\nimport kotlin.concurrent.read\nimport kotlin.concurrent.write\n\n\ninterface ILineId : Comparable<ILineId> {\n    val no: Int\n    val generation: Int\n}\n\ndata class ReplHistoryRecord<out T> (val id: ILineId, val item: T)\n\ninterface IReplStageHistory<T> : List<ReplHistoryRecord<T>> {\n\n    fun peek(): ReplHistoryRecord<T>? = lock.read { lastOrNull() }\n\n    fun push(id: ILineId, item: T)\n\n    fun pop(): ReplHistoryRecord<T>?\n\n    fun verifiedPop(id: ILineId): ReplHistoryRecord<T>? = lock.write {\n        if (lastOrNull()?.id == id) pop()\n        else null\n    }\n\n    fun reset(): Iterable<ILineId>\n\n    fun resetTo(id: ILineId): Iterable<ILineId>\n\n    val lock: ReentrantReadWriteLock\n}\n\ninterface IReplStageState<T> {\n    val history: IReplStageHistory<T>\n\n    val lock: ReentrantReadWriteLock\n\n    val currentGeneration: Int\n\n    fun getNextLineNo(): Int = history.peek()?.id?.no?.let { it + 1 } ?"}
{"code": ": REPL_CODE_LINE_FIRST_NO // TODO: it should be more robust downstream (e.g. use atomic)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun <StateT : IReplStageState<*>> asState(target: Class<out StateT>): StateT =\n        if (target.isAssignableFrom(this::class.java)) this as StateT\n        else throw IllegalArgumentException(\"$this is not an expected instance of IReplStageState\")\n\n    fun dispose() {\n    }\n}\n\n\nfun <T> IReplStageHistory<T>.firstMismatch(other: Sequence<ILineId>): Pair<ReplHistoryRecord<T>?, ILineId?>? =\n        lock.read {\n            iterator().asSequence().zip(other.asSequence()).firstOrNull { it.first.id != it.second }?.let { it.first to it.second }\n        }\n\nfun<T> IReplStageHistory<T>.firstMismatchFiltered(other: Sequence<ILineId>, predicate: (ReplHistoryRecord<T>) -> Boolean): Pair<ReplHistoryRecord<T>?, ILineId?>? =\n        lock.read {\n            iterator().asSequence().filter(predicate).zip(other.asSequence()).firstOrNull { it.first.id != it.second }?.let { it.first t"}
{"code": "o it.second }\n        }\n\nfun<T> IReplStageHistory<T>.firstMismatchWhile(other: Sequence<ILineId>, predicate: (ReplHistoryRecord<T>) -> Boolean): Pair<ReplHistoryRecord<T>?, ILineId?>? =\n        lock.read {\n            iterator().asSequence().takeWhile(predicate).zip(other.asSequence()).firstOrNull { it.first.id != it.second }?.let { it.first to it.second }\n        }\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.expression\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.KtRealSourceElementKind\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.declaration.hasExplicitReturnType\nimport org.jetbrains.kotlin.fir.analysis.checkers.isSubtypeForTypeMismatch\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NULL_FOR_NONNULL_TYPE\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RETURN_TYPE_MISMATCH\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SMARTCAST_IMPOSSIBLE\nimport org.jetbrains.kotlin.fir.declarations.FirAnonymousFunction\nimport org.jetbrains.kotlin.fir.declarations.FirConstructor\nimport org.jetbrains.kotlin.fir.declarations.Fi"}
{"code": "rErrorFunction\nimport org.jetbrains.kotlin.fir.declarations.FirPropertyAccessor\nimport org.jetbrains.kotlin.fir.expressions.FirReturnExpression\nimport org.jetbrains.kotlin.fir.expressions.FirSmartCastExpression\nimport org.jetbrains.kotlin.fir.expressions.FirWhenExpression\nimport org.jetbrains.kotlin.fir.expressions.impl.FirUnitExpression\nimport org.jetbrains.kotlin.fir.expressions.isExhaustive\nimport org.jetbrains.kotlin.fir.resolve.fullyExpandedType\nimport org.jetbrains.kotlin.fir.types.*\n\nobject FirFunctionReturnTypeMismatchChecker : FirReturnExpressionChecker(MppCheckerKind.Common) {\n    override fun check(expression: FirReturnExpression, context: CheckerContext, reporter: DiagnosticReporter) {\n        // checked in FirDelegatedPropertyChecker\n        if (expression.source?.kind == KtFakeSourceElementKind.DelegatedPropertyAccessor) return\n\n        val targetElement = expression.target.labeledElement\n        if (targetElement is FirErrorFunction) {\n            return\n        }\n\n     "}
{"code": "   val sourceKind = expression.source?.kind\n        if (\n            !targetElement.symbol.hasExplicitReturnType &&\n            sourceKind != KtRealSourceElementKind &&\n            targetElement !is FirPropertyAccessor\n        ) {\n            return\n        }\n        val resultExpression = expression.result\n        // To avoid duplications with NO_ELSE_IN_WHEN or INVALID_IF_AS_EXPRESSION\n        if (resultExpression is FirWhenExpression && !resultExpression.isExhaustive) return\n\n        val functionReturnType = if (targetElement is FirConstructor)\n            context.session.builtinTypes.unitType.coneType\n        else\n            targetElement.returnTypeRef.coneType\n        if (targetElement is FirAnonymousFunction) {\n            if (sourceKind is KtFakeSourceElementKind.ImplicitReturn.FromLastStatement &&\n                functionReturnType.isUnit\n            ) {\n                return\n            }\n            if (targetElement.isLambda) {\n                // In lambda, we normally hav"}
{"code": "e ARGUMENT_TYPE_MISMATCH or some other diagnostic(s) at return statement\n                // Exceptions:\n                when {\n                    // 1) lambda inferred to Unit (coercion-to-Unit case), e.g. testLocalReturnSecondUnit\n                    // val a = b@ {\n                    //    if (flag) return@b 4 // Should be error\n                    //    return@b\n                    // }\n                    functionReturnType.isUnit -> {}\n                    // 2) return without explicitly given argument (implicit Unit case), e.g. testKt66277\n                    // val x: () -> Any = l@ {\n                    //    if (\"0\".hashCode() == 42) return@l // Should be error (explicit return@l Unit would be Ok)\n                    //    \"\"\n                    // }\n                    resultExpression is FirUnitExpression && resultExpression.source?.kind is KtFakeSourceElementKind.ImplicitUnit -> {}\n                    // Otherwise, we don't want to report anything\n                    else "}
{"code": "-> return\n                }\n            }\n        }\n\n        val typeContext = context.session.typeContext\n        val returnExpressionType = resultExpression.resolvedType\n\n        if (!isSubtypeForTypeMismatch(typeContext, subtype = returnExpressionType, supertype = functionReturnType)) {\n            if (resultExpression.isNullLiteral && functionReturnType.nullability == ConeNullability.NOT_NULL) {\n                reporter.reportOn(resultExpression.source, NULL_FOR_NONNULL_TYPE, functionReturnType, context)\n            } else {\n                val isDueToNullability =\n                    context.session.typeContext.isTypeMismatchDueToNullability(returnExpressionType, functionReturnType)\n                if (resultExpression is FirSmartCastExpression && !resultExpression.isStable &&\n                    isSubtypeForTypeMismatch(typeContext, subtype = resultExpression.smartcastType.coneType, supertype = functionReturnType)\n                ) {\n                    reporter.reportOn(\n       "}
{"code": "                 resultExpression.source,\n                        SMARTCAST_IMPOSSIBLE,\n                        functionReturnType,\n                        resultExpression,\n                        resultExpression.smartcastStability.description,\n                        isDueToNullability,\n                        context\n                    )\n                } else {\n                    reporter.reportOn(\n                        resultExpression.source,\n                        RETURN_TYPE_MISMATCH,\n                        functionReturnType,\n                        returnExpressionType,\n                        targetElement,\n                        isDueToNullability,\n                        context\n                    )\n                }\n            }\n        } else if (resultExpression.source?.kind is KtFakeSourceElementKind.ImplicitUnit &&\n            !functionReturnType.fullyExpandedType(context.session).lowerBoundIfFlexible().isUnit\n        ) {\n            // Disallow cases like\n "}
{"code": "           //     fun foo(): Any { return }\n            // Allow cases like\n            //     fun foo(): Unit { return }\n            //     fun foo() { return Unit }\n            // If type parameter is specified explicitly, checking is performed in the branch above and RETURN_TYPE_MISMATCH is reported\n            reporter.reportOn(\n                resultExpression.source,\n                RETURN_TYPE_MISMATCH,\n                functionReturnType,\n                returnExpressionType,\n                targetElement,\n                false,\n                context\n            )\n        }\n    }\n}\n\n"}
{"code": "package one\n\ninterface Interface {\n    fun foo(param: String)\n}\n\nopen class ClassWithParameter(i: Interface)\n\nclass TopLevelClass : ClassWithParameter(object : Interface {\n    class NestedClassFromAnonymousObject\n})\n"}
{"code": "\n\npackage org.jetbrains.kotlin.diagnostics\n\nimport com.intellij.psi.PsiElement\n\ninterface DiagnosticMarker {\n    val psiElement: PsiElement\n    val factoryName: String\n}\n\ninterface DiagnosticWithParameters1Marker<A> : DiagnosticMarker {\n    val a: A\n}\n\ninterface DiagnosticWithParameters2Marker<A, B> : DiagnosticMarker {\n    val a: A\n    val b: B\n}\n\ninterface DiagnosticWithParameters3Marker<A, B, C> : DiagnosticMarker {\n    val a: A\n    val b: B\n    val c: C\n}\n\ninterface DiagnosticWithParameters4Marker<A, B, C, D> : DiagnosticMarker {\n    val a: A\n    val b: B\n    val c: C\n    val d: D\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.diagnostics.rendering\n\nimport org.jetbrains.kotlin.diagnostics.*\n\nfun RenderingContext.Companion.parameters(d: Diagnostic): List<Any> = when (d) {\n    is SimpleDiagnostic<*> -> listOf()\n    is DiagnosticWithParameters1<*, *> -> listOf(d.a)\n    is DiagnosticWithParameters2<*, *, *> -> listOf(d.a, d.b)\n    is DiagnosticWithParameters3<*, *, *, *> -> listOf(d.a, d.b, d.c)\n    is DiagnosticWithParameters4<*, *, *, *, *> -> listOf(d.a, d.b, d.c, d.d)\n    is ParametrizedDiagnostic<*> -> error(\"Unexpected diagnostic: ${d::class.java}\")\n    else -> listOf()\n}\n\nfun RenderingContext.Companion.fromDiagnostic(d: Diagnostic): RenderingContext = RenderingContext.Impl(parameters(d))\n"}
{"code": "// MODULE: lib\n\n// FILE: some/Dependency.kt\npackage some\n\ninterface Flag<T>\n\nclass Dependency {\n    companion object Named {\n        @JvmField val JVM_FIELD_FLAG: Flag<*> = TODO()\n        @JvmStatic val JVM_STATIC_FLAG: Flag<*> = TODO()\n        val VAL_FLAG: Flag<*> = TODO()\n        var varFlag: Flag<*> = TODO()\n    }\n}\n\nval DEPENDENCY_TOP_LEVEL_VAL_FLAG: Flag<*> = TODO()\n\n// MODULE: app(lib)\n// MODULE_KIND: Source\n// FILE: main.kt\n\npackage some\n\nprivate fun consumeFlag(p: Flag<*>) {\n    println(p)\n}\n\nfun test() {\n    consumeFlag(Dependency.JVM_FIELD_FLAG)\n    consumeFlag(Dependency.JVM_<caret>STATIC_FLAG)\n    consumeFlag(Dependency.VAL_FLAG)\n    consumeFlag(Dependency.varFlag)\n    consumeFlag(DEPENDENCY_TOP_LEVEL_VAL_FLAG)\n}"}
{"code": "package foo.bar.baz\n\nclass AA {\n    class BB {\n        companion object\n    }\n}\n\nfun test() {\n    val b = foo.bar.b<caret>az.AA.BB\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.caches\n\nimport org.jetbrains.kotlinx.lincheck.RandomProvider\nimport org.jetbrains.kotlinx.lincheck.annotations.Operation\nimport org.jetbrains.kotlinx.lincheck.annotations.Param\nimport org.jetbrains.kotlinx.lincheck.check\nimport org.jetbrains.kotlinx.lincheck.paramgen.ParameterGenerator\nimport org.jetbrains.kotlinx.lincheck.paramgen.StringGen\nimport org.jetbrains.kotlinx.lincheck.strategy.managed.modelchecking.ModelCheckingOptions\nimport org.jetbrains.kotlinx.lincheck.strategy.stress.StressOptions\nimport org.junit.jupiter.api.Test\nimport java.io.Serializable\n\n\n@Param(name = \"value\", gen = ValueWithCleanupGenerator::class)\nclass CleanableSoftValueCacheLincheckTest {\n    private val cache = CleanableSoftValueCache<Int, ValueWithCleanup> { it.cleanupMarker }\n\n    @Operation\n    fun get(key: Int): ValueWithCleanup? = cache.get(key)\n\n    @Operation\n    fun computeIfAbsent(\n        key: Int,\n        @Param(name = \"value\") value: ValueW"}
{"code": "ithCleanup,\n    ): ValueWithCleanup = cache.computeIfAbsent(key) { value }\n\n    \n    @Operation\n    fun computeReplaceValue(\n        key: Int,\n        @Param(name = \"value\") newValue: ValueWithCleanup,\n    ): ValueWithCleanup? = cache.compute(key) { _, _ -> newValue }\n\n    \n    @Operation\n    fun computeKeepValue(key: Int): ValueWithCleanup? = cache.compute(key) { _, existingValue -> existingValue }\n\n    \n    @Operation\n    fun computeRemoveValue(key: Int): ValueWithCleanup? = cache.compute(key) { _, _ -> null }\n\n    @Operation\n    fun put(\n        key: Int,\n        @Param(name = \"value\") value: ValueWithCleanup,\n    ): RemovalResult? = withRemovalResult { cache.put(key, value) }\n\n    @Operation\n    fun remove(key: Int): RemovalResult? = withRemovalResult { cache.remove(key) }\n\n    \n    data class RemovalResult(\n        val value: ValueWithCleanup,\n        val isCleanedUp: Boolean,\n    ) : Serializable\n\n    private fun withRemovalResult(operation: () -> ValueWithCleanup?): RemovalResul"}
{"code": "t? {\n        val value = operation() ?: return null\n        return RemovalResult(value, value.isCleanedUp)\n    }\n\n    @Test\n    fun modelCheckingTest() = ModelCheckingOptions().check(this::class)\n\n    @Test\n    fun stressTest() = StressOptions().check(this::class)\n}\n\nclass ValueWithCleanupGenerator(randomProvider: RandomProvider, configuration: String) : ParameterGenerator<ValueWithCleanup> {\n    private val stringGenerator: StringGen = StringGen(randomProvider, \"\")\n\n    override fun generate(): ValueWithCleanup = ValueWithCleanup(stringGenerator.generate())\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen\n\nimport org.jetbrains.kotlin.codegen.coroutines.INITIAL_DESCRIPTOR_FOR_SUSPEND_FUNCTION\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.descriptors.annotations.Annotations\nimport org.jetbrains.kotlin.descriptors.impl.FunctionDescriptorImpl\nimport org.jetbrains.kotlin.name.Name\nimport java.util.*\n\nclass AccessorForFunctionDescriptor(\n    override val calleeDescriptor: FunctionDescriptor,\n    containingDeclaration: DeclarationDescriptor,\n    override val superCallTarget: ClassDescriptor?,\n    private val nameSuffix: String,\n    override val accessorKind: AccessorKind\n) : AbstractAccessorForFunctionDescriptor(containingDeclaration, Name.identifier(\"access$$nameSuffix\")),\n    AccessorForCallableDescriptor<FunctionDescriptor> {\n\n    init {\n        initialize(\n            calleeDescriptor.extensionReceiverParameter?.copy(this),\n            if (calleeDescriptor is ConstructorDescriptor || calleeDescriptor.isJvmStaticInObjectOrClassO"}
{"code": "rInterface())\n                null\n            else\n                calleeDescriptor.dispatchReceiverParameter,\n            calleeDescriptor.contextReceiverParameters.map { p -> p.copy(this) },\n            copyTypeParameters(calleeDescriptor),\n            copyValueParameters(calleeDescriptor),\n            calleeDescriptor.returnType,\n            Modality.FINAL,\n            DescriptorVisibilities.LOCAL\n        )\n\n        isSuspend = calleeDescriptor.isSuspend\n        if (calleeDescriptor.getUserData(INITIAL_DESCRIPTOR_FOR_SUSPEND_FUNCTION) != null) {\n            userDataMap = LinkedHashMap<CallableDescriptor.UserDataKey<*>, Any>()\n            userDataMap[INITIAL_DESCRIPTOR_FOR_SUSPEND_FUNCTION] =\n                calleeDescriptor.getUserData(INITIAL_DESCRIPTOR_FOR_SUSPEND_FUNCTION)\n        }\n    }\n\n    override fun createSubstitutedCopy(\n        newOwner: DeclarationDescriptor,\n        original: FunctionDescriptor?,\n        kind: CallableMemberDescriptor.Kind,\n        newName: Name?,\n   "}
{"code": "     annotations: Annotations,\n        source: SourceElement\n    ): FunctionDescriptorImpl {\n        return AccessorForFunctionDescriptor(calleeDescriptor, newOwner, superCallTarget, nameSuffix, accessorKind)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.idea.references\n\nimport com.intellij.openapi.util.TextRange\nimport com.intellij.psi.*\nimport com.intellij.psi.impl.source.resolve.ResolveCache\nimport com.intellij.psi.util.MethodSignatureUtil\nimport org.jetbrains.kotlin.asJava.unwrapped\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtAnnotationEntry\nimport org.jetbrains.kotlin.psi.KtParameter\nimport org.jetbrains.kotlin.psi.KtPrimaryConstructor\nimport org.jetbrains.kotlin.psi.KtValueArgument\nimport org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType\n\n\nclass KtDefaultAnnotationArgumentReference(element: KtValueArgument) : AbstractKtReference<KtValueArgument>(element) {\n    override val resolver: ResolveCache.PolyVariantResolver<KtReference>\n        get() = Resolver\n\n    override val resolvesByNames: Collection<Name>\n        get() = listOf(Name.identifier(PsiAnnotation.DEFAULT_REFERENCED_METHOD_NAME))\n\n    override fun getRangeInElement() = TextRange.EMPTY_RANGE\n\n    override fun "}
{"code": "getCanonicalText() = PsiAnnotation.DEFAULT_REFERENCED_METHOD_NAME\n\n    override fun isReferenceTo(candidateTarget: PsiElement): Boolean {\n        val unwrapped = candidateTarget.unwrapped\n        return (unwrapped is PsiMethod || unwrapped is KtParameter) && unwrapped == resolve()\n    }\n\n    override fun canRename(): Boolean = true\n\n    private object Resolver : ResolveCache.PolyVariantResolver<KtReference> {\n        override fun resolve(t: KtReference, incompleteCode: Boolean): Array<ResolveResult> {\n            require(t is KtDefaultAnnotationArgumentReference)\n            val annotationPsi = t.resolveAnnotationCallee() ?: return emptyArray()\n            return when (annotationPsi) {\n                is PsiClass -> {\n                    val name = PsiAnnotation.DEFAULT_REFERENCED_METHOD_NAME\n                    val signature = MethodSignatureUtil.createMethodSignature(\n                        name, PsiType.EMPTY_ARRAY, PsiTypeParameter.EMPTY_ARRAY, PsiSubstitutor.EMPTY\n               "}
{"code": "     )\n                    val method = MethodSignatureUtil.findMethodBySignature(annotationPsi, signature, false) ?: return emptyArray()\n                    arrayOf(PsiElementResolveResult(method))\n                }\n                is KtPrimaryConstructor -> {\n                    // parameters in primary constructor on Kotlin annotation can have any names,\n                    // so we just take the first parameter\n                    val property = annotationPsi.valueParameters.firstOrNull() ?: return emptyArray()\n                    arrayOf(PsiElementResolveResult(property))\n                }\n                else -> emptyArray()\n            }\n        }\n\n        private fun KtDefaultAnnotationArgumentReference.resolveAnnotationCallee(): PsiElement? =\n            element.getStrictParentOfType<KtAnnotationEntry>()\n                ?.calleeExpression\n                ?.constructorReferenceExpression\n                ?.mainReference\n                ?.resolve()\n\n    }\n}\n"}
{"code": "open class A\n\nopen class B : A()\n\nopen class resolve<caret>Me : A()"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers\n\nimport org.jetbrains.kotlin.config.ApiVersion\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.expressions.FirLiteralExpression\nimport org.jetbrains.kotlin.fir.languageVersionSettings\nimport org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol\nimport org.jetbrains.kotlin.name.StandardClassIds\nimport org.jetbrains.kotlin.resolve.checkers.OptInNames\n\nsealed class FirSinceKotlinAccessibility {\n    object Accessible : FirSinceKotlinAccessibility()\n\n    data class NotAccessibleButWasExperimental(\n        val version: ApiVersion,\n        val markerClasses: List<FirRegularClassSymbol>\n    ) : FirSinceKotlinAccessibility()\n\n    data class NotAccessible(\n        val version: ApiVersion\n    ) : FirSinceKotlinAccessibility()\n}\n\nprivate data class FirSinceKotlinValue(\n    val apiVersion: ApiVer"}
{"code": "sion,\n    val wasExperimentalMarkerClasses: List<FirRegularClassSymbol>\n)\n\nfun FirDeclaration.checkSinceKotlinVersionAccessibility(context: CheckerContext): FirSinceKotlinAccessibility {\n    val value = getOwnSinceKotlinVersion(context.session)\n    val version = value?.apiVersion\n    val languageVersionSettings = context.session.languageVersionSettings\n\n    // Allow access in the following cases:\n    // 1) There's no @SinceKotlin annotation for this descriptor\n    // 2) There's a @SinceKotlin annotation but its value is some unrecognizable nonsense\n    // 3) The value as a version is not greater than our API version\n    if (version == null || version <= languageVersionSettings.apiVersion) return FirSinceKotlinAccessibility.Accessible\n\n    val wasExperimentalFqNames = value.wasExperimentalMarkerClasses\n    if (wasExperimentalFqNames.isNotEmpty()) {\n        return FirSinceKotlinAccessibility.NotAccessibleButWasExperimental(version, wasExperimentalFqNames)\n    }\n\n    return FirSinceKotlin"}
{"code": "Accessibility.NotAccessible(version)\n}\n\nprivate fun FirDeclaration.getOwnSinceKotlinVersion(session: FirSession): FirSinceKotlinValue? {\n    val sinceKotlinSingleArgument = getAnnotationByClassId(StandardClassIds.Annotations.SinceKotlin, session)?.findArgumentByName(\n        StandardClassIds.Annotations.ParameterNames.sinceKotlinVersion\n    )\n    val apiVersion = ((sinceKotlinSingleArgument as? FirLiteralExpression<*>)?.value as? String)?.let(ApiVersion.Companion::parse)\n    return if (apiVersion != null) {\n        FirSinceKotlinValue(apiVersion, loadWasExperimentalMarkerClasses(session))\n    } else null\n}\n\nprivate fun FirDeclaration.loadWasExperimentalMarkerClasses(session: FirSession): List<FirRegularClassSymbol> {\n    val wasExperimental = getAnnotationByClassId(OptInNames.WAS_EXPERIMENTAL_CLASS_ID, session) ?: return emptyList()\n    val annotationClasses = wasExperimental.findArgumentByName(OptInNames.WAS_EXPERIMENTAL_ANNOTATION_CLASS) ?: return emptyList()\n    return annotationCla"}
{"code": "sses.extractClassesFromArgument(session)\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.impl.base.java.source\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.*\nimport org.jetbrains.kotlin.load.java.structure.impl.source.JavaElementPsiSource\nimport org.jetbrains.kotlin.load.java.structure.impl.source.JavaElementSourceFactory\nimport org.jetbrains.kotlin.load.java.structure.impl.source.JavaElementTypeSource\n\nclass JavaElementSourceWithSmartPointerFactory(project: Project) : JavaElementSourceFactory() {\n    private val smartTypePointerManager = SmartTypePointerManager.getInstance(project)\n    private val smartPsiPointerManager = SmartPointerManager.getInstance(project)\n\n    override fun <PSI : PsiElement> createPsiSource(psi: PSI): JavaElementPsiSource<PSI> {\n        return JavaElementPsiSourceWithSmartPointer(smartPsiPointerManager.createSmartPsiElementPointer(psi), this)\n    }\n\n    override fun <TYPE : PsiType> createTypeSource(type: TYPE): JavaElementTypeSource<TYPE> {\n        return JavaElementTypeSourceWith"}
{"code": "SmartPointer(smartTypePointerManager.createSmartTypePointer(type), this)\n    }\n\n    override fun <TYPE : PsiType> createVariableReturnTypeSource(psiVariableSource: JavaElementPsiSource<out PsiVariable>): JavaElementTypeSource<TYPE> {\n        require(psiVariableSource is JavaElementPsiSourceWithSmartPointer)\n        return JavaElementDelegatingVariableReturnTypeSourceWithSmartPointer(psiVariableSource.pointer, psiVariableSource.factory)\n    }\n\n    override fun <TYPE : PsiType> createMethodReturnTypeSource(psiMethodSource: JavaElementPsiSource<out PsiMethod>): JavaElementTypeSource<TYPE> {\n        require(psiMethodSource is JavaElementPsiSourceWithSmartPointer)\n        return JavaElementDelegatingMethodReturnTypeSourceWithSmartPointer(psiMethodSource.pointer, psiMethodSource.factory)\n    }\n\n    override fun <TYPE : PsiType> createTypeParameterUpperBoundTypeSource(\n        psiTypeParameterSource: JavaElementPsiSource<out PsiTypeParameter>,\n        boundIndex: Int\n    ): JavaElementTypeSou"}
{"code": "rce<TYPE> {\n        require(psiTypeParameterSource is JavaElementPsiSourceWithSmartPointer)\n        return JavaElementDelegatingTypeParameterBoundTypeSourceWithSmartPointer(\n            psiTypeParameterSource.pointer,\n            boundIndex,\n            psiTypeParameterSource.factory\n        )\n    }\n\n    override fun createSuperTypeSource(\n        psiTypeParameterSource: JavaElementPsiSource<out PsiClass>,\n        superTypeIndex: Int\n    ): JavaElementTypeSource<PsiClassType> {\n        require(psiTypeParameterSource is JavaElementPsiSourceWithSmartPointer)\n        return JavaElementDelegatingSuperTypeSourceWithSmartPointer(\n            psiTypeParameterSource.pointer,\n            superTypeIndex,\n            psiTypeParameterSource.factory,\n        )\n    }\n\n    override fun <TYPE : PsiType> createExpressionTypeSource(psiExpressionSource: JavaElementPsiSource<out PsiExpression>): JavaElementTypeSource<TYPE> {\n        require(psiExpressionSource is JavaElementPsiSourceWithSmartPointer)\n    "}
{"code": "    return JavaElementDelegatingExpressionTypeSourceWithSmartPointer(psiExpressionSource.pointer, psiExpressionSource.factory)\n    }\n\n    override fun createPermittedTypeSource(\n        psiTypeParameterSource: JavaElementPsiSource<out PsiClass>,\n        permittedTypeIndex: Int\n    ): JavaElementTypeSource<PsiClassType> {\n        require(psiTypeParameterSource is JavaElementPsiSourceWithSmartPointer)\n        return JavaElementDelegatingPermittedTypeSourceWithSmartPointer(\n            psiTypeParameterSource.pointer,\n            permittedTypeIndex,\n            psiTypeParameterSource.factory,\n        )\n    }\n}"}
{"code": "interface CommonBackendContext\n\ninterface PhaserState<Data> {\n    var depth: Int\n}\n\ninterface PhaseConfig {\n    val needProfiling: Boolean\n}\n\ninline fun <R, D> PhaserState<D>.downlevel(nlevels: Int, block: () -> R): R {\n    depth += nlevels\n    val result = block()\n    depth -= nlevels\n    return result\n}\n\ninterface CompilerPhase<in Context : CommonBackendContext, Input, Output> {\n    fun invoke(phaseConfig: PhaseConfig, phaserState: PhaserState<Input>, context: Context, input: Input): Output\n}\n\nclass NamedCompilerPhase<in Context : CommonBackendContext, Data>(\n    private val lower: CompilerPhase<Context, Data, Data>\n) : CompilerPhase<Context, Data, Data> {\n    override fun invoke(phaseConfig: PhaseConfig, phaserState: PhaserState<Data>, context: Context, input: Data): Data {\n        // Expected: output: Data, Actual: output: Data?\n        val output = if (phaseConfig.needProfiling) {\n            runAndProfile(phaseConfig, phaserState, context, input)\n        } else {\n            phas"}
{"code": "erState.downlevel(1) {\n                lower.invoke(phaseConfig, phaserState, context, input)\n            }\n        }\n        runAfter(phaseConfig, phaserState, context, output)\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n    private fun runAfter(phaseConfig: PhaseConfig, phaserState: PhaserState<Data>, context: Context, output: Data) {\n\n    }\n\n    private fun runAndProfile(phaseConfig: PhaseConfig, phaserState: PhaserState<Data>, context: Context, source: Data): Data {\n\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n}\n"}
{"code": "interface A\ninterface B\n\nfun test(a: Any) {\n    if (a is A && a is B) {\n        <expr>a</expr>\n    }\n}"}
{"code": "annotation class Anno\n\n@An<caret>no\nclass Sub"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.checkers\n\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.ClassifierDescriptor\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.descriptors.isSealed\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.psi.KtClassOrObject\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType\nimport org.jetbrains.kotlin.resolve.descriptorUtil.module\nimport org.jetbrains.kotlin.resolve.multiplatform.isCommonSource\nimport org.jetbrains.kotlin.resolve.source.PsiSourceFile\n\nobject SealedInheritorInSameModuleChecker : DeclarationChecker {\n    override fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n        if (descriptor !is ClassDescriptor || declaration !is KtClassOrObject) return\n       "}
{"code": " val currentModule = descriptor.module\n        for (superTypeListEntry in declaration.superTypeListEntries) {\n            val typeReference = superTypeListEntry.typeReference ?: continue\n            val superType = typeReference.getAbbreviatedTypeOrType(context.trace.bindingContext)?.unwrap() ?: continue\n            val superClass = superType.constructor.declarationDescriptor ?: continue\n            if (superClass.isSealed()) {\n                \n                if (descriptor.isFromCommonSource && superClass.module == currentModule) {\n                    return\n                }\n                \n                if (!(superClass.isExpect || (superClass.module == currentModule && !superClass.isFromCommonSource))) {\n                    context.trace.report(Errors.SEALED_INHERITOR_IN_DIFFERENT_MODULE.on(typeReference))\n                }\n            }\n        }\n    }\n\n    private val ClassifierDescriptor.isFromCommonSource: Boolean\n        get() = ((this.source.containingFile as? PsiSourceFi"}
{"code": "le)?.psiFile as? KtFile)?.isCommonSource ?: false\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.annotations\n\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget\n\npublic fun interface AnnotationUseSiteTargetFilter {\n    public fun isAllowed(useSiteTarget: AnnotationUseSiteTarget?): Boolean\n}\n\npublic fun AnnotationUseSiteTarget?.toFilter(): AnnotationUseSiteTargetFilter = when (this) {\n    null -> NoAnnotationUseSiteTargetFilter\n    AnnotationUseSiteTarget.FIELD -> FieldAnnotationUseSiteTargetFilter\n    AnnotationUseSiteTarget.FILE -> FileAnnotationUseSiteTargetFilter\n    AnnotationUseSiteTarget.PROPERTY -> PropertyAnnotationUseSiteTargetFilter\n    AnnotationUseSiteTarget.PROPERTY_GETTER -> PropertyGetterAnnotationUseSiteTargetFilter\n    AnnotationUseSiteTarget.PROPERTY_SETTER -> PropertySetterAnnotationUseSiteTargetFilter\n    AnnotationUseSiteTarget.RECEIVER -> ReceiverAnnotationUseSiteTargetFilter\n    AnnotationUseSiteTarget.CONSTRUCTOR_PARAMETER -> ConstructorParameterAnnotationUseSiteTargetFilter\n    Annotation"}
{"code": "UseSiteTarget.SETTER_PARAMETER -> SetterParameterAnnotationUseSiteTargetFilter\n    AnnotationUseSiteTarget.PROPERTY_DELEGATE_FIELD -> PropertyDelegateFieldAnnotationUseSiteTargetFilter\n}\n\npublic object AnyAnnotationUseSiteTargetFilter : AnnotationUseSiteTargetFilter {\n    override fun isAllowed(useSiteTarget: AnnotationUseSiteTarget?): Boolean = true\n}\n\npublic object NoAnnotationUseSiteTargetFilter : AnnotationUseSiteTargetFilter {\n    override fun isAllowed(useSiteTarget: AnnotationUseSiteTarget?): Boolean = useSiteTarget == null\n}\n\npublic object FieldAnnotationUseSiteTargetFilter : AnnotationUseSiteTargetFilter {\n    override fun isAllowed(useSiteTarget: AnnotationUseSiteTarget?): Boolean = useSiteTarget == AnnotationUseSiteTarget.FIELD\n}\n\npublic object FileAnnotationUseSiteTargetFilter : AnnotationUseSiteTargetFilter {\n    override fun isAllowed(useSiteTarget: AnnotationUseSiteTarget?): Boolean = useSiteTarget == AnnotationUseSiteTarget.FILE\n}\n\npublic object PropertyAnnotationUseSit"}
{"code": "eTargetFilter : AnnotationUseSiteTargetFilter {\n    override fun isAllowed(useSiteTarget: AnnotationUseSiteTarget?): Boolean = useSiteTarget == AnnotationUseSiteTarget.PROPERTY\n}\n\npublic object PropertyGetterAnnotationUseSiteTargetFilter : AnnotationUseSiteTargetFilter {\n    override fun isAllowed(useSiteTarget: AnnotationUseSiteTarget?): Boolean = useSiteTarget == AnnotationUseSiteTarget.PROPERTY_GETTER\n}\n\npublic object PropertySetterAnnotationUseSiteTargetFilter : AnnotationUseSiteTargetFilter {\n    override fun isAllowed(useSiteTarget: AnnotationUseSiteTarget?): Boolean = useSiteTarget == AnnotationUseSiteTarget.PROPERTY_SETTER\n}\n\npublic object ReceiverAnnotationUseSiteTargetFilter : AnnotationUseSiteTargetFilter {\n    override fun isAllowed(useSiteTarget: AnnotationUseSiteTarget?): Boolean = useSiteTarget == AnnotationUseSiteTarget.RECEIVER\n}\n\npublic object ConstructorParameterAnnotationUseSiteTargetFilter : AnnotationUseSiteTargetFilter {\n    override fun isAllowed(useSiteTarget: "}
{"code": "AnnotationUseSiteTarget?): Boolean =\n        useSiteTarget == AnnotationUseSiteTarget.CONSTRUCTOR_PARAMETER\n}\n\npublic object SetterParameterAnnotationUseSiteTargetFilter : AnnotationUseSiteTargetFilter {\n    override fun isAllowed(useSiteTarget: AnnotationUseSiteTarget?): Boolean = useSiteTarget == AnnotationUseSiteTarget.SETTER_PARAMETER\n}\n\npublic object PropertyDelegateFieldAnnotationUseSiteTargetFilter : AnnotationUseSiteTargetFilter {\n    override fun isAllowed(useSiteTarget: AnnotationUseSiteTarget?): Boolean =\n        useSiteTarget == AnnotationUseSiteTarget.PROPERTY_DELEGATE_FIELD\n}\n"}
{"code": "package util\n\n@Target(AnnotationTarget.TYPE)\nannotation class Anno(val position: String)\n\nconst val prop = \"str\"\n\ninterface I\n\nclass MyClassWithoutConstructor : @Anno(\"MyClassWithoutConstructor super type ref $prop\") List<@Anno(\"MyClassWithoutConstructor nested super type ref $prop\") List<@Anno(\"MyClassWithoutConstructor nested nested super type ref $prop\") I>>\n\nclass MyClassWithConstructor() : @Anno(\"MyClassWithConstructor super type ref $prop\") List<@Anno(\"MyClassWithConstructor nested super type ref $prop\") List<@Anno(\"MyClassWithConstructor nested nested super type ref $prop\") I>>"}
{"code": "package second\n\nimport kotlin.reflect.KClass\n\n@Target(AnnotationTarget.TYPE)\nannotation class Anno(val str: KClass<*>)\nfun <T> lambda(action: () -> T): T = action()\n\nfun c<caret>heck() = lambda {\n    class A {\n        fun bar() = B().foo()\n\n        private inner class B {\n            fun foo(): @Anno(C::class) List<@Anno(C::class) Collection<@Anno(C::class) String>>? = null\n            private inner class C\n        }\n    }\n\n    A().bar()\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.typeParameterSymbols\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.collectUpperBounds\nimport org.jetbrains.kotlin.fir.declarations.FirRegularClass\nimport org.jetbrains.kotlin.fir.scopes.impl.toConeType\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassifierSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirTypeParameterSymbol\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.types.ProjectionKind\nimport org.jetbrains.kotlin.fir.types.forEachType\nimport org.jetbrains.kotlin.fir.types.toSymbol\nimport o"}
{"code": "rg.jetbrains.kotlin.utils.DFS\n\n\nobject FirFiniteBoundRestrictionChecker : FirRegularClassChecker(MppCheckerKind.Common) {\n    override fun check(declaration: FirRegularClass, context: CheckerContext, reporter: DiagnosticReporter) {\n        if (declaration.typeParameters.isEmpty()) return\n\n        // TODO, KT-61103: Improve documentation on finite bounds validation, especially B-closure and constituent types definition.\n        // For every projection type argument A in every generic type B<\u2026> in the set of constituent types\n        // of every type in the B-closure of the set of declared upper bounds of every type parameter T add an\n        // edge from T to U, where U is the type parameter of the declaration of B<\u2026> corresponding to the type argument A.\n        // It is a compile-time error if the graph G has a cycle.\n        val edges = buildTypeEdges(declaration, context.session)\n\n        val problemNodes = edges.keys.filterTo(mutableSetOf()) { isInCycle(it, edges) }\n        if (pro"}
{"code": "blemNodes.isEmpty()) return\n\n        for (ref in declaration.typeParameters) {\n            if (problemNodes.remove(ref.toConeType())) {\n                reporter.reportOn(ref.source, FirErrors.FINITE_BOUNDS_VIOLATION, context)\n                return\n            }\n        }\n\n        val problemSymbols = problemNodes.mapNotNullTo(mutableSetOf()) { it.toSymbol(context.session) as? FirTypeParameterSymbol }\n        if (problemSymbols.any { it.source != null }) return\n\n        val containers = problemSymbols.map { it.containingDeclarationSymbol }\n        reporter.reportOn(declaration.source, FirErrors.FINITE_BOUNDS_VIOLATION_IN_JAVA, containers, context)\n    }\n\n    private fun buildTypeEdges(declaration: FirRegularClass, session: FirSession): Map<ConeKotlinType, Set<ConeKotlinType>> {\n        val edges = mutableMapOf<ConeKotlinType, MutableSet<ConeKotlinType>>()\n\n        val visitedSymbols = mutableSetOf<FirClassifierSymbol<*>>()\n        fun visit(coneType: ConeKotlinType) {\n            val c"}
{"code": "onstituentTypes = mutableSetOf<ConeKotlinType>()\n            for (type in coneType.collectUpperBounds()) {\n                type.forEachType { constituentTypes.add(it) }\n            }\n\n            for (type in constituentTypes) {\n                val symbol = type.toSymbol(session)\n                val parameters = symbol?.typeParameterSymbols ?: continue\n\n                if (visitedSymbols.add(symbol)) {\n                    parameters.forEach { visit(it.toConeType()) }\n                }\n                if (parameters.size != type.typeArguments.size) continue\n\n                for (i in parameters.indices) {\n                    if (type.typeArguments[i].kind != ProjectionKind.INVARIANT) {\n                        val parameter = parameters[i].toConeType()\n                        edges.getOrPut(coneType) { mutableSetOf() }.add(parameter)\n                        edges.getOrPut(parameter) { mutableSetOf() }\n                    }\n                }\n            }\n        }\n\n        declaration.ty"}
{"code": "peParameters.forEach { visit(it.toConeType()) }\n\n        return edges\n    }\n\n    private fun isInCycle(start: ConeKotlinType, edges: Map<ConeKotlinType, Set<ConeKotlinType>>): Boolean {\n        var containsCycle = false\n\n        val dfsNeighbors = DFS.Neighbors<ConeKotlinType> { edges[it] ?: emptyList() }\n\n        val dfsVisited = object : DFS.VisitedWithSet<ConeKotlinType>() {\n            override fun checkAndMarkVisited(current: ConeKotlinType): Boolean {\n                val added = super.checkAndMarkVisited(current)\n                if (!added && current == start) {\n                    containsCycle = true\n                }\n                return added\n            }\n        }\n\n        val dfsHandler = object : DFS.AbstractNodeHandler<ConeKotlinType, Unit>() {\n            override fun result() {}\n        }\n\n        DFS.dfs(listOf(start), dfsNeighbors, dfsVisited, dfsHandler)\n\n        return containsCycle\n    }\n}\n"}
{"code": "package org.jetbrains.kotlin.incremental\n\nimport org.jetbrains.kotlin.cli.common.arguments.K2JSCompilerArguments\nimport org.jetbrains.kotlin.incremental.testingUtils.BuildLogFinder\nimport org.jetbrains.kotlin.incremental.utils.TestCompilationResult\nimport org.jetbrains.kotlin.incremental.utils.TestICReporter\nimport org.jetbrains.kotlin.incremental.utils.TestMessageCollector\nimport java.io.File\n\nabstract class AbstractIncrementalK1JsKlibCompilerRunnerTest : AbstractIncrementalCompilerRunnerTestBase<K2JSCompilerArguments>() {\n    override fun createCompilerArguments(destinationDir: File, testDir: File): K2JSCompilerArguments =\n        K2JSCompilerArguments().apply {\n            libraries = \"build/js-ir-runtime/full-runtime.klib\"\n            outputDir = destinationDir.path\n            moduleName = testDir.name\n            sourceMap = false\n            irProduceKlibDir = false\n            irProduceKlibFile = true\n            irOnly = true\n            languageVersion = \"1.9\"\n        }\n\n    "}
{"code": "override val buildLogFinder: BuildLogFinder\n        get() = super.buildLogFinder.copy(\n            isFirEnabled = false,\n            isKlibEnabled = true,\n            isJsEnabled = true,\n            isScopeExpansionEnabled = scopeExpansionMode != CompileScopeExpansionMode.NEVER,\n        )\n\n    override fun make(cacheDir: File, outDir: File, sourceRoots: Iterable<File>, args: K2JSCompilerArguments): TestCompilationResult {\n        val reporter = TestICReporter()\n        val messageCollector = TestMessageCollector()\n        makeJsIncrementally(cacheDir, sourceRoots, args, buildHistoryFile(cacheDir), messageCollector, reporter, scopeExpansionMode)\n        return TestCompilationResult(reporter, messageCollector)\n    }\n\n    protected open val scopeExpansionMode = CompileScopeExpansionMode.NEVER\n\n    override fun failFile(testDir: File): File = testDir.resolve(\"fail_js_legacy.txt\")\n}\n\nabstract class AbstractIncrementalK1JsKlibCompilerWithScopeExpansionRunnerTest : AbstractIncrementalK1JsKlib"}
{"code": "CompilerRunnerTest() {\n    override val scopeExpansionMode = CompileScopeExpansionMode.ALWAYS\n}\n\nabstract class AbstractIncrementalK2JsKlibCompilerWithScopeExpansionRunnerTest : AbstractIncrementalK1JsKlibCompilerWithScopeExpansionRunnerTest() {\n    override fun createCompilerArguments(destinationDir: File, testDir: File): K2JSCompilerArguments {\n        return super.createCompilerArguments(destinationDir, testDir).apply {\n            languageVersion = \"2.0\"\n        }\n    }\n\n    override val buildLogFinder: BuildLogFinder\n        get() = super.buildLogFinder.copy(isFirEnabled = true)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.expression\n\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.descriptors.ClassKind\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirDeclarationOrigin\nimport org.jetbrains.kotlin.fir.declarations.FirRegularClass\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirFunctionCall\nimport org.jetbrains.kotlin.fir.references.toResolvedConstructorSymbol\nimport org.jetbrains.kotlin.fir.types.ConeCapturedType\nimport org.jetbrains.kotlin.fir.types.coneType\nimport org.jetbrains.kotlin.fir.types.contains\nimport org.jetbrains.kotlin.fir.types.toRegularClassSymbol\n\n"}
{"code": "object FirConstructorCallChecker : FirFunctionCallChecker(MppCheckerKind.Common) {\n    override fun check(expression: FirFunctionCall, context: CheckerContext, reporter: DiagnosticReporter) {\n        val constructorSymbol = expression.calleeReference.toResolvedConstructorSymbol() ?: return\n        val coneType = constructorSymbol.resolvedReturnTypeRef.coneType\n\n        if (constructorSymbol.origin == FirDeclarationOrigin.Synthetic.TypeAliasConstructor && coneType.contains { it is ConeCapturedType }) {\n            reporter.reportOn(expression.source, FirErrors.CONSTRUCTOR_OR_SUPERTYPE_ON_TYPEALIAS_WITH_TYPE_PROJECTION, context)\n        }\n\n        val declarationClass = coneType.toRegularClassSymbol(context.session)\n            ?: return\n\n        if (declarationClass.classKind == ClassKind.ANNOTATION_CLASS &&\n            context.callsOrAssignments.all { call ->\n                call !is FirAnnotation\n            } &&\n            context.containingDeclarations.all { klass ->\n              "}
{"code": "  klass !is FirRegularClass || klass.classKind != ClassKind.ANNOTATION_CLASS\n            }\n        ) {\n            if (!context.languageVersionSettings.supportsFeature(LanguageFeature.InstantiationOfAnnotationClasses)) reporter.reportOn(\n                expression.source,\n                FirErrors.ANNOTATION_CLASS_CONSTRUCTOR_CALL,\n                context\n            )\n        }\n\n        if (declarationClass.classKind == ClassKind.ENUM_CLASS) {\n            reporter.reportOn(\n                expression.source,\n                FirErrors.ENUM_CLASS_CONSTRUCTOR_CALL,\n                context\n            )\n        }\n    }\n}\n"}
{"code": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE_K1\nclass Foo {\n    constructor(vararg ints: )\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.expressions\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.FirTarget\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\n\nabstract class FirLoopJump : FirJump<FirLoop>() {\n    abstract override val source: KtSourceElement?\n    @UnresolvedExpressionTypeAccess\n    abstract override val coneTypeOrNull: ConeKotlinType?\n    abstract override val annotations: List<FirAnnotation>\n    abstract override val target: FirTarget<FirLoop>\n\n    override fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitLoopJump(this, data)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data:"}
{"code": " D): E =\n        transformer.transformLoopJump(this, data) as E\n\n    abstract override fun replaceConeTypeOrNull(newConeTypeOrNull: ConeKotlinType?)\n\n    abstract override fun replaceAnnotations(newAnnotations: List<FirAnnotation>)\n\n    abstract override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirLoopJump\n}\n"}
{"code": "fun foo() {\n    val f = <expr>fun(it: String) {}</expr>\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.impl.base.test.cases.components.containingDeclarationProvider\n\nimport org.jetbrains.kotlin.analysis.api.impl.base.test.cases.components.renderScopeWithParentDeclarations\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.test.framework.services.expressionMarkerProvider\nimport org.jetbrains.kotlin.psi.KtClassOrObject\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.assertions\n\nabstract class AbstractContainingDeclarationProviderByDelegatedMemberScopeTest : AbstractAnalysisApiBasedTest() {\n    override fun doTestByMainFile(mainFile: KtFile, mainModule: KtTestModule, testServices: TestServices) {\n        val declaration = testServices.expressionMarkerProvider.getElementOfTypeAtCaret<KtClassOrObject>(mainFile"}
{"code": ")\n\n        val memberToContainingClass = analyseForTest(declaration) {\n            val symbol = declaration.getClassOrObjectSymbol()!!\n            renderScopeWithParentDeclarations(symbol.getDelegatedMemberScope())\n        }\n\n        testServices.assertions.assertEqualsToTestDataFileSibling(memberToContainingClass)\n    }\n}"}
{"code": "fun test() {\n    val f = String::<expr>length</expr>\n    val s = \"hello\"\n    val g = s::length\n    f() + g() + String::length.invoke(s) + s::length.invoke()\n}"}
{"code": "fun box() {\n    class Foo {\n        fun foo() {\n            <expr>Bar()</expr>.unknown()\n        }\n\n        private inner class Bar: Unknown<Unit, Unit, Int>() {\n            override fun unknown() {}\n        }\n    }\n}"}
{"code": "class A\n\noperator fun A.plus(a: A): A = A()\noperator fun A.plusAssign(a: A){}\n\nfun foo() {\n    var a1 = A()\n    val a2 = A()\n    <!ASSIGNED_VALUE_IS_NEVER_READ!>a1<!> = a1 + a2\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.FirDesignation\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.util.errorWithFirSpecificEntries\nimport org.jetbrains.kotlin.fir.FirElementWithResolveState\n\nabstract class ContextByDesignationCollector<C : Any>(private val designation: FirDesignation) {\n    private var context: C? = null\n    private val designationState = FirDesignationState(designation)\n\n    protected abstract fun getCurrentContext(): C\n    protected abstract fun goToNestedDeclaration(target: FirElementWithResolveState)\n\n    fun getCollectedContext(): C {\n        return context\n            ?: error(\"Context is not collected yet\")\n    }\n\n    fun nextStep() {\n        if (designationState.canGoNext()) {\n            designationState.goNext()\n            if (designationState.currentDeclarationIfPresent == designation.target) {\n                check(context == null)\n                context = getCurrent"}
{"code": "Context()\n            }\n            goToNestedDeclaration(designationState.currentDeclaration)\n        } else {\n            if (designationState.currentDeclarationIfPresent == designation.target) {\n                designationState.goToInnerDeclaration()\n            }\n        }\n    }\n}\n\nprivate class FirDesignationState(val designation: FirDesignation) {\n    \n    private var currentIndex = -1\n\n    fun canGoNext(): Boolean = currentIndex < designation.path.size\n\n    val currentDeclarationIfPresent: FirElementWithResolveState?\n        get() = designation.path.getOrNull(currentIndex) ?: when (currentIndex) {\n            designation.path.size -> designation.target\n            else -> null\n        }\n\n    val currentDeclaration: FirElementWithResolveState\n        get() = currentDeclarationIfPresent\n            ?: errorWithFirSpecificEntries(\"Went inside target declaration\")\n\n    fun goNext() {\n        if (canGoNext()) {\n            currentIndex++\n        } else {\n            throw IndexOutOfB"}
{"code": "oundsException()\n        }\n    }\n\n    fun goToInnerDeclaration() {\n        if (currentIndex == designation.path.size) {\n            currentIndex++\n        } else {\n            throw IndexOutOfBoundsException()\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.references\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.fir.symbols.KtFirSymbol\nimport org.jetbrains.kotlin.analysis.api.fir.symbols.KtFirSyntheticJavaPropertySymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtSymbol\nimport org.jetbrains.kotlin.idea.references.KDocReference\nimport org.jetbrains.kotlin.idea.references.KtFirReference\nimport org.jetbrains.kotlin.idea.references.getPsiDeclarations\nimport org.jetbrains.kotlin.kdoc.psi.impl.KDocName\n\n\ninternal class KtFirKDocReference(element: KDocName) : KDocReference(element), KtFirReference {\n    override fun KtAnalysisSession.resolveToSymbols(): Collection<KtSymbol> {\n        val fullFqName = generateSequence(element) { it.parent as? KDocName }.last().getQualifiedNameAsFqName()\n        val selectedFqName = element.getQualifiedNameAsFqName()\n        return KDocReferenceResolver.resolveKdocFqName"}
{"code": "(selectedFqName, fullFqName, element)\n    }\n\n    override fun getResolvedToPsi(\n        analysisSession: KtAnalysisSession,\n        referenceTargetSymbols: Collection<KtSymbol>,\n    ): Collection<PsiElement> = with(analysisSession) {\n        referenceTargetSymbols.flatMap { symbol ->\n            when (symbol) {\n                is KtFirSyntheticJavaPropertySymbol -> listOfNotNull(symbol.javaGetterSymbol.psi, symbol.javaSetterSymbol?.psi)\n                is KtFirSymbol<*> -> getPsiDeclarations(symbol)\n                else -> listOfNotNull(symbol.psi)\n            }\n        }\n    }\n}"}
{"code": "enum class Some {\n    ENTRY {\n        override fun toString(): String = \"Entry\"\n    };\n\n    override fun toString(): String = \"Some\"\n}\n"}
{"code": "val a = 12\nval x = <expr>12.toByte()</expr>\n"}
{"code": "// FILE: A.java\n\npublic class A {\n    Object foo(String s) {\n        return null;\n    };\n}\n\n// FILE: main.kt\n\nclass B : A() {\n    override fun foo(s: String): Any? {\n        return null\n    }\n}\n\nfun test(b: B) {\n    b.<!INVISIBLE_REFERENCE!>foo<!>(\"\")\n}\n"}
{"code": "class Foo(private val name: String) {\n    private fun foo() {\n        nam<caret>e.length\n    }\n}"}
{"code": "// DECLARATION_TYPE: org.jetbrains.kotlin.psi.KtProperty\nclass FooBar {\n    val p: String\n\n    constructor(p: String) {\n        this.p = p\n    }\n\n    fun doSmth() {}\n}\n"}
{"code": "val p = <expr>3.14f</expr>\n"}
{"code": "// FILE: main.kt\npackage test\n\nimport dependency.component1\nimport dependency.component2\n\nfun usage(target: dependency.Target) {\n    val (c1, \u04412) = target\n}\n\n// FILE: dependency.kt\npackage dependency\n\nclass Target\n\noperator fun Target.component1(): Int = 1\noperator fun Target.component2(): Int = 2\n"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.classes\n\nimport com.intellij.openapi.util.ModificationTracker\nimport com.intellij.psi.*\nimport com.intellij.psi.impl.InheritanceImplUtil\nimport com.intellij.psi.impl.PsiClassImplUtil\nimport com.intellij.psi.search.GlobalSearchScope\nimport com.intellij.psi.search.SearchScope\nimport com.intellij.psi.stubs.IStubElementType\nimport com.intellij.psi.stubs.StubElement\nimport org.jetbrains.annotations.NonNls\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.symbols.KtClassKind\nimport org.jetbrains.kotlin.analysis.api.symbols.KtClassOrObjectSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtNamedClassOrObjectSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolKind\nimport org.jetbrains.kotlin.analysis.api.symbols.pointers.KtSymbolPointer\nimport org.jetbrains.kotlin.analysis.api.symbols.sourcePsiSafe\nimport org.jetbrains.kotlin.analysis.project.structure.KtModule\nimport"}
{"code": " org.jetbrains.kotlin.asJava.classes.lazyPub\nimport org.jetbrains.kotlin.asJava.elements.KtLightField\nimport org.jetbrains.kotlin.asJava.elements.KtLightIdentifier\nimport org.jetbrains.kotlin.asJava.toLightClass\nimport org.jetbrains.kotlin.light.classes.symbol.*\nimport org.jetbrains.kotlin.light.classes.symbol.annotations.hasDeprecatedAnnotation\nimport org.jetbrains.kotlin.light.classes.symbol.parameters.SymbolLightTypeParameterList\nimport org.jetbrains.kotlin.load.java.structure.LightClassOriginKind\nimport org.jetbrains.kotlin.psi.KtClassOrObject\nimport org.jetbrains.kotlin.psi.KtScript\nimport org.jetbrains.kotlin.psi.debugText.getDebugText\nimport org.jetbrains.kotlin.psi.stubs.KotlinClassOrObjectStub\nimport org.jetbrains.kotlin.utils.addToStdlib.ifTrue\n\nabstract class SymbolLightClassForClassLike<SType : KtClassOrObjectSymbol> protected constructor(\n    internal val classOrObjectDeclaration: KtClassOrObject?,\n    internal val classOrObjectSymbolPointer: KtSymbolPointer<SType>,\n    kt"}
{"code": "Module: KtModule,\n    manager: PsiManager,\n) : SymbolLightClassBase(ktModule, manager),\n    StubBasedPsiElement<KotlinClassOrObjectStub<out KtClassOrObject>> {\n    constructor(\n        ktAnalysisSession: KtAnalysisSession,\n        ktModule: KtModule,\n        classOrObjectSymbol: SType,\n        manager: PsiManager,\n    ) : this(\n        classOrObjectDeclaration = classOrObjectSymbol.sourcePsiSafe(),\n        classOrObjectSymbolPointer = with(ktAnalysisSession) {\n            @Suppress(\"UNCHECKED_CAST\")\n            classOrObjectSymbol.createPointer() as KtSymbolPointer<SType>\n        },\n        ktModule = ktModule,\n        manager = manager,\n    )\n\n    override fun modificationTrackerForClassInnerStuff(): List<ModificationTracker> {\n        return classOrObjectDeclaration?.modificationTrackerForClassInnerStuff() ?: super.modificationTrackerForClassInnerStuff()\n    }\n\n    override val kotlinOrigin: KtClassOrObject? get() = classOrObjectDeclaration\n\n    internal inline fun <T> withClassOrObj"}
{"code": "ectSymbol(crossinline action: KtAnalysisSession.(SType) -> T): T =\n        classOrObjectSymbolPointer.withSymbol(ktModule, action)\n\n    override val isTopLevel: Boolean by lazyPub {\n        classOrObjectDeclaration?.isTopLevel() ?: withClassOrObjectSymbol { it.symbolKind == KtSymbolKind.TOP_LEVEL }\n    }\n\n    private val _isDeprecated: Boolean by lazyPub {\n        withClassOrObjectSymbol { it.hasDeprecatedAnnotation() }\n    }\n\n    override fun isDeprecated(): Boolean = _isDeprecated\n\n    abstract override fun getModifierList(): PsiModifierList?\n\n    abstract override fun getOwnFields(): List<KtLightField>\n    abstract override fun getOwnMethods(): List<PsiMethod>\n\n    override fun getNameIdentifier(): PsiIdentifier? = KtLightIdentifier(this, classOrObjectDeclaration)\n\n    abstract override fun getExtendsList(): PsiReferenceList?\n\n    abstract override fun getImplementsList(): PsiReferenceList?\n\n    private val _typeParameterList: PsiTypeParameterList? by lazyPub {\n        hasTypeParame"}
{"code": "ters().ifTrue {\n            SymbolLightTypeParameterList(\n                owner = this,\n                symbolWithTypeParameterPointer = classOrObjectSymbolPointer,\n                ktModule = ktModule,\n                ktDeclaration = classOrObjectDeclaration,\n            )\n        }\n    }\n\n    override fun hasTypeParameters(): Boolean =\n        hasTypeParameters(ktModule, classOrObjectDeclaration, classOrObjectSymbolPointer)\n\n    override fun getTypeParameterList(): PsiTypeParameterList? = _typeParameterList\n\n    override fun getTypeParameters(): Array<PsiTypeParameter> = _typeParameterList?.typeParameters ?: PsiTypeParameter.EMPTY_ARRAY\n\n    override fun getOwnInnerClasses(): List<PsiClass> = cachedValue {\n        withClassOrObjectSymbol {\n            it.createInnerClasses(manager, this@SymbolLightClassForClassLike, classOrObjectDeclaration)\n        }\n    }\n\n    override fun getTextOffset(): Int = classOrObjectDeclaration?.textOffset ?: -1\n\n    override fun getStartOffsetInParent(): I"}
{"code": "nt = classOrObjectDeclaration?.startOffsetInParent ?: -1\n    override fun isWritable() = false\n    override fun getNavigationElement(): PsiElement = classOrObjectDeclaration ?: this\n\n    override fun isEquivalentTo(another: PsiElement?): Boolean =\n        isEquivalentToByName(another) ||\n                isOriginEquivalentTo(another)\n\n    protected fun isEquivalentToByName(another: PsiElement?): Boolean = basicIsEquivalentTo(this, another) ||\n            another is PsiClass && qualifiedName != null && another.qualifiedName == qualifiedName\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other !is SymbolLightClassForClassLike<*> || other.ktModule != ktModule || other.manager != manager) return false\n        if (classOrObjectDeclaration != null || other.classOrObjectDeclaration != null) {\n            return other.classOrObjectDeclaration == classOrObjectDeclaration\n        }\n\n        return compareSymbolPointers(classOrObjectSymbolPoint"}
{"code": "er, other.classOrObjectSymbolPointer)\n    }\n\n    override fun hashCode(): Int = classOrObjectDeclaration.hashCode()\n\n    override fun getName(): String? = classOrObjectDeclaration?.name ?: withClassOrObjectSymbol {\n        it.name?.asString()\n    }\n\n    override fun hasModifierProperty(@NonNls name: String): Boolean = modifierList?.hasModifierProperty(name) ?: false\n\n    abstract fun classKind(): KtClassKind\n    override fun isInterface(): Boolean = classKind().let { it == KtClassKind.INTERFACE || it == KtClassKind.ANNOTATION_CLASS }\n    override fun isAnnotationType(): Boolean = classKind() == KtClassKind.ANNOTATION_CLASS\n    override fun isEnum(): Boolean = classKind() == KtClassKind.ENUM_CLASS\n\n    override fun isValid(): Boolean = classOrObjectDeclaration?.isValid ?: classOrObjectSymbolPointer.isValid(ktModule)\n\n    override fun toString() = \"${this::class.java.simpleName}:${classOrObjectDeclaration?.getDebugText()}\"\n\n    override fun getUseScope(): SearchScope = classOrObjectDecla"}
{"code": "ration?.useScope ?: GlobalSearchScope.projectScope(project)\n    override fun getElementType(): IStubElementType<out StubElement<*>, *>? = classOrObjectDeclaration?.elementType\n    override fun getStub(): KotlinClassOrObjectStub<out KtClassOrObject>? = classOrObjectDeclaration?.stub\n\n    override val originKind: LightClassOriginKind get() = LightClassOriginKind.SOURCE\n\n    override fun getQualifiedName(): String? {\n        val classOrObjectFqName = classOrObjectDeclaration?.fqName\n            ?: withClassOrObjectSymbol { s -> s.classIdIfNonLocal?.asSingleFqName() }\n\n        return classOrObjectFqName?.toString()\n    }\n\n    override fun getInterfaces(): Array<PsiClass> = PsiClassImplUtil.getInterfaces(this)\n    override fun getSuperClass(): PsiClass? = PsiClassImplUtil.getSuperClass(this)\n    override fun getSupers(): Array<PsiClass> = PsiClassImplUtil.getSupers(this)\n    override fun getSuperTypes(): Array<PsiClassType> = PsiClassImplUtil.getSuperTypes(this)\n\n    private val _containing"}
{"code": "Class: PsiClass? by lazyPub {\n        val containingBody = classOrObjectDeclaration?.parent\n        when (val parent = containingBody?.parent) {\n            is KtClassOrObject -> parent.toLightClass()\n            is KtScript -> parent.toLightClass()\n            null -> withClassOrObjectSymbol { s ->\n                (s.getContainingSymbol() as? KtNamedClassOrObjectSymbol)?.let { createLightClassNoCache(it, ktModule, manager) }\n            }\n            else -> null\n        }\n    }\n\n    override fun getContainingClass(): PsiClass? = _containingClass\n\n    private val _containingFile: PsiFile? by lazyPub {\n        super.getContainingFile() ?: containingClass?.containingFile\n    }\n\n    override fun getContainingFile(): PsiFile? = _containingFile\n\n    abstract override fun getParent(): PsiElement?\n    override fun getScope(): PsiElement? = parent\n\n    override fun isInheritorDeep(baseClass: PsiClass?, classToByPass: PsiClass?): Boolean =\n        baseClass?.let { InheritanceImplUtil.isInherit"}
{"code": "orDeep(this, it, classToByPass) } ?: false\n\n    abstract override fun copy(): SymbolLightClassForClassLike<*>\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.expressions\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\n\nabstract class FirSamConversionExpression : FirExpression() {\n    abstract override val source: KtSourceElement?\n    @UnresolvedExpressionTypeAccess\n    abstract override val coneTypeOrNull: ConeKotlinType?\n    abstract override val annotations: List<FirAnnotation>\n    abstract val expression: FirExpression\n\n    override fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitSamConversionExpression(this, data)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transfor"}
{"code": "mer.transformSamConversionExpression(this, data) as E\n\n    abstract override fun replaceConeTypeOrNull(newConeTypeOrNull: ConeKotlinType?)\n\n    abstract override fun replaceAnnotations(newAnnotations: List<FirAnnotation>)\n\n    abstract override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirSamConversionExpression\n}\n"}
{"code": "// MODULE: context\n\n// FILE: context.kt\nfun test() {\n    <caret_context>val x = 0\n}\n\ninline fun call(block: (Int) -> Int) {\n    System.out.println(block(5))\n}\n\n\n// MODULE: main\n// MODULE_KIND: CodeFragment\n// CONTEXT_MODULE: context\n\n// FILE: fragment.kt\n// CODE_FRAGMENT_KIND: EXPRESSION\ncall { it * 2 }"}
{"code": "// FILE: Foo.kt\npackage foo\n\ninterface Foo {\n    val foo: Int\n}\n\n// FILE: main.kt\npackage test\n\n\nfun usage() {}\n"}
{"code": "class Foo {\n  operator fun invoke(vararg a: Any) {}\n}\n\nfun test(f: Foo) {\n  f<caret>(1)\n}\n"}
{"code": "// BODY_RESOLVE\npackage myPack\n\n@Target(\n    AnnotationTarget.PROPERTY,\n    AnnotationTarget.TYPE_PARAMETER,\n    AnnotationTarget.FUNCTION,\n    AnnotationTarget.VALUE_PARAMETER,\n    AnnotationTarget.PROPERTY_GETTER,\n    AnnotationTarget.PROPERTY_SETTER,\n    AnnotationTarget.TYPE,\n)\nannotation class Anno(val position: String)\nconst val prop = \"str\"\n\nfun t<caret>tt() {\n    @Anno(\"property $prop\")\n    var <@Anno(\"type parameter $prop\") T : @Anno(\"bound $prop\") List<@Anno(\"nested bound $prop\") String>> @receiver:Anno(\"receiver $prop\") @Anno(\n        \"receiver type $prop\"\n    ) List<@Anno(\"nested receiver type $prop\")>.variableToResolve: @Anno(\"return type $prop\") Collection<@Anno(\"nested return type $prop\") List<@Anno(\n        \"nested nested return type $prop\"\n    ) Int>>\n    @Anno(\"getter $prop\")\n    get() = \"str\"\n    @Anno(\"setter $prop\")\n    set(@Anno(\"setter parameter $prop\") value) = Unit\n}"}
{"code": "// bug: type of the expression in return statement is Char\nfun illegalReturnIf(): Char {\n    return <!RETURN_TYPE_MISMATCH!>if (1 < 2) 'a' else { 1 }<!>\n}\n\nfun foo(): String {\n    return <!RETURN_TYPE_MISMATCH!>1<!>\n}\n\nfun ok(): Int {\n    return 1\n}\n\nfun okOneLineFunction(): Int = 10 + 1\nfun errorOneLineFunction(): String = <!RETURN_TYPE_MISMATCH!>10 + 1<!>\n\nclass A {\n    fun bar() {}\n}\n\ninfix fun (() -> Unit).foo(x: A.() -> Unit) {}\n\nfun okWithLambda(): String {\n    {\n        return@foo\n    } foo {\n        bar()\n        return@foo\n    }\n\n    return \"\"\n}\n\n// no report due bad returns in lambda\nfun errorWithLambda(): String {\n    {\n        return@foo\n    } foo {\n        bar()\n        return@foo <!ARGUMENT_TYPE_MISMATCH, RETURN_TYPE_MISMATCH!>10<!>\n    }\n\n    return \"\"\n}\n\nfun blockReturnValueTypeMatch1() : Int {\n    if (1 > 2)\n        return <!RETURN_TYPE_MISMATCH!>1.0<!>\n    return <!RETURN_TYPE_MISMATCH!>2.0<!>\n}\nfun blockReturnValueTypeMatch2() : Int {\n    if (1 > 2)\n    else return <"}
{"code": "!RETURN_TYPE_MISMATCH!>1.0<!>\n    return <!RETURN_TYPE_MISMATCH!>2.0<!>\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.build\n\nimport org.jetbrains.kotlin.cli.common.arguments.CommonCompilerArguments\nimport org.jetbrains.kotlin.config.*\n\nabstract class BuildMetaInfo {\n    enum class CustomKeys {\n        LANGUAGE_VERSION_STRING, IS_EAP, METADATA_VERSION_STRING, PLUGIN_CLASSPATHS, API_VERSION_STRING\n    }\n\n    fun obtainReasonForRebuild(currentCompilerArgumentsMap: Map<String, String>, previousCompilerArgsMap: Map<String, String>): String? {\n        if (currentCompilerArgumentsMap.keys != previousCompilerArgsMap.keys) {\n            return \"Compiler arguments version was changed\"\n        }\n\n        val changedCompilerArguments = currentCompilerArgumentsMap.mapNotNull {\n            val key = it.key\n            val previousValue = previousCompilerArgsMap[it.key] ?: return@mapNotNull key\n            val currentValue = it.value\n            return@mapNotNull if (compareIsChanged(key, currentValue, previousValue)) key else null\n        }\n\n        if (changedCompilerArguments.isNotE"}
{"code": "mpty()) {\n            val rebuildReason = when (changedCompilerArguments.size) {\n                1 -> \"One of compiler arguments was changed: \"\n                else -> \"Some compiler arguments were changed: \"\n            } + changedCompilerArguments.joinToReadableString()\n            return rebuildReason\n        }\n        return null\n    }\n\n    private fun compareIsChanged(key: String, currentValue: String, previousValue: String): Boolean {\n        // check for specific key changes\n        checkIfPlatformSpecificCompilerArgumentWasChanged(key, currentValue, previousValue)?.let { comparisonResult ->\n            return comparisonResult\n        }\n        when (key) {\n            CustomKeys.LANGUAGE_VERSION_STRING.name ->\n                return LanguageVersion.fromVersionString(currentValue) != LanguageVersion.fromVersionString(previousValue)\n            CustomKeys.API_VERSION_STRING.name -> return ApiVersion.parse(currentValue) != ApiVersion.parse(previousValue)\n            CustomKeys.PLU"}
{"code": "GIN_CLASSPATHS.name -> return !PluginClasspathComparator(previousValue, currentValue).equals()\n        }\n\n        // check keys that are sensitive for true -> false change\n        if (key in argumentsListForSpecialCheck) {\n            return previousValue == \"true\" && currentValue != \"true\"\n        }\n\n        // compare all other change-sensitive values\n        if (previousValue != currentValue) {\n            return true\n        }\n\n        return false\n    }\n\n    open fun checkIfPlatformSpecificCompilerArgumentWasChanged(key: String, currentValue: String, previousValue: String): Boolean? {\n        return null\n    }\n\n    open fun createPropertiesMapFromCompilerArguments(args: CommonCompilerArguments): Map<String, String> {\n        val resultMap = transformClassToPropertiesMap(args, excludedProperties).toMutableMap()\n        val languageVersion = args.languageVersion?.let { LanguageVersion.fromVersionString(it) }\n            ?: LanguageVersion.LATEST_STABLE\n        val languageVersionSti"}
{"code": "ng = languageVersion.versionString\n        resultMap[CustomKeys.LANGUAGE_VERSION_STRING.name] = languageVersionSting\n\n        val isEAP = languageVersion.isPreRelease()\n        resultMap[CustomKeys.IS_EAP.name] = isEAP.toString()\n\n        val apiVersionString = args.apiVersion ?: languageVersionSting\n        resultMap[CustomKeys.API_VERSION_STRING.name] = apiVersionString\n\n        val pluginClasspath = PluginClasspath(args.pluginClasspaths).serialize()\n        resultMap[CustomKeys.PLUGIN_CLASSPATHS.name] = pluginClasspath\n\n        return resultMap\n    }\n\n    fun deserializeMapFromString(inputString: String): Map<String, String> = inputString\n        .split(\"\\n\")\n        .filter(String::isNotBlank)\n        .associate { it.substringBefore(\"=\") to it.substringAfter(\"=\") }\n\n    private fun serializeMapToString(myList: Map<String, String>) = myList.map { \"${it.key}=${it.value}\" }.joinToString(\"\\n\")\n    fun serializeArgsToString(args: CommonCompilerArguments) = serializeMapToString(createPro"}
{"code": "pertiesMapFromCompilerArguments(args))\n\n    open val excludedProperties = listOf(\n        \"languageVersion\",\n        \"apiVersion\",\n        \"pluginClasspaths\",\n        \"metadataVersion\",\n        \"dumpDirectory\",\n        \"dumpOnlyFqName\",\n        \"dumpPerf\",\n        \"errors\",\n        \"extraHelp\",\n        \"freeArgs\",\n        \"help\",\n        \"intellijPluginRoot\",\n        \"kotlinHome\",\n        \"listPhases\",\n        \"phasesToDump\",\n        \"phasesToDumpAfter\",\n        \"phasesToDumpBefore\",\n        \"profilePhases\",\n        \"renderInternalDiagnosticNames\",\n        \"reportOutputFiles\",\n        \"reportPerf\",\n        \"script\",\n        \"verbose\",\n        \"verbosePhases\",\n        \"version\"\n    )\n\n    open val argumentsListForSpecialCheck = listOf(\n        \"allowAnyScriptsInSourceRoots\",\n        \"allowKotlinPackage\",\n        \"allowResultReturnType\",\n        \"noCheckActual\",\n        \"skipMetadataVersionCheck\",\n        \"skipPrereleaseCheck\",\n        \"suppressVersionWarnings\",\n        \"suppressWarnings"}
{"code": "\",\n        CustomKeys.IS_EAP.name\n    )\n}"}
{"code": "interface A\n\ninterface B\n\nclass Clazz1 : A, B\nclass Clazz2 : A, B\n\n<!NON_MEMBER_FUNCTION_NO_BODY!>fun <K> select(x: K, y: K): K<!>\n\nfun test() = select(Clazz1(), Clazz2())\n\nfun <T> makeNull(x: T): T? = null\n\nfun testNull() = makeNull(select(Clazz1(), Clazz2()))\n"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental\n\nimport org.jetbrains.kotlin.backend.common.pop\nimport org.jetbrains.kotlin.backend.common.push\nimport org.jetbrains.kotlin.backend.jvm.metadata.MetadataSerializer\nimport org.jetbrains.kotlin.build.report.ICReporter\nimport org.jetbrains.kotlin.codegen.serialization.JvmSerializationBindings\nimport org.jetbrains.kotlin.config.CompilerConfiguration\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.backend.FirMetadataSource\nimport org.jetbrains.kotlin.fir.backend.jvm.makeLocalFirMetadataSerializerForMetadataSource\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.declarations.utils.classId\nimport org.jetbrains.kotlin.fir.pipeline.FirResult\nimport org.jetbrains.kotlin.fir.pipeline.ModuleCompilerAnalyzedOutput\nimport org.jetbrains.kotlin.fir.scopes.jvm.computeJvmDescriptor\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.metadata.ProtoBuf\nimport org.jetbrains.kotlin"}
{"code": ".modules.TargetId\nimport org.jetbrains.kotlin.name.SpecialNames\nimport org.jetbrains.org.objectweb.asm.commons.Method\nimport java.io.File\n\ninternal fun collectNewDirtySources(\n    analysisResults: FirResult,\n    targetId: TargetId,\n    configuration: CompilerConfiguration,\n    caches: IncrementalJvmCachesManager,\n    alreadyCompiledSources: Set<File>,\n    reporter: ICReporter\n): LinkedHashSet<File> {\n    val changesCollector = ChangesCollector()\n    val globalSerializationBindings = JvmSerializationBindings()\n\n    fun visitFirFiles(analyzedOutput: ModuleCompilerAnalyzedOutput) {\n        analyzedOutput.fir.forEach {\n            it.accept(object : FirVisitor<Unit, MutableList<MetadataSerializer>>() {\n                inline fun withMetadataSerializer(\n                    metadata: FirMetadataSource,\n                    data: MutableList<MetadataSerializer>,\n                    body: (MetadataSerializer) -> Unit\n                ) {\n                    val serializer = makeLocalFirMetadataS"}
{"code": "erializerForMetadataSource(\n                        metadata,\n                        analyzedOutput.session,\n                        analyzedOutput.scopeSession,\n                        globalSerializationBindings,\n                        data.lastOrNull(),\n                        targetId,\n                        configuration,\n                        actualizedExpectDeclarations = null\n                    )\n                    data.push(serializer)\n                    body(serializer)\n                    data.pop()\n                }\n\n                override fun visitElement(element: FirElement, data: MutableList<MetadataSerializer>) {\n                    element.acceptChildren(this, data)\n                }\n\n                override fun visitRegularClass(regularClass: FirRegularClass, data: MutableList<MetadataSerializer>) {\n                    visitClass(regularClass, data)\n                }\n\n                override fun visitAnonymousObject(anonymousObject: FirAnonymousObject, dat"}
{"code": "a: MutableList<MetadataSerializer>) {\n                    visitClass(anonymousObject, data)\n                }\n\n                override fun visitFile(file: FirFile, data: MutableList<MetadataSerializer>) {\n                    val metadata = FirMetadataSource.File(file)\n                    withMetadataSerializer(metadata, data) {\n                        file.acceptChildren(this, data)\n                        // TODO: compare package fragments?\n                    }\n                }\n\n                override fun visitSimpleFunction(simpleFunction: FirSimpleFunction, data: MutableList<MetadataSerializer>) {\n                    data.firstOrNull()?.let { serializer ->\n                        super.visitFunction(simpleFunction, data)\n                        serializer.bindMethodMetadata(\n                            FirMetadataSource.Function(simpleFunction),\n                            Method(simpleFunction.name.asString(), simpleFunction.computeJvmDescriptor())\n                        )\n  "}
{"code": "                  }\n                }\n\n                override fun visitConstructor(constructor: FirConstructor, data: MutableList<MetadataSerializer>) {\n                    super.visitConstructor(constructor, data)\n                    data.first().bindMethodMetadata(\n                        FirMetadataSource.Function(constructor),\n                        Method(SpecialNames.INIT.asString(), constructor.computeJvmDescriptor(\"\"))\n                    )\n                }\n\n                override fun visitProperty(property: FirProperty, data: MutableList<MetadataSerializer>) {\n                    property.acceptChildren(this, data)\n                    //                    data.firstOrNull()?.let {\n                    //                        property.acceptChildren(this, data)\n                    //                        it.bindPropertyMetadata(\n                    //                            FirMetadataSource.Property(property),\n                    //                            Met"}
{"code": "hod(property.name.asString(), \"\"),//property.computeJvmDescriptor())\n                    //                            IrDeclarationOrigin.DEFINED\n                    //                        )\n                    //                    }\n                }\n\n                override fun visitClass(klass: FirClass, data: MutableList<MetadataSerializer>) {\n                    val metadata = FirMetadataSource.Class(klass)\n                    withMetadataSerializer(metadata, data) { serializer ->\n                        klass.acceptChildren(this, data)\n                        serializer.serialize(metadata)?.let { (classProto, nameTable) ->\n                            caches.platformCache.saveFrontendClassToCache(\n                                klass.classId,\n                                classProto as ProtoBuf.Class,\n                                nameTable,\n                                null, // TODO: !!\n                                changesCollector\n                            )\n "}
{"code": "                       }\n                    }\n                }\n            }, mutableListOf())\n        }\n    }\n\n    for (output in analysisResults.outputs) {\n        visitFirFiles(output)\n    }\n\n    val (dirtyLookupSymbols, dirtyClassFqNames, forceRecompile) =\n        changesCollector.getChangedAndImpactedSymbols(listOf(caches.platformCache), reporter)\n\n    val forceToRecompileFiles = mapClassesFqNamesToFiles(listOf(caches.platformCache), forceRecompile, reporter)\n\n    return linkedSetOf<File>().apply {\n        addAll(mapLookupSymbolsToFiles(caches.lookupCache, dirtyLookupSymbols, reporter, excludes = alreadyCompiledSources))\n        addAll(\n            mapClassesFqNamesToFiles(\n                listOf(caches.platformCache),\n                dirtyClassFqNames,\n                reporter,\n                excludes = alreadyCompiledSources\n            )\n        )\n        if (!alreadyCompiledSources.containsAll(forceToRecompileFiles)) {\n            addAll(forceToRecompileFiles)\n        }\n   "}
{"code": "     removeAll { !it.exists() }\n    }\n}\n"}
{"code": "import java.<expr>util</expr>.ArrayList"}
{"code": "// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n\npackage org.jetbrains.kotlin.analysis.decompiler.psi.text\n\nimport org.jetbrains.kotlin.metadata.deserialization.BinaryVersion\n\nprivate const val FILE_ABI_VERSION_MARKER: String = \"FILE_ABI\"\nprivate const val CURRENT_ABI_VERSION_MARKER: String = \"CURRENT_ABI\"\n\nconst val INCOMPATIBLE_ABI_VERSION_GENERAL_COMMENT: String =\n    \"// This class file was compiled with different version of Kotlin compiler and can't be decompiled.\"\n\nprivate const val INCOMPATIBLE_ABI_VERSION_COMMENT: String = \"$INCOMPATIBLE_ABI_VERSION_GENERAL_COMMENT\\n\" +\n        \"//\\n\" +\n        \"// Current compiler ABI version is $CURRENT_ABI_VERSION_MARKER\\n\" +\n        \"// File ABI version is $FILE_ABI_VERSION_MARKER\"\n\nfun <V : BinaryVersion> createIncompatibleAbiVersionDecompiledText(expectedVersion: V, actualVersion: V): DecompiledText = DecompiledText(\n    INCOMPAT"}
{"code": "IBLE_ABI_VERSION_COMMENT.replace(CURRENT_ABI_VERSION_MARKER, expectedVersion.toString())\n        .replace(FILE_ABI_VERSION_MARKER, actualVersion.toString())\n)\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cli.common.messages\n\nimport com.intellij.psi.PsiFile\nimport org.jetbrains.kotlin.diagnostics.Diagnostic\nimport org.jetbrains.kotlin.diagnostics.DiagnosticUtils\n\n\nclass DefaultDiagnosticReporter(override val messageCollector: MessageCollector) : MessageCollectorBasedReporter\n\ninterface MessageCollectorBasedReporter : DiagnosticMessageReporter {\n    val messageCollector: MessageCollector\n\n    override fun report(diagnostic: Diagnostic, file: PsiFile, render: String) = messageCollector.report(\n        AnalyzerWithCompilerReport.convertSeverity(diagnostic.severity),\n        render,\n        MessageUtil.psiFileToMessageLocation(file, file.name, DiagnosticUtils.getLineAndColumnRange(diagnostic))\n    )\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.declarations.bodies\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.renderer.declarations.KtDeclarationRenderer\nimport org.jetbrains.kotlin.analysis.api.symbols.KtScriptSymbol\nimport org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter\n\npublic interface KtScriptInitializerRenderer {\n    context(KtAnalysisSession, KtDeclarationRenderer)\n    public fun renderInitializer(symbol: KtScriptSymbol, printer: PrettyPrinter)\n\n    public object NO_INITIALIZER : KtScriptInitializerRenderer {\n        context(KtAnalysisSession, KtDeclarationRenderer)\n        override fun renderInitializer(symbol: KtScriptSymbol, printer: PrettyPrinter) {\n        }\n    }\n}\n"}
{"code": "// !DUMP_CFG\nfun foo() {}\n\nfun test() {\n    val x = 1\n    val y = x + 1\n    foo()\n}\n"}
{"code": "fun resolve<caret>Me() {\n    receive(withGetter)\n}\n\nfun receive(value: Int){}\n\nval withGetter: Int\n    get() = 42"}
{"code": "// DO_NOT_CHECK_SYMBOL_RESTORE_K1\nannotation class Anno(val param1: String, val param2: Int)\n\n@Anno(param1 = \"param\", 2)\nclass X {\n    @Anno(\"funparam\", 3)\n    fun x() {\n\n    }\n}\n"}
{"code": "class Owner {\n\n    fun foo() {\n        bar()\n        this.bar()\n    }\n\n    fun bar() {\n        val i = Inner()\n        i.baz()\n    }\n\n    fun err() {}\n\n    inner class Inner {\n        fun baz() {\n            gau()\n            this.gau()\n        }\n\n        fun gau() {\n            val o = Owner()\n            o.foo()\n            foo()\n            this@Owner.foo()\n            this.<!UNRESOLVED_REFERENCE!>err<!>()\n        }\n    }\n}\n\nfun test() {\n    val o = Owner()\n    o.foo()\n    val err = Owner.<!INNER_CLASS_CONSTRUCTOR_NO_RECEIVER!>Inner<!>()\n    err.<!UNRESOLVED_REFERENCE!>baz<!>()\n    val i = o.Inner()\n    i.gau()\n}\n"}
{"code": "annotation class Anno(val value: String)\n\nfun test() {\n    // Annotation class cannot be instantiated\n    consume(<expr>::Anno</expr>)\n}\n\nfun consume(f: (String) -> Any) {}"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.optimization.boxing\n\nimport com.intellij.openapi.util.Pair\nimport org.jetbrains.kotlin.codegen.inline.insnOpcodeText\nimport org.jetbrains.kotlin.codegen.inline.insnText\nimport org.jetbrains.kotlin.codegen.intrinsics.IntrinsicMethods\nimport org.jetbrains.kotlin.codegen.optimization.common.FastMethodAnalyzer\nimport org.jetbrains.kotlin.codegen.optimization.common.StrictBasicValue\nimport org.jetbrains.kotlin.codegen.optimization.common.remapLocalVariables\nimport org.jetbrains.kotlin.codegen.optimization.fixStack.peek\nimport org.jetbrains.kotlin.codegen.optimization.fixStack.top\nimport org.jetbrains.kotlin.codegen.optimization.transformer.MethodTransformer\nimport org.jetbrains.kotlin.codegen.state.GenerationState\nimport org.jetbrains.org.objectweb.asm.Label\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\nimport org.jetbrains.org.objectweb.asm.t"}
{"code": "ree.*\nimport org.jetbrains.org.objectweb.asm.tree.analysis.BasicValue\nimport org.jetbrains.org.objectweb.asm.tree.analysis.Frame\n\nclass RedundantBoxingMethodTransformer(private val generationState: GenerationState) : MethodTransformer() {\n\n    override fun transform(internalClassName: String, node: MethodNode) {\n        if (node.instructions.none { it.isBoxing(generationState) || it.isMethodInsnWith(Opcodes.INVOKEINTERFACE) { name == \"next\" } })\n            return\n\n        val interpreter = RedundantBoxingInterpreter(node, generationState)\n        val analyzer = FastMethodAnalyzer<BasicValue>(\n            internalClassName, node, interpreter, pruneExceptionEdges = false\n        ) { nLocals, nStack -> BoxingFrame(nLocals, nStack) }\n        val frames = analyzer.analyze()\n\n        interpretPopInstructionsForBoxedValues(interpreter, node, frames)\n\n        val valuesToOptimize = interpreter.candidatesBoxedValues\n\n        if (!valuesToOptimize.isEmpty) {\n            // has side effect on va"}
{"code": "luesToOptimize\n            removeValuesFromTaintedProgressionIterators(valuesToOptimize)\n\n            // has side effect on valuesToOptimize and frames, containing BoxedBasicValues that are unsafe to remove\n            removeValuesClashingWithVariables(valuesToOptimize, node, frames)\n\n            // cannot replace them inplace because replaced variables indexes are known after remapping\n            val variablesForReplacement = adaptLocalSingleVariableTableForBoxedValuesAndPrepareMultiVariables(node, frames)\n\n            node.remapLocalVariables(buildVariablesRemapping(valuesToOptimize, node))\n\n            replaceVariables(node, variablesForReplacement)\n\n            sortAdaptableInstructionsForBoxedValues(node, valuesToOptimize)\n\n            adaptInstructionsForBoxedValues(node, valuesToOptimize)\n        }\n    }\n\n    private fun sortAdaptableInstructionsForBoxedValues(node: MethodNode, valuesToOptimize: RedundantBoxedValuesCollection) {\n        val indexes = node.instructions.withIndex"}
{"code": "().associate { (index, insn) -> insn to index }\n        for (value in valuesToOptimize) {\n            value.sortAssociatedInsns(indexes)\n            value.sortUnboxingWithCastInsns(indexes)\n        }\n    }\n\n    private fun replaceVariables(node: MethodNode, variablesForReplacement: Map<LocalVariableNode, List<LocalVariableNode>>) {\n        if (variablesForReplacement.isEmpty()) return\n        node.localVariables = node.localVariables.flatMap { oldVar ->\n            variablesForReplacement[oldVar]?.also { newVars -> for (newVar in newVars) newVar.index += oldVar.index } ?: listOf(oldVar)\n        }.toMutableList()\n    }\n\n    private fun interpretPopInstructionsForBoxedValues(\n        interpreter: RedundantBoxingInterpreter,\n        node: MethodNode,\n        frames: Array<out Frame<BasicValue>?>\n    ) {\n        for (i in frames.indices) {\n            val insn = node.instructions[i]\n            if (insn.opcode != Opcodes.POP && insn.opcode != Opcodes.POP2) {\n                continue\n      "}
{"code": "      }\n\n            val frame = frames[i] ?: continue\n\n            val top = frame.top()!!\n            interpreter.processPopInstruction(insn, top)\n\n            if (top.size == 1 && insn.opcode == Opcodes.POP2) {\n                interpreter.processPopInstruction(insn, frame.peek(1)!!)\n            }\n        }\n    }\n\n    private fun removeValuesClashingWithVariables(\n        values: RedundantBoxedValuesCollection,\n        node: MethodNode,\n        frames: Array<Frame<BasicValue>?>\n    ) {\n        while (removeValuesClashingWithVariablesPass(values, node, frames)) {\n            // do nothing\n        }\n    }\n\n    private fun removeValuesClashingWithVariablesPass(\n        values: RedundantBoxedValuesCollection,\n        node: MethodNode,\n        frames: Array<out Frame<BasicValue>?>\n    ): Boolean {\n        var needToRepeat = false\n\n        for (localVariableNode in node.localVariables) {\n            if (Type.getType(localVariableNode.desc).sort != Type.OBJECT) {\n                continue\n  "}
{"code": "          }\n\n            val variableValues = getValuesStoredOrLoadedToVariable(localVariableNode, node, frames)\n\n            val boxed = variableValues.filterIsInstance<BoxedBasicValue>()\n\n            if (boxed.isEmpty()) continue\n\n            val firstBoxed = boxed.first().descriptor\n            if (isUnsafeToRemoveBoxingForConnectedValues(variableValues, firstBoxed.unboxedTypes)) {\n                for (value in boxed) {\n                    val descriptor = value.descriptor\n                    if (descriptor.isSafeToRemove) {\n                        values.remove(descriptor)\n                        needToRepeat = true\n                    }\n                }\n            }\n        }\n\n        return needToRepeat\n    }\n\n    private fun removeValuesFromTaintedProgressionIterators(valuesToOptimize: RedundantBoxedValuesCollection) {\n        for (descriptor in valuesToOptimize.toList()) {\n            val progressionIterator = descriptor?.progressionIterator ?: continue\n            if (progre"}
{"code": "ssionIterator.tainted) {\n                valuesToOptimize.remove(descriptor)\n            }\n        }\n    }\n\n    private fun isUnsafeToRemoveBoxingForConnectedValues(usedValues: List<BasicValue>, unboxedTypes: List<Type>): Boolean =\n        usedValues.any { input ->\n            if (input === StrictBasicValue.UNINITIALIZED_VALUE) return@any false\n            if (input !is CleanBoxedValue) return@any true\n\n            val descriptor = input.descriptor\n            !descriptor.isSafeToRemove || descriptor.unboxedTypes != unboxedTypes\n        }\n\n    private fun adaptLocalSingleVariableTableForBoxedValuesAndPrepareMultiVariables(\n        node: MethodNode, frames: Array<Frame<BasicValue>?>\n    ): Map<LocalVariableNode, List<LocalVariableNode>> {\n        val localVariablesReplacement = mutableMapOf<LocalVariableNode, List<LocalVariableNode>>()\n        for (localVariableNode in node.localVariables) {\n            if (Type.getType(localVariableNode.desc).sort != Type.OBJECT) {\n                cont"}
{"code": "inue\n            }\n\n            for (value in getValuesStoredOrLoadedToVariable(localVariableNode, node, frames)) {\n                if (value !is BoxedBasicValue) continue\n\n                val descriptor = value.descriptor\n                if (!descriptor.isSafeToRemove) continue\n                val unboxedType = descriptor.unboxedTypes.singleOrNull()\n                if (unboxedType == null) {\n                    var offset = 0\n                    localVariablesReplacement[localVariableNode] =\n                        descriptor.multiFieldValueClassUnboxInfo!!.unboxedTypesAndMethodNamesAndFieldNames.map { (type, _, fieldName) ->\n                            val newVarName = \"${localVariableNode.name}-$fieldName\"\n                            val newStart = localVariableNode.start\n                            val newEnd = localVariableNode.end\n                            val newOffset = offset\n                            offset += type.size\n                            LocalVariableNode(newVar"}
{"code": "Name, type.descriptor, null, newStart, newEnd, newOffset)\n                        }\n                } else {\n                    localVariableNode.desc = unboxedType.descriptor\n                }\n            }\n        }\n        return localVariablesReplacement\n    }\n\n    private fun getValuesStoredOrLoadedToVariable(\n        localVariableNode: LocalVariableNode,\n        node: MethodNode,\n        frames: Array<out Frame<BasicValue>?>\n    ): List<BasicValue> {\n        val values = ArrayList<BasicValue>()\n        val insnList = node.instructions\n        val localVariableStart = insnList.indexOf(localVariableNode.start)\n        val localVariableEnd = insnList.indexOf(localVariableNode.end)\n\n        frames[localVariableStart]?.let { frameForStartInsn ->\n            frameForStartInsn.getLocal(localVariableNode.index)?.let { localVarValue ->\n                values.add(localVarValue)\n            }\n        }\n\n        for (i in localVariableStart until localVariableEnd) {\n            if (i < 0 ||"}
{"code": " i >= insnList.size()) continue\n            val frame = frames[i] ?: continue\n            val insn = insnList[i]\n            if ((insn.opcode == Opcodes.ASTORE || insn.opcode == Opcodes.ALOAD) &&\n                (insn as VarInsnNode).`var` == localVariableNode.index\n            ) {\n                if (insn.getOpcode() == Opcodes.ASTORE) {\n                    values.add(frame.top()!!)\n                } else {\n                    values.add(frame.getLocal(insn.`var`))\n                }\n            }\n        }\n\n        return values\n    }\n\n    private fun buildVariablesRemapping(values: RedundantBoxedValuesCollection, node: MethodNode): IntArray {\n        val wideVars2SizeMinusOne = HashMap<Int, Int>()\n        for (valueDescriptor in values) {\n            val size = valueDescriptor.getTotalUnboxSize()\n            if (size < 2) continue\n            for (index in valueDescriptor.getVariablesIndexes()) {\n                wideVars2SizeMinusOne.merge(index, size - 1, ::maxOf)\n            }\n    "}
{"code": "    }\n\n        node.maxLocals += wideVars2SizeMinusOne.values.sum()\n        val remapping = IntArray(node.maxLocals)\n        for (i in remapping.indices) {\n            remapping[i] = i\n        }\n\n        for ((varIndex, shift) in wideVars2SizeMinusOne) {\n            for (i in varIndex + 1..remapping.lastIndex) {\n                remapping[i] += shift\n            }\n        }\n\n        return remapping\n    }\n\n    private fun adaptInstructionsForBoxedValues(\n        node: MethodNode,\n        values: RedundantBoxedValuesCollection\n    ) {\n        for (value in values) {\n            adaptInstructionsForBoxedValue(node, value)\n        }\n    }\n\n    private fun adaptInstructionsForBoxedValue(node: MethodNode, value: BoxedValueDescriptor) {\n        adaptBoxingInstruction(node, value)\n\n        for (cast in value.getUnboxingWithCastInsns()) {\n            adaptCastInstruction(node, value, cast)\n        }\n\n        var extraSlotsUsed = 0\n        for (insn in value.getAssociatedInsns()) {\n            e"}
{"code": "xtraSlotsUsed = maxOf(extraSlotsUsed, adaptInstruction(node, insn, value))\n        }\n        node.maxLocals += extraSlotsUsed\n    }\n\n    private fun adaptBoxingInstruction(node: MethodNode, value: BoxedValueDescriptor) {\n        if (!value.isFromProgressionIterator()) {\n            node.instructions.remove(value.boxingInsn)\n        } else {\n            val iterator = value.progressionIterator ?: error(\"iterator should not be null because isFromProgressionIterator returns true\")\n\n            //add checkcast to kotlin/<T>Iterator before next() call\n            node.instructions.insertBefore(value.boxingInsn, TypeInsnNode(Opcodes.CHECKCAST, iterator.type.internalName))\n\n            //invoke concrete method (kotlin/<T>iterator.next<T>())\n            node.instructions.set(\n                value.boxingInsn,\n                MethodInsnNode(\n                    Opcodes.INVOKEVIRTUAL,\n                    iterator.type.internalName, iterator.nextMethodName, iterator.nextMethodDesc,\n              "}
{"code": "      false\n                )\n            )\n        }\n    }\n\n    private fun adaptCastInstruction(\n        node: MethodNode,\n        value: BoxedValueDescriptor,\n        castWithType: Pair<AbstractInsnNode, Type>\n    ) {\n        val castInsn = castWithType.getFirst()\n        val castInsnsListener = MethodNode(Opcodes.API_VERSION)\n        InstructionAdapter(castInsnsListener)\n            .cast(value.getUnboxTypeOrOtherwiseMethodReturnType(castInsn as? MethodInsnNode), castWithType.getSecond())\n\n\n        for (insn in castInsnsListener.instructions.toArray()) {\n            node.instructions.insertBefore(castInsn, insn)\n        }\n\n        node.instructions.remove(castInsn)\n    }\n\n    private fun adaptInstruction(\n        node: MethodNode, insn: AbstractInsnNode, value: BoxedValueDescriptor\n    ): Int {\n        var usedExtraSlots = 0\n\n        when (insn.opcode) {\n            Opcodes.POP -> {\n                val newPops = makePops(value.unboxedTypes)\n                node.instructions.insert("}
{"code": "insn, newPops)\n                node.instructions.remove(insn)\n            }\n\n            Opcodes.DUP -> when (value.getTotalUnboxSize()) {\n                1 -> Unit\n                2 -> node.instructions.set(insn, InsnNode(Opcodes.DUP2))\n                else -> {\n                    usedExtraSlots = value.getTotalUnboxSize()\n                    var currentSlot = node.maxLocals\n                    val slotIndices = value.unboxedTypes.map { type -> currentSlot.also { currentSlot += type.size } }\n                    for ((type, index) in (value.unboxedTypes zip slotIndices).asReversed()) {\n                        node.instructions.insertBefore(insn, VarInsnNode(type.getOpcode(Opcodes.ISTORE), index))\n                    }\n                    repeat(2) {\n                        for ((type, index) in (value.unboxedTypes zip slotIndices)) {\n                            node.instructions.insertBefore(insn, VarInsnNode(type.getOpcode(Opcodes.ILOAD), index))\n                        }\n           "}
{"code": "         }\n                    node.instructions.remove(insn)\n                }\n            }\n\n            Opcodes.ASTORE, Opcodes.ALOAD -> {\n                val isStore = insn.opcode == Opcodes.ASTORE\n                val singleUnboxedType = value.unboxedTypes.singleOrNull()\n                if (singleUnboxedType == null) {\n                    val newInstructions = mutableListOf<VarInsnNode>()\n                    var offset = 0\n                    for (unboxedType in value.unboxedTypes) {\n                        val opcode = unboxedType.getOpcode(if (isStore) Opcodes.ISTORE else Opcodes.ILOAD)\n                        val newIndex = (insn as VarInsnNode).`var` + offset\n                        newInstructions.add(VarInsnNode(opcode, newIndex))\n                        offset += unboxedType.size\n                    }\n                    if (isStore) {\n                        val previousInstructions = generateSequence(insn.previous) { it.previous }\n                            .take(value.un"}
{"code": "boxedTypes.size).toList().asReversed()\n                        if (value.unboxedTypes.map { it.getOpcode(Opcodes.ILOAD) } == previousInstructions.map { it.opcode }) {\n                            // help optimizer and put each xSTORE after the corresponding xLOAD\n                            for ((load, store) in previousInstructions zip newInstructions) {\n                                newInstructions.remove(store)\n                                node.instructions.insert(load, store)\n                            }\n                        } else {\n                            for (newInstruction in newInstructions.asReversed()) {\n                                node.instructions.insertBefore(insn, newInstruction)\n                            }\n                        }\n                    } else {\n                        for (newInstruction in newInstructions) {\n                            node.instructions.insertBefore(insn, newInstruction)\n                        }\n                    }\n"}
{"code": "                    node.instructions.remove(insn)\n                } else {\n                    val storeOpcode = singleUnboxedType.getOpcode(if (isStore) Opcodes.ISTORE else Opcodes.ILOAD)\n                    node.instructions.set(insn, VarInsnNode(storeOpcode, (insn as VarInsnNode).`var`))\n                }\n            }\n\n            Opcodes.INSTANCEOF -> {\n                node.instructions.insertBefore(insn, makePops(value.unboxedTypes))\n                node.instructions.set(insn, InsnNode(Opcodes.ICONST_1))\n            }\n\n            Opcodes.INVOKESTATIC -> {\n                when {\n                    insn.isAreEqualIntrinsic() ->\n                        adaptAreEqualIntrinsic(node, insn, value)\n                    insn.isJavaLangComparableCompareTo() ->\n                        adaptJavaLangComparableCompareTo(node, insn, value)\n                    insn.isJavaLangClassBoxing() ||\n                            insn.isJavaLangClassUnboxing() ->\n                        node.instructions"}
{"code": ".remove(insn)\n                    else ->\n                        throwCannotAdaptInstruction(insn)\n                }\n            }\n\n            Opcodes.INVOKEINTERFACE -> {\n                if (insn.isJavaLangComparableCompareTo()) {\n                    adaptJavaLangComparableCompareTo(node, insn, value)\n                } else {\n                    throwCannotAdaptInstruction(insn)\n                }\n            }\n\n            Opcodes.CHECKCAST -> node.instructions.remove(insn)\n            Opcodes.INVOKEVIRTUAL -> {\n                if (value.unboxedTypes.size != 1) {\n                    val unboxMethodCall = insn as MethodInsnNode\n                    val unboxMethodIndex = value.multiFieldValueClassUnboxInfo!!.unboxedMethodNames.indexOf(unboxMethodCall.name)\n                    val unboxedType = value.unboxedTypes[unboxMethodIndex]\n\n                    var canRemoveInsns = true\n                    var savedToVariable = false\n                    for ((i, type) in value.unboxedTypes.withI"}
{"code": "ndex().toList().asReversed()) {\n                        fun canRemoveInsn(includeDup: Boolean): Boolean {\n                            if (!canRemoveInsns) return false\n                            val insnToCheck = if (i < unboxMethodIndex) unboxMethodCall.previous.previous else unboxMethodCall.previous\n                            val result = when (insnToCheck.opcode) {\n                                type.getOpcode(Opcodes.ILOAD) -> true\n                                Opcodes.DUP2 -> includeDup && type.size == 2\n                                Opcodes.DUP -> includeDup && type.size == 1\n                                else -> false\n                            }\n\n                            canRemoveInsns = result\n                            return result\n                        }\n\n                        fun insertPopInstruction() =\n                            node.instructions.insertBefore(unboxMethodCall, InsnNode(if (type.size == 2) Opcodes.POP2 else Opcodes.POP))\n\n               "}
{"code": "         fun saveToVariableIfNecessary() {\n                            if (savedToVariable) return\n                            if (i > unboxMethodIndex) return\n                            savedToVariable = true\n                            usedExtraSlots = unboxedType.size\n                            node.instructions.insertBefore(insn, VarInsnNode(unboxedType.getOpcode(Opcodes.ISTORE), node.maxLocals))\n                        }\n\n                        if (i == unboxMethodIndex) {\n                            if (unboxMethodIndex > 0 && !canRemoveInsn(includeDup = false)) {\n                                saveToVariableIfNecessary()\n                            }\n                        } else if (canRemoveInsn(includeDup = i > unboxMethodIndex)) {\n                            node.instructions.remove(if (i < unboxMethodIndex) unboxMethodCall.previous.previous else unboxMethodCall.previous)\n                        } else {\n                            saveToVariableIfNecessary()\n          "}
{"code": "                  insertPopInstruction()\n                        }\n                    }\n                    if (savedToVariable) {\n                        node.instructions.insertBefore(insn, VarInsnNode(unboxedType.getOpcode(Opcodes.ILOAD), node.maxLocals))\n                    }\n                }\n                node.instructions.remove(insn)\n            }\n\n            else ->\n                throwCannotAdaptInstruction(insn)\n        }\n        return usedExtraSlots\n    }\n\n    private fun throwCannotAdaptInstruction(insn: AbstractInsnNode): Nothing =\n        throw AssertionError(\"Cannot adapt instruction: ${insn.insnText}\")\n\n    private fun adaptAreEqualIntrinsic(\n        node: MethodNode,\n        insn: AbstractInsnNode,\n        value: BoxedValueDescriptor\n    ) {\n        val unboxedType = value.unboxedTypes.singleOrNull()\n\n        when (unboxedType?.sort) {\n            Type.BOOLEAN, Type.BYTE, Type.SHORT, Type.INT, Type.CHAR ->\n                adaptAreEqualIntrinsicForInt(node, insn)"}
{"code": "\n            Type.LONG ->\n                adaptAreEqualIntrinsicForLong(node, insn)\n            Type.OBJECT, null -> {\n            }\n            else ->\n                throw AssertionError(\"Unexpected unboxed type kind: $unboxedType\")\n        }\n    }\n\n    private fun adaptAreEqualIntrinsicForInt(node: MethodNode, insn: AbstractInsnNode) {\n        node.instructions.run {\n            val next = insn.next\n            if (next != null && (next.opcode == Opcodes.IFEQ || next.opcode == Opcodes.IFNE)) {\n                fuseAreEqualWithBranch(node, insn, Opcodes.IF_ICMPNE, Opcodes.IF_ICMPEQ)\n                remove(insn)\n                remove(next)\n            } else {\n                ifEqual1Else0(node, insn, Opcodes.IF_ICMPNE)\n                remove(insn)\n            }\n        }\n    }\n\n    private fun adaptAreEqualIntrinsicForLong(node: MethodNode, insn: AbstractInsnNode) {\n        node.instructions.run {\n            insertBefore(insn, InsnNode(Opcodes.LCMP))\n            val next = insn.nex"}
{"code": "t\n            if (next != null && (next.opcode == Opcodes.IFEQ || next.opcode == Opcodes.IFNE)) {\n                fuseAreEqualWithBranch(node, insn, Opcodes.IFNE, Opcodes.IFEQ)\n                remove(insn)\n                remove(next)\n            } else {\n                ifEqual1Else0(node, insn, Opcodes.IFNE)\n                remove(insn)\n            }\n        }\n    }\n\n    private fun fuseAreEqualWithBranch(\n        node: MethodNode,\n        insn: AbstractInsnNode,\n        ifEqualOpcode: Int,\n        ifNotEqualOpcode: Int\n    ) {\n        node.instructions.run {\n            val next = insn.next\n            assert(next is JumpInsnNode) { \"JumpInsnNode expected: $next\" }\n            val nextLabel = (next as JumpInsnNode).label\n            when {\n                next.getOpcode() == Opcodes.IFEQ ->\n                    insertBefore(insn, JumpInsnNode(ifEqualOpcode, nextLabel))\n                next.getOpcode() == Opcodes.IFNE ->\n                    insertBefore(insn, JumpInsnNode(ifNotEqualOp"}
{"code": "code, nextLabel))\n                else ->\n                    throw AssertionError(\"IFEQ or IFNE expected: ${next.insnOpcodeText}\")\n            }\n        }\n    }\n\n    private fun ifEqual1Else0(node: MethodNode, insn: AbstractInsnNode, ifneOpcode: Int) {\n        node.instructions.run {\n            val lNotEqual = LabelNode(Label())\n            val lDone = LabelNode(Label())\n            insertBefore(insn, JumpInsnNode(ifneOpcode, lNotEqual))\n            insertBefore(insn, InsnNode(Opcodes.ICONST_1))\n            insertBefore(insn, JumpInsnNode(Opcodes.GOTO, lDone))\n            insertBefore(insn, lNotEqual)\n            insertBefore(insn, InsnNode(Opcodes.ICONST_0))\n            insertBefore(insn, lDone)\n        }\n    }\n\n    private fun adaptJavaLangComparableCompareTo(\n        node: MethodNode,\n        insn: AbstractInsnNode,\n        value: BoxedValueDescriptor\n    ) {\n        val unboxedType = value.unboxedTypes.single()\n\n        when (unboxedType.sort) {\n            Type.BOOLEAN, Type.BYT"}
{"code": "E, Type.SHORT, Type.INT, Type.CHAR ->\n                adaptJavaLangComparableCompareToForInt(node, insn)\n            Type.LONG ->\n                adaptJavaLangComparableCompareToForLong(node, insn)\n            Type.FLOAT ->\n                adaptJavaLangComparableCompareToForFloat(node, insn)\n            Type.DOUBLE ->\n                adaptJavaLangComparableCompareToForDouble(node, insn)\n            else ->\n                throw AssertionError(\"Unexpected unboxed type kind: $unboxedType\")\n        }\n    }\n\n    private fun adaptJavaLangComparableCompareToForInt(node: MethodNode, insn: AbstractInsnNode) {\n        node.instructions.run {\n            val next = insn.next\n            val next2 = next?.next\n            when {\n                next != null && next2 != null &&\n                        next.opcode == Opcodes.ICONST_0 &&\n                        next2.opcode >= Opcodes.IF_ICMPEQ && next2.opcode <= Opcodes.IF_ICMPLE -> {\n                    // Fuse: compareTo + ICONST_0 + IF_ICMPxx ->"}
{"code": " IF_ICMPxx\n                    remove(insn)\n                    remove(next)\n                }\n\n                next != null &&\n                        next.opcode >= Opcodes.IFEQ && next.opcode <= Opcodes.IFLE -> {\n                    // Fuse: compareTo + IFxx -> IF_ICMPxx\n                    val nextLabel = (next as JumpInsnNode).label\n                    val ifCmpOpcode = next.opcode - Opcodes.IFEQ + Opcodes.IF_ICMPEQ\n                    insertBefore(insn, JumpInsnNode(ifCmpOpcode, nextLabel))\n                    remove(insn)\n                    remove(next)\n                }\n\n                else -> {\n                    // Can't fuse with branching instruction. Use Intrinsics#compare(int, int).\n                    set(insn, MethodInsnNode(Opcodes.INVOKESTATIC, IntrinsicMethods.INTRINSICS_CLASS_NAME, \"compare\", \"(II)I\", false))\n                }\n            }\n        }\n    }\n\n    private fun adaptJavaLangComparableCompareToForLong(node: MethodNode, insn: AbstractInsnNode) {\n       "}
{"code": " node.instructions.set(insn, InsnNode(Opcodes.LCMP))\n    }\n\n    private fun adaptJavaLangComparableCompareToForFloat(node: MethodNode, insn: AbstractInsnNode) {\n        node.instructions.set(insn, MethodInsnNode(Opcodes.INVOKESTATIC, \"java/lang/Float\", \"compare\", \"(FF)I\", false))\n    }\n\n    private fun adaptJavaLangComparableCompareToForDouble(node: MethodNode, insn: AbstractInsnNode) {\n        node.instructions.set(insn, MethodInsnNode(Opcodes.INVOKESTATIC, \"java/lang/Double\", \"compare\", \"(DD)I\", false))\n    }\n}\n"}
{"code": "class A {\n    val a = 20\n\n    val it: Number\n    field = 4\n\n    <!PROPERTY_MUST_HAVE_GETTER!>val joke: Number\n    field = \"Haha\"<!>\n\n    <!PROPERTY_MUST_HAVE_GETTER!>val incompatible: Number\n    field: Any? = 42<!>\n\n    <!PROPERTY_MUST_HAVE_GETTER!>val customGetterNeeded: Int\n    field: Number = 42<!>\n\n    val invertedTypes: Int\n    field: Number = 42\n    get() = 30\n\n    val uninitialized: Number\n    <!PROPERTY_FIELD_DECLARATION_MISSING_INITIALIZER!>field: Int<!>\n\n    val uninitializedWithGetter: Number\n    <!PROPERTY_FIELD_DECLARATION_MISSING_INITIALIZER!>field: Int<!>\n    get() = 2\n\n    val initiaizedWithExplicitBackingField = <!PROPERTY_INITIALIZER_WITH_EXPLICIT_FIELD_DECLARATION!>listOf(1, 2)<!>\n    <!PROPERTY_FIELD_DECLARATION_MISSING_INITIALIZER!>field: MutableList<Int><!>\n\n    val p = 5\n        get() = field\n\n    <!PROPERTY_MUST_HAVE_SETTER!>var setterNeeded: Int\n        field = \"test\"\n        get() = field.length<!>\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.calls.checkers\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.contracts.parsing.isContractCallDescriptor\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.psi.KtElement\nimport org.jetbrains.kotlin.psi.psiUtil.isFirstStatement\nimport org.jetbrains.kotlin.resolve.BindingContext\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\nimport org.jetbrains.kotlin.resolve.scopes.LexicalScope\nimport org.jetbrains.kotlin.resolve.scopes.LexicalScopeKind\n\nobject ContractNotAllowedCallChecker : CallChecker {\n    override fun check(resolvedCall: ResolvedCall<*>, reportOn: PsiElement, context: CallCheckerContext) {\n        if (reportOn !is KtElement) return\n        val descriptor = resolvedCall.resultingDescriptor as? FunctionDescriptor ?: return\n        if (!descriptor.isContractCallDescriptor()) return\n\n        val allow"}
{"code": "edOnMembers = context.languageVersionSettings.supportsFeature(LanguageFeature.AllowContractsForNonOverridableMembers)\n\n        val callElement = resolvedCall.call.callElement\n        var hasErrors = false\n\n        fun contractNotAllowed(message: String) {\n            hasErrors = true\n            context.trace.report(Errors.CONTRACT_NOT_ALLOWED.on(reportOn, message))\n        }\n\n        val scope = context.scope\n        val functionDescriptor = scope.ownerDescriptor as? FunctionDescriptor\n\n        if (functionDescriptor == null || functionDescriptor is PropertyAccessorDescriptor)\n            contractNotAllowed(\"Contracts are allowed only for functions\")\n\n        var inFunctionBodyBlock = true\n\n        val declarationOwner = scope.ownerDescriptor.containingDeclaration\n        val acceptableParent = if (allowedOnMembers) {\n            var owner = declarationOwner\n            var result = true\n            while (owner !is PackageFragmentDescriptor) {\n                if (owner !is ClassDescr"}
{"code": "iptor) {\n                    result = false\n                    break\n                }\n                owner = owner.containingDeclaration\n            }\n            result\n        } else {\n            declarationOwner is PackageFragmentDescriptor\n        }\n\n        if (!acceptableParent\n            || scope.kind != LexicalScopeKind.CODE_BLOCK\n            || (scope.parent as? LexicalScope)?.kind != LexicalScopeKind.FUNCTION_INNER_SCOPE\n        ) {\n            if (scope.kind == LexicalScopeKind.FUNCTION_INNER_SCOPE) {\n                contractNotAllowed(\"Contracts are allowed only in function body block\")\n                inFunctionBodyBlock = false\n            } else {\n                val message = if (allowedOnMembers)\n                    \"Contracts are allowed only for functions\"\n                else\n                    \"Contracts are allowed only for top-level functions\"\n                contractNotAllowed(message)\n            }\n        }\n\n        if (functionDescriptor?.isOperator == "}
{"code": "true) contractNotAllowed(\"Contracts are not allowed for operator functions\")\n\n\n        if (!allowedOnMembers && functionDescriptor?.isOverridable == true) {\n            contractNotAllowed(\"Contracts are not allowed for open functions\")\n        }\n        if (allowedOnMembers && functionDescriptor?.isOverridableOrOverrides == true) {\n            contractNotAllowed(\"Contracts are not allowed for open or override functions\")\n        }\n\n        if (!callElement.isFirstStatement() && inFunctionBodyBlock) {\n            contractNotAllowed(\"Contract should be the first statement\")\n        }\n\n        if (hasErrors) {\n            context.trace.record(BindingContext.CONTRACT_NOT_ALLOWED, callElement, true)\n        }\n    }\n}"}
{"code": "package testing\n\ninterface Foo\n\nval otherFoo: Foo = makeFoo()\n\nfun makeFoo(): Foo = Foo()\n\nfun test() {\n    <caret>makeFoo().\n}"}
{"code": "// RESOLVE_FILE\n\n@file:[Deprecated(\"deprecated file\") Anno(1)]\npackage one\n\nannotation class Anno(val i: Int)\n\nval a = 1\nval b = 2 + a\nval c = b + a\n\nfun test1() {}\n@Deprecated(\"\")\n@Anno(2)\nfun test2() {}\n\nclass A {\n    fun test3() {}\n    @Deprecated(\"\")\n    @Anno(3)\n    fun test4() {}\n}\n\n@Anno(4)\n@Deprecated(\"\")\nclass B\n"}
{"code": "import kotli<caret>n.text.toString\n"}
{"code": "// FILE: main.kt\nimport dependency.Base\nimport dependency.Child.staticFunFromBase\nimport dependency.Child.STATIC_CONSTANT_FROM_BASE\nimport KotlinChild.nonStaticFieldFromBase\n\nfun usage() {\n    staticFunFromBase()\n    STATIC_CONSTANT_FROM_BASE\n    nonStaticFieldFromBase\n}\n\nobject KotlinChild : Base()\n\n// FILE: dependency/Base.java\npackage dependency;\n\npublic class Base {\n    public static void staticFunFromBase() {}\n    public static String STATIC_CONSTANT_FROM_BASE = \"\";\n\n    public String nonStaticFieldFromBase = \"\";\n}\n\n// FILE: dependency/Child.java\npackage dependency;\n\npublic class Child extends Base {}"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\")\n\npackage org.jetbrains.kotlin.fir.expressions.impl\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.MutableOrEmptyList\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.types.constructClassLikeType\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.fir.visitors.transformInplace\nimport org.jetbrains.kotlin.name.StandardClassIds\n\ninternal class FirEqualityOperatorCallImpl(\n    override val source: KtSourceElement?,\n    override var annotations: MutableOrEmptyList<FirAnnotation>,\n    override var argumentList: FirArgumentList,\n    override val operation: FirOperation,\n) : FirEqualityOperat"}
{"code": "orCall() {\n    @OptIn(UnresolvedExpressionTypeAccess::class)\n    override var coneTypeOrNull: ConeKotlinType? = StandardClassIds.Boolean.constructClassLikeType()\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {\n        annotations.forEach { it.accept(visitor, data) }\n        argumentList.accept(visitor, data)\n    }\n\n    override fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirEqualityOperatorCallImpl {\n        transformAnnotations(transformer, data)\n        argumentList = argumentList.transform(transformer, data)\n        return this\n    }\n\n    override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirEqualityOperatorCallImpl {\n        annotations.transformInplace(transformer, data)\n        return this\n    }\n\n    override fun replaceConeTypeOrNull(newConeTypeOrNull: ConeKotlinType?) {\n        coneTypeOrNull = newConeTypeOrNull\n    }\n\n    override fun replaceAnnotations(newAnnotations: List<FirAnnotation>) {\n   "}
{"code": "     annotations = newAnnotations.toMutableOrEmpty()\n    }\n\n    override fun replaceArgumentList(newArgumentList: FirArgumentList) {\n        argumentList = newArgumentList\n    }\n}\n"}
{"code": "package nativeKLib\n\nfun nativeKLibFunction(arg: String): Int {\n    return 1\n}"}
{"code": "fun test() {\n\n    outer@while(true) {\n        inner@while(false) {\n            break<expr>@outer</expr>\n        }\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.components\n\nimport org.jetbrains.kotlin.analysis.api.components.KtOriginalPsiProvider\nimport org.jetbrains.kotlin.analysis.api.fir.KtFirAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.util.originalDeclaration\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.util.originalKtFile\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtFile\n\ninternal class KtFirOriginalPsiProvider(\n    override val analysisSession: KtFirAnalysisSession,\n    override val token: KtLifetimeToken,\n) : KtOriginalPsiProvider(), KtFirAnalysisSessionComponent {\n    override fun getOriginalDeclaration(declaration: KtDeclaration): KtDeclaration? = declaration.originalDeclaration\n\n    override fun getOriginalKtFile(file: KtFile): KtFile? = file.originalKtFile\n\n    override fun recordOriginalDeclaration(fakeDeclaration: KtDeclaration, originalDeclaration"}
{"code": ": KtDeclaration) {\n        fakeDeclaration.originalDeclaration = originalDeclaration\n    }\n\n    override fun recordOriginalKtFile(fakeFile: KtFile, originalFile: KtFile) {\n        fakeFile.originalKtFile = originalFile\n    }\n}"}
{"code": "open class A\n\n\nclass B : A"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.inference\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.diagnostics.ConeCannotInferTypeParameterType\nimport org.jetbrains.kotlin.fir.diagnostics.ConeSimpleDiagnostic\nimport org.jetbrains.kotlin.fir.diagnostics.DiagnosticKind\nimport org.jetbrains.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.languageVersionSettings\nimport org.jetbrains.kotlin.fir.resolve.BodyResolveComponents\nimport org.jetbrains.kotlin.fir.resolve.calls.Candidate\nimport org.jetbrains.kotlin.fir.resolve.calls.FirNamedReferenceWithCandidate\nimport org.jetbrains.kotlin.fir.resolve.calls.ResolutionContext\nimport org.jetbrains.kotlin.fir.resolve.inference.model.ConeFixVariableConstraintPosition\nimport org.jetbrains.kotlin.fir.returnExpressions\nimport org.jetbrains.kotlin.fir.symbols.impl.FirTypeParameterSymbol\nimport org.jetbrains.kotlin.fir.types.ConeErrorType\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin."}
{"code": "fir.types.ConeTypeVariable\nimport org.jetbrains.kotlin.resolve.calls.inference.components.*\nimport org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl\nimport org.jetbrains.kotlin.resolve.calls.inference.model.NotEnoughInformationForTypeParameter\nimport org.jetbrains.kotlin.resolve.calls.inference.model.VariableWithConstraints\nimport org.jetbrains.kotlin.resolve.calls.model.PostponedAtomWithRevisableExpectedType\nimport org.jetbrains.kotlin.types.model.TypeConstructorMarker\nimport org.jetbrains.kotlin.types.model.TypeVariableMarker\nimport org.jetbrains.kotlin.utils.addIfNotNull\nimport org.jetbrains.kotlin.utils.addToStdlib.filterIsInstanceWithChecker\n\nclass ConstraintSystemCompleter(components: BodyResolveComponents) {\n    private val inferenceComponents = components.session.inferenceComponents\n    private val variableFixationFinder = inferenceComponents.variableFixationFinder\n    private val postponedArgumentsInputTypesResolver = inferenceComponents.postponedArgum"}
{"code": "entInputTypesResolver\n    private val languageVersionSettings = components.session.languageVersionSettings\n\n    fun interface PostponedAtomAnalyzer {\n        fun analyze(postponedResolvedAtom: PostponedResolvedAtom, withPCLASession: Boolean)\n    }\n\n    fun complete(\n        c: ConstraintSystemCompletionContext,\n        completionMode: ConstraintSystemCompletionMode,\n        topLevelAtoms: List<FirStatement>,\n        candidateReturnType: ConeKotlinType,\n        context: ResolutionContext,\n        analyzer: PostponedAtomAnalyzer,\n    ) = c.runCompletion(completionMode, topLevelAtoms, candidateReturnType, context, analyzer)\n\n    private fun ConstraintSystemCompletionContext.runCompletion(\n        completionMode: ConstraintSystemCompletionMode,\n        topLevelAtoms: List<FirStatement>,\n        topLevelType: ConeKotlinType,\n        context: ResolutionContext,\n        analyzer: PostponedAtomAnalyzer,\n    ) {\n        val topLevelTypeVariables = topLevelType.extractTypeVariables()\n\n        co"}
{"code": "mpletion@ while (true) {\n            if (completionMode.shouldForkPointConstraintsBeResolved) {\n                resolveForkPointsConstraints()\n            }\n\n            // TODO: This is very slow, KT-59680\n            val postponedArguments = getOrderedNotAnalyzedPostponedArguments(topLevelAtoms)\n\n            if (completionMode == ConstraintSystemCompletionMode.UNTIL_FIRST_LAMBDA && hasLambdaToAnalyze(\n                    languageVersionSettings,\n                    postponedArguments\n                )\n            ) return\n\n            // Stage 1: analyze postponed arguments with fixed parameter types\n            if (analyzeArgumentWithFixedParameterTypes(languageVersionSettings, postponedArguments) {\n                    analyzer.analyze(it, withPCLASession = false)\n                }\n            ) continue\n\n            val isThereAnyReadyForFixationVariable = findFirstVariableForFixation(\n                topLevelAtoms,\n                postponedArguments,\n                completionMode"}
{"code": ",\n                topLevelType\n            ) != null\n\n            // If there aren't any postponed arguments and ready for fixation variables, then completion isn't needed: nothing to do\n            if (postponedArguments.isEmpty() && !isThereAnyReadyForFixationVariable)\n                break\n\n            val postponedArgumentsWithRevisableType = postponedArguments\n                .filterIsInstanceWithChecker<PostponedAtomWithRevisableExpectedType> {\n                    // NB: FE 1.0 does not perform this check\n                    it.revisedExpectedType == null\n                }\n            val dependencyProvider =\n                TypeVariableDependencyInformationProvider(notFixedTypeVariables, postponedArguments, topLevelType, this)\n\n            // Stage 2: collect parameter types for postponed arguments\n            val wasBuiltNewExpectedTypeForSomeArgument = postponedArgumentsInputTypesResolver.collectParameterTypesAndBuildNewExpectedTypes(\n                this,\n                post"}
{"code": "ponedArgumentsWithRevisableType,\n                completionMode,\n                dependencyProvider,\n                topLevelTypeVariables\n            )\n\n            if (wasBuiltNewExpectedTypeForSomeArgument)\n                continue\n\n            if (completionMode.allLambdasShouldBeAnalyzed) {\n                // Stage 3: fix variables for parameter types of all postponed arguments\n                for (argument in postponedArguments) {\n                    val variableWasFixed = postponedArgumentsInputTypesResolver.fixNextReadyVariableForParameterTypeIfNeeded(\n                        this,\n                        argument,\n                        postponedArguments,\n                        topLevelType,\n                        dependencyProvider,\n                    ) {\n                        // NB: FE 1.0 calls findResolvedAtomBy here\n                        // atom provided here is used only inside constraint positions, omitting right now\n                        null\n               "}
{"code": "     }\n\n                    if (variableWasFixed)\n                        continue@completion\n                }\n\n                // Stage 4: create atoms with revised expected types if needed\n                for (argument in postponedArgumentsWithRevisableType) {\n                    val argumentWasTransformed = transformToAtomWithNewFunctionExpectedType(\n                        this, context, argument\n                    )\n\n                    if (argumentWasTransformed)\n                        continue@completion\n                }\n            }\n\n            // Stage 5: analyze the next ready postponed argument\n            if (analyzeNextReadyPostponedArgument(languageVersionSettings, postponedArguments, completionMode) {\n                    analyzer.analyze(it, withPCLASession = false)\n                }\n            ) continue\n\n            // Stage 6: fix next ready type variable with proper constraints\n            if (fixNextReadyVariable(completionMode, topLevelAtoms, topLevelType, p"}
{"code": "ostponedArguments))\n                continue\n\n            // Stage 7: try to complete call with the builder inference if there are uninferred type variables\n            val areThereAppearedProperConstraintsForSomeVariable = tryToCompleteWithPCLA(\n                completionMode, postponedArguments, analyzer,\n            )\n\n            if (areThereAppearedProperConstraintsForSomeVariable)\n                continue\n\n            if (completionMode == ConstraintSystemCompletionMode.PCLA_POSTPONED_CALL) {\n                // Complete all lambdas, maybe with fixing type variables used as top-level input types.\n                // It's necessary because we need to process all data-flow info before going to the next statement.\n                if (analyzeRemainingNotAnalyzedPostponedArgument(postponedArguments) {\n                        analyzer.analyze(it, withPCLASession = false)\n                    }\n                ) continue\n                reportNotEnoughInformationForTypeVariablesRequiredFor"}
{"code": "InputTypesOfLambdas(\n                    postponedArguments, topLevelType, dependencyProvider, topLevelAtoms\n                )\n            } else if (completionMode != ConstraintSystemCompletionMode.PARTIAL) {\n                // Stage 8: report \"not enough information\" for uninferred type variables\n                reportNotEnoughTypeInformation(\n                    completionMode, topLevelAtoms, topLevelType, postponedArguments\n                )\n            }\n\n            // Stage 9: force analysis of remaining not analyzed postponed arguments and rerun stages if there are\n            if (completionMode.allLambdasShouldBeAnalyzed) {\n                if (analyzeRemainingNotAnalyzedPostponedArgument(postponedArguments) {\n                        analyzer.analyze(it, withPCLASession = false)\n                    }\n                ) continue\n            }\n\n            break\n        }\n    }\n\n    private fun ConstraintSystemCompletionContext.reportNotEnoughInformationForTypeVariablesRequiredFor"}
{"code": "InputTypesOfLambdas(\n        postponedArguments: List<PostponedResolvedAtom>,\n        topLevelType: ConeKotlinType,\n        dependencyProvider: TypeVariableDependencyInformationProvider,\n        topLevelAtoms: List<FirStatement>,\n    ) {\n        for (argument in postponedArguments) {\n            val variableForFixation = postponedArgumentsInputTypesResolver.findNextVariableForReportingNotInferredInputType(\n                this,\n                argument,\n                postponedArguments,\n                topLevelType,\n                dependencyProvider,\n            ) ?: continue\n\n            assert(!variableForFixation.isReady) {\n                \"At this stage there should be no remaining variables with proper constraints from input types\"\n            }\n\n            val variableWithConstraints = notFixedTypeVariables.getValue(variableForFixation.variable)\n            processVariableWhenNotEnoughInformation(variableWithConstraints, topLevelAtoms)\n        }\n    }\n\n    private fun Constra"}
{"code": "intSystemCompletionContext.findFirstVariableForFixation(\n        topLevelAtoms: List<FirStatement>,\n        postponedArguments: List<PostponedResolvedAtom>,\n        completionMode: ConstraintSystemCompletionMode,\n        topLevelType: ConeKotlinType,\n    ): VariableFixationFinder.VariableForFixation? {\n        return variableFixationFinder.findFirstVariableForFixation(\n            this,\n            getOrderedAllTypeVariables(\n                topLevelAtoms\n            ),\n            postponedArguments,\n            completionMode,\n            topLevelType\n        )\n    }\n\n    \n    private fun ConstraintSystemCompletionContext.tryToCompleteWithPCLA(\n        completionMode: ConstraintSystemCompletionMode,\n        postponedArguments: List<PostponedResolvedAtom>,\n        analyzer: PostponedAtomAnalyzer,\n    ): Boolean {\n        if (!completionMode.allLambdasShouldBeAnalyzed) return false\n\n        val lambdaArguments = postponedArguments.filterIsInstance<ResolvedLambdaAtom>().takeIf { it.isNo"}
{"code": "tEmpty() } ?: return false\n\n        var anyAnalyzed = false\n        for (argument in lambdaArguments) {\n            val notFixedInputTypeVariables = argument.inputTypes.flatMap { it.extractTypeVariables() }.filter { it !in fixedTypeVariables }\n\n            if (notFixedInputTypeVariables.isEmpty()) continue\n            analyzer.analyze(argument, withPCLASession = true)\n\n            anyAnalyzed = true\n        }\n\n        return anyAnalyzed\n    }\n\n    private fun transformToAtomWithNewFunctionExpectedType(\n        c: ConstraintSystemCompletionContext,\n        resolutionContext: ResolutionContext,\n        argument: PostponedAtomWithRevisableExpectedType,\n    ): Boolean = with(c) {\n        val revisedExpectedType = argument.revisedExpectedType\n            ?.takeIf { it.isFunctionOrKFunctionWithAnySuspendability() } as ConeKotlinType?\n            ?: return false\n\n        when (argument) {\n            is ResolvedCallableReferenceAtom ->\n                argument.reviseExpectedType(revisedExpect"}
{"code": "edType)\n            is LambdaWithTypeVariableAsExpectedTypeAtom ->\n                argument.transformToResolvedLambda(c.getBuilder(), resolutionContext, revisedExpectedType)\n            else -> throw IllegalStateException(\"Unsupported postponed argument type of $argument\")\n        }\n\n        return true\n    }\n\n    private fun ConstraintSystemCompletionContext.fixNextReadyVariable(\n        completionMode: ConstraintSystemCompletionMode,\n        topLevelAtoms: List<FirStatement>,\n        topLevelType: ConeKotlinType,\n        postponedArguments: List<PostponedResolvedAtom>,\n    ): Boolean {\n        val variableForFixation = findFirstVariableForFixation(\n            topLevelAtoms, postponedArguments, completionMode, topLevelType\n        ) ?: return false\n\n        val variableWithConstraints = notFixedTypeVariables.getValue(variableForFixation.variable)\n        if (!variableForFixation.isReady) return false\n\n        fixVariable(this, variableWithConstraints)\n\n        return true\n    }\n\n    "}
{"code": "private fun ConstraintSystemCompletionContext.reportNotEnoughTypeInformation(\n        completionMode: ConstraintSystemCompletionMode,\n        topLevelAtoms: List<FirStatement>,\n        topLevelType: ConeKotlinType,\n        postponedArguments: List<PostponedResolvedAtom>,\n    ) {\n        while (true) {\n            val variableForFixation =\n                findFirstVariableForFixation(topLevelAtoms, postponedArguments, completionMode, topLevelType)\n                    ?: break\n            assert(!variableForFixation.isReady) {\n                \"At this stage there should be no remaining variables with proper constraints\"\n            }\n\n            val variableWithConstraints = notFixedTypeVariables.getValue(variableForFixation.variable)\n            processVariableWhenNotEnoughInformation(variableWithConstraints, topLevelAtoms)\n        }\n    }\n\n    private fun ConstraintSystemCompletionContext.processVariableWhenNotEnoughInformation(\n        variableWithConstraints: VariableWithConstraints"}
{"code": ",\n        topLevelAtoms: List<FirStatement>,\n    ) {\n        val typeVariable = variableWithConstraints.typeVariable\n        val resolvedAtom = findResolvedAtomBy(typeVariable, topLevelAtoms) ?: topLevelAtoms.firstOrNull()\n\n        if (resolvedAtom != null) {\n            addError(\n                NotEnoughInformationForTypeParameter(typeVariable, resolvedAtom, couldBeResolvedWithUnrestrictedBuilderInference())\n            )\n        }\n\n        val resultErrorType = when (typeVariable) {\n            is ConeTypeParameterBasedTypeVariable ->\n                createCannotInferErrorType(\n                    typeVariable.typeParameterSymbol,\n                    \"Cannot infer argument for type parameter ${typeVariable.typeParameterSymbol.name}\",\n                    isUninferredParameter = true,\n                )\n\n            is ConeTypeVariableForLambdaParameterType -> createCannotInferErrorType(\n                typeParameterSymbol = null,\n                message = \"Cannot infer lambda paramete"}
{"code": "r type\"\n            )\n            else -> createCannotInferErrorType(typeParameterSymbol = null, \"Cannot infer type variable $typeVariable\")\n        }\n\n        fixVariable(typeVariable, resultErrorType, ConeFixVariableConstraintPosition(typeVariable))\n    }\n\n    private fun ConstraintSystemCompletionContext.getOrderedAllTypeVariables(\n        topLevelAtoms: List<FirStatement>,\n    ): List<TypeConstructorMarker> {\n        val result = LinkedHashSet<TypeConstructorMarker>(notFixedTypeVariables.size)\n        fun ConeTypeVariable?.toTypeConstructor(): TypeConstructorMarker? =\n            this?.typeConstructor?.takeIf { it in notFixedTypeVariables.keys }\n\n        fun PostponedAtomWithRevisableExpectedType.collectNotFixedVariables() {\n            revisedExpectedType?.lowerBoundIfFlexible()?.asArgumentList()?.let { typeArgumentList ->\n                for (typeArgument in typeArgumentList) {\n                    val constructor = typeArgument.getType().typeConstructor()\n                    if ("}
{"code": "constructor in notFixedTypeVariables) {\n                        result.add(constructor)\n                    }\n                }\n            }\n        }\n\n        fun FirStatement.collectAllTypeVariables() {\n            this.processAllContainingCallCandidates(processBlocks = true) { candidate ->\n                candidate.freshVariables.mapNotNullTo(result) { typeVariable ->\n                    typeVariable.toTypeConstructor()\n                }\n\n                for (postponedAtom in candidate.postponedAtoms) {\n                    when (postponedAtom) {\n                        is ResolvedLambdaAtom -> {\n                            result.addIfNotNull(postponedAtom.typeVariableForLambdaReturnType.toTypeConstructor())\n                        }\n                        is LambdaWithTypeVariableAsExpectedTypeAtom -> {\n                            postponedAtom.collectNotFixedVariables()\n                        }\n                        is ResolvedCallableReferenceAtom -> {\n                      "}
{"code": "      if (postponedAtom.mightNeedAdditionalResolution) {\n                                postponedAtom.collectNotFixedVariables()\n                            }\n                        }\n                        // ResolvedCallAtom?\n                        // ResolvedCallableReferenceArgumentAtom?\n                    }\n                }\n            }\n        }\n\n        for (topLevelAtom in topLevelAtoms) {\n            topLevelAtom.collectAllTypeVariables()\n        }\n\n        return result.toList()\n    }\n\n    private fun fixVariable(\n        c: ConstraintSystemCompletionContext,\n        variableWithConstraints: VariableWithConstraints,\n    ) {\n        val resultType = inferenceComponents.resultTypeResolver.findResultType(\n            c,\n            variableWithConstraints,\n            TypeVariableDirectionCalculator.ResolveDirection.UNKNOWN\n        )\n\n        val variable = variableWithConstraints.typeVariable\n        c.fixVariable(variable, resultType, ConeFixVariableConstraintPosition(v"}
{"code": "ariable))\n    }\n\n    companion object {\n        internal fun getOrderedNotAnalyzedPostponedArguments(candidate: Candidate): List<PostponedResolvedAtom> {\n            val callSite = candidate.callInfo.callSite as? FirStatement ?: return emptyList()\n            return getOrderedNotAnalyzedPostponedArguments(listOf(callSite))\n        }\n\n        private fun getOrderedNotAnalyzedPostponedArguments(topLevelAtoms: List<FirStatement>): List<PostponedResolvedAtom> {\n            val notAnalyzedArguments = arrayListOf<PostponedResolvedAtom>()\n            for (primitive in topLevelAtoms) {\n                primitive.processAllContainingCallCandidates(\n                    // TODO: remove this argument and relevant parameter, KT-59679\n                    // Currently, it's used because otherwise problem happens with a lambda in a try-block (see tryWithLambdaInside test)\n                    processBlocks = true\n                ) { candidate ->\n                    candidate.postponedAtoms.forEach { ato"}
{"code": "m ->\n                        notAnalyzedArguments.addIfNotNull(atom.takeUnless { it.analyzed })\n                    }\n                }\n            }\n\n            return notAnalyzedArguments\n        }\n\n        private fun findResolvedAtomBy(\n            typeVariable: TypeVariableMarker,\n            topLevelAtoms: List<FirStatement>,\n        ): FirStatement? {\n\n            fun FirStatement.findFirstAtomContainingVariable(): FirStatement? {\n\n                var result: FirStatement? = null\n\n                fun suggestElement(element: FirElement) {\n                    if (result == null && element is FirStatement) {\n                        result = element\n                    }\n                }\n\n                this@findFirstAtomContainingVariable.processAllContainingCallCandidates(processBlocks = true) { candidate ->\n                    if (typeVariable in candidate.freshVariables) {\n                        suggestElement(candidate.callInfo.callSite)\n                    }\n\n             "}
{"code": "       for (postponedAtom in candidate.postponedAtoms) {\n                        if (postponedAtom is ResolvedLambdaAtom) {\n                            if (postponedAtom.typeVariableForLambdaReturnType == typeVariable) {\n                                suggestElement(postponedAtom.atom)\n                            }\n                        }\n                    }\n                }\n\n                return result\n            }\n\n            return topLevelAtoms.firstNotNullOfOrNull(FirStatement::findFirstAtomContainingVariable)\n        }\n\n        private fun createCannotInferErrorType(\n            typeParameterSymbol: FirTypeParameterSymbol?,\n            message: String,\n            isUninferredParameter: Boolean = false,\n        ): ConeErrorType {\n            val diagnostic = when (typeParameterSymbol) {\n                null -> ConeSimpleDiagnostic(message, DiagnosticKind.CannotInferParameterType)\n                else -> ConeCannotInferTypeParameterType(\n                    typeParameter"}
{"code": "Symbol,\n                    message,\n                )\n            }\n            return ConeErrorType(diagnostic, isUninferredParameter)\n        }\n\n\n    }\n}\n\nfun FirStatement.processAllContainingCallCandidates(processBlocks: Boolean, processor: (Candidate) -> Unit) {\n    when (this) {\n        is FirFunctionCall -> {\n            processCandidateIfApplicable(processor, processBlocks)\n            this.arguments.forEach { it.processAllContainingCallCandidates(processBlocks, processor) }\n        }\n\n        is FirSafeCallExpression -> {\n            this.selector.processAllContainingCallCandidates(processBlocks, processor)\n        }\n\n        is FirWhenExpression -> {\n            processCandidateIfApplicable(processor, processBlocks)\n            this.branches.forEach { it.result.processAllContainingCallCandidates(processBlocks, processor) }\n        }\n\n        is FirTryExpression -> {\n            processCandidateIfApplicable(processor, processBlocks)\n            tryBlock.processAllContainingCal"}
{"code": "lCandidates(processBlocks, processor)\n            catches.forEach { it.block.processAllContainingCallCandidates(processBlocks, processor) }\n        }\n\n        is FirCheckNotNullCall -> {\n            processCandidateIfApplicable(processor, processBlocks)\n            this.arguments.forEach { it.processAllContainingCallCandidates(processBlocks, processor) }\n        }\n\n        is FirQualifiedAccessExpression -> {\n            processCandidateIfApplicable(processor, processBlocks)\n        }\n\n        is FirVariableAssignment -> {\n            (lValue as? FirResolvable)?.processCandidateIfApplicable(processor, processBlocks)\n            rValue.processAllContainingCallCandidates(processBlocks, processor)\n        }\n\n        is FirWrappedArgumentExpression -> this.expression.processAllContainingCallCandidates(processBlocks, processor)\n        is FirBlock -> {\n            if (processBlocks) {\n                this.returnExpressions().forEach { it.processAllContainingCallCandidates(processBlocks = tr"}
{"code": "ue, processor) }\n            }\n        }\n\n        is FirDelegatedConstructorCall -> {\n            processCandidateIfApplicable(processor, processBlocks)\n            this.arguments.forEach { it.processAllContainingCallCandidates(processBlocks, processor) }\n        }\n\n        is FirElvisExpression -> {\n            processCandidateIfApplicable(processor, processBlocks)\n            lhs.processAllContainingCallCandidates(processBlocks, processor)\n            rhs.processAllContainingCallCandidates(processBlocks, processor)\n        }\n\n        is FirAnnotationCall -> {\n            processCandidateIfApplicable(processor, processBlocks)\n            arguments.forEach { it.processAllContainingCallCandidates(processBlocks, processor) }\n        }\n    }\n}\n\nprivate fun FirResolvable.processCandidateIfApplicable(\n    processor: (Candidate) -> Unit,\n    processBlocks: Boolean,\n) {\n    val candidate = (calleeReference as? FirNamedReferenceWithCandidate)?.candidate ?: return\n    processor(candidate)\n\n    "}
{"code": "val visited = mutableSetOf<FirStatement>()\n\n    for (atom in candidate.postponedAtoms) {\n        if (atom !is ResolvedLambdaAtom || !atom.analyzed) continue\n\n        atom.returnStatements.forEach {\n            visited += it\n            it.processAllContainingCallCandidates(processBlocks, processor)\n        }\n    }\n\n    for (call in candidate.postponedPCLACalls) {\n        if (!visited.add(call)) continue\n        call.processAllContainingCallCandidates(processBlocks, processor)\n    }\n}\n\nval Candidate.csBuilder: NewConstraintSystemImpl get() = system.getBuilder()\n"}
{"code": "fun x(p: (a) -> Int) {\n\n}"}
{"code": "\n@Target(AnnotationTarget.VALUE_PARAMETER)\nannotation class Ann\n\nvar <!REDECLARATION!>x<!>: Int\n    get() = 1\n    set(@Ann <!WRONG_MODIFIER_TARGET!>private<!> x) { }\n\n\nvar <!REDECLARATION!>x<!>: String = \"\"\n    set(param: <!REDUNDANT_SETTER_PARAMETER_TYPE!>String<!>) {\n        field = \"$param \"\n    }\n\nclass My {\n    var y: Int = 1\n        set(param: <!REDUNDANT_SETTER_PARAMETER_TYPE!>Int<!>) {\n            field = param - 1\n        }\n\n    var z: Double = 3.14\n        private set\n\n    var w: Boolean = true\n        set(param) {\n            field = !param\n        }\n}\n"}
{"code": "// MEMBER_NAME_FILTER: resolveMe\npackage second\n\nabstract class S<caret>ubClass: AbstractClass<Int>()\n\nabstract class AbstractClass<T> {\n    abstract fun T.resolveMe(param: T): T\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir\n\n\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.SOURCE)\nannotation class NoMutableState\n\n\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.SOURCE)\nannotation class ThreadSafeMutableState\n\n\n@RequiresOptIn\nannotation class PrivateSessionConstructor\n\n\n@RequiresOptIn\nannotation class SessionConfiguration\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir\n\nimport org.jetbrains.kotlin.fir.types.impl.*\nimport org.jetbrains.kotlin.fir.util.ConeTypeRegistry\nimport org.jetbrains.kotlin.util.ArrayMapAccessor\nimport org.jetbrains.kotlin.util.ComponentArrayOwner\nimport org.jetbrains.kotlin.util.NullableArrayMapAccessor\nimport org.jetbrains.kotlin.util.TypeRegistry\nimport kotlin.reflect.KClass\n\ninterface FirSessionComponent\n\nabstract class FirSession @PrivateSessionConstructor constructor(\n    val sessionProvider: FirSessionProvider?,\n    val kind: Kind\n) : ComponentArrayOwner<FirSessionComponent, FirSessionComponent>() {\n    companion object : ConeTypeRegistry<FirSessionComponent, FirSessionComponent>() {\n        inline fun <reified T : FirSessionComponent> sessionComponentAccessor(): ArrayMapAccessor<FirSessionComponent, FirSessionComponent, T> {\n            return generateAccessor(T::class)\n        }\n\n        inline fun <reified T : FirSessionComponent> sessionComponentAccessor(id: String): ArrayMapAccessor<"}
{"code": "FirSessionComponent, FirSessionComponent, T> {\n            return generateAccessor(id)\n        }\n\n        inline fun <reified T : FirSessionComponent> nullableSessionComponentAccessor(): NullableArrayMapAccessor<FirSessionComponent, FirSessionComponent, T> {\n            return generateNullableAccessor(T::class)\n        }\n    }\n\n    open val builtinTypes: BuiltinTypes = BuiltinTypes()\n\n    final override val typeRegistry: TypeRegistry<FirSessionComponent, FirSessionComponent> = Companion\n\n    @SessionConfiguration\n    fun register(tClass: KClass<out FirSessionComponent>, value: FirSessionComponent) {\n        registerComponent(tClass, value)\n    }\n\n    @SessionConfiguration\n    fun register(keyQualifiedName: String, value: FirSessionComponent) {\n        registerComponent(keyQualifiedName, value)\n    }\n\n    override fun toString(): String {\n        val moduleData = nullableModuleData ?: return \"Libraries session\"\n        return \"Source session for module ${moduleData.name}\"\n    }\n\n    enu"}
{"code": "m class Kind {\n        Source, Library\n    }\n}\n\nabstract class FirSessionProvider {\n    abstract fun getSession(moduleData: FirModuleData): FirSession?\n}\n\nclass BuiltinTypes {\n    val unitType: FirImplicitBuiltinTypeRef = FirImplicitUnitTypeRef(null)\n    val anyType: FirImplicitBuiltinTypeRef = FirImplicitAnyTypeRef(null)\n    val nullableAnyType: FirImplicitBuiltinTypeRef = FirImplicitNullableAnyTypeRef(null)\n    val enumType: FirImplicitBuiltinTypeRef = FirImplicitEnumTypeRef(null)\n    val annotationType: FirImplicitBuiltinTypeRef = FirImplicitAnnotationTypeRef(null)\n    val booleanType: FirImplicitBuiltinTypeRef = FirImplicitBooleanTypeRef(null)\n    val numberType: FirImplicitBuiltinTypeRef = FirImplicitNumberTypeRef(null)\n    val byteType: FirImplicitBuiltinTypeRef = FirImplicitByteTypeRef(null)\n    val shortType: FirImplicitBuiltinTypeRef = FirImplicitShortTypeRef(null)\n    val intType: FirImplicitBuiltinTypeRef = FirImplicitIntTypeRef(null)\n    val longType: FirImplicitBuiltinType"}
{"code": "Ref = FirImplicitLongTypeRef(null)\n    val doubleType: FirImplicitBuiltinTypeRef = FirImplicitDoubleTypeRef(null)\n    val floatType: FirImplicitBuiltinTypeRef = FirImplicitFloatTypeRef(null)\n\n    val uIntType: FirImplicitUIntTypeRef = FirImplicitUIntTypeRef(null)\n\n    val nothingType: FirImplicitBuiltinTypeRef = FirImplicitNothingTypeRef(null)\n    val nullableNothingType: FirImplicitBuiltinTypeRef = FirImplicitNullableNothingTypeRef(null)\n    val charType: FirImplicitBuiltinTypeRef = FirImplicitCharTypeRef(null)\n    val stringType: FirImplicitBuiltinTypeRef = FirImplicitStringTypeRef(null)\n    val throwableType: FirImplicitThrowableTypeRef = FirImplicitThrowableTypeRef(null)\n\n    val charSequenceType: FirImplicitCharSequenceTypeRef = FirImplicitCharSequenceTypeRef(null)\n    val charIteratorType: FirImplicitCharIteratorTypeRef = FirImplicitCharIteratorTypeRef(null)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.scopes\n\nimport org.jetbrains.kotlin.builtins.StandardNames\nimport org.jetbrains.kotlin.descriptors.ClassKind\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.FirSessionComponent\nimport org.jetbrains.kotlin.fir.declarations.FirClass\nimport org.jetbrains.kotlin.fir.declarations.FirDeclarationOrigin\nimport org.jetbrains.kotlin.fir.declarations.FirRegularClass\nimport org.jetbrains.kotlin.fir.declarations.FirResolvePhase\nimport org.jetbrains.kotlin.fir.declarations.FirSimpleFunction\nimport org.jetbrains.kotlin.fir.declarations.hasAnnotation\nimport org.jetbrains.kotlin.fir.declarations.utils.delegateFields\nimport org.jetbrains.kotlin.fir.declarations.utils.isData\nimport org.jetbrains.kotlin.fir.declarations.utils.isExpect\nimport org.jetbrains.kotlin.fir.declarations.utils.isInline\nimport org.jetbrains.kotlin.fir.resolve.*\nimport org.jetbrains.kotlin.fir.resolve.substitution.ConeRawScopeSubstitutor\nimport org.jetbrains.kotlin.fir.re"}
{"code": "solve.substitution.ConeSubstitutor\nimport org.jetbrains.kotlin.fir.resolve.substitution.substitutorByMap\nimport org.jetbrains.kotlin.fir.scopes.impl.*\nimport org.jetbrains.kotlin.fir.symbols.ConeClassLikeLookupTag\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassifierSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirVariableSymbol\nimport org.jetbrains.kotlin.fir.symbols.lazyResolveToPhaseWithCallableMembers\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.name.Name\n\nclass FirKotlinScopeProvider(\n    val declaredMemberScopeDecorator: (\n        klass: FirClass,\n        declaredMemberScope: FirContainingNamesAwareScope,\n        useSiteSession: FirSession,\n        scopeSession: ScopeSession,\n        member"}
{"code": "RequiredPhase: FirResolvePhase?,\n    ) -> FirContainingNamesAwareScope = { _, declaredMemberScope, session, _, _ ->\n        PlatformDependentFilteringScope(declaredMemberScope, session)\n    }\n) : FirScopeProvider(), FirSessionComponent {\n    override fun getUseSiteMemberScope(\n        klass: FirClass,\n        useSiteSession: FirSession,\n        scopeSession: ScopeSession,\n        memberRequiredPhase: FirResolvePhase?,\n    ): FirTypeScope {\n        memberRequiredPhase?.let {\n            klass.lazyResolveToPhaseWithCallableMembers(it)\n        }\n\n        return scopeSession.getOrBuild(useSiteSession to klass.symbol, USE_SITE) {\n            val declaredScope = useSiteSession.declaredMemberScope(klass, memberRequiredPhase)\n            val possiblyDelegatedDeclaredMemberScope = declaredMemberScopeDecorator(\n                klass,\n                declaredScope,\n                useSiteSession,\n                scopeSession,\n                memberRequiredPhase\n            ).let {\n               "}
{"code": " val delegateFields = klass.delegateFields\n                if (delegateFields.isEmpty())\n                    it\n                else\n                    FirDelegatedMemberScope(useSiteSession, scopeSession, klass, it, delegateFields)\n            }\n            val declaredMemberScopeWithPossiblySynthesizedMembers =\n                // Related: https://youtrack.jetbrains.com/issue/KT-20427#focus=Comments-27-8652759.0-0\n                if (klass is FirRegularClass && !klass.isExpect && (klass.isData || klass.isInline)) {\n                    // See also KT-58926 (we apply delegation first, and data/value classes after it)\n                    FirClassAnySynthesizedMemberScope(useSiteSession, possiblyDelegatedDeclaredMemberScope, klass, scopeSession)\n                } else {\n                    possiblyDelegatedDeclaredMemberScope\n                }\n\n            val scopes = lookupSuperTypes(\n                klass, lookupInterfaces = true, deep = false, useSiteSession = useSiteSession, substit"}
{"code": "uteTypes = true\n            ).mapNotNull { useSiteSuperType ->\n                useSiteSuperType.scopeForSupertype(useSiteSession, scopeSession, klass, memberRequiredPhase = memberRequiredPhase)\n            }\n            FirClassUseSiteMemberScope(\n                klass,\n                useSiteSession,\n                scopes,\n                declaredMemberScopeWithPossiblySynthesizedMembers,\n            )\n        }\n    }\n\n    override fun getStaticMemberScopeForCallables(\n        klass: FirClass,\n        useSiteSession: FirSession,\n        scopeSession: ScopeSession\n    ): FirContainingNamesAwareScope? {\n        return when (klass.classKind) {\n            ClassKind.ENUM_CLASS -> FirNameAwareOnlyCallablesScope(\n                FirStaticScope(\n                    useSiteSession.declaredMemberScope(\n                        klass,\n                        memberRequiredPhase = null,\n                    )\n                )\n            )\n            else -> null\n        }\n    }\n\n    override f"}
{"code": "un getNestedClassifierScope(\n        klass: FirClass,\n        useSiteSession: FirSession,\n        scopeSession: ScopeSession\n    ): FirContainingNamesAwareScope? {\n        return useSiteSession.nestedClassifierScope(klass)\n    }\n\n    class PlatformDependentFilteringScope(\n        val declaredMemberScope: FirContainingNamesAwareScope,\n        val session: FirSession,\n    ) : FirContainingNamesAwareScope() {\n        override fun getCallableNames(): Set<Name> = declaredMemberScope.getCallableNames()\n\n        override fun getClassifierNames(): Set<Name> = declaredMemberScope.getClassifierNames()\n\n        override fun processPropertiesByName(name: Name, processor: (FirVariableSymbol<*>) -> Unit) {\n            declaredMemberScope.processPropertiesByName(name, processor)\n        }\n\n        override fun processClassifiersByNameWithSubstitution(name: Name, processor: (FirClassifierSymbol<*>, ConeSubstitutor) -> Unit) {\n            declaredMemberScope.processClassifiersByNameWithSubstitution(nam"}
{"code": "e, processor)\n        }\n\n        override fun processDeclaredConstructors(processor: (FirConstructorSymbol) -> Unit) {\n            declaredMemberScope.processDeclaredConstructors(processor)\n        }\n\n        override fun processFunctionsByName(name: Name, processor: (FirNamedFunctionSymbol) -> Unit) {\n            declaredMemberScope.processFunctionsByName(name) {\n                if (FirPlatformDeclarationFilter.isFunctionAvailable(it.fir, session)) {\n                    processor(it)\n                }\n            }\n        }\n\n        override fun mayContainName(name: Name): Boolean = declaredMemberScope.mayContainName(name)\n\n        override val scopeOwnerLookupNames: List<String>\n            get() = declaredMemberScope.scopeOwnerLookupNames\n    }\n}\n\nobject FirPlatformDeclarationFilter {\n    fun isFunctionAvailable(function: FirSimpleFunction, session: FirSession): Boolean {\n        // Optimization: only check the annotations for functions named \"getOrDefault\" and \"remove\",\n        //"}
{"code": " since only two functions with these names in kotlin.collections.Map are currently annotated with @PlatformDependent.\n        // This also allows to optimize more heavyweight FirJvmPlatformDeclarationFilter as it uses this function\n        return function.name !in namesToCheck || !function.symbol.hasAnnotation(StandardNames.FqNames.platformDependentClassId, session)\n    }\n\n    private val namesToCheck = listOf(\"getOrDefault\", \"remove\").map(Name::identifier)\n}\n\ndata class ConeSubstitutionScopeKey(\n    val lookupTag: ConeClassLikeLookupTag,\n    val isFromExpectClass: Boolean,\n    val substitutor: ConeSubstitutor,\n    val derivedClassLookupTag: ConeClassLikeLookupTag?\n) : ScopeSessionKey<FirClass, FirClassSubstitutionScope>()\n\nfun FirClass.unsubstitutedScope(\n    useSiteSession: FirSession,\n    scopeSession: ScopeSession,\n    withForcedTypeCalculator: Boolean,\n    memberRequiredPhase: FirResolvePhase?,\n): FirTypeScope {\n    val scope = scopeProvider.getUseSiteMemberScope(this, useSiteSess"}
{"code": "ion, scopeSession, memberRequiredPhase)\n    if (withForcedTypeCalculator) return FirScopeWithCallableCopyReturnTypeUpdater(scope, CallableCopyTypeCalculator.Forced)\n    return scope\n}\n\nfun FirClassSymbol<*>.unsubstitutedScope(\n    useSiteSession: FirSession,\n    scopeSession: ScopeSession,\n    withForcedTypeCalculator: Boolean,\n    memberRequiredPhase: FirResolvePhase?,\n): FirTypeScope {\n    return fir.unsubstitutedScope(useSiteSession, scopeSession, withForcedTypeCalculator, memberRequiredPhase)\n}\n\nfun FirClass.scopeForClass(\n    substitutor: ConeSubstitutor,\n    useSiteSession: FirSession,\n    scopeSession: ScopeSession,\n    memberOwnerLookupTag: ConeClassLikeLookupTag,\n    memberRequiredPhase: FirResolvePhase?,\n): FirTypeScope = scopeForClassImpl(\n    substitutor, useSiteSession, scopeSession,\n    skipPrivateMembers = false,\n    classFirDispatchReceiver = this,\n    // TODO: why it's always false?\n    isFromExpectClass = false,\n    memberOwnerLookupTag = memberOwnerLookupTag,\n    mem"}
{"code": "berRequiredPhase = memberRequiredPhase,\n)\n\nfun ConeKotlinType.scopeForSupertype(\n    useSiteSession: FirSession,\n    scopeSession: ScopeSession,\n    derivedClass: FirClass,\n    memberRequiredPhase: FirResolvePhase?,\n): FirTypeScope? {\n    if (this !is ConeClassLikeType) return null\n    if (this is ConeErrorType) return null\n\n    val symbol = lookupTag.toSymbol(useSiteSession) as? FirRegularClassSymbol ?: return null\n\n    val substitutor = substitutorForSuperType(useSiteSession, symbol)\n\n    return symbol.fir.scopeForClassImpl(\n        substitutor,\n        useSiteSession,\n        scopeSession,\n        skipPrivateMembers = true,\n        classFirDispatchReceiver = derivedClass,\n        isFromExpectClass = (derivedClass as? FirRegularClass)?.isExpect == true,\n        memberOwnerLookupTag = derivedClass.symbol.toLookupTag(),\n        memberRequiredPhase = memberRequiredPhase,\n    )\n}\n\nfun ConeClassLikeType.substitutorForSuperType(useSiteSession: FirSession, classTypeSymbol: FirRegularClassSy"}
{"code": "mbol): ConeSubstitutor {\n    return when {\n        this.type.attributes.contains(CompilerConeAttributes.RawType) -> ConeRawScopeSubstitutor(useSiteSession)\n        else -> substitutor(classTypeSymbol, this, useSiteSession)\n    }\n}\n\nprivate fun substitutor(symbol: FirRegularClassSymbol, type: ConeClassLikeType, useSiteSession: FirSession): ConeSubstitutor {\n    if (type.typeArguments.isEmpty()) return ConeSubstitutor.Empty\n    val originalSubstitution = createSubstitutionForScope(symbol.fir.typeParameters, type, useSiteSession)\n    return substitutorByMap(originalSubstitution, useSiteSession)\n}\n\nprivate fun FirClass.scopeForClassImpl(\n    substitutor: ConeSubstitutor,\n    useSiteSession: FirSession,\n    scopeSession: ScopeSession,\n    skipPrivateMembers: Boolean,\n    classFirDispatchReceiver: FirClass,\n    isFromExpectClass: Boolean,\n    memberOwnerLookupTag: ConeClassLikeLookupTag?,\n    memberRequiredPhase: FirResolvePhase?,\n): FirTypeScope {\n    val basicScope = unsubstitutedScope(use"}
{"code": "SiteSession, scopeSession, withForcedTypeCalculator = false, memberRequiredPhase)\n    if (substitutor == ConeSubstitutor.Empty) return basicScope\n\n    val key = ConeSubstitutionScopeKey(\n        classFirDispatchReceiver.symbol.toLookupTag(),\n        isFromExpectClass,\n        substitutor,\n        memberOwnerLookupTag\n    )\n\n    return scopeSession.getOrBuild(this, key) {\n        FirClassSubstitutionScope(\n            useSiteSession,\n            basicScope,\n            key, substitutor,\n            substitutor.substituteOrSelf(classFirDispatchReceiver.defaultType()).lowerBoundIfFlexible() as ConeClassLikeType,\n            skipPrivateMembers,\n            makeExpect = isFromExpectClass,\n            memberOwnerLookupTag ?: classFirDispatchReceiver.symbol.toLookupTag(),\n            origin = if (classFirDispatchReceiver != this) {\n                FirDeclarationOrigin.SubstitutionOverride.DeclarationSite\n            } else {\n                FirDeclarationOrigin.SubstitutionOverride.CallSite\n "}
{"code": "           },\n        )\n    }\n}\n\nval FirSession.kotlinScopeProvider: FirKotlinScopeProvider by FirSession.sessionComponentAccessor()\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.getContainingClassSymbol\nimport org.jetbrains.kotlin.fir.analysis.checkers.unsubstitutedScope\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FUN_INTERFACE_ABSTRACT_METHOD_WITH_DEFAULT_VALUE\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FUN_INTERFACE_ABSTRACT_METHOD_WITH_TYPE_PARAMETERS\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FUN_INTERFACE_CANNOT_HAVE_ABSTRACT_PROPERTIES\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FUN_INTERFACE_WITH_SUSPEND_FUNCTION\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErr"}
{"code": "ors.FUN_INTERFACE_WRONG_COUNT_OF_ABSTRACT_MEMBERS\nimport org.jetbrains.kotlin.fir.declarations.FirRegularClass\nimport org.jetbrains.kotlin.fir.declarations.utils.*\nimport org.jetbrains.kotlin.fir.languageVersionSettings\nimport org.jetbrains.kotlin.fir.scopes.getFunctions\nimport org.jetbrains.kotlin.fir.scopes.getProperties\nimport org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol\n\n\nsealed class FirFunInterfaceDeclarationChecker(mppKind: MppCheckerKind) : FirRegularClassChecker(mppKind) {\n    object Regular : FirFunInterfaceDeclarationChecker(MppCheckerKind.Platform) {\n        override fun check(declaration: FirRegularClass, context: CheckerContext, reporter: DiagnosticReporter) {\n            if (declaration.isExpect) return\n            super.check(declaration, context, reporter)\n        }\n    }\n\n    object ForExpectClass : FirFunInterfaceDeclarationChecker(MppCheckerKind.Common) {\n        override fun check(declar"}
{"code": "ation: FirRegularClass, context: CheckerContext, reporter: DiagnosticReporter) {\n            if (!declaration.isExpect) return\n            super.check(declaration, context, reporter)\n        }\n    }\n\n    override fun check(declaration: FirRegularClass, context: CheckerContext, reporter: DiagnosticReporter) {\n        if (!declaration.isInterface || !declaration.isFun) return\n\n        val scope = declaration.unsubstitutedScope(context)\n        val classSymbol = declaration.symbol\n\n        var abstractFunctionSymbol: FirNamedFunctionSymbol? = null\n\n        for (name in scope.getCallableNames()) {\n            val functions = scope.getFunctions(name)\n            val properties = scope.getProperties(name)\n\n            for (function in functions) {\n                if (function.isAbstract) {\n                    if (abstractFunctionSymbol == null) {\n                        abstractFunctionSymbol = function\n                    } else {\n                        reporter.reportOn(declaration.source"}
{"code": ", FUN_INTERFACE_WRONG_COUNT_OF_ABSTRACT_MEMBERS, context)\n                    }\n                }\n            }\n\n            for (property in properties) {\n                val firProperty = property as? FirPropertySymbol ?: continue\n                if (firProperty.isAbstract) {\n                    val source =\n                        if (firProperty.getContainingClassSymbol(context.session) != classSymbol)\n                            declaration.source\n                        else\n                            firProperty.source\n\n                    reporter.reportOn(source, FUN_INTERFACE_CANNOT_HAVE_ABSTRACT_PROPERTIES, context)\n                }\n            }\n        }\n\n        if (abstractFunctionSymbol == null) {\n            reporter.reportOn(declaration.source, FUN_INTERFACE_WRONG_COUNT_OF_ABSTRACT_MEMBERS, context)\n            return\n        }\n\n        val inFunInterface = abstractFunctionSymbol.getContainingClassSymbol(context.session) === classSymbol\n\n        when {\n            a"}
{"code": "bstractFunctionSymbol.typeParameterSymbols.isNotEmpty() ->\n                reporter.reportOn(\n                    if (inFunInterface) abstractFunctionSymbol.source else declaration.source,\n                    FUN_INTERFACE_ABSTRACT_METHOD_WITH_TYPE_PARAMETERS,\n                    context\n                )\n\n            abstractFunctionSymbol.isSuspend ->\n                if (!context.session.languageVersionSettings.supportsFeature(LanguageFeature.SuspendFunctionsInFunInterfaces)) {\n                    reporter.reportOn(\n                        if (inFunInterface) abstractFunctionSymbol.source else declaration.source,\n                        FUN_INTERFACE_WITH_SUSPEND_FUNCTION,\n                        context\n                    )\n                }\n        }\n\n        abstractFunctionSymbol.valueParameterSymbols.forEach {\n            if (it.hasDefaultValue) {\n                reporter.reportOn(\n                    if (inFunInterface) it.source else declaration.source,\n                    FU"}
{"code": "N_INTERFACE_ABSTRACT_METHOD_WITH_DEFAULT_VALUE,\n                    context\n                )\n            }\n        }\n    }\n}\n\n"}
{"code": "// MODULE: context\n\n// FILE: context.kt\nfun test() {\n    <caret_context>call(\"foo\")\n}\n\nfun call(text: String) {}\n\n\n// MODULE: main\n// MODULE_KIND: CodeFragment\n// CONTEXT_MODULE: context\n\n// FILE: fragment.kt\n// CODE_FRAGMENT_KIND: EXPRESSION\n// CODE_FRAGMENT_FOREIGN_VALUE: foo_DebugLabel(Ljava/lang/String;)\n<caret>foo_DebugLabel"}
{"code": "val prop: Int\n    ge<caret>t() {\n        return 42\n    }"}
{"code": "package test\n\nopen class C\n\ntypealias CA = C\n\nclass D : <caret>CA()\n\n"}
{"code": "// PRE_RESOLVED_PHASE: STATUS\ninterface EmptyI<caret>nt<caret_preresolved>erface : InterfaceWithMembers {\n    val newProperty: String\n}\n\ninterface InterfaceWithMembers : AnotherSuperInterface {\n    val property: Int\n\n    fun functionWithDefaultImplementation(i: Int): Int = i\n\n    override fun baseFunction()\n\n    override fun baz() {\n        // default implementation\n    }\n}\n\ninterface AnotherSuperInterface {\n    fun baz()\n\n    fun baseFunction()\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\", \"unused\")\n\npackage org.jetbrains.kotlin.fir.declarations.builder\n\nimport kotlin.contracts.*\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirModuleData\nimport org.jetbrains.kotlin.fir.builder.FirAnnotationContainerBuilder\nimport org.jetbrains.kotlin.fir.builder.FirBuilderDsl\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.contracts.FirContractDescription\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.declarations.impl.FirConstructorImpl\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirBlock\nimport org.jetbrains.kotlin.fir.expressions.FirDelegatedConstructorCall\nimport org.jetbrains.kotlin.fir.references.FirControlFlowGraphReference\nimport org.jetbrains.kotlin.fir.symbols.impl."}
{"code": "FirConstructorSymbol\nimport org.jetbrains.kotlin.fir.types.ConeSimpleKotlinType\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedContainerSource\n\n@FirBuilderDsl\nopen class FirConstructorBuilder : FirAbstractConstructorBuilder, FirAnnotationContainerBuilder {\n    override var source: KtSourceElement? = null\n    override var resolvePhase: FirResolvePhase = FirResolvePhase.RAW_FIR\n    override lateinit var moduleData: FirModuleData\n    override lateinit var origin: FirDeclarationOrigin\n    override var attributes: FirDeclarationAttributes = FirDeclarationAttributes()\n    override val typeParameters: MutableList<FirTypeParameterRef> = mutableListOf()\n    override lateinit var status: FirDeclarationStatus\n    override lateinit var returnTypeRef: FirTypeRef\n    override var receiverParameter: FirReceiverParameter? = null\n    override var deprecationsProvider: DeprecationsProvider = UnresolvedDeprecationProvider"}
{"code": "\n    override var containerSource: DeserializedContainerSource? = null\n    override var dispatchReceiverType: ConeSimpleKotlinType? = null\n    override val contextReceivers: MutableList<FirContextReceiver> = mutableListOf()\n    override val valueParameters: MutableList<FirValueParameter> = mutableListOf()\n    override var contractDescription: FirContractDescription? = null\n    override val annotations: MutableList<FirAnnotation> = mutableListOf()\n    override lateinit var symbol: FirConstructorSymbol\n    override var delegatedConstructor: FirDelegatedConstructorCall? = null\n    override var body: FirBlock? = null\n\n    override fun build(): FirConstructor {\n        return FirConstructorImpl(\n            source,\n            resolvePhase,\n            moduleData,\n            origin,\n            attributes,\n            typeParameters,\n            status,\n            returnTypeRef,\n            receiverParameter,\n            deprecationsProvider,\n            containerSource,\n            dispa"}
{"code": "tchReceiverType,\n            contextReceivers.toMutableOrEmpty(),\n            valueParameters,\n            contractDescription,\n            annotations.toMutableOrEmpty(),\n            symbol,\n            delegatedConstructor,\n            body,\n        )\n    }\n\n\n    @Deprecated(\"Modification of 'controlFlowGraphReference' has no impact for FirConstructorBuilder\", level = DeprecationLevel.HIDDEN)\n    override var controlFlowGraphReference: FirControlFlowGraphReference?\n        get() = throw IllegalStateException()\n        set(_) {\n            throw IllegalStateException()\n        }\n}\n\n@OptIn(ExperimentalContracts::class)\ninline fun buildConstructor(init: FirConstructorBuilder.() -> Unit): FirConstructor {\n    contract {\n        callsInPlace(init, InvocationKind.EXACTLY_ONCE)\n    }\n    return FirConstructorBuilder().apply(init).build()\n}\n\n@OptIn(ExperimentalContracts::class)\ninline fun buildConstructorCopy(original: FirConstructor, init: FirConstructorBuilder.() -> Unit): FirConstructor {"}
{"code": "\n    contract {\n        callsInPlace(init, InvocationKind.EXACTLY_ONCE)\n    }\n    val copyBuilder = FirConstructorBuilder()\n    copyBuilder.source = original.source\n    copyBuilder.resolvePhase = original.resolvePhase\n    copyBuilder.moduleData = original.moduleData\n    copyBuilder.origin = original.origin\n    copyBuilder.attributes = original.attributes.copy()\n    copyBuilder.typeParameters.addAll(original.typeParameters)\n    copyBuilder.status = original.status\n    copyBuilder.returnTypeRef = original.returnTypeRef\n    copyBuilder.receiverParameter = original.receiverParameter\n    copyBuilder.deprecationsProvider = original.deprecationsProvider\n    copyBuilder.containerSource = original.containerSource\n    copyBuilder.dispatchReceiverType = original.dispatchReceiverType\n    copyBuilder.contextReceivers.addAll(original.contextReceivers)\n    copyBuilder.valueParameters.addAll(original.valueParameters)\n    copyBuilder.contractDescription = original.contractDescription\n    copyBuilder.an"}
{"code": "notations.addAll(original.annotations)\n    copyBuilder.symbol = original.symbol\n    copyBuilder.delegatedConstructor = original.delegatedConstructor\n    copyBuilder.body = original.body\n    return copyBuilder.apply(init).build()\n}\n"}
{"code": "package t\n\nclass A {\n    companion object B {\n\n    }\n}\n\nval A.B.bar : Int get() = 1\n\nfun test() {\n    <caret>A.bar\n}\n\n\n\n"}
{"code": "fun test() {\n    class Local {\n        fun foo(): String {\n            <expr>return \"foo\"</expr>\n        }\n    }\n\n    Local().foo()\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.buildtools.api\n\n@RequiresOptIn(\"This part of the Build Tools API is experimental and might change in the future releases\")\npublic annotation class ExperimentalBuildToolsApi\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.scopes\n\nimport org.jetbrains.kotlin.fir.declarations.FirMemberDeclaration\nimport org.jetbrains.kotlin.fir.declarations.utils.isInner\nimport org.jetbrains.kotlin.fir.declarations.utils.isStatic\nimport org.jetbrains.kotlin.fir.resolve.substitution.ConeSubstitutor\nimport org.jetbrains.kotlin.fir.scopes.FirContainingNamesAwareScope\nimport org.jetbrains.kotlin.fir.scopes.FirScope\nimport org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassifierSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol\nimport org.jetbrains.kotlin.name.Name\n\n\ninternal class FirNonStaticMembersScope(\n    private val delegate: FirContainingNamesAwareScope,\n) : FirCallableFilteringScope(delegate) {\n    override fun isTargetCallable(callable: FirCallableSymbol<*>): Boolean = !callable.fir.isStatic\n\n    override fun processDeclaredConstructors(processor: (FirConstructorSymbol) -> Unit) {\n        de"}
{"code": "legate.processDeclaredConstructors(processor)\n    }\n\n    override fun getClassifierNames(): Set<Name> = delegate.getClassifierNames()\n\n    override fun processClassifiersByNameWithSubstitution(name: Name, processor: (FirClassifierSymbol<*>, ConeSubstitutor) -> Unit) {\n        delegate.processInnerClassesByName(name, processor)\n    }\n}\n\ninternal fun FirScope.processInnerClassesByName(name: Name, processor: (FirClassifierSymbol<*>, ConeSubstitutor) -> Unit) {\n    processClassifiersByNameWithSubstitution(name) { classifier, substitutor ->\n        val firDeclaration = classifier.fir\n        if (firDeclaration is FirMemberDeclaration && firDeclaration.isInner) {\n            processor(classifier, substitutor)\n        }\n    }\n}\n"}
{"code": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE_K1\npackage test\n\nclass SomeClass\n\nopen class TopLevel<Outer> {\n    open inner class Base<T> {\n        fun noGeneric() {}\n        fun withOuter(): Outer? = null\n        fun withOwnAndOuter(t: T): Outer? = null\n    }\n\n    inner class <caret>Child : Base<SomeClass>()\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.isCatchParameter\nimport org.jetbrains.kotlin.util.capitalizeDecapitalize.toLowerCaseAsciiOnly\n\nopen class FirDeclarationRenderer(\n    private val localVariablePrefix: String = \"l\",\n) {\n\n    internal lateinit var components: FirRendererComponents\n    protected val printer get() = components.printer\n    private val resolvePhaseRenderer get() = components.resolvePhaseRenderer\n    private val typeRenderer get() = components.typeRenderer\n\n    fun render(declaration: FirDeclaration) {\n        renderPhaseAndAttributes(declaration)\n        if (declaration is FirConstructor) {\n            declaration.dispatchReceiverType?.let {\n                typeRenderer.render(it)\n                printer.print(\".\")\n            }\n            if (declaration is FirErrorPrimaryConstructor) {\n                printer.print(\"error_\")\n            }\n            printer.print(\"constructor\")\n    "}
{"code": "        return\n        }\n        printer.print(\n            when (declaration) {\n                is FirRegularClass -> declaration.classKind.name.toLowerCaseAsciiOnly().replace(\"_\", \" \")\n                is FirTypeAlias -> \"typealias\"\n                is FirAnonymousFunction -> (declaration.label?.let { \"${it.name}@\" } ?: \"\") + \"fun\"\n                is FirSimpleFunction -> \"fun\"\n                is FirProperty -> {\n                    if (declaration.isCatchParameter == true) {\n                        \"\"\n                    } else {\n                        val prefix = if (declaration.isLocal) localVariablePrefix else \"\"\n                        prefix + if (declaration.isVal) \"val\" else \"var\"\n                    }\n                }\n                is FirPropertyAccessor -> if (declaration.isGetter) \"get\" else \"set\"\n                is FirField -> \"field\"\n                is FirEnumEntry -> \"enum entry\"\n                else -> \"unknown\"\n            }\n        )\n    }\n\n    internal fun renderP"}
{"code": "haseAndAttributes(declaration: FirDeclaration) {\n        resolvePhaseRenderer?.render(declaration)\n        with(declaration) {\n            renderDeclarationAttributes()\n        }\n    }\n\n    protected open fun FirDeclaration.renderDeclarationAttributes() {\n    }\n}\n"}
{"code": "class Test {\n    init <expr>{\n        \"value\"\n    }</expr>\n}"}
{"code": "open class B(x: () -> Unit)\n\nclass A : B(1, {\n    foo()\n})\n\nfun foo() {}\n"}
{"code": "interface Foo {\n    operator fun <T> invoke(t: T)\n}\n\nfun test(f: Foo) {\n    <expr>f(\"\")</expr>\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.lazy.descriptors\n\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor\nimport org.jetbrains.kotlin.descriptors.annotations.Annotations\nimport org.jetbrains.kotlin.descriptors.annotations.FilteredByPredicateAnnotations\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtAnnotationEntry\nimport org.jetbrains.kotlin.resolve.AnnotationResolver\nimport org.jetbrains.kotlin.resolve.AnnotationResolverImpl\nimport org.jetbrains.kotlin.resolve.BindingContext\nimport org.jetbrains.kotlin.resolve.BindingTrace\nimport org.jetbrains.kotlin.resolve.lazy.ForceResolveUtil\nimport org.jetbrains.kotlin.resolve.lazy.LazyEntity\nimport org.jetbrains.kotlin.resolve.scopes.LexicalScope\nimport org.jetbrains.kotlin.resolve.source.toSourceElement\nimport org.jetbrains.kotlin.storage.StorageManager\nimport org.jetbrains.kotlin.storage.getValue\nimport org."}
{"code": "jetbrains.kotlin.types.AbbreviatedType\nimport org.jetbrains.kotlin.types.error.ErrorTypeKind\nimport org.jetbrains.kotlin.types.error.ErrorUtils\nimport org.jetbrains.kotlin.types.typeUtil.replaceAnnotations\n\nabstract class LazyAnnotationsContext(\n    val annotationResolver: AnnotationResolver,\n    val storageManager: StorageManager,\n    val trace: BindingTrace\n) {\n    abstract val scope: LexicalScope\n}\n\nclass LazyAnnotationsContextImpl(\n    annotationResolver: AnnotationResolver,\n    storageManager: StorageManager,\n    trace: BindingTrace,\n    override val scope: LexicalScope\n) : LazyAnnotationsContext(annotationResolver, storageManager, trace)\n\nclass LazyAnnotations(\n    val c: LazyAnnotationsContext,\n    val annotationEntries: List<KtAnnotationEntry>\n) : Annotations, LazyEntity {\n    override fun isEmpty() = annotationEntries.isEmpty()\n\n    private val annotation = c.storageManager.createMemoizedFunction { entry: KtAnnotationEntry ->\n        c.trace.get(BindingContext.ANNOTATION, entr"}
{"code": "y) ?: LazyAnnotationDescriptor(c, entry)\n    }\n\n    override fun iterator(): Iterator<AnnotationDescriptor> = annotationEntries.asSequence().map(annotation).iterator()\n\n    override fun forceResolveAllContents() {\n        // To resolve all entries\n        for (annotation in this) {\n            // TODO: probably we should do ForceResolveUtil.forceResolveAllContents(annotation) here\n        }\n    }\n}\n\nclass LazyAnnotationDescriptor(\n    val c: LazyAnnotationsContext,\n    val annotationEntry: KtAnnotationEntry\n) : AnnotationDescriptor, LazyEntity, ValidateableDescriptor {\n\n    override val type by c.storageManager.createLazyValue(\n        computable = lazy@{\n            val annotationType = c.annotationResolver.resolveAnnotationType(scope, annotationEntry, c.trace)\n            if (annotationType is AbbreviatedType) {\n                // This is needed to prevent recursion in cases like this: typealias S = @S Ann\n                if (annotationType.annotations.any { it == this }) {\n         "}
{"code": "           annotationType.abbreviation.constructor.declarationDescriptor?.let { typeAliasDescriptor ->\n                        c.trace.report(Errors.RECURSIVE_TYPEALIAS_EXPANSION.on(annotationEntry, typeAliasDescriptor))\n                    }\n                    return@lazy annotationType.replaceAnnotations(FilteredByPredicateAnnotations(annotationType.annotations) { it != this })\n                }\n            }\n            annotationType\n        },\n        onRecursiveCall = {\n            ErrorUtils.createErrorType(ErrorTypeKind.RECURSIVE_ANNOTATION_TYPE)\n        }\n    )\n\n    override val source = annotationEntry.toSourceElement()\n\n    private val scope = (c.scope.ownerDescriptor as? PackageFragmentDescriptor)?.let {\n        LexicalScope.Base(c.scope, FileDescriptorForVisibilityChecks(source, it))\n    } ?: c.scope\n\n    private val valueArgumentsWithSourceInfo by c.storageManager.createLazyValue {\n        val resolutionResults = c.annotationResolver.resolveAnnotationCall(annotationEntry"}
{"code": ", scope, c.trace)\n        AnnotationResolverImpl.checkAnnotationType(annotationEntry, c.trace, resolutionResults)\n\n        if (!resolutionResults.isSingleResult) return@createLazyValue emptyMap()\n\n        resolutionResults.resultingCall.valueArguments.mapNotNull { (valueParameter, resolvedArgument) ->\n            if (resolvedArgument == null) null\n            else c.annotationResolver.getAnnotationArgumentValue(c.trace, valueParameter, resolvedArgument)?.let { value ->\n                valueParameter.name to (value to resolvedArgument.arguments.firstOrNull()?.getArgumentExpression().toSourceElement())\n            }\n        }.toMap()\n    }\n\n    override val allValueArguments by c.storageManager.createLazyValue {\n        valueArgumentsWithSourceInfo.mapValues { it.value.first }\n    }\n\n    init {\n        c.trace.record(BindingContext.ANNOTATION, annotationEntry, this)\n    }\n\n    fun getSourceForArgument(name: Name): SourceElement =\n        valueArgumentsWithSourceInfo[name]?.second ?: Sour"}
{"code": "ceElement.NO_SOURCE\n\n\n    override fun validate() {\n        checkNotNull(scope) { \"scope == null for $this\" }\n    }\n\n    override fun forceResolveAllContents() {\n        ForceResolveUtil.forceResolveAllContents(type)\n        allValueArguments\n    }\n\n    private class FileDescriptorForVisibilityChecks(\n        private val source: SourceElement,\n        private val containingDeclaration: PackageFragmentDescriptor\n    ) : DeclarationDescriptorWithSource, PackageFragmentDescriptor by containingDeclaration {\n        override val annotations: Annotations get() = Annotations.EMPTY\n        override fun getSource() = source\n        override fun getOriginal() = this\n        override fun getName() = Name.special(\"< file descriptor for annotation resolution >\")\n\n        private fun error(): Nothing = error(\"This method should not be called\")\n        override fun <R : Any?, D : Any?> accept(visitor: DeclarationDescriptorVisitor<R, D>?, data: D): R = error()\n        override fun acceptVoid(visitor: "}
{"code": "DeclarationDescriptorVisitor<Void, Void>?) = error()\n\n        override fun toString(): String = \"${name.asString()} declared in LazyAnnotations.kt\"\n    }\n}\n\nfun AnnotationDescriptor.getSourceForArgument(name: Name): SourceElement =\n    (this as? LazyAnnotationDescriptor)?.getSourceForArgument(name) ?: SourceElement.NO_SOURCE\n"}
{"code": "\n\npackage org.jetbrains.kotlin.load.kotlin.incremental\n\nimport org.jetbrains.kotlin.descriptors.ModuleDescriptor\nimport org.jetbrains.kotlin.descriptors.PackageFragmentDescriptor\nimport org.jetbrains.kotlin.descriptors.PackageFragmentProviderOptimized\nimport org.jetbrains.kotlin.descriptors.impl.PackageFragmentDescriptorImpl\nimport org.jetbrains.kotlin.load.kotlin.JvmPackagePartSource\nimport org.jetbrains.kotlin.load.kotlin.KotlinClassFinder\nimport org.jetbrains.kotlin.load.kotlin.PackagePartClassUtils\nimport org.jetbrains.kotlin.load.kotlin.findKotlinClass\nimport org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache\nimport org.jetbrains.kotlin.metadata.jvm.deserialization.JvmMetadataVersion\nimport org.jetbrains.kotlin.metadata.jvm.deserialization.JvmProtoBufUtil\nimport org.jetbrains.kotlin.modules.TargetId\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtFile\nimpo"}
{"code": "rt org.jetbrains.kotlin.resolve.jvm.JvmClassName\nimport org.jetbrains.kotlin.resolve.scopes.ChainedMemberScope\nimport org.jetbrains.kotlin.resolve.scopes.MemberScope\nimport org.jetbrains.kotlin.serialization.deserialization.DeserializationComponents\nimport org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedPackageMemberScope\nimport org.jetbrains.kotlin.storage.StorageManager\nimport org.jetbrains.kotlin.utils.addIfNotNull\nimport org.jetbrains.kotlin.utils.jvmMetadataVersionOrDefault\nimport org.jetbrains.kotlin.utils.keysToMap\n\nclass IncrementalPackageFragmentProvider(\n    sourceFiles: Collection<KtFile>,\n    val moduleDescriptor: ModuleDescriptor,\n    val storageManager: StorageManager,\n    val deserializationComponents: DeserializationComponents,\n    val incrementalCache: IncrementalCache,\n    val target: TargetId,\n    private val kotlinClassFinder: KotlinClassFinder\n) : PackageFragmentProviderOptimized {\n    private val fqNameToPackageFragment =\n        Package"}
{"code": "PartClassUtils.getFilesWithCallables(sourceFiles)\n            .mapTo(hashSetOf()) { it.packageFqName }\n            .keysToMap(this::IncrementalPackageFragment)\n\n    override fun getSubPackagesOf(fqName: FqName, nameFilter: (Name) -> Boolean): Collection<FqName> = emptySet()\n\n    override fun collectPackageFragments(fqName: FqName, packageFragments: MutableCollection<PackageFragmentDescriptor>) =\n        packageFragments.addIfNotNull(fqNameToPackageFragment[fqName])\n\n    override fun isEmpty(fqName: FqName): Boolean = !fqNameToPackageFragment.containsKey(fqName)\n\n    @Deprecated(\"for usages use #packageFragments(FqName) at final point, for impl use #collectPackageFragments(FqName, MutableCollection<PackageFragmentDescriptor>)\")\n    override fun getPackageFragments(fqName: FqName): List<PackageFragmentDescriptor> {\n        return listOfNotNull(fqNameToPackageFragment[fqName])\n    }\n\n    inner class IncrementalPackageFragment(fqName: FqName) : PackageFragmentDescriptorImpl(moduleDescripto"}
{"code": "r, fqName) {\n        val target: TargetId\n            get() = this@IncrementalPackageFragmentProvider.target\n\n        fun getPackageFragmentForMultifileClass(multifileClassFqName: FqName): IncrementalMultifileClassPackageFragment? {\n            val facadeName = JvmClassName.byFqNameWithoutInnerClasses(multifileClassFqName)\n            val partsNames = incrementalCache.getStableMultifileFacadeParts(facadeName.internalName) ?: return null\n            return IncrementalMultifileClassPackageFragment(facadeName, partsNames, multifileClassFqName.parent())\n        }\n\n        override fun getMemberScope(): MemberScope = MemberScope.Empty\n    }\n\n    inner class IncrementalMultifileClassPackageFragment(\n        val facadeName: JvmClassName,\n        val partsInternalNames: Collection<String>,\n        packageFqName: FqName\n    ) : PackageFragmentDescriptorImpl(moduleDescriptor, packageFqName) {\n        private val memberScope = storageManager.createLazyValue {\n            ChainedMemberScope.create"}
{"code": "(\n                \"Member scope for incremental compilation: union of multifile class parts data for $facadeName\",\n                partsInternalNames.mapNotNull { internalName ->\n                    incrementalCache.getPackagePartData(internalName)?.let { (data, strings) ->\n                        val (nameResolver, packageProto) = JvmProtoBufUtil.readPackageDataFrom(data, strings)\n\n                        val partName = JvmClassName.byInternalName(internalName)\n                        val jvmBinaryClass =\n                            kotlinClassFinder.findKotlinClass(\n                                ClassId.topLevel(partName.fqNameForTopLevelClassMaybeWithDollars),\n                                deserializationComponents.configuration.jvmMetadataVersionOrDefault()\n                            )\n\n                        val metadataVersion =\n                            jvmBinaryClass?.classHeader?.metadataVersion\n                                ?: JvmMetadataVersion.INSTANCE\n\n          "}
{"code": "              DeserializedPackageMemberScope(\n                            this, packageProto, nameResolver, metadataVersion,\n                            JvmPackagePartSource(\n                                partName, facadeName, packageProto, nameResolver, knownJvmBinaryClass = jvmBinaryClass\n                            ),\n                            deserializationComponents,\n                            \"scope for IncrementalMultifileClassPackageFragment for facadeName=$facadeName, packageFqName=$packageFqName, part $partName\",\n                        ) { emptyList() }\n                    }\n                }\n            )\n        }\n\n        override fun getMemberScope() = memberScope()\n    }\n}\n"}
{"code": "interface Any\n\ninline fun <reified T : Any> Any.safeAs(): T? = this as? T\n\nabstract class Summator {\n    abstract fun <T> plus(first: T, second: T): T\n}"}
{"code": "fun test() {\n    <expr>consume(1)\n    val x = 2</expr>\n    consume(x)\n}\n\nfun consume(n: Int) {}"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.range.forLoop\n\nimport org.jetbrains.kotlin.codegen.ExpressionCodegen\nimport org.jetbrains.kotlin.codegen.OwnerKind\nimport org.jetbrains.kotlin.codegen.StackValue\nimport org.jetbrains.kotlin.incremental.components.NoLookupLocation\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtForExpression\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.org.objectweb.asm.Label\nimport org.jetbrains.org.objectweb.asm.Type\n\nabstract class AbstractForInProgressionOrRangeLoopGenerator(codegen: ExpressionCodegen, forExpression: KtForExpression) :\n    AbstractForLoopGenerator(codegen, forExpression) {\n    protected var endVar: Int = -1\n\n    private var loopParameter: StackValue? = null\n\n    protected val rangeKotlinType = bindingContext.getType(forExpression.loopRange!!)!!\n\n    init {\n        assert(\n            asmElementType.sort == Type.INT ||\n                    asmElementType.sort == Type.BYTE ||\n                    asmElem"}
{"code": "entType.sort == Type.SHORT ||\n                    asmElementType.sort == Type.CHAR ||\n                    asmElementType.sort == Type.LONG\n        ) {\n            \"Unexpected range element type: $asmElementType\"\n        }\n    }\n\n    override fun beforeLoop() {\n        super.beforeLoop()\n\n        endVar = createLoopTempVariable(asmElementType)\n    }\n\n    protected fun checkPostCondition(loopExit: Label) {\n        assert(endVar != -1) {\n            \"endVar must be allocated, endVar = $endVar\"\n        }\n        loopParameter().put(asmElementType, elementType, v)\n        v.load(endVar, asmElementType)\n        if (asmElementType.sort == Type.LONG) {\n            v.lcmp()\n            v.ifeq(loopExit)\n        } else {\n            v.ificmpeq(loopExit)\n        }\n    }\n\n    override fun checkPreCondition(loopExit: Label) {}\n\n    protected fun loopParameter(): StackValue =\n        loopParameter ?: StackValue.local(loopParameterVar, loopParameterType).also { loopParameter = it }\n\n    protected fun "}
{"code": "KotlinType.getPropertyGetterName(propertyName: String): String {\n        // In case of unsigned ranges, getter methods for corresponding range/progression properties would be mangled.\n        val propertyDescriptor = memberScope.getContributedVariables(Name.identifier(propertyName), NoLookupLocation.FROM_BACKEND)\n            .singleOrNull()\n            ?: throw AssertionError(\"No '$propertyName' in member scope of type $this\")\n        val getter = propertyDescriptor.getter\n            ?: throw AssertionError(\"Property has no getter: $propertyDescriptor\")\n        return codegen.typeMapper.mapFunctionName(getter, OwnerKind.IMPLEMENTATION)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.asJava.elements\n\nimport com.intellij.psi.*\nimport com.intellij.psi.impl.PsiVariableEx\nimport org.jetbrains.kotlin.asJava.builder.LightMemberOrigin\nimport org.jetbrains.kotlin.asJava.classes.KtLightClass\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtElement\nimport org.jetbrains.kotlin.psi.KtParameter\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOriginKind\n\ninterface KtLightElement<out T : KtElement, out D : PsiElement> : PsiElement {\n    val kotlinOrigin: T?\n\n    \n    val givenAnnotations: List<KtLightAbstractAnnotation>? get() = null\n}\n\ninterface KtLightDeclaration<out T : KtDeclaration, out D : PsiElement> : KtLightElement<T, D>, PsiNamedElement\n\ninterface KtLightMember<out D : PsiMember> : PsiMember, KtLightDeclaration<KtDeclaration, D>, PsiNameIdentifierOwner, PsiDocCommentOwner {\n    val lightMemberOrigin: LightMemberOrigin?\n\n    override fun getContainingClass(): KtLightClass\n}\n\ninterface KtLight"}
{"code": "Field : PsiField, KtLightMember<PsiField>, PsiVariableEx\n\ninterface KtLightParameter : PsiParameter, KtLightDeclaration<KtParameter, PsiParameter> {\n    val method: KtLightMethod\n}\n\ninterface KtLightFieldForSourceDeclarationSupport : PsiField {\n    val kotlinOrigin: KtDeclaration?\n}\n\ninterface KtLightMethod : PsiAnnotationMethod, KtLightMember<PsiMethod> {\n    val isDelegated: Boolean\n        get() = lightMemberOrigin?.originKind == JvmDeclarationOriginKind.DELEGATION\n                || lightMemberOrigin?.originKind == JvmDeclarationOriginKind.CLASS_MEMBER_DELEGATION_TO_DEFAULT_IMPL\n\n    val isMangled: Boolean\n}\n"}
{"code": "val x = <expr>+1</expr>\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.scopes.impl\n\nimport org.jetbrains.kotlin.config.AnalysisFlags\nimport org.jetbrains.kotlin.config.LanguageVersionSettingsImpl\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.builder.buildImport\nimport org.jetbrains.kotlin.fir.declarations.builder.buildResolvedImport\nimport org.jetbrains.kotlin.fir.languageVersionSettings\nimport org.jetbrains.kotlin.fir.resolve.ScopeSession\nimport org.jetbrains.kotlin.fir.scopes.defaultImportProvider\nimport org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirVariableSymbol\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\n\ninterface DefaultStarImportingScopeMarker\n\nclass FirSingleLevelDefaultStarImportingScope(\n    session: FirSession,\n    scopeSession: ScopeSession,\n    priority: DefaultImportPriority,\n    excludedImportNames: Set<FqName>\n) : FirAbstractStarImportingScope(\n    session, scopeSessi"}
{"code": "on,\n    lookupInFir = session.languageVersionSettings.getFlag(AnalysisFlags.allowKotlinPackage),\n    excludedImportNames + session.defaultImportProvider.excludedImports\n), DefaultStarImportingScopeMarker {\n    // TODO: put languageVersionSettings into FirSession?\n    override val starImports = run {\n        val defaultImportProvider = session.defaultImportProvider\n        val allDefaultImports = priority.getAllDefaultImports(defaultImportProvider, LanguageVersionSettingsImpl.DEFAULT)\n        allDefaultImports\n            ?.filter { it.isAllUnder }\n            ?.map {\n                buildResolvedImport {\n                    delegate = buildImport {\n                        importedFqName = it.fqName\n                        isAllUnder = true\n                    }\n                    packageFqName = it.fqName\n                }\n            } ?: emptyList()\n    }\n\n    override fun processFunctionsByName(name: Name, processor: (FirNamedFunctionSymbol) -> Unit) {\n        if (name.isSpecial ||"}
{"code": " name.identifier.isNotEmpty()) {\n            for (import in starImports) {\n                if (isExcluded(import, name)) {\n                    continue\n                }\n\n                for (symbol in provider.getTopLevelFunctionSymbols(import.packageFqName, name)) {\n                    processor(symbol)\n                }\n            }\n        }\n    }\n\n    override fun processPropertiesByName(name: Name, processor: (FirVariableSymbol<*>) -> Unit) {\n        if (name.isSpecial || name.identifier.isNotEmpty()) {\n            for (import in starImports) {\n                if (isExcluded(import, name)) {\n                    continue\n                }\n\n                for (symbol in provider.getTopLevelPropertySymbols(import.packageFqName, name)) {\n                    processor(symbol)\n                }\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.stubBased.deserialization\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.search.GlobalSearchScope\nimport org.jetbrains.kotlin.analysis.decompiler.psi.BuiltInsVirtualFileProvider\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.project.structure.LLFirLibrarySymbolProviderFactory\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.project.structure.LLFirModuleData\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.providers.LLFirJavaSymbolProvider\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.util.LLFirKotlinSymbolNamesProvider\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.FirDeclarationOrigin\nimport org.jetbrains.kotlin.fir.deserialization.SingleModuleDataProvider\nimport org.jetbrains.kotlin.fir.java.FirJavaFacade\nimport org.jetbrains.kotlin.fir.resolve.providers.FirCompositeCachedSymbolNamesProvider\nimport org.jetbrains.kotlin.fir.resolve.provi"}
{"code": "ders.FirSymbolNamesProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.impl.FirBuiltinSyntheticFunctionInterfaceProvider\nimport org.jetbrains.kotlin.fir.scopes.FirKotlinScopeProvider\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol\nimport org.jetbrains.kotlin.load.kotlin.PackagePartProvider\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.psi.KtFile\n\ninternal class LLStubBasedLibrarySymbolProviderFactory(private val project: Project) : LLFirLibrarySymbolProviderFactory() {\n    override fun createJvmLibrarySymbolProvider(\n        session: FirSession,\n        moduleData: LLFirModuleData,\n        kotlinScopeProvider: FirKotlinScopeProvider,\n        moduleDataProvider: SingleModuleDataProvider,\n        firJavaFacade: FirJavaFacade,\n        packagePartProvider: PackagePartProvider,\n        scope: GlobalSearchScope,\n        isFallbackDependenciesProvider: Boolean,\n    ): List<FirSymb"}
{"code": "olProvider> {\n        return buildList {\n            //stub based provider here works over kotlin-only indices and thus provides only kotlin declarations\n            //in order to find java declarations, one need to explicitly setup java symbol provider.\n            //for ProtoBuf based provider (used in compiler), there is no need in separated java provider,\n            //because all declarations are retrieved at once and are not distinguished\n            add(\n                createStubBasedFirSymbolProviderForClassFiles(\n                    project,\n                    scope,\n                    session,\n                    moduleDataProvider,\n                    kotlinScopeProvider,\n                    isFallbackDependenciesProvider,\n                )\n            )\n            add(LLFirJavaSymbolProvider(session, moduleData, project, scope))\n        }\n    }\n\n    override fun createCommonLibrarySymbolProvider(\n        session: FirSession,\n        moduleData: LLFirModuleData,\n        "}
{"code": "kotlinScopeProvider: FirKotlinScopeProvider,\n        moduleDataProvider: SingleModuleDataProvider,\n        packagePartProvider: PackagePartProvider,\n        scope: GlobalSearchScope,\n        isFallbackDependenciesProvider: Boolean,\n    ): List<FirSymbolProvider> = listOf(\n        createStubBasedFirSymbolProviderForCommonMetadataFiles(\n            project = project,\n            baseScope = scope,\n            session = session,\n            moduleDataProvider = moduleDataProvider,\n            kotlinScopeProvider = kotlinScopeProvider,\n            isFallbackDependenciesProvider = isFallbackDependenciesProvider,\n        )\n    )\n\n    override fun createNativeLibrarySymbolProvider(\n        session: FirSession,\n        moduleData: LLFirModuleData,\n        kotlinScopeProvider: FirKotlinScopeProvider,\n        moduleDataProvider: SingleModuleDataProvider,\n        scope: GlobalSearchScope,\n        isFallbackDependenciesProvider: Boolean,\n    ): List<FirSymbolProvider> {\n        return listOf(\n    "}
{"code": "        createStubBasedFirSymbolProviderForKotlinNativeMetadataFiles(\n                project,\n                scope,\n                session,\n                moduleDataProvider,\n                kotlinScopeProvider,\n                isFallbackDependenciesProvider,\n            )\n        )\n    }\n\n    override fun createJsLibrarySymbolProvider(\n        session: FirSession,\n        moduleData: LLFirModuleData,\n        kotlinScopeProvider: FirKotlinScopeProvider,\n        moduleDataProvider: SingleModuleDataProvider,\n        scope: GlobalSearchScope,\n        isFallbackDependenciesProvider: Boolean,\n    ): List<FirSymbolProvider> {\n        return listOf(\n            createStubBasedFirSymbolProviderForKotlinNativeMetadataFiles(\n                project,\n                scope,\n                session,\n                moduleDataProvider,\n                kotlinScopeProvider,\n                isFallbackDependenciesProvider,\n            ),\n        )\n    }\n\n    override fun createBuiltinsSymbolProvider"}
{"code": "(\n        session: FirSession,\n        moduleData: LLFirModuleData,\n        kotlinScopeProvider: FirKotlinScopeProvider\n    ): List<FirSymbolProvider> {\n        return listOf(\n            StubBasedBuiltInsSymbolProvider(project, session, moduleData, kotlinScopeProvider)\n        )\n    }\n}\n\nprivate class StubBasedBuiltInsSymbolProvider(\n    project: Project,\n    session: FirSession,\n    moduleData: LLFirModuleData,\n    kotlinScopeProvider: FirKotlinScopeProvider,\n) : StubBasedFirDeserializedSymbolProvider(\n    session,\n    SingleModuleDataProvider(moduleData),\n    kotlinScopeProvider,\n    project,\n    createBuiltInsScope(project),\n    isFallbackDependenciesProvider = false,\n) {\n    private val syntheticFunctionInterfaceProvider = FirBuiltinSyntheticFunctionInterfaceProvider(\n        session,\n        moduleData,\n        kotlinScopeProvider\n    )\n\n    override val symbolNamesProvider: FirSymbolNamesProvider = FirCompositeCachedSymbolNamesProvider(\n        session,\n        listOf(\n         "}
{"code": "   LLFirKotlinSymbolNamesProvider(declarationProvider, allowKotlinPackage),\n            syntheticFunctionInterfaceProvider.symbolNamesProvider,\n        ),\n    )\n\n    override fun getClassLikeSymbolByClassId(classId: ClassId): FirClassLikeSymbol<*>? {\n        return super.getClassLikeSymbolByClassId(classId)\n            ?: syntheticFunctionInterfaceProvider.getClassLikeSymbolByClassId(classId)\n    }\n\n    override fun getDeclarationOriginFor(file: KtFile): FirDeclarationOrigin {\n        // this provider operates only on builtins files, no need to check anything\n        return FirDeclarationOrigin.BuiltIns\n    }\n}\n\nprivate fun createBuiltInsScope(project: Project): GlobalSearchScope {\n    val builtInFiles = BuiltInsVirtualFileProvider.getInstance().getBuiltInVirtualFiles()\n    return GlobalSearchScope.filesScope(project, builtInFiles)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.types\n\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.render\nimport org.jetbrains.kotlin.fir.renderer.FirRenderer\nimport kotlin.reflect.KClass\n\nclass CustomAnnotationTypeAttribute(val annotations: List<FirAnnotation>) : ConeAttribute<CustomAnnotationTypeAttribute>() {\n    override fun union(other: CustomAnnotationTypeAttribute?): CustomAnnotationTypeAttribute? = null\n\n    override fun intersect(other: CustomAnnotationTypeAttribute?): CustomAnnotationTypeAttribute? = null\n\n    override fun add(other: CustomAnnotationTypeAttribute?): CustomAnnotationTypeAttribute {\n        if (other == null || other === this) return this\n        return CustomAnnotationTypeAttribute(annotations + other.annotations)\n    }\n\n    override fun isSubtypeOf(other: CustomAnnotationTypeAttribute?): Boolean = true\n\n    override fun toString(): String = annotations.joinToString(separator = \" \") { it.render() }\n\n    override fun renderForRe"}
{"code": "adability(): String =\n        annotations.joinToString(separator = \" \") { FirRenderer.forReadability().renderElementAsString(it, trim = true) }\n\n    override val key: KClass<out CustomAnnotationTypeAttribute>\n        get() = CustomAnnotationTypeAttribute::class\n    override val keepInInferredDeclarationType: Boolean\n        get() = true\n}\n\nval ConeAttributes.custom: CustomAnnotationTypeAttribute? by ConeAttributes.attributeAccessor<CustomAnnotationTypeAttribute>()\n\nval ConeAttributes.customAnnotations: List<FirAnnotation> get() = custom?.annotations.orEmpty()\n\nval ConeKotlinType.customAnnotations: List<FirAnnotation> get() = attributes.customAnnotations\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.modules\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.FirSessionComponent\nimport org.jetbrains.kotlin.resolve.jvm.modules.JavaModuleResolver\n\nclass FirJavaModuleResolverProvider(val javaModuleResolver: JavaModuleResolver) : FirSessionComponent\n\nval FirSession.javaModuleResolverProvider: FirJavaModuleResolverProvider by FirSession.sessionComponentAccessor()\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.descriptors.symbols.psiBased\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.descriptors.Fe10AnalysisContext\nimport org.jetbrains.kotlin.analysis.api.descriptors.Fe10AnalysisFacade\nimport org.jetbrains.kotlin.analysis.api.descriptors.symbols.base.KtFe10AnnotatedSymbol\nimport org.jetbrains.kotlin.analysis.api.descriptors.symbols.pointers.KtFe10NeverRestoringSymbolPointer\nimport org.jetbrains.kotlin.analysis.api.descriptors.symbols.psiBased.base.KtFe10PsiSymbol\nimport org.jetbrains.kotlin.analysis.api.descriptors.utils.cached\nimport org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion\nimport org.jetbrains.kotlin.analysis.api.symbols.KtScriptSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtSymbolOrigin\nimport org.jetbrains.kotlin.analysis.api.symbols.KtTypeParameterSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.pointers.KtPsiBase"}
{"code": "dSymbolPointer\nimport org.jetbrains.kotlin.analysis.api.symbols.pointers.KtSymbolPointer\nimport org.jetbrains.kotlin.descriptors.ScriptDescriptor\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtScript\nimport org.jetbrains.kotlin.resolve.BindingContext\n\ninternal class KtFe10PsiScriptSymbol(\n    private val script: KtScript,\n    override val analysisContext: Fe10AnalysisContext\n) : KtScriptSymbol(), KtFe10AnnotatedSymbol, KtFe10PsiSymbol<KtScript, ScriptDescriptor> {\n    override val descriptor: ScriptDescriptor? by cached {\n        val bindingContext = analysisContext.analyze(psi, Fe10AnalysisFacade.AnalysisMode.PARTIAL)\n        bindingContext[BindingContext.SCRIPT, psi]\n    }\n\n    override val origin: KtSymbolOrigin\n        get() = withValidityAssertion { if (script.containingKtFile.isCompiled) KtSymbolOrigin.LIBRARY else KtSymbolOrigin.SOURCE }\n\n    override val psi: KtScript\n        get() = withValidityAssertion { script }\n\n    override val name: Name\n        "}
{"code": "get() = withValidityAssertion { script.nameAsSafeName }\n\n    override val typeParameters: List<KtTypeParameterSymbol>\n        get() = withValidityAssertion { emptyList() }\n\n    context(KtAnalysisSession)\n    override fun createPointer(): KtSymbolPointer<KtScriptSymbol> = withValidityAssertion {\n        KtPsiBasedSymbolPointer.createForSymbolFromSource<KtScriptSymbol>(this) ?: KtFe10NeverRestoringSymbolPointer()\n    }\n}\n"}
{"code": "fun withLocals(p: Int): Int {\n    class Local(val pp: Int) {\n        fun diff() = pp - p\n    }\n\n    val x = Local(42).diff()\n\n    fun sum(y: Int, z: Int, f: (Int, Int) -> Int): Int {\n        return x + f(y, z)\n    }\n\n    val code = (object : Any() {\n        fun foo() = hashCode()\n    }).foo()\n\n    return sum(code, Local(1).diff(), fun(x: Int, y: Int) = x + y)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.calls\n\nimport org.jetbrains.kotlin.builtins.UnsignedTypes\nimport org.jetbrains.kotlin.builtins.functions.FunctionInvokeDescriptor\nimport org.jetbrains.kotlin.builtins.isExtensionFunctionType\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.TypeParameterDescriptor\nimport org.jetbrains.kotlin.diagnostics.Diagnostic\nimport org.jetbrains.kotlin.diagnostics.DiagnosticFactory2\nimport org.jetbrains.kotlin.diagnostics.Errors.*\nimport org.jetbrains.kotlin.diagnostics.Errors.BadNamedArgumentsTarget.*\nimport org.jetbrains.kotlin.diagnostics.reportDiagnosticOnce\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.name.SpecialNames\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.psi.psiUtil.isNull\nimport org.jetbrains.kotlin.psi.psiUtil.lastBlockStatementOrThis\nimport org.jetbrains.kotlin.psi.psiUtil.parents\nimport org.jetbrains.ko"}
{"code": "tlin.resolve.BindingContext\nimport org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext\nimport org.jetbrains.kotlin.resolve.calls.inference.BuilderInferenceExpectedTypeConstraintPosition\nimport org.jetbrains.kotlin.resolve.calls.inference.model.*\nimport org.jetbrains.kotlin.resolve.calls.model.*\nimport org.jetbrains.kotlin.resolve.calls.model.MultiLambdaBuilderInferenceRestriction\nimport org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory\nimport org.jetbrains.kotlin.resolve.calls.smartcasts.SingleSmartCast\nimport org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager\nimport org.jetbrains.kotlin.resolve.calls.tasks.TracingStrategy\nimport org.jetbrains.kotlin.resolve.calls.tower.*\nimport org.jetbrains.kotlin.resolve.calls.util.extractCallableReferenceExpression\nimport org.jetbrains.kotlin.resolve.calls.util.getCalleeExpressionIfAny\nimport org.jetbrains.kotlin.resolve.calls.util.getResolvedCall\nimport org.jetbrains.kotlin.resolve.calls.util.reportTr"}
{"code": "ailingLambdaErrorOr\nimport org.jetbrains.kotlin.resolve.constants.CompileTimeConstantChecker\nimport org.jetbrains.kotlin.resolve.constants.TypedCompileTimeConstant\nimport org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator\nimport org.jetbrains.kotlin.resolve.descriptorUtil.module\nimport org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver\nimport org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedCallableMemberDescriptor\nimport org.jetbrains.kotlin.types.AbstractTypeChecker\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.kotlin.types.StubTypeForBuilderInference\nimport org.jetbrains.kotlin.types.TypeUtils\nimport org.jetbrains.kotlin.types.checker.intersectWrappedTypes\nimport org.jetbrains.kotlin.types.error.ErrorUtils\nimport org.jetbrains.kotlin.types.expressions.ControlStructureTypingUtils\nimport org.jetbrains.kotlin.types.model.TypeSystemInferenceExtensionContextDelegate\nimport org.jetbrains.kotlin.types.mode"}
{"code": "l.TypeVariableMarker\nimport org.jetbrains.kotlin.types.model.freshTypeConstructor\nimport org.jetbrains.kotlin.types.typeUtil.contains\nimport org.jetbrains.kotlin.types.typeUtil.isNullableNothing\nimport org.jetbrains.kotlin.types.typeUtil.makeNullable\nimport org.jetbrains.kotlin.utils.addToStdlib.shouldNotBeCalled\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.contract\n\nclass DiagnosticReporterByTrackingStrategy(\n    val constantExpressionEvaluator: ConstantExpressionEvaluator,\n    val context: BasicCallResolutionContext,\n    val psiKotlinCall: PSIKotlinCall,\n    val dataFlowValueFactory: DataFlowValueFactory,\n    val allDiagnostics: List<KotlinCallDiagnostic>,\n    private val smartCastManager: SmartCastManager,\n    private val typeSystemContext: TypeSystemInferenceExtensionContextDelegate\n) : DiagnosticReporter {\n    private val trace = context.trace as TrackingBindingTrace\n    private val tracingStrategy: TracingStrategy get() = psiKotlinCall.tracingStrategy\n   "}
{"code": " private val call: Call get() = psiKotlinCall.psiCall\n\n    override fun onExplicitReceiver(diagnostic: KotlinCallDiagnostic) {\n\n    }\n\n    override fun onCall(diagnostic: KotlinCallDiagnostic) {\n        when (diagnostic) {\n            is VisibilityError -> tracingStrategy.invisibleMember(trace, diagnostic.invisibleMember)\n            is NoValueForParameter -> tracingStrategy.noValueForParameter(trace, diagnostic.parameterDescriptor)\n            is TypeCheckerHasRanIntoRecursion -> {\n                // Note: we have two similar diagnostics here\n                // - TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM (error starting from 1.7)\n                // - TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM_IN_AUGMENTED_ASSIGNMENT (error starting from 1.9)\n                // however they have different deprecation cycle, and thus it's better to distinguish them.\n                // This 'insideAugmentedAssignment' is just a heuristics (approximate) to do it.\n                // It cannot turn red cod"}
{"code": "e to green or green to red; the worst thing we can get here\n                // is replacing red code with yellow, if e.g. LV is set to 1.8 explicitly,\n                // and we have chosen the second diagnostics instead of the first one.\n                val insideAugmentedAssignment = call.callElement.parents.any {\n                    it is KtBinaryExpression && it.operationToken in KtTokens.AUGMENTED_ASSIGNMENTS\n                }\n                tracingStrategy.recursiveType(trace, context.languageVersionSettings, insideAugmentedAssignment)\n            }\n            is InstantiationOfAbstractClass -> tracingStrategy.instantiationOfAbstractClass(trace)\n            is AbstractSuperCall -> {\n                val superExpression = diagnostic.receiver.psiExpression as? KtSuperExpression\n                if (context.languageVersionSettings.supportsFeature(LanguageFeature.ForbidSuperDelegationToAbstractAnyMethod) ||\n                    superExpression == null ||\n                    trace[Bindi"}
{"code": "ngContext.SUPER_EXPRESSION_FROM_ANY_MIGRATION, superExpression] != true\n                ) {\n                    tracingStrategy.abstractSuperCall(trace)\n                } else {\n                    tracingStrategy.abstractSuperCallWarning(trace)\n                }\n            }\n            is AbstractFakeOverrideSuperCall -> {\n                if (context.languageVersionSettings.supportsFeature(LanguageFeature.ForbidSuperDelegationToAbstractFakeOverride)) {\n                    tracingStrategy.abstractSuperCall(trace)\n                } else {\n                    tracingStrategy.abstractSuperCallWarning(trace)\n                }\n            }\n            is NonApplicableCallForBuilderInferenceDiagnostic -> {\n                val reportOn = diagnostic.kotlinCall\n                trace.reportDiagnosticOnce(NON_APPLICABLE_CALL_FOR_BUILDER_INFERENCE.on(reportOn.psiKotlinCall.psiCall.callElement))\n            }\n            is CandidateChosenUsingOverloadResolutionByLambdaAnnotation -> {\n          "}
{"code": "      trace.report(CANDIDATE_CHOSEN_USING_OVERLOAD_RESOLUTION_BY_LAMBDA_ANNOTATION.on(psiKotlinCall.psiCall.callElement))\n            }\n            is EnumEntryAmbiguityWarning -> {\n                val propertyDescriptor = diagnostic.property\n                val enumEntryDescriptor = diagnostic.enumEntry\n                val enumCompanionDescriptor = (enumEntryDescriptor.containingDeclaration as? ClassDescriptor)?.companionObjectDescriptor\n                if (enumCompanionDescriptor == null || propertyDescriptor.containingDeclaration != enumCompanionDescriptor) {\n                    trace.report(\n                        DEPRECATED_RESOLVE_WITH_AMBIGUOUS_ENUM_ENTRY.on(\n                            psiKotlinCall.psiCall.callElement, propertyDescriptor, enumEntryDescriptor\n                        )\n                    )\n                }\n            }\n            is CompatibilityWarning -> {\n                val callElement = psiKotlinCall.psiCall.callElement\n                trace.report(\n  "}
{"code": "                  COMPATIBILITY_WARNING.on(callElement.getCalleeExpressionIfAny() ?: callElement, diagnostic.candidate)\n                )\n            }\n            is NoContextReceiver -> {\n                val callElement = psiKotlinCall.psiCall.callElement\n                trace.report(\n                    NO_CONTEXT_RECEIVER.on(\n                        callElement.getCalleeExpressionIfAny() ?: callElement,\n                        diagnostic.receiverDescriptor.value.toString()\n                    )\n                )\n            }\n            is MultipleArgumentsApplicableForContextReceiver -> {\n                val callElement = psiKotlinCall.psiCall.callElement\n                trace.report(\n                    MULTIPLE_ARGUMENTS_APPLICABLE_FOR_CONTEXT_RECEIVER.on(callElement, diagnostic.receiverDescriptor.value.toString())\n                )\n            }\n            is ContextReceiverAmbiguity -> {\n                val callElement = psiKotlinCall.psiCall.callElement\n                trac"}
{"code": "e.report(AMBIGUOUS_CALL_WITH_IMPLICIT_CONTEXT_RECEIVER.on(callElement))\n            }\n            is UnsupportedContextualDeclarationCall -> {\n                val callElement = psiKotlinCall.psiCall.callElement\n                trace.report(UNSUPPORTED_CONTEXTUAL_DECLARATION_CALL.on(callElement))\n            }\n\n            is AdaptedCallableReferenceIsUsedWithReflection, is NotCallableMemberReference, is CallableReferencesDefaultArgumentUsed -> {\n                // AdaptedCallableReferenceIsUsedWithReflection -> reported in onCallArgument\n                // NotCallableMemberReference -> UNSUPPORTED reported in DoubleColonExpressionResolver\n                // CallableReferencesDefaultArgumentUsed -> possible in 1.3 and earlier versions only\n                return\n            }\n\n            else -> {\n                unknownError(diagnostic, \"onCall\")\n            }\n        }\n    }\n\n    override fun onTypeArguments(diagnostic: KotlinCallDiagnostic) {\n        val psiCallElement = psiKotlinCa"}
{"code": "ll.psiCall.callElement\n        val reportElement =\n            if (psiCallElement is KtCallExpression)\n                psiCallElement.typeArgumentList ?: psiCallElement.calleeExpression ?: psiCallElement\n            else\n                psiCallElement\n\n        when (diagnostic) {\n            is WrongCountOfTypeArguments -> {\n                val expectedTypeArgumentsCount = diagnostic.descriptor.typeParameters.size\n                trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(reportElement, expectedTypeArgumentsCount, diagnostic.descriptor))\n            }\n            else -> {\n                unknownError(diagnostic, \"onTypeArguments\")\n            }\n        }\n    }\n\n    private fun unknownError(diagnostic: KotlinCallDiagnostic, onTarget: String) {\n        if (AbstractTypeChecker.RUN_SLOW_ASSERTIONS) {\n            throw AssertionError(\"$onTarget should not be called with ${diagnostic::class.java}\")\n        } else if (reportAdditionalErrors) {\n            trace.report(\n                NE"}
{"code": "W_INFERENCE_UNKNOWN_ERROR.on(\n                    psiKotlinCall.psiCall.callElement,\n                    diagnostic.candidateApplicability,\n                    onTarget\n                )\n            )\n        }\n    }\n\n    override fun onCallName(diagnostic: KotlinCallDiagnostic) {\n\n    }\n\n    override fun onTypeArgument(typeArgument: TypeArgument, diagnostic: KotlinCallDiagnostic) {\n\n    }\n\n    override fun onCallReceiver(callReceiver: SimpleKotlinCallArgument, diagnostic: KotlinCallDiagnostic) {\n        when (diagnostic) {\n            is UnsafeCallError -> {\n                val isForImplicitInvoke = when (callReceiver) {\n                    is ReceiverExpressionKotlinCallArgument -> callReceiver.isForImplicitInvoke\n                    else -> diagnostic.isForImplicitInvoke\n                            || callReceiver.receiver.receiverValue.type.isExtensionFunctionType\n                }\n\n                tracingStrategy.unsafeCall(trace, callReceiver.receiver.receiverValue.type, isForImp"}
{"code": "licitInvoke)\n            }\n\n            is SuperAsExtensionReceiver -> {\n                val psiExpression = callReceiver.psiExpression\n                if (psiExpression is KtSuperExpression) {\n                    trace.report(SUPER_CANT_BE_EXTENSION_RECEIVER.on(psiExpression, psiExpression.text))\n                }\n            }\n\n            is StubBuilderInferenceReceiver -> {\n                val stubType = callReceiver.receiver.receiverValue.type as? StubTypeForBuilderInference\n                val originalTypeParameter = stubType?.originalTypeVariable?.originalTypeParameter\n\n                trace.report(\n                    BUILDER_INFERENCE_STUB_RECEIVER.on(\n                        callReceiver.psiExpression ?: call.callElement,\n                        originalTypeParameter?.name ?: SpecialNames.NO_NAME_PROVIDED,\n                        originalTypeParameter?.containingDeclaration?.name ?: SpecialNames.NO_NAME_PROVIDED\n                    )\n                )\n            }\n          "}
{"code": "  else -> {\n                unknownError(diagnostic, \"onCallReceiver\")\n            }\n        }\n    }\n\n    override fun onCallArgument(callArgument: KotlinCallArgument, diagnostic: KotlinCallDiagnostic) {\n        when (diagnostic) {\n            is SmartCastDiagnostic -> reportSmartCast(diagnostic)\n            is UnstableSmartCast -> reportUnstableSmartCast(diagnostic)\n            is VisibilityErrorOnArgument -> {\n                val invisibleMember = diagnostic.invisibleMember\n                val argumentExpression =\n                    diagnostic.argument.psiCallArgument.valueArgument.getArgumentExpression()?.lastBlockStatementOrThis()\n\n                if (argumentExpression != null) {\n                    trace.report(INVISIBLE_MEMBER.on(argumentExpression, invisibleMember, invisibleMember.visibility, invisibleMember))\n                }\n            }\n            is TooManyArguments -> {\n                trace.reportTrailingLambdaErrorOr(callArgument.psiExpression) { expr ->\n            "}
{"code": "        TOO_MANY_ARGUMENTS.on(expr, diagnostic.descriptor)\n                }\n\n                trace.markAsReported()\n            }\n            is VarargArgumentOutsideParentheses -> trace.reportTrailingLambdaErrorOr(callArgument.psiExpression) { expr ->\n                VARARG_OUTSIDE_PARENTHESES.on(expr)\n            }\n\n            is MixingNamedAndPositionArguments -> {\n                trace.report(MIXING_NAMED_AND_POSITIONED_ARGUMENTS.on(callArgument.psiCallArgument.valueArgument.asElement()))\n            }\n\n            is NoneCallableReferenceCallCandidates -> {\n                val argument = diagnostic.argument\n                val expression = (argument as? CallableReferenceKotlinCallArgumentImpl)?.ktCallableReferenceExpression\n                if (expression != null) {\n                    trace.report(UNRESOLVED_REFERENCE.on(expression.callableReference, expression.callableReference))\n                }\n            }\n\n            is CallableReferenceCallCandidatesAmbiguity -> {\n     "}
{"code": "           val expression = when (val psiExpression = diagnostic.argument.psiExpression) {\n                    is KtPsiUtil.KtExpressionWrapper -> psiExpression.baseExpression\n                    else -> psiExpression\n                } as? KtCallableReferenceExpression\n\n                val candidates = diagnostic.candidates.map { it.candidate }\n                if (expression != null) {\n                    trace.reportDiagnosticOnce(CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY.on(expression.callableReference, candidates))\n                    trace.record(BindingContext.AMBIGUOUS_REFERENCE_TARGET, expression.callableReference, candidates)\n                }\n            }\n\n            is ArgumentNullabilityErrorDiagnostic -> reportNullabilityMismatchDiagnostic(callArgument, diagnostic)\n\n            is ArgumentNullabilityWarningDiagnostic -> reportNullabilityMismatchDiagnostic(callArgument, diagnostic)\n\n            is CallableReferencesDefaultArgumentUsed -> {\n                val callableReferen"}
{"code": "ceExpression = diagnostic.argument.call.extractCallableReferenceExpression()\n\n                require(callableReferenceExpression != null) {\n                    \"A call element must be callable reference for `CallableReferencesDefaultArgumentUsed`\"\n                }\n\n                trace.report(\n                    UNSUPPORTED_FEATURE.on(\n                        callableReferenceExpression,\n                        LanguageFeature.FunctionReferenceWithDefaultValueAsOtherType to context.languageVersionSettings\n                    )\n                )\n            }\n\n            is ResolvedToSamWithVarargDiagnostic -> {\n                trace.report(TYPE_INFERENCE_CANDIDATE_WITH_SAM_AND_VARARG.on(callArgument.psiCallArgument.valueArgument.asElement()))\n            }\n\n            is NotEnoughInformationForLambdaParameter -> {\n                val lambdaArgument = diagnostic.lambdaArgument\n                val parameterIndex = diagnostic.parameterIndex\n\n                val valueArgument = lambd"}
{"code": "aArgument.psiCallArgument.valueArgument\n\n                val valueParameters = when (val argumentExpression = KtPsiUtil.deparenthesize(valueArgument.getArgumentExpression())) {\n                    is KtLambdaExpression -> argumentExpression.valueParameters\n                    is KtNamedFunction -> argumentExpression.valueParameters // for anonymous functions\n                    else -> return\n                }\n\n                val parameter = valueParameters.getOrNull(parameterIndex)\n                if (parameter != null) {\n                    trace.report(CANNOT_INFER_PARAMETER_TYPE.on(parameter))\n                }\n            }\n\n            is CompatibilityWarningOnArgument -> {\n                trace.report(\n                    COMPATIBILITY_WARNING.on(callArgument.psiCallArgument.valueArgument.asElement(), diagnostic.candidate)\n                )\n            }\n\n            is AdaptedCallableReferenceIsUsedWithReflection -> {\n                trace.report(\n                    ADAPTED_C"}
{"code": "ALLABLE_REFERENCE_AGAINST_REFLECTION_TYPE.on(\n                        callArgument.psiCallArgument.valueArgument.asElement()\n                    )\n                )\n            }\n\n            is MultiLambdaBuilderInferenceRestriction -> {\n                val typeParameter = diagnostic.typeParameter as? TypeParameterDescriptor\n\n                trace.reportDiagnosticOnce(\n                    BUILDER_INFERENCE_MULTI_LAMBDA_RESTRICTION.on(\n                        callArgument.psiCallArgument.valueArgument.asElement(),\n                        typeParameter?.name ?: SpecialNames.NO_NAME_PROVIDED,\n                        typeParameter?.containingDeclaration?.name ?: SpecialNames.NO_NAME_PROVIDED,\n                    )\n                )\n            }\n\n            is NotCallableMemberReference, is NotCallableExpectedType -> {\n                // NotCallableMemberReference -> UNSUPPORTED is reported in DoubleColonExpressionResolver\n                // NotCallableExpectedType -> TYPE_MISMATCH is re"}
{"code": "ported in reportConstraintErrorByPosition\n                return\n            }\n\n            else -> {\n                unknownError(diagnostic, \"onCallArgument\")\n            }\n        }\n    }\n\n    override fun onCallArgumentName(callArgument: KotlinCallArgument, diagnostic: KotlinCallDiagnostic) {\n        val nameReference = callArgument.psiCallArgument.valueArgument.getArgumentName()?.referenceExpression ?: return\n        when (diagnostic) {\n            is NamedArgumentReference -> {\n                trace.record(BindingContext.REFERENCE_TARGET, nameReference, diagnostic.parameterDescriptor)\n                trace.markAsReported()\n            }\n            is NameForAmbiguousParameter -> trace.report(NAME_FOR_AMBIGUOUS_PARAMETER.on(nameReference))\n            is NameNotFound -> trace.report(NAMED_PARAMETER_NOT_FOUND.on(nameReference, nameReference))\n\n            is NamedArgumentNotAllowed -> trace.report(\n                NAMED_ARGUMENTS_NOT_ALLOWED.on(\n                    nameReference,\n"}
{"code": "                    when (diagnostic.descriptor) {\n                        is FunctionInvokeDescriptor -> INVOKE_ON_FUNCTION_TYPE\n                        is DeserializedCallableMemberDescriptor -> INTEROP_FUNCTION\n                        else -> NON_KOTLIN_FUNCTION\n                    }\n                )\n            )\n            is ArgumentPassedTwice -> trace.report(ARGUMENT_PASSED_TWICE.on(nameReference))\n            else -> {\n                unknownError(diagnostic, \"onCallArgumentName\")\n            }\n        }\n    }\n\n    override fun onCallArgumentSpread(callArgument: KotlinCallArgument, diagnostic: KotlinCallDiagnostic) {\n        when (diagnostic) {\n            is NonVarargSpread -> {\n                val castedPsiCallArgument = callArgument as? PSIKotlinCallArgument\n                val castedCallArgument = callArgument as? ExpressionKotlinCallArgumentImpl\n\n                if (castedCallArgument != null) {\n                    val spreadElement = castedCallArgument.valueArgument.ge"}
{"code": "tSpreadElement()\n                    if (spreadElement != null) {\n                        trace.report(NON_VARARG_SPREAD.onError(spreadElement))\n                    }\n                } else if (castedPsiCallArgument != null) {\n                    val spreadElement = castedPsiCallArgument.valueArgument.getSpreadElement()\n                    if (spreadElement != null) {\n                        trace.report(NON_VARARG_SPREAD.on(context.languageVersionSettings, spreadElement))\n                    }\n                }\n            }\n            else -> {\n                unknownError(diagnostic, \"onCallArgumentSpread\")\n            }\n        }\n    }\n\n    private fun reportSmartCast(smartCastDiagnostic: SmartCastDiagnostic) {\n        val expressionArgument = smartCastDiagnostic.argument\n        val smartCastResult = when (expressionArgument) {\n            is ExpressionKotlinCallArgumentImpl -> {\n                trace.markAsReported()\n                val context = context.replaceDataFlowInfo(expr"}
{"code": "essionArgument.dataFlowInfoBeforeThisArgument)\n                val argumentExpression = KtPsiUtil.getLastElementDeparenthesized(\n                    expressionArgument.valueArgument.getArgumentExpression(),\n                    context.statementFilter\n                )\n                val dataFlowValue = dataFlowValueFactory.createDataFlowValue(expressionArgument.receiver.receiverValue, context)\n                val call = if (call.callElement is KtBinaryExpression) null else call\n                if (!expressionArgument.valueArgument.isExternal()) {\n                    smartCastManager.checkAndRecordPossibleCast(\n                        dataFlowValue, smartCastDiagnostic.smartCastType, argumentExpression, context, call,\n                        recordExpressionType = false\n                    )\n                } else null\n            }\n            is ReceiverExpressionKotlinCallArgument -> {\n                trace.markAsReported()\n                val receiverValue = expressionArgument.rece"}
{"code": "iver.receiverValue\n                val dataFlowValue = dataFlowValueFactory.createDataFlowValue(receiverValue, context)\n                smartCastManager.checkAndRecordPossibleCast(\n                    dataFlowValue, smartCastDiagnostic.smartCastType, (receiverValue as? ExpressionReceiver)?.expression, context, call,\n                    recordExpressionType = true\n                )\n            }\n            else -> null\n        }\n        val resolvedCall =\n            smartCastDiagnostic.kotlinCall?.psiKotlinCall?.psiCall?.getResolvedCall(trace.bindingContext) as? NewResolvedCallImpl<*>\n        if (resolvedCall != null && smartCastResult != null) {\n            if (resolvedCall.extensionReceiver == expressionArgument.receiver.receiverValue) {\n                resolvedCall.updateExtensionReceiverWithSmartCastIfNeeded(smartCastResult.resultType)\n            }\n            if (resolvedCall.dispatchReceiver == expressionArgument.receiver.receiverValue) {\n                resolvedCall.setSmartCa"}
{"code": "stDispatchReceiverType(smartCastResult.resultType)\n            }\n        }\n    }\n\n    private fun reportUnstableSmartCast(unstableSmartCast: UnstableSmartCast) {\n        val dataFlowValue = dataFlowValueFactory.createDataFlowValue(unstableSmartCast.argument.receiver.receiverValue, context)\n        val possibleTypes = unstableSmartCast.argument.receiver.typesFromSmartCasts\n        val argumentExpression = unstableSmartCast.argument.psiExpression ?: return\n\n        require(possibleTypes.isNotEmpty()) { \"Receiver for unstable smart cast without possible types\" }\n        val intersectWrappedTypes = intersectWrappedTypes(possibleTypes)\n        trace.record(BindingContext.UNSTABLE_SMARTCAST, argumentExpression, SingleSmartCast(null, intersectWrappedTypes))\n        trace.report(\n            SMARTCAST_IMPOSSIBLE.on(\n                argumentExpression,\n                intersectWrappedTypes,\n                argumentExpression.text,\n                dataFlowValue.kind.description\n            )\n   "}
{"code": "     )\n    }\n\n    private fun reportCallableReferenceConstraintError(\n        error: NewConstraintMismatch,\n        rhsExpression: KtSimpleNameExpression\n    ) {\n        trace.report(TYPE_MISMATCH.on(rhsExpression, error.lowerKotlinType, error.upperKotlinType))\n    }\n\n    private fun reportConstraintErrorByPosition(error: NewConstraintMismatch, position: ConstraintPosition) {\n        if (position is CallableReferenceConstraintPositionImpl) {\n            val callableReferenceExpression = position.callableReferenceCall.call.extractCallableReferenceExpression()\n\n            require(callableReferenceExpression != null) {\n                \"There should be the corresponding callable reference expression for `CallableReferenceConstraintPositionImpl`\"\n            }\n\n            reportCallableReferenceConstraintError(error, callableReferenceExpression.callableReference)\n            return\n        }\n\n        val isWarning = error is NewConstraintWarning\n        val typeMismatchDiagnostic = if (is"}
{"code": "Warning) TYPE_MISMATCH_WARNING else TYPE_MISMATCH\n        val report = if (isWarning) trace::reportDiagnosticOnce else trace::report\n\n        when (position) {\n            is ArgumentConstraintPosition<*> -> {\n                reportArgumentConstraintErrorByPosition(\n                    error, position.argument as KotlinCallArgument,\n                    isWarning, typeMismatchDiagnostic,\n                    selectorCall = null, report\n                )\n            }\n            is ReceiverConstraintPosition<*> -> {\n                reportArgumentConstraintErrorByPosition(\n                    error, position.argument as KotlinCallArgument,\n                    isWarning, typeMismatchDiagnostic,\n                    selectorCall = (position as ReceiverConstraintPositionImpl).selectorCall, report\n                )\n            }\n            is LambdaArgumentConstraintPosition<*> -> {\n                reportArgumentConstraintErrorByPosition(\n                    error, (position.lambda as Resolve"}
{"code": "dLambdaAtom).atom,\n                    isWarning, typeMismatchDiagnostic,\n                    selectorCall = null, report\n                )\n            }\n            is BuilderInferenceExpectedTypeConstraintPosition -> {\n                val inferredType =\n                    if (!error.lowerKotlinType.isNullableNothing()) error.lowerKotlinType\n                    else error.upperKotlinType.makeNullable()\n                trace.report(TYPE_MISMATCH.on(position.topLevelCall, error.upperKotlinType, inferredType))\n            }\n            is ExpectedTypeConstraintPosition<*> -> {\n                val call = (position.topLevelCall as? KotlinCall)?.psiKotlinCall?.psiCall?.callElement as? KtExpression\n                val inferredType =\n                    if (!error.lowerKotlinType.isNullableNothing()) error.lowerKotlinType\n                    else error.upperKotlinType.makeNullable()\n                if (call != null) {\n                    report(typeMismatchDiagnostic.on(call, error.upperKotl"}
{"code": "inType, inferredType))\n                }\n            }\n            is BuilderInferenceSubstitutionConstraintPosition<*> -> {\n                reportConstraintErrorByPosition(error, position.initialConstraint.position)\n            }\n            is ExplicitTypeParameterConstraintPosition<*> -> {\n                val typeArgumentReference = (position.typeArgument as SimpleTypeArgumentImpl).typeProjection.typeReference ?: return\n                val diagnosticFactory = if (isWarning) UPPER_BOUND_VIOLATED_WARNING else UPPER_BOUND_VIOLATED\n                report(diagnosticFactory.on(typeArgumentReference, error.upperKotlinType, error.lowerKotlinType))\n            }\n            is FixVariableConstraintPosition<*> -> {\n                val morePreciseDiagnosticExists = allDiagnostics.any { other ->\n                    val otherError = other.constraintSystemError ?: return@any false\n                    otherError is NewConstraintError && otherError.position.from !is FixVariableConstraintPositionImp"}
{"code": "l\n                }\n                if (morePreciseDiagnosticExists) return\n\n                val call = ((position.resolvedAtom as? ResolvedAtom)?.atom as? PSIKotlinCall)?.psiCall ?: call\n                val expression = call.calleeExpression ?: return\n\n                trace.reportDiagnosticOnce(typeMismatchDiagnostic.on(expression, error.upperKotlinType, error.lowerKotlinType))\n            }\n            BuilderInferencePosition -> {\n                // some error reported later?\n            }\n            is DeclaredUpperBoundConstraintPosition<*> -> {\n                val originalCall = (position as DeclaredUpperBoundConstraintPositionImpl).kotlinCall\n                val typeParameterDescriptor = position.typeParameter\n                val ownerDescriptor = typeParameterDescriptor.containingDeclaration\n                if (reportAdditionalErrors) {\n                    trace.reportDiagnosticOnce(\n                        UPPER_BOUND_VIOLATION_IN_CONSTRAINT.on(\n                            (o"}
{"code": "riginalCall as PSIKotlinCall).psiCall.callElement,\n                            typeParameterDescriptor.name,\n                            ownerDescriptor.name,\n                            error.upperKotlinType,\n                            error.lowerKotlinType\n                        )\n                    )\n                }\n            }\n            is DelegatedPropertyConstraintPosition<*> -> {\n                // DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE, reported later\n            }\n            is KnownTypeParameterConstraintPosition<*> -> {\n                // UPPER_BOUND_VIOLATED, reported later?\n            }\n            is CallableReferenceConstraintPosition<*>,\n            is IncorporationConstraintPosition,\n            is InjectedAnotherStubTypeConstraintPosition<*>,\n            is SimpleConstraintSystemConstraintPosition, ProvideDelegateFixationPosition\n            -> {\n                if (AbstractTypeChecker.RUN_SLOW_ASSERTIONS) {\n                    throw AssertionError(\"Cons"}
{"code": "traint error in unexpected position: $position\")\n                } else if (reportAdditionalErrors) {\n                    report(\n                        TYPE_MISMATCH_IN_CONSTRAINT.on(\n                            psiKotlinCall.psiCall.callElement,\n                            error.upperKotlinType,\n                            error.lowerKotlinType,\n                            position\n                        )\n                    )\n                }\n            }\n        }\n    }\n\n    private fun reportArgumentConstraintErrorByPosition(\n        error: NewConstraintMismatch,\n        argument: KotlinCallArgument,\n        isWarning: Boolean,\n        typeMismatchDiagnostic: DiagnosticFactory2<KtExpression, KotlinType, KotlinType>,\n        selectorCall: KotlinCall?,\n        report: (Diagnostic) -> Unit\n    ) {\n        if (argument is LambdaKotlinCallArgument) {\n            val parameterTypes = argument.parametersTypes?.toList()\n            if (parameterTypes != null) {\n                val in"}
{"code": "dex = parameterTypes.indexOf(error.upperKotlinType.unwrap())\n                val lambdaExpression = argument.psiExpression as? KtLambdaExpression\n                val parameter = lambdaExpression?.valueParameters?.getOrNull(index)\n                if (parameter != null) {\n                    val diagnosticFactory =\n                        if (isWarning) EXPECTED_PARAMETER_TYPE_MISMATCH_WARNING else EXPECTED_PARAMETER_TYPE_MISMATCH\n                    report(diagnosticFactory.on(parameter, error.lowerKotlinType))\n                    return\n                }\n            }\n        }\n\n        val expression = argument.psiExpression ?: run {\n            val psiCall = (selectorCall as? PSIKotlinCall)?.psiCall ?: psiKotlinCall.psiCall\n            // Note: we don't report RECEIVER_TYPE_MISMATCH w/out ProperTypeInferenceConstraintsProcessing\n            // See KT-57854. This is needed for intellij.go.tests (recursive generics case) compilation with K1\n            if (context.languageVersionSettin"}
{"code": "gs.supportsFeature(LanguageFeature.ProperTypeInferenceConstraintsProcessing) &&\n                reportAdditionalErrors\n            ) {\n                report(\n                    RECEIVER_TYPE_MISMATCH.on(\n                        psiCall.calleeExpression ?: psiCall.callElement, error.upperKotlinType, error.lowerKotlinType\n                    )\n                )\n            }\n            return\n        }\n\n        val deparenthesized = KtPsiUtil.safeDeparenthesize(expression)\n        if (reportConstantTypeMismatch(error, deparenthesized)) return\n\n        val compileTimeConstant = trace[BindingContext.COMPILE_TIME_VALUE, deparenthesized] as? TypedCompileTimeConstant\n        if (compileTimeConstant != null) {\n            val expressionType = trace[BindingContext.EXPRESSION_TYPE_INFO, expression]?.type\n            if (expressionType != null &&\n                !UnsignedTypes.isUnsignedType(compileTimeConstant.type) && UnsignedTypes.isUnsignedType(expressionType)\n            ) {\n             "}
{"code": "   // This is a special \"hack\" to prevent TYPE_MISMATCH\n                // in case of a compile-time constant with signed VS unsigned type\n                // See conversionOfSignedToUnsigned.kt diagnostic test\n                return\n            }\n        }\n        report(typeMismatchDiagnostic.on(deparenthesized, error.upperKotlinType, error.lowerKotlinType))\n    }\n\n    \n    private val reportAdditionalErrors: Boolean\n        get() = !context.languageVersionSettings.supportsFeature(LanguageFeature.NoAdditionalErrorsInK1DiagnosticReporter)\n\n    override fun constraintError(error: ConstraintSystemError) {\n        when (error) {\n            is NewConstraintMismatch -> reportConstraintErrorByPosition(error, error.position.from)\n\n            is CapturedTypeFromSubtyping -> {\n                val position = error.position\n                val argumentPosition: ArgumentConstraintPositionImpl? =\n                    position as? ArgumentConstraintPositionImpl\n                        ?: (position "}
{"code": "as? IncorporationConstraintPosition)?.from as? ArgumentConstraintPositionImpl\n\n                argumentPosition?.let {\n                    val expression = it.argument.psiExpression ?: return\n                    trace.reportDiagnosticOnce(\n                        NEW_INFERENCE_ERROR.on(\n                            expression,\n                            \"Capture type from subtyping ${error.constraintType} for variable ${error.typeVariable}\"\n                        )\n                    )\n                }\n            }\n\n            is InferredIntoDeclaredUpperBounds -> {\n                val psiCall = psiKotlinCall.psiCall\n                val expression = if (psiCall is CallTransformer.CallForImplicitInvoke) {\n                    psiCall.outerCall.calleeExpression\n                } else {\n                    psiCall.calleeExpression?.takeIf { it.isPhysical } ?: psiCall.callElement\n                } ?: return\n                val typeVariable = error.typeVariable as? TypeVariableFromCalla"}
{"code": "bleDescriptor ?: return\n\n                trace.reportDiagnosticOnce(\n                    INFERRED_INTO_DECLARED_UPPER_BOUNDS.on(expression, typeVariable.originalTypeParameter.name.asString())\n                )\n            }\n\n            is NotEnoughInformationForTypeParameterImpl -> {\n                val resolvedAtom = error.resolvedAtom\n                val isDiagnosticRedundant = !isSpecialFunction(resolvedAtom) && allDiagnostics.any {\n                    when (it) {\n                        is WrongCountOfTypeArguments -> true\n                        is KotlinConstraintSystemDiagnostic -> {\n                            val otherError = it.error\n                            (otherError is ConstrainingTypeIsError && otherError.typeVariable == error.typeVariable)\n                                    || otherError is NewConstraintError\n                        }\n                        else -> false\n                    }\n                }\n\n                if (isDiagnosticRedundant) return\n   "}
{"code": "             val expression = when (val atom = error.resolvedAtom.atom) {\n                    is PSIKotlinCall -> {\n                        val psiCall = atom.psiCall\n                        if (psiCall is CallTransformer.CallForImplicitInvoke) {\n                            psiCall.outerCall.calleeExpression\n                        } else {\n                            psiCall.calleeExpression\n                        }\n                    }\n                    is PSIKotlinCallArgument -> atom.valueArgument.getArgumentExpression()\n                    else -> call.calleeExpression\n                } ?: return\n\n                if (isSpecialFunction(resolvedAtom)) {\n                    // We locally report errors on some arguments of special calls, on which the error may not be reported directly\n                    reportNotEnoughInformationForTypeParameterForSpecialCall(resolvedAtom, error)\n                } else {\n                    val typeVariableName = when (val typeVariable = error.ty"}
{"code": "peVariable) {\n                        is TypeVariableFromCallableDescriptor -> typeVariable.originalTypeParameter.name.asString()\n                        is TypeVariableForLambdaReturnType -> \"return type of lambda\"\n                        else -> error(\"Unsupported type variable: $typeVariable\")\n                    }\n                    val unwrappedExpression = if (expression is KtBlockExpression) {\n                        expression.statements.lastOrNull() ?: expression\n                    } else expression\n\n                    val diagnostic = if (error.couldBeResolvedWithUnrestrictedBuilderInference) {\n                        COULD_BE_INFERRED_ONLY_WITH_UNRESTRICTED_BUILDER_INFERENCE\n                    } else {\n                        NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER\n                    }\n\n                    trace.reportDiagnosticOnce(diagnostic.on(unwrappedExpression, typeVariableName))\n                }\n            }\n\n            is OnlyInputTypesDiagnostic -> {\n    "}
{"code": "            val typeVariable = error.typeVariable as? TypeVariableFromCallableDescriptor ?: return\n                psiKotlinCall.psiCall.calleeExpression?.let {\n                    trace.report(\n                        TYPE_INFERENCE_ONLY_INPUT_TYPES.on(context.languageVersionSettings, it, typeVariable.originalTypeParameter)\n                    )\n                }\n            }\n\n            is InferredEmptyIntersectionError, is InferredEmptyIntersectionWarning -> {\n                val typeVariable = (error as InferredEmptyIntersection).typeVariable\n                psiKotlinCall.psiCall.calleeExpression?.let { expression ->\n                    val typeVariableText = (typeVariable as? TypeVariableFromCallableDescriptor)?.originalTypeParameter?.name?.asString()\n                        ?: typeVariable.toString()\n\n                    @Suppress(\"UNCHECKED_CAST\")\n                    val incompatibleTypes = error.incompatibleTypes as List<KotlinType>\n\n                    @Suppress(\"UNCHECKED_C"}
{"code": "AST\")\n                    val causingTypes = error.causingTypes as List<KotlinType>\n                    val causingTypesText = if (incompatibleTypes == causingTypes) \"\" else \": ${causingTypes.joinToString()}\"\n                    val diagnostic = if (error.kind.isDefinitelyEmpty) {\n                        INFERRED_TYPE_VARIABLE_INTO_EMPTY_INTERSECTION.on(\n                            context.languageVersionSettings, expression, typeVariableText,\n                            incompatibleTypes, error.kind.description, causingTypesText\n                        )\n                    } else {\n                        INFERRED_TYPE_VARIABLE_INTO_POSSIBLE_EMPTY_INTERSECTION.on(\n                            expression, typeVariableText,\n                            incompatibleTypes, error.kind.description, causingTypesText\n                        )\n                    }\n\n                    trace.reportDiagnosticOnce(diagnostic)\n                }\n            }\n            // ConstrainingTypeIsError "}
{"code": "means that some type isError, so it's reported somewhere else\n            is ConstrainingTypeIsError -> {}\n            // LowerPriorityToPreserveCompatibility is not expected to report something\n            is LowerPriorityToPreserveCompatibility -> {}\n            // NoSuccessfulFork does not exist in K1\n            is NoSuccessfulFork -> shouldNotBeCalled()\n            // MultiLambdaBuilderInferenceRestriction does not exist in K1\n            is org.jetbrains.kotlin.resolve.calls.inference.model.MultiLambdaBuilderInferenceRestriction<*> -> shouldNotBeCalled()\n            // NotEnoughInformationForTypeParameterImpl is already considered above\n            is NotEnoughInformationForTypeParameter<*> -> {\n                throw AssertionError(\"constraintError should not be called with ${error::class.java}\")\n            }\n        }\n    }\n\n    private fun reportNullabilityMismatchDiagnostic(callArgument: KotlinCallArgument, diagnostic: ArgumentNullabilityMismatchDiagnostic) {\n        val expr"}
{"code": "ession = (callArgument as? PSIKotlinCallArgument)?.valueArgument?.getArgumentExpression()?.let {\n            KtPsiUtil.deparenthesize(it) ?: it\n        }\n        if (expression != null) {\n            @Suppress(\"USELESS_IS_CHECK\") // K2 warning suppression, TODO: KT-62472\n            if (expression.isNull() && expression is KtConstantExpression) {\n                val factory = when (diagnostic) {\n                    is ArgumentNullabilityErrorDiagnostic -> NULL_FOR_NONNULL_TYPE\n                    is ArgumentNullabilityWarningDiagnostic -> NULL_FOR_NONNULL_TYPE_WARNING\n                }\n                trace.reportDiagnosticOnce(factory.on(expression, diagnostic.expectedType))\n            } else {\n                val factory = when (diagnostic) {\n                    is ArgumentNullabilityErrorDiagnostic -> TYPE_MISMATCH\n                    is ArgumentNullabilityWarningDiagnostic -> TYPE_MISMATCH_WARNING\n                }\n                trace.report(factory.on(expression, diagnostic.exp"}
{"code": "ectedType, diagnostic.actualType))\n            }\n        }\n    }\n\n    private fun reportNotEnoughInformationForTypeParameterForSpecialCall(\n        resolvedAtom: ResolvedCallAtom,\n        error: NotEnoughInformationForTypeParameterImpl\n    ) {\n        val subResolvedAtomsToReportError =\n            getSubResolvedAtomsOfSpecialCallToReportUninferredTypeParameter(resolvedAtom, error.typeVariable)\n\n        if (subResolvedAtomsToReportError.isEmpty()) return\n\n        for (subResolvedAtom in subResolvedAtomsToReportError) {\n            val atom = subResolvedAtom.atom as? PSIKotlinCallArgument ?: continue\n            val argumentsExpression = getArgumentsExpressionOrLastExpressionInBlock(atom)\n\n            if (argumentsExpression != null) {\n                val specialFunctionName = requireNotNull(\n                    ControlStructureTypingUtils.ResolveConstruct.entries.find { specialFunction ->\n                        specialFunction.specialFunctionName == resolvedAtom.candidateDescriptor.na"}
{"code": "me\n                    }\n                ) { \"Unsupported special construct: ${resolvedAtom.candidateDescriptor.name} not found in special construct names\" }\n\n                trace.reportDiagnosticOnce(\n                    NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER.on(\n                        argumentsExpression, \" for subcalls of ${specialFunctionName.getName()} expression\"\n                    )\n                )\n            }\n        }\n    }\n\n    private fun getArgumentsExpressionOrLastExpressionInBlock(atom: PSIKotlinCallArgument): KtExpression? {\n        val valueArgumentExpression = atom.valueArgument.getArgumentExpression()\n\n        return if (valueArgumentExpression is KtBlockExpression) valueArgumentExpression.statements.lastOrNull() else valueArgumentExpression\n    }\n\n    private fun KotlinType.containsUninferredTypeParameter(uninferredTypeVariable: TypeVariableMarker) = contains {\n        ErrorUtils.isUninferredTypeVariable(it) || it == TypeUtils.DONT_CARE\n                || "}
{"code": "it.constructor == uninferredTypeVariable.freshTypeConstructor(typeSystemContext)\n    }\n\n    private fun getSubResolvedAtomsOfSpecialCallToReportUninferredTypeParameter(\n        resolvedAtom: ResolvedAtom,\n        uninferredTypeVariable: TypeVariableMarker\n    ): Set<ResolvedAtom> =\n        buildSet {\n            for (subResolvedAtom in resolvedAtom.subResolvedAtoms ?: return@buildSet) {\n                val atom = subResolvedAtom.atom\n                val typeToCheck = when {\n                    subResolvedAtom is PostponedResolvedAtom -> subResolvedAtom.expectedType ?: return@buildSet\n                    atom is SimpleKotlinCallArgument -> atom.receiver.receiverValue.type\n                    else -> return@buildSet\n                }\n\n                if (typeToCheck.containsUninferredTypeParameter(uninferredTypeVariable)) {\n                    add(subResolvedAtom)\n                }\n\n                if (!subResolvedAtom.subResolvedAtoms.isNullOrEmpty()) {\n                    addAll(\n     "}
{"code": "                   getSubResolvedAtomsOfSpecialCallToReportUninferredTypeParameter(subResolvedAtom, uninferredTypeVariable)\n                    )\n                }\n            }\n        }\n\n    @OptIn(ExperimentalContracts::class)\n    private fun isSpecialFunction(atom: ResolvedAtom): Boolean {\n        contract {\n            returns(true) implies (atom is ResolvedCallAtom)\n        }\n        if (atom !is ResolvedCallAtom) return false\n\n        return ControlStructureTypingUtils.ResolveConstruct.entries.any { specialFunction ->\n            specialFunction.specialFunctionName == atom.candidateDescriptor.name\n        }\n    }\n\n    private fun reportConstantTypeMismatch(constraintError: NewConstraintMismatch, expression: KtExpression): Boolean {\n        if (expression is KtConstantExpression) {\n            val module = context.scope.ownerDescriptor.module\n            val constantValue = constantExpressionEvaluator.evaluateToConstantValue(expression, trace, context.expectedType)\n            va"}
{"code": "l hasConstantTypeError = CompileTimeConstantChecker(context, module, true)\n                .checkConstantExpressionType(constantValue, expression, constraintError.upperKotlinType)\n            if (hasConstantTypeError) return true\n        }\n        return false\n    }\n\n}\n\nval NewConstraintMismatch.upperKotlinType get() = upperType as KotlinType\nval NewConstraintMismatch.lowerKotlinType get() = lowerType as KotlinType\n"}
{"code": "// FILE: useSite.kt\n\nimport InspectionProfileImpl.INIT_INSPECTIONS\n\nfun foo(): Int = 4\n\n// FILE: InspectionProfileImpl.java\nimport static Configuration.StaticConfigurationClass\n\npublic class InspectionProfileImpl extends InspectionProfile<StaticConfigurationClass> {\n    public static boolean INIT_INSPECTIONS;\n}\n\n// FILE: InspectionProfile.java\npublic class InspectionProfile <T> {\n}\n\n// FILE: Configuration.java\npublic class Configuration implements KotlinInterface {\n    public static class StaticConfigurationClass {\n\n    }\n}\n\n// FILE: KotlinInterface.kt\ninterface KotlinInterface {\n    var selectedOptions: Int\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.descriptors.contracts\n\nimport org.jetbrains.kotlin.analysis.api.contracts.description.*\nimport org.jetbrains.kotlin.analysis.api.contracts.description.KtContractConstantValue.KtContractConstantType\nimport org.jetbrains.kotlin.analysis.api.contracts.description.KtContractReturnsContractEffectDeclaration.*\nimport org.jetbrains.kotlin.analysis.api.contracts.description.booleans.*\nimport org.jetbrains.kotlin.analysis.api.descriptors.Fe10AnalysisContext\nimport org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.toKtSymbol\nimport org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.toKtType\nimport org.jetbrains.kotlin.analysis.api.symbols.KtParameterSymbol\nimport org.jetbrains.kotlin.contracts.description.*\nimport org.jetbrains.kotlin.contracts.description.expressions.*\n\ninternal fun EffectDeclaration.effectDeclarationToAnalysisApi(analysisContext: Fe10AnalysisContext): KtContractEffectDeclaration =\n    "}
{"code": "accept(ContractDescriptionElementToAnalysisApi(analysisContext), Unit) as KtContractEffectDeclaration\n\nprivate class ContractDescriptionElementToAnalysisApi(val analysisContext: Fe10AnalysisContext) :\n    ContractDescriptionVisitor<Any, Unit> {\n\n    override fun visitConditionalEffectDeclaration(\n        conditionalEffect: ConditionalEffectDeclaration,\n        data: Unit\n    ): Any = KtContractConditionalContractEffectDeclaration(\n        conditionalEffect.effect.accept(),\n        conditionalEffect.condition.accept(),\n    )\n\n    override fun visitReturnsEffectDeclaration(\n        returnsEffect: ReturnsEffectDeclaration,\n        data: Unit\n    ): KtContractReturnsContractEffectDeclaration =\n        when (val value = returnsEffect.value) {\n            ConstantReference.NULL ->\n                KtContractReturnsSpecificValueEffectDeclaration(KtContractConstantValue(KtContractConstantType.NULL, analysisContext.token))\n            ConstantReference.NOT_NULL -> KtContractReturnsNotNullEffectD"}
{"code": "eclaration(analysisContext.token)\n            ConstantReference.WILDCARD -> KtContractReturnsSuccessfullyEffectDeclaration(analysisContext.token)\n            is BooleanConstantReference -> KtContractReturnsSpecificValueEffectDeclaration(\n                KtContractConstantValue(\n                    when (value) {\n                        BooleanConstantReference.TRUE -> KtContractConstantType.TRUE\n                        BooleanConstantReference.FALSE -> KtContractConstantType.FALSE\n                        else -> error(\"Can't convert $value to the Analysis API\")\n                    },\n                    analysisContext.token\n                )\n            )\n            else -> error(\"Can't convert $returnsEffect to the Analysis API\")\n        }\n\n    override fun visitCallsEffectDeclaration(callsEffect: CallsEffectDeclaration, data: Unit): Any =\n        KtContractCallsInPlaceContractEffectDeclaration(callsEffect.variableReference.accept(), callsEffect.kind)\n\n    override fun visitLogicalO"}
{"code": "r(logicalOr: LogicalOr, data: Unit): Any = KtContractBinaryLogicExpression(\n        logicalOr.left.accept(),\n        logicalOr.right.accept(),\n        KtContractBinaryLogicExpression.KtLogicOperation.OR\n    )\n\n    override fun visitLogicalAnd(logicalAnd: LogicalAnd, data: Unit): Any = KtContractBinaryLogicExpression(\n        logicalAnd.left.accept(),\n        logicalAnd.right.accept(),\n        KtContractBinaryLogicExpression.KtLogicOperation.AND\n    )\n\n    override fun visitLogicalNot(logicalNot: LogicalNot, data: Unit): Any =\n        KtContractLogicalNotExpression(logicalNot.arg.accept())\n\n    override fun visitIsInstancePredicate(isInstancePredicate: IsInstancePredicate, data: Unit): Any =\n        KtContractIsInstancePredicateExpression(\n            isInstancePredicate.arg.accept(),\n            isInstancePredicate.type.toKtType(analysisContext),\n            isInstancePredicate.isNegated\n        )\n\n    override fun visitIsNullPredicate(isNullPredicate: IsNullPredicate, data: Unit): Any"}
{"code": " =\n        KtContractIsNullPredicateExpression(isNullPredicate.arg.accept(), isNullPredicate.isNegated)\n\n    override fun visitBooleanConstantDescriptor(\n        booleanConstantDescriptor: BooleanConstantReference,\n        data: Unit\n    ): KtContractBooleanConstantExpression =\n        when (booleanConstantDescriptor) {\n            BooleanConstantReference.TRUE -> KtContractBooleanConstantExpression(true, analysisContext.token)\n            BooleanConstantReference.FALSE -> KtContractBooleanConstantExpression(false, analysisContext.token)\n            else -> error(\"Can't convert $booleanConstantDescriptor to Analysis API\")\n        }\n\n    override fun visitVariableReference(variableReference: VariableReference, data: Unit): Any =\n        visitVariableReference(variableReference, ::KtContractParameterValue)\n\n    override fun visitBooleanVariableReference(\n        booleanVariableReference: BooleanVariableReference,\n        data: Unit\n    ): Any = visitVariableReference(booleanVariableRefer"}
{"code": "ence, ::KtContractBooleanValueParameterExpression)\n\n    private fun <T> visitVariableReference(\n        variableReference: VariableReference,\n        constructor: (KtParameterSymbol) -> T\n    ): T = constructor(variableReference.descriptor.toKtSymbol(analysisContext) as KtParameterSymbol)\n\n    // Util function to avoid hard coding names of the classes. Type inference will do a better job figuring out the best type to cast to.\n    // This visitor isn't type-safe anyway\n    private inline fun <reified T> ContractDescriptionElement.accept() = accept(this@ContractDescriptionElementToAnalysisApi, Unit) as T\n}\n"}
{"code": "// MODULE: context\n\n// FILE: context.kt\nfun test() {\n    block(\"foo\") {\n        fun call() {\n            consume(this@block)\n        }\n\n        <caret_context>call()\n    }\n}\n\nfun <T> block(obj: T, block: T.() -> Unit) {\n    obj.block()\n}\n\nfun consume(text: String) {}\n\n\n// MODULE: main\n// MODULE_KIND: CodeFragment\n// CONTEXT_MODULE: context\n\n// FILE: fragment.kt\n// CODE_FRAGMENT_KIND: EXPRESSION\ncall()"}
{"code": "// callable: test/C.x\npackage test\n\ninterface A<T> {\n    val x: T\n}\n\ninterface B<T> : A<T>\n\ninterface C : B<String>"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.tree.generator.printer\n\nimport org.jetbrains.kotlin.descriptors.Modality\nimport org.jetbrains.kotlin.fir.tree.generator.BASE_PACKAGE\nimport org.jetbrains.kotlin.fir.tree.generator.firTransformerType\nimport org.jetbrains.kotlin.fir.tree.generator.model.Field\nimport org.jetbrains.kotlin.fir.tree.generator.model.FieldList\nimport org.jetbrains.kotlin.fir.tree.generator.model.FieldWithDefault\nimport org.jetbrains.kotlin.generators.tree.*\nimport org.jetbrains.kotlin.generators.tree.printer.FunctionParameter\nimport org.jetbrains.kotlin.generators.tree.printer.printFunctionDeclaration\nimport org.jetbrains.kotlin.utils.SmartPrinter\n\ncontext(ImportCollector)\nfun SmartPrinter.transformFunctionDeclaration(\n    field: Field,\n    returnType: TypeRef,\n    override: Boolean,\n    implementationKind: ImplementationKind,\n) {\n    transformFunctionDeclaration(field.name.replaceFirstChar(Char::uppercaseChar), returnType, override, implementationKind)\n}\n\ncontext(ImportColle"}
{"code": "ctor)\nfun SmartPrinter.transformOtherChildrenFunctionDeclaration(\n    element: TypeRef,\n    override: Boolean,\n    implementationKind: ImplementationKind,\n) {\n    transformFunctionDeclaration(\"OtherChildren\", element, override, implementationKind)\n}\n\ncontext(ImportCollector)\nprivate fun SmartPrinter.transformFunctionDeclaration(\n    transformName: String,\n    returnType: TypeRef,\n    override: Boolean,\n    implementationKind: ImplementationKind,\n) {\n    val dataTP = TypeVariable(\"D\")\n    printFunctionDeclaration(\n        name = \"transform$transformName\",\n        parameters = listOf(\n            FunctionParameter(\"transformer\", firTransformerType.withArgs(dataTP)),\n            FunctionParameter(\"data\", dataTP),\n        ),\n        returnType = returnType,\n        typeParameters = listOf(dataTP),\n        modality = Modality.ABSTRACT.takeIf {\n            implementationKind == ImplementationKind.AbstractClass || implementationKind == ImplementationKind.SealedClass\n        },\n        overrid"}
{"code": "e = override,\n    )\n}\n\ncontext(ImportCollector)\nfun SmartPrinter.replaceFunctionDeclaration(\n    field: Field,\n    override: Boolean,\n    implementationKind: ImplementationKind,\n    overriddenType: TypeRefWithNullability? = null,\n    forceNullable: Boolean = false,\n) {\n    val capName = field.name.replaceFirstChar(Char::uppercaseChar)\n    val type = overriddenType ?: field.typeRef\n    val typeWithNullable = if (forceNullable) type.copy(nullable = true) else type\n\n    printFunctionDeclaration(\n        name = \"replace$capName\",\n        parameters = listOf(FunctionParameter(\"new$capName\", typeWithNullable)),\n        returnType = StandardTypes.unit,\n        modality = Modality.ABSTRACT.takeIf {\n            implementationKind == ImplementationKind.AbstractClass || implementationKind == ImplementationKind.SealedClass\n        },\n        override = override,\n        optInAnnotation = field.replaceOptInAnnotation,\n    )\n}\n\nfun Field.getMutableType(forBuilder: Boolean = false): TypeRefWithNullab"}
{"code": "ility = when (this) {\n    is FieldList -> when {\n        isMutableOrEmptyList && !forBuilder -> type(BASE_PACKAGE, \"MutableOrEmptyList\", kind = TypeKind.Class)\n        isMutable -> StandardTypes.mutableList\n        else -> StandardTypes.list\n    }.withArgs(baseType).copy(nullable)\n    is FieldWithDefault -> if (isMutable) origin.getMutableType() else typeRef\n    else -> typeRef\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\")\n\npackage org.jetbrains.kotlin.fir.declarations.impl\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirImplementationDetail\nimport org.jetbrains.kotlin.fir.FirModuleData\nimport org.jetbrains.kotlin.fir.MutableOrEmptyList\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.references.FirControlFlowGraphReference\nimport org.jetbrains.kotlin.fir.symbols.impl.FirFieldSymbol\nimport org.jetbrains.kotlin.fir.types.ConeSimpleKotlinType\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotli"}
{"code": "n.fir.visitors.transformInplace\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedContainerSource\n\n@OptIn(FirImplementationDetail::class, ResolveStateAccess::class)\nclass FirFieldImpl @FirImplementationDetail constructor(\n    override val source: KtSourceElement?,\n    resolvePhase: FirResolvePhase,\n    override val moduleData: FirModuleData,\n    override val origin: FirDeclarationOrigin,\n    override val attributes: FirDeclarationAttributes,\n    override val typeParameters: MutableList<FirTypeParameterRef>,\n    override var status: FirDeclarationStatus,\n    override var returnTypeRef: FirTypeRef,\n    override var deprecationsProvider: DeprecationsProvider,\n    override val containerSource: DeserializedContainerSource?,\n    override val dispatchReceiverType: ConeSimpleKotlinType?,\n    override var contextReceivers: MutableOrEmptyList<FirContextReceiver>,\n    override val name: Name,\n    override var initializer: FirEx"}
{"code": "pression?,\n    override val isVar: Boolean,\n    override var backingField: FirBackingField?,\n    override var annotations: MutableOrEmptyList<FirAnnotation>,\n    override val symbol: FirFieldSymbol,\n) : FirField() {\n    override val receiverParameter: FirReceiverParameter?\n        get() = null\n    override val delegate: FirExpression?\n        get() = null\n    override val isVal: Boolean\n        get() = !isVar\n    override val getter: FirPropertyAccessor?\n        get() = null\n    override val setter: FirPropertyAccessor?\n        get() = null\n    override var controlFlowGraphReference: FirControlFlowGraphReference? = null\n    override val hasConstantInitializer: Boolean\n        get() = status.isConst\n\n    init {\n        symbol.bind(this)\n        resolveState = resolvePhase.asResolveState()\n    }\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {\n        typeParameters.forEach { it.accept(visitor, data) }\n        status.accept(visitor, data)\n        returnTypeRe"}
{"code": "f.accept(visitor, data)\n        contextReceivers.forEach { it.accept(visitor, data) }\n        initializer?.accept(visitor, data)\n        backingField?.accept(visitor, data)\n        annotations.forEach { it.accept(visitor, data) }\n        controlFlowGraphReference?.accept(visitor, data)\n    }\n\n    override fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirFieldImpl {\n        transformTypeParameters(transformer, data)\n        transformStatus(transformer, data)\n        transformReturnTypeRef(transformer, data)\n        transformInitializer(transformer, data)\n        transformBackingField(transformer, data)\n        transformOtherChildren(transformer, data)\n        return this\n    }\n\n    override fun <D> transformTypeParameters(transformer: FirTransformer<D>, data: D): FirFieldImpl {\n        typeParameters.transformInplace(transformer, data)\n        return this\n    }\n\n    override fun <D> transformStatus(transformer: FirTransformer<D>, data: D): FirFieldImpl {\n        st"}
{"code": "atus = status.transform(transformer, data)\n        return this\n    }\n\n    override fun <D> transformReturnTypeRef(transformer: FirTransformer<D>, data: D): FirFieldImpl {\n        returnTypeRef = returnTypeRef.transform(transformer, data)\n        return this\n    }\n\n    override fun <D> transformReceiverParameter(transformer: FirTransformer<D>, data: D): FirFieldImpl {\n        return this\n    }\n\n    override fun <D> transformInitializer(transformer: FirTransformer<D>, data: D): FirFieldImpl {\n        initializer = initializer?.transform(transformer, data)\n        return this\n    }\n\n    override fun <D> transformDelegate(transformer: FirTransformer<D>, data: D): FirFieldImpl {\n        return this\n    }\n\n    override fun <D> transformGetter(transformer: FirTransformer<D>, data: D): FirFieldImpl {\n        return this\n    }\n\n    override fun <D> transformSetter(transformer: FirTransformer<D>, data: D): FirFieldImpl {\n        return this\n    }\n\n    override fun <D> transformBackingField(trans"}
{"code": "former: FirTransformer<D>, data: D): FirFieldImpl {\n        backingField = backingField?.transform(transformer, data)\n        return this\n    }\n\n    override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirFieldImpl {\n        annotations.transformInplace(transformer, data)\n        return this\n    }\n\n    override fun <D> transformOtherChildren(transformer: FirTransformer<D>, data: D): FirFieldImpl {\n        contextReceivers.transformInplace(transformer, data)\n        transformAnnotations(transformer, data)\n        controlFlowGraphReference = controlFlowGraphReference?.transform(transformer, data)\n        return this\n    }\n\n    override fun replaceStatus(newStatus: FirDeclarationStatus) {\n        status = newStatus\n    }\n\n    override fun replaceReturnTypeRef(newReturnTypeRef: FirTypeRef) {\n        returnTypeRef = newReturnTypeRef\n    }\n\n    override fun replaceReceiverParameter(newReceiverParameter: FirReceiverParameter?) {}\n\n    override fun replaceDeprecation"}
{"code": "sProvider(newDeprecationsProvider: DeprecationsProvider) {\n        deprecationsProvider = newDeprecationsProvider\n    }\n\n    override fun replaceContextReceivers(newContextReceivers: List<FirContextReceiver>) {\n        contextReceivers = newContextReceivers.toMutableOrEmpty()\n    }\n\n    override fun replaceInitializer(newInitializer: FirExpression?) {\n        initializer = newInitializer\n    }\n\n    override fun replaceDelegate(newDelegate: FirExpression?) {}\n\n    override fun replaceGetter(newGetter: FirPropertyAccessor?) {}\n\n    override fun replaceSetter(newSetter: FirPropertyAccessor?) {}\n\n    override fun replaceAnnotations(newAnnotations: List<FirAnnotation>) {\n        annotations = newAnnotations.toMutableOrEmpty()\n    }\n\n    override fun replaceControlFlowGraphReference(newControlFlowGraphReference: FirControlFlowGraphReference?) {\n        controlFlowGraphReference = newControlFlowGraphReference\n    }\n}\n"}
{"code": "package util\n\nannotation class Anno(val position: String)\ndata class Pair(val a: Int, val b: Int)\nconst val prop = \"str\"\n\n@Anno(\"destr $prop\")\nv<caret>al (@Anno(\"a $prop\") a, @Anno(\"b $prop\") b) = Pair(0, 1)\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.components\n\nimport org.jetbrains.kotlin.analysis.api.components.KtTypeInfoProvider\nimport org.jetbrains.kotlin.analysis.api.fir.KtFirAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.fir.types.KtFirType\nimport org.jetbrains.kotlin.analysis.api.fir.types.PublicTypeApproximator\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken\nimport org.jetbrains.kotlin.analysis.api.types.KtType\nimport org.jetbrains.kotlin.builtins.functions.FunctionTypeKind\nimport org.jetbrains.kotlin.fir.resolve.FirSamResolver\nimport org.jetbrains.kotlin.fir.resolve.fullyExpandedType\nimport org.jetbrains.kotlin.fir.types.*\n\ninternal class KtFirTypeInfoProvider(\n    override val analysisSession: KtFirAnalysisSession,\n    override val token: KtLifetimeToken\n) : KtTypeInfoProvider(), KtFirAnalysisSessionComponent {\n\n    override fun isFunctionalInterfaceType(type: KtType): Boolean {\n        val coneType = (type as KtFirType).coneType\n        val firSe"}
{"code": "ssion = analysisSession.useSiteSession\n        val samResolver = FirSamResolver(\n            firSession,\n            analysisSession.getScopeSessionFor(firSession),\n        )\n        return samResolver.isSamType(coneType)\n    }\n\n    override fun getFunctionClassKind(type: KtType): FunctionTypeKind? {\n        return (type as KtFirType).coneType.functionTypeKind(analysisSession.useSiteSession)\n    }\n\n    override fun canBeNull(type: KtType): Boolean = (type as KtFirType).coneType.canBeNull(analysisSession.useSiteSession)\n\n    override fun isDenotable(type: KtType): Boolean {\n        val coneType = (type as KtFirType).coneType\n        return analysisSession.useSiteSession.typeApproximator.approximateToSuperType(\n            coneType,\n            PublicTypeApproximator.PublicApproximatorConfiguration(false)\n        ) == null\n    }\n\n    override fun isArrayOrPrimitiveArray(type: KtType): Boolean {\n        require(type is KtFirType)\n        return type.coneType.isArrayOrPrimitiveArray\n    }\n"}
{"code": "\n    override fun isNestedArray(type: KtType): Boolean {\n        if (!isArrayOrPrimitiveArray(type)) return false\n        require(type is KtFirType)\n        return type.coneType.arrayElementType()?.isArrayOrPrimitiveArray == true\n    }\n\n    override fun fullyExpandedType(type: KtType): KtType = type.coneType.fullyExpandedType(analysisSession.useSiteSession).asKtType()\n}\n"}
{"code": "// WITH_STDLIB\nfun foo(limit: Int) {\n    var k = 0\n    some@ while (k < limit) {\n        k++\n        println(k)\n        while (k == 13) {\n            k++\n            if (k < limit) break@some\n            if (k > limit) continue\n        }\n    }\n}\n\nfun bar(limit: Int) {\n    var k = limit\n    do {\n        k--\n        println(k)\n    } while (k >= 0)\n}"}
{"code": "interface Box<T>\n\npublic fun <T> foo(nextFunction: (T) -> T): Box<T> = null!!\n\nfun leaves(value: String, forward: Boolean): Box<String> {\n    if (forward) {\n        return foo { \"\" }\n    } else {\n        return foo { \"\" }\n    }\n}\n"}
{"code": "package test\n\nclass Regular {\n    fun one() {}\n}\n\nfun test(action: Regular.() -> Unit) {}\n\nfun usage() {\n    test {\n        <expr>this@test.one()</expr>\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.util\n\nfun getExceptionMessage(\n    subsystemName: String,\n    message: String,\n    cause: Throwable?,\n    location: String?\n): String =\n    buildString {\n        append(subsystemName).append(\" Internal error: \").appendLine(message)\n\n        if (location != null) {\n            append(\"File being compiled: \").appendLine(location)\n        } else {\n            appendLine(\"File is unknown\")\n        }\n\n        if (cause != null) {\n            append(\"The root cause ${cause::class.java.name} was thrown at: \")\n            append(cause.stackTrace?.firstOrNull()?.toString() ?: \"unknown\")\n        }\n    }\n"}
{"code": "fun box(msg: String): String {\n    return <expr>\"message\" + msg</expr>\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.impl.base.test.cases.types\n\nimport org.jetbrains.kotlin.analysis.api.symbols.KtCallableSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.getSymbolOfType\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.test.framework.services.SubstitutionParser\nimport org.jetbrains.kotlin.analysis.test.framework.services.expressionMarkerProvider\nimport org.jetbrains.kotlin.analysis.utils.printer.prettyPrint\nimport org.jetbrains.kotlin.psi.KtCallableDeclaration\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.assertions\nimport org.jetbrains.kotlin.types.Variance\n\nabstract class AbstractAnalysisApiSubstitutorsTest : AbstractAnalysisApiBasedTest() {\n    override fun doTestByMainFile(mainFile: KtFile, mainModule: KtTe"}
{"code": "stModule, testServices: TestServices) {\n        val declaration = testServices.expressionMarkerProvider.getElementOfTypeAtCaret<KtCallableDeclaration>(mainFile)\n        val actual = analyseForTest(declaration) {\n            val substitutor = SubstitutionParser.parseSubstitutor(mainFile, declaration)\n            val symbol = declaration.getSymbolOfType<KtCallableSymbol>()\n            val type = symbol.returnType\n            val substituted = substitutor.substitute(type)\n            val substitutedOrNull = substitutor.substituteOrNull(type)\n\n            prettyPrint {\n                appendLine(\"PSI type: ${declaration.typeReference?.text}\")\n                appendLine(\"KtType: ${type.render(position = Variance.INVARIANT)}\")\n                appendLine(\"substitutor.substitute: ${substituted.render(position = Variance.INVARIANT)}\")\n                appendLine(\"substitutor.substituteOrNull: ${substitutedOrNull?.render(position = Variance.INVARIANT)}\")\n            }\n        }\n        testServic"}
{"code": "es.assertions.assertEqualsToTestDataFileSibling(actual)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.test.framework.project.structure\n\nimport com.intellij.openapi.project.Project\nimport org.jetbrains.kotlin.analysis.project.structure.*\n\nabstract class KtModuleWithModifiableDependencies {\n    abstract val project: Project\n\n    abstract val directRegularDependencies: MutableList<KtModule>\n    abstract val directDependsOnDependencies: MutableList<KtModule>\n    abstract val directFriendDependencies: MutableList<KtModule>\n\n    \n    val transitiveDependsOnDependencies: List<KtModule>\n        get() = computeTransitiveDependsOnDependencies(directDependsOnDependencies)\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\", \"unused\")\n\npackage org.jetbrains.kotlin.fir.expressions.builder\n\nimport kotlin.contracts.*\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.builder.FirAnnotationContainerBuilder\nimport org.jetbrains.kotlin.fir.builder.FirBuilderDsl\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirResolvedReifiedParameterReference\nimport org.jetbrains.kotlin.fir.expressions.impl.FirResolvedReifiedParameterReferenceImpl\nimport org.jetbrains.kotlin.fir.symbols.impl.FirTypeParameterSymbol\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\n\n@FirBuilderDsl\nclass FirResolvedReifiedParameterReferenceBuilder : FirAnnotationContainerBuilder, FirExpressionBuilder {\n    override var source: KtSourceElement? = null\n    ove"}
{"code": "rride var coneTypeOrNull: ConeKotlinType? = null\n    override val annotations: MutableList<FirAnnotation> = mutableListOf()\n    lateinit var symbol: FirTypeParameterSymbol\n\n    override fun build(): FirResolvedReifiedParameterReference {\n        return FirResolvedReifiedParameterReferenceImpl(\n            source,\n            coneTypeOrNull,\n            annotations.toMutableOrEmpty(),\n            symbol,\n        )\n    }\n\n}\n\n@OptIn(ExperimentalContracts::class)\ninline fun buildResolvedReifiedParameterReference(init: FirResolvedReifiedParameterReferenceBuilder.() -> Unit): FirResolvedReifiedParameterReference {\n    contract {\n        callsInPlace(init, InvocationKind.EXACTLY_ONCE)\n    }\n    return FirResolvedReifiedParameterReferenceBuilder().apply(init).build()\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.diagnostics\n\nimport org.jetbrains.kotlin.fir.analysis.collectors.CheckerRunningDiagnosticCollectorVisitor\nimport org.jetbrains.kotlin.fir.declarations.FirDeclaration\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.diagnostics.fir.LLFirStructureElementDiagnosticsCollector\nimport org.jetbrains.kotlin.fir.analysis.collectors.DiagnosticCollectorComponents\n\ninternal class FileStructureElementDiagnosticsCollector private constructor(private val useExtendedCheckers: Boolean) {\n    companion object {\n        val USUAL_COLLECTOR = FileStructureElementDiagnosticsCollector(useExtendedCheckers = false)\n        val EXTENDED_COLLECTOR = FileStructureElementDiagnosticsCollector(useExtendedCheckers = true)\n    }\n\n    fun collectForStructureElement(\n        firDeclaration: FirDeclaration,\n        createVisitor: (components: DiagnosticCollectorComponents) -> CheckerRunningDiagnosticCollectorVisitor,\n    ): FileStructureElementDiagnosticLis"}
{"code": "t {\n        val reporter = LLFirDiagnosticReporter()\n        val collector = LLFirStructureElementDiagnosticsCollector(\n            firDeclaration.moduleData.session,\n            createVisitor,\n            useExtendedCheckers,\n        )\n        collector.collectDiagnostics(firDeclaration, reporter)\n        val source = firDeclaration.source\n        if (source != null) {\n            reporter.checkAndCommitReportsOn(source, null)\n        }\n        return FileStructureElementDiagnosticList(reporter.committedDiagnostics)\n    }\n}\n"}
{"code": "// FILE: main.kt\nclass SortedSet\n\nfun test() {\n    val a = <expr>java.util.SortedSet</expr>\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.intrinsics\n\nimport org.jetbrains.kotlin.codegen.AsmUtil\nimport org.jetbrains.kotlin.codegen.Callable\nimport org.jetbrains.kotlin.codegen.CallableMethod\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\n\nclass HashCode : IntrinsicMethod() {\n    override fun toCallable(method: CallableMethod): Callable {\n        val receiverType = method.dispatchReceiverType ?: method.extensionReceiverType ?: error(\"No receiver for callable: $method\")\n        val useObjectHashCode = !AsmUtil.isPrimitive(receiverType)\n        return object : IntrinsicCallable(\n                Type.INT_TYPE,\n                emptyList(),\n                if (useObjectHashCode) nullOrObject(method.dispatchReceiverType) else method.dispatchReceiverType,\n                if (useObjectHashCode) nullOrObject(method.extensionReceiverType) e"}
{"code": "lse method.extensionReceiverType\n        ) {\n            override fun invokeIntrinsic(v: InstructionAdapter) {\n                v.invokeHashCode(if (useObjectHashCode) AsmTypes.OBJECT_TYPE else receiverType)\n            }\n        }\n    }\n\n    companion object {\n        fun InstructionAdapter.invokeHashCode(type: Type) {\n            if (AsmUtil.isPrimitive(type)) {\n                val boxedType = AsmUtil.boxType(type)\n                visitMethodInsn(Opcodes.INVOKESTATIC, boxedType.internalName, \"hashCode\", Type.getMethodDescriptor(Type.INT_TYPE, type), false)\n            }\n            else {\n                visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/Object\", \"hashCode\", \"()I\", false)\n            }\n        }\n    }\n}\n"}
{"code": "class Foo private constructor() {\n    companion object Helper {\n        operator fun invoke() {}\n    }\n}\n\nfun test() {\n    <expr>Foo</expr>()\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.backend.native\n\nimport org.jetbrains.kotlin.descriptors.Visibilities\nimport org.jetbrains.kotlin.descriptors.Visibility\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.backend.native.interop.decodeObjCMethodAnnotation\nimport org.jetbrains.kotlin.fir.backend.native.interop.isObjCClass\nimport org.jetbrains.kotlin.fir.containingClassLookupTag\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.resolve.toSymbol\nimport org.jetbrains.kotlin.fir.scopes.FirOverrideChecker\nimport org.jetbrains.kotlin.fir.scopes.impl.*\nimport org.jetbrains.kotlin.fir.symbols.impl.*\n\n\nclass FirNativeOverrideChecker(private val session: FirSession) : FirOverrideChecker {\n    private val standardOverrideChecker = FirStandardOverrideChecker(session)\n\n    override fun isOverriddenFunction(overrideCandidate: FirSimpleFunction, baseDeclaration: FirSimpleFunction): Boolean =\n            overrideCandidate.isPlatformOverriddenFunction"}
{"code": "(session, baseDeclaration)\n                    ?: standardOverrideChecker.isOverriddenFunction(overrideCandidate, baseDeclaration)\n\n    override fun isOverriddenProperty(overrideCandidate: FirCallableDeclaration, baseDeclaration: FirProperty): Boolean =\n        // KT-57640: There's no necessity to implement platform-dependent overridability check for properties\n        standardOverrideChecker.isOverriddenProperty(overrideCandidate, baseDeclaration)\n\n    override fun chooseIntersectionVisibility(\n        overrides: Collection<FirCallableSymbol<*>>,\n        dispatchClassSymbol: FirRegularClassSymbol?,\n    ): Visibility {\n        return chooseIntersectionVisibilityOrNull(overrides) { it.isAbstractAccordingToRawStatus || it.isObjCClassPropertyOrAccessor(session) }\n            ?: Visibilities.Unknown\n    }\n\n    private fun FirCallableSymbol<*>.isObjCClassPropertyOrAccessor(session: FirSession) =\n        (this is FirPropertySymbol || this is FirPropertyAccessorSymbol)\n                && (con"}
{"code": "tainingClassLookupTag()?.toSymbol(session) as? FirClassSymbol<*>)?.isObjCClass(session) ?: false\n\n    \n    private fun FirSimpleFunction.isPlatformOverriddenFunction(session: FirSession, baseDeclaration: FirSimpleFunction): Boolean? {\n        if (this.name != baseDeclaration.name) {\n            return null\n        }\n        val superInfo = baseDeclaration.symbol.decodeObjCMethodAnnotation(session) ?: return null\n        val subInfo = symbol.decodeObjCMethodAnnotation(session)\n        return if (subInfo != null) {\n            // Overriding Objective-C method by Objective-C method in interop stubs.\n            // Don't even check method signatures, so this check is weaker than the standard one\n            superInfo.selector == subInfo.selector\n        } else {\n            // Overriding Objective-C method by Kotlin method.\n            if (!parameterNamesMatch(this, baseDeclaration)) false else null\n        }\n    }\n\n    \n    private fun parameterNamesMatch(first: FirSimpleFunction, second:"}
{"code": " FirSimpleFunction): Boolean {\n        // The original Objective-C method selector is represented as\n        // function name and parameter names (except first).\n\n        if (first.valueParameters.size != second.valueParameters.size) {\n            return false\n        }\n\n        first.valueParameters.forEachIndexed { index, parameter ->\n            if (index > 0 && parameter.name != second.valueParameters[index].name) {\n                return false\n            }\n        }\n\n        return true\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.asJava.classes\n\nimport com.intellij.psi.PsiElement\nimport com.intellij.psi.PsiFile\nimport com.intellij.psi.PsiTypeParameterListOwner\nimport com.intellij.psi.impl.light.LightReferenceListBuilder\nimport com.intellij.psi.impl.light.LightTypeParameterBuilder\nimport org.jetbrains.kotlin.asJava.elements.PsiElementWithOrigin\nimport org.jetbrains.kotlin.asJava.unwrapped\nimport org.jetbrains.kotlin.psi.KtTypeParameter\nimport org.jetbrains.kotlin.psi.KtTypeParameterListOwner\n\nclass KtUltraLightTypeParameter(\n    name: String,\n    private val myOwner: PsiTypeParameterListOwner,\n    private val myParent: PsiElement,\n    index: Int,\n    referenceListBuilder: (PsiElement) -> KotlinLightReferenceListBuilder\n) :\n    LightTypeParameterBuilder(name, myOwner, index),\n    PsiElementWithOrigin<KtTypeParameter> {\n\n    private val superList: LightReferenceListBuilder by lazyPub { referenceListBuilder(this) }\n\n    override val origin: KtTypeParameter get() = (myOwner.unwrapped a"}
{"code": "s KtTypeParameterListOwner).typeParameters[index]\n\n    override fun getExtendsList(): LightReferenceListBuilder = superList\n\n    override fun getParent(): PsiElement = myParent\n\n    override fun getContainingFile(): PsiFile = myOwner.containingFile\n\n    override fun getUseScope() = origin.useScope\n}"}
{"code": "val i = <expr>1</expr>"}
{"code": "// WITH_STDLIB\n// DUMP_CFG\nimport kotlin.reflect.KClass\n\nfun test(x: String): KClass<*> {\n    return x.let { it::class }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.range\n\nimport org.jetbrains.kotlin.codegen.ExpressionCodegen\nimport org.jetbrains.kotlin.codegen.range.forLoop.ForLoopGenerator\nimport org.jetbrains.kotlin.codegen.range.inExpression.InExpressionGenerator\nimport org.jetbrains.kotlin.psi.KtForExpression\nimport org.jetbrains.kotlin.psi.KtSimpleNameExpression\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\n\ninterface RangeValue {\n    fun createForLoopGenerator(codegen: ExpressionCodegen, forExpression: KtForExpression): ForLoopGenerator\n\n    fun createInExpressionGenerator(codegen: ExpressionCodegen, operatorReference: KtSimpleNameExpression): InExpressionGenerator\n}\n\n\ninterface ReversableRangeValue : RangeValue {\n    fun createForInReversedLoopGenerator(codegen: ExpressionCodegen, forExpression: KtForExpression): ForLoopGenerator\n}\n\n"}
{"code": "package test\n\nclass A\n\nclass Some(a: <caret>A)\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.decompiled\n\nimport org.jetbrains.kotlin.light.classes.symbol.base.AbstractSymbolLightClassesStructureByFqNameTest\nimport org.jetbrains.kotlin.light.classes.symbol.decompiled.test.configurators.AnalysisApiSymbolLightClassesDecompiledTestConfigurator\n\nabstract class AbstractSymbolLightClassesStructureByFqNameForLibraryTest : AbstractSymbolLightClassesStructureByFqNameTest(\n    configurator = AnalysisApiSymbolLightClassesDecompiledTestConfigurator,\n    testPrefix = \"lib\",\n    stopIfCompilationErrorDirectivePresent = true,\n)\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.checkers\n\nimport org.jetbrains.kotlin.descriptors.CallableDescriptor\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.descriptors.PropertyAccessorDescriptor\nimport org.jetbrains.kotlin.descriptors.PropertyDescriptor\nimport org.jetbrains.kotlin.descriptors.annotations.Annotations\nimport org.jetbrains.kotlin.descriptors.impl.LocalVariableDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.psi.KtAnnotationEntry\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtProperty\nimport org.jetbrains.kotlin.resolve.calls.util.getType\nimport org.jetbrains.kotlin.resolve.needsMfvcFlattening\nimport org.jetbrains.kotlin.resolve.source.getPsi\nimport org.jetbrains.kotlin.types.KotlinType\n\nobject MultiFieldValueClassAnnotationsChecker : DeclarationChecker {\n    private fun report(context: DeclarationCheckerContext, name: String, type: KotlinType, annotationEntry: K"}
{"code": "tAnnotationEntry) {\n        if (!type.needsMfvcFlattening()) return\n        context.trace.report(Errors.ANNOTATION_ON_ILLEGAL_MULTI_FIELD_VALUE_CLASS_TYPED_TARGET.on(annotationEntry, name))\n    }\n\n    override fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n        fun report(name: String, type: KotlinType, annotations: Annotations) {\n            for (annotationDescriptor in annotations) {\n                report(context, name, type, annotationDescriptor.source.getPsi() as KtAnnotationEntry)\n            }\n        }\n\n        when (descriptor) {\n            is PropertyDescriptor -> {\n                descriptor.backingField?.let { report(\"fields\", descriptor.type, it.annotations) }\n                val delegateType = (declaration as? KtProperty)?.delegateExpression?.getType(context.trace.bindingContext)\n                descriptor.delegateField?.let {\n                    if (delegateType == null) return@let\n                    re"}
{"code": "port(\"delegate fields\", delegateType, it.annotations)\n                }\n                descriptor.getter?.let { getterDescriptor ->\n                    if (getterDescriptor.contextReceiverParameters.isNotEmpty() || getterDescriptor.extensionReceiverParameter != null) return@let\n                    val type = getterDescriptor.returnType ?: return@let\n                    report(\"getters\", type, getterDescriptor.annotations)\n                }\n                descriptor.setter?.valueParameters?.single()?.let { report(\"parameters\", it.type, it.annotations) }\n                descriptor.extensionReceiverParameter?.let { report(\"receivers\", it.type, it.annotations) }\n                descriptor.contextReceiverParameters.forEach { report(\"receivers\", it.type, it.annotations) }\n            }\n            is PropertyAccessorDescriptor -> Unit\n            is LocalVariableDescriptor -> {\n                report(\"variables\", descriptor.type, descriptor.annotations)\n            }\n            is Callabl"}
{"code": "eDescriptor -> {\n                descriptor.extensionReceiverParameter?.let { report(\"receivers\", it.type, it.annotations) }\n                descriptor.contextReceiverParameters.forEach { report(\"receivers\", it.type, it.annotations) }\n                descriptor.valueParameters.forEach { report(\"parameters\", it.type, it.annotations) }\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.platform.jvm\n\nimport org.jetbrains.kotlin.config.JvmTarget\nimport org.jetbrains.kotlin.platform.SimplePlatform\nimport org.jetbrains.kotlin.platform.TargetPlatform\nimport org.jetbrains.kotlin.platform.TargetPlatformVersion\nimport org.jetbrains.kotlin.platform.toTargetPlatform\n\nabstract class JvmPlatform : SimplePlatform(\"JVM\") {\n    override val oldFashionedDescription: String\n        get() = \"JVM \"\n}\n\n@Suppress(\"DEPRECATION_ERROR\")\nobject JvmPlatforms {\n    private val UNSPECIFIED_SIMPLE_JVM_PLATFORM = JdkPlatform(JvmTarget.DEFAULT)\n    private val jvmTargetToJdkPlatform: Map<JvmTarget, TargetPlatform> =\n        JvmTarget.entries.map { it to JdkPlatform(it).toTargetPlatform() }.toMap()\n\n    // This platform is needed mostly for compatibility and migration of code base,\n    // as previously some clients used TargetPlatform just as platform-marker\n    // and didn't care about particular jvmTarget.\n    // TODO(dsavvinov): review all usages and choose proper "}
{"code": "JvmTarget\n    val unspecifiedJvmPlatform: TargetPlatform\n        get() = CompatJvmPlatform\n\n    val defaultJvmPlatform: TargetPlatform = jvmTargetToJdkPlatform[JvmTarget.DEFAULT]!!\n\n    val jvm6: TargetPlatform = jvmTargetToJdkPlatform[JvmTarget.JVM_1_6]!!\n    val jvm8: TargetPlatform = jvmTargetToJdkPlatform[JvmTarget.JVM_1_8]!!\n    val jvm11: TargetPlatform = jvmTargetToJdkPlatform[JvmTarget.JVM_11]!!\n    val jvm17: TargetPlatform = jvmTargetToJdkPlatform[JvmTarget.JVM_17]!!\n\n    fun jvmPlatformByTargetVersion(targetVersion: JvmTarget): TargetPlatform =\n        jvmTargetToJdkPlatform[targetVersion]!!\n\n    val allJvmPlatforms: List<TargetPlatform> = jvmTargetToJdkPlatform.values.toList()\n\n    @Deprecated(\n        message = \"Should be accessed only by compatibility layer, other clients should use 'unspecifiedJvmPlatform'\",\n        level = DeprecationLevel.ERROR\n    )\n    object CompatJvmPlatform : TargetPlatform(setOf(UNSPECIFIED_SIMPLE_JVM_PLATFORM)),\n        // Needed for backward co"}
{"code": "mpatibility, because old code uses INSTANCEOF checks instead of calling extensions\n        org.jetbrains.kotlin.resolve.jvm.platform.JvmPlatform {\n        override val platformName: String\n            get() = \"JVM\"\n    }\n}\n\nclass JdkPlatform(val targetVersion: JvmTarget) : JvmPlatform() {\n    override fun toString(): String = \"$platformName ($targetVersion)\"\n\n    override val oldFashionedDescription: String\n        get() = \"JVM \" + targetVersion.description\n\n    override val targetPlatformVersion: TargetPlatformVersion\n        get() = targetVersion\n\n    // TODO(dsavvinov): temporarily conservative measure; make JdkPlatform data class later\n    //  Explanation: previously we had only one JvmPlatform, and all 'TargetPlatform's had an\n    //  equality (actually, identity, because each platform had only one instance). This lead\n    //  to common pattern of putting them in map (e.g., see KotlinCacheServiceImpl.globalFacadesPerPlatformAndSdk).\n    //  .\n    //  If we start distinguishing Jvm"}
{"code": "Platforms with different JvmTarget right now, it may accidentally\n    //  break some clients (in particular, we'll create global facade for *each* JvmTarget, which is a bad idea)\n    override fun equals(other: Any?): Boolean = other is JdkPlatform\n    override fun hashCode(): Int = JdkPlatform::class.hashCode()\n}\n\n// TODO: temporarily conservative implementation; use the same approach as for TargetPlatform?.isNative()\n//  when JdkPlatform becomes a data class\nfun TargetPlatform?.isJvm(): Boolean = this?.singleOrNull() is JvmPlatform\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.providers.impl\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.openapi.util.ModificationTracker\nimport com.intellij.openapi.util.SimpleModificationTracker\nimport org.jetbrains.kotlin.analysis.providers.KotlinModificationTrackerFactory\n\npublic class KotlinStaticModificationTrackerFactory : KotlinModificationTrackerFactory() {\n    private val projectWide = SimpleModificationTracker()\n    private val librariesWide = SimpleModificationTracker()\n\n    override fun createProjectWideOutOfBlockModificationTracker(): ModificationTracker {\n        return projectWide\n    }\n\n    override fun createLibrariesWideModificationTracker(): ModificationTracker {\n        return librariesWide\n    }\n\n    internal fun incrementModificationsCount(includeBinaryTrackers: Boolean) {\n        projectWide.incModificationCount()\n        if (includeBinaryTrackers) {\n            librariesWide.incModificationCount()\n        }\n    }\n\n    public companion object {\n  "}
{"code": "      public fun getInstance(project: Project): KotlinStaticModificationTrackerFactory =\n            KotlinModificationTrackerFactory.getInstance(project) as KotlinStaticModificationTrackerFactory\n    }\n}\n"}
{"code": "typealias Alias<<expr>T</expr>> = List<T>"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.transformers\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.targets.LLFirResolveTarget\nimport org.jetbrains.kotlin.fir.FirElementWithResolveState\nimport org.jetbrains.kotlin.fir.declarations.FirProperty\nimport org.jetbrains.kotlin.fir.declarations.FirResolvePhase\nimport org.jetbrains.kotlin.fir.declarations.utils.evaluatedInitializer\nimport org.jetbrains.kotlin.fir.declarations.utils.isConst\nimport org.jetbrains.kotlin.fir.expressions.FirExpressionEvaluator\n\ninternal object LLFirConstantEvaluationLazyResolver : LLFirLazyResolver(FirResolvePhase.CONSTANT_EVALUATION) {\n    override fun createTargetResolver(target: LLFirResolveTarget): LLFirTargetResolver = LLFirConstantEvaluationTargetResolver(target)\n\n    override fun phaseSpecificCheckIsResolved(target: FirElementWithResolveState) {}\n}\n\n\nprivate class LLFirConstantEvaluationTargetResolver(resolveTarget: LLFirResolveTarget) : LLFirTargetResolver(\n    resolveTarget,\n "}
{"code": "   FirResolvePhase.CONSTANT_EVALUATION,\n) {\n    override fun doLazyResolveUnderLock(target: FirElementWithResolveState) {\n        if (target is FirProperty && target.isConst) {\n            target.evaluatedInitializer = FirExpressionEvaluator.evaluatePropertyInitializer(target, target.moduleData.session)\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.backend.native.interop\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.containingClassLookupTag\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirLiteralExpression\nimport org.jetbrains.kotlin.fir.resolve.*\nimport org.jetbrains.kotlin.fir.scopes.getDirectOverriddenFunctions\nimport org.jetbrains.kotlin.fir.scopes.impl.declaredMemberScope\nimport org.jetbrains.kotlin.fir.scopes.processAllFunctions\nimport org.jetbrains.kotlin.fir.scopes.unsubstitutedScope\nimport org.jetbrains.kotlin.fir.symbols.ConeClassLikeLookupTag\nimport org.jetbrains.kotlin.fir.symbols.impl.*\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.name.NativeStandardInteropNames\nimport org.jetbrains.kotlin.native.interop.ObjCMethodInfo\n\n\nfun FirFunctionSymbol<*>.getObjCMethodInfoFromOverriddenFunctio"}
{"code": "ns(session: FirSession, scopeSession: ScopeSession): ObjCMethodInfo? {\n    decodeObjCMethodAnnotation(session)?.let {\n        return it\n    }\n    // recursively find ObjCMethod annotation in getDirectOverriddenFunctions() (same as `overriddenDescriptors` in K1)\n    return when (val symbol = this) {\n        is FirNamedFunctionSymbol -> {\n            val firClassSymbol = containingClassLookupTag()?.toSymbol(session) as FirClassSymbol<*>?\n            firClassSymbol?.let {\n                val unsubstitutedScope = it.unsubstitutedScope(session, scopeSession, withForcedTypeCalculator = false, memberRequiredPhase = null)\n                // call of `processFunctionsByName()` is needed only for necessary side-effect before `getDirectOverriddenFunctions` call\n                unsubstitutedScope.processFunctionsByName(symbol.name) {}\n                unsubstitutedScope.getDirectOverriddenFunctions(symbol).firstNotNullOfOrNull {\n                    require(it != this) { \"Function ${symbol.name}() is"}
{"code": " wrongly contained in its own getDirectOverriddenFunctions\" }\n                    it.getObjCMethodInfoFromOverriddenFunctions(session, scopeSession)\n                }\n            }\n        }\n        else -> null\n    }\n}\n\n\nfun FirConstructorSymbol.getObjCInitMethod(session: FirSession): FirFunctionSymbol<*>? {\n    this.annotations.getAnnotationByClassId(NativeStandardInteropNames.objCConstructorClassId, session)?.let { annotation ->\n        val initSelector: String = annotation.constStringArgument(\"initSelector\")\n        val classSymbol = containingClassLookupTag()?.toSymbol(session) as FirClassSymbol<*>\n        val initSelectors = mutableListOf<FirFunctionSymbol<*>>()\n        session.declaredMemberScope(classSymbol, memberRequiredPhase = null)\n            .processAllFunctions {\n                if (it.decodeObjCMethodAnnotation(session)?.selector == initSelector)\n                    initSelectors.add(it)\n            }\n        return initSelectors.singleOrNull()\n            ?: error(\"exp"}
{"code": "ected one init method for $classSymbol $initSelector, got ${initSelectors.size}\")\n    }\n    return null\n}\n\n\ninternal fun List<FirAnnotation>.decodeObjCMethodAnnotation(session: FirSession): ObjCMethodInfo? =\n    getAnnotationByClassId(NativeStandardInteropNames.objCMethodClassId, session)?.let {\n        ObjCMethodInfo(\n            selector = it.constStringArgument(\"selector\"),\n            encoding = it.constStringArgument(\"encoding\"),\n            isStret = it.constBooleanArgumentOrNull(\"isStret\") ?: false,\n            directSymbol = getAnnotationByClassId(NativeStandardInteropNames.objCDirectClassId, session)?.constStringArgument(\"symbol\"),\n        )\n    }\n\ninternal fun FirFunctionSymbol<*>.decodeObjCMethodAnnotation(session: FirSession): ObjCMethodInfo? =\n    annotations.decodeObjCMethodAnnotation(session)\n\n\nprivate fun FirAnnotation.constStringArgument(argumentName: String): String =\n        constArgument(argumentName) as? String ?: error(\"Expected string constant value of argument '"}
{"code": "$argumentName' at annotation $this\")\n\nprivate fun FirAnnotation.constBooleanArgumentOrNull(argumentName: String): Boolean? =\n        constArgument(argumentName) as Boolean?\n\nprivate fun FirAnnotation.constArgument(argumentName: String) =\n        (argumentMapping.mapping[Name.identifier(argumentName)] as? FirLiteralExpression<*>)?.value\n\ninternal fun FirFunction.hasObjCFactoryAnnotation(session: FirSession) = this.annotations.hasAnnotation(NativeStandardInteropNames.objCFactoryClassId, session)\n\ninternal fun FirFunction.hasObjCMethodAnnotation(session: FirSession) = this.annotations.hasAnnotation(NativeStandardInteropNames.objCMethodClassId, session)\n\n\ninternal fun FirFunction.isObjCClassMethod(session: FirSession) =\n        getContainingClass(session).let { it is FirClass && it.symbol.isObjCClass(session) }\n\n\ninternal fun FirConstructorSymbol.isObjCConstructor(session: FirSession) =\n    this.annotations.hasAnnotation(NativeStandardInteropNames.objCConstructorClassId, session)\n\n\nfun Fir"}
{"code": "ClassSymbol<*>.isObjCClass(session: FirSession) = classId.packageFqName != NativeStandardInteropNames.cInteropPackage &&\n        selfOrAnySuperClass(session) {\n            it.classId == NativeStandardInteropNames.objCObjectClassId\n        }\n\nprivate fun FirClassSymbol<*>.selfOrAnySuperClass(session: FirSession, predicate: (ConeClassLikeLookupTag) -> Boolean): Boolean =\n    predicate(toLookupTag()) ||\n            lookupSuperTypes(listOf(this), lookupInterfaces = true, deep = true, session, substituteTypes = false)\n                .any { predicate(it.lookupTag) }\n\ninternal fun FirFunctionSymbol<*>.getInitMethodIfObjCConstructor(session: FirSession): FirFunctionSymbol<*>? =\n        if (this is FirConstructorSymbol && isObjCConstructor(session))\n            getObjCInitMethod(session)\n        else\n            this\n\nfun FirProperty.isExternalObjCClassProperty(session: FirSession): Boolean =\n        (containingClassLookupTag()?.toSymbol(session) as? FirClassSymbol)?.isExternalObjCClass(sessio"}
{"code": "n) == true\n\ninternal fun FirClassSymbol<*>.isExternalObjCClass(session: FirSession): Boolean =\n        isObjCClass(session) &&\n                parentsWithSelf(session).filterIsInstance<FirClassSymbol<*>>().any {\n                    it.hasAnnotation(NativeStandardInteropNames.externalObjCClassClassId, session)\n                }\n\nfun FirClassSymbol<*>.parentsWithSelf(session: FirSession): Sequence<FirClassLikeSymbol<FirClassLikeDeclaration>> {\n    return generateSequence<FirClassLikeSymbol<FirClassLikeDeclaration>>(this) { it.getContainingDeclaration(session) }\n}\n\nfun FirClassSymbol<*>.isKotlinObjCClass(session: FirSession): Boolean = isObjCClass(session) && !isExternalObjCClass(session)\n\nfun FirTypeRef.isObjCObjectType(session: FirSession): Boolean {\n    val symbol = firClassLike(session)?.symbol\n    return symbol is FirClassSymbol && symbol.isObjCClass(session)\n}\n"}
{"code": "// EXPECTED: org.jetbrains.kotlin.light.classes.symbol.methods.SymbolLightAccessorMethod\n@get:JvmName(\"getBar\")\nval <caret>p: Int\n    get() = 42"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.impl.base.test.cases.components.typeInfoProvider\n\nimport com.intellij.psi.PsiElement\nimport com.intellij.psi.impl.source.tree.LeafPsiElement\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.utils.printer.parentOfType\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtAnnotatedExpression\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.psi.KtPsiUtil.deparenthesize\nimport org.jetbrains.kotlin.psi.KtQualifiedExpression\nimport org.jetbrains.kotlin.psi.KtTreeVisitorVoid\nimport org.jetbrains.kotlin.test.builders.TestConfigurationBuilder\nimport org.jetbrains.kotlin.test.directives.ConfigurationDirectives\nimport org.jetbrains.kotlin.test.directives.model.RegisteredDirectives\nimport org.jetbrains.kotlin.test.model.TestFile\nimport org.jetbrains.kotlin.test.mod"}
{"code": "el.TestModule\nimport org.jetbrains.kotlin.test.services.AdditionalSourceProvider\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.assertions\nimport org.jetbrains.kotlin.types.Variance\nimport java.io.File\n\nabstract class AbstractIsDenotableTest : AbstractAnalysisApiBasedTest() {\n    val denotableName = Name.identifier(\"Denotable\")\n    val undenotableName = Name.identifier(\"Nondenotable\")\n\n    override fun doTestByMainModuleAndOptionalMainFile(mainFile: KtFile?, mainModule: KtTestModule, testServices: TestServices) {\n        val ktFile = mainFile ?: mainModule.ktFiles.first()\n        val actualText = buildString {\n            ktFile.accept(object : KtTreeVisitorVoid() {\n                override fun visitElement(element: PsiElement) {\n                    if (element is LeafPsiElement) {\n                        append(element.text)\n                    }\n                    super.visitElement(element)\n                }\n\n\n                overri"}
{"code": "de fun visitAnnotatedExpression(expression: KtAnnotatedExpression) {\n                    val base = expression.baseExpression\n                    if (base == null || expression.annotationEntries.none {\n                            it.shortName == denotableName || it.shortName == undenotableName\n                        }) {\n                        super.visitAnnotatedExpression(expression)\n                        return\n                    }\n\n                    analyseForTest(expression) {\n                        val parent = expression.parentOfType<KtQualifiedExpression>()\n                        // Try locating the containing PSI that is a receiver of a qualified expression because the smart cast information\n                        // is only available at that level for FE1.0. For example, consider\n                        // ```\n                        // if (a is String) {\n                        //   (@Denotable(\"...\") a).length\n                        // }\n                        /"}
{"code": "/ ```\n                        // smart cast is available for `(@Denotable(\"...\") a)` and not for `a` or `@Denotable(\"...\") a`.\n                        val ktType = if (parent != null && deparenthesize(parent.receiverExpression) == deparenthesize(base)) {\n                            parent.receiverExpression.getKtType()\n                        } else {\n                            expression.getKtType()\n                        }\n                        val actualHasDenotableType = ktType?.isDenotable ?: error(\"${base.text} does not have a type.\")\n                        when (actualHasDenotableType) {\n                            true -> append(\"@Denotable\")\n                            false -> append(\"@Nondenotable\")\n                        }\n                        append(\"(\\\"${ktType.render(position = Variance.INVARIANT)}\\\") \")\n                        append(base.text)\n                    }\n                }\n            })\n        }\n        testServices.assertions.assertEqualsToFile(te"}
{"code": "stDataPath, actualText)\n    }\n\n    override fun configureTest(builder: TestConfigurationBuilder) {\n        super.configureTest(builder)\n        builder.useAdditionalSourceProviders(AbstractIsDenotableTest::TestHelperProvider)\n        builder.defaultDirectives {\n            +ConfigurationDirectives.WITH_STDLIB\n        }\n    }\n\n    private class TestHelperProvider(testServices: TestServices) : AdditionalSourceProvider(testServices) {\n        override fun produceAdditionalFiles(globalDirectives: RegisteredDirectives, module: TestModule): List<TestFile> {\n            return listOf(File(\"analysis/analysis-api/testData/helpers/isDenotable/helpers.kt\").toTestFile())\n        }\n    }\n}"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.types\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirAnnotationContainer\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.FirPureAbstractElement\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\n\nsealed class FirTypeRef : FirPureAbstractElement(), FirAnnotationContainer {\n    abstract override val source: KtSourceElement?\n    abstract override val annotations: List<FirAnnotation>\n\n    override fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitTypeRef(this, data)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transformer.transformTypeRef(this, da"}
{"code": "ta) as E\n\n    abstract override fun replaceAnnotations(newAnnotations: List<FirAnnotation>)\n\n    abstract override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirTypeRef\n}\n"}
{"code": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE_K1\nannotation class ReceiverAnnotation\n@Target(AnnotationTarget.TYPE)\nannotation class ReceiverTypeAnnotation\n\nval @receiver:ReceiverAnnotation @ReceiverTypeAnnotation Long.prop: Boolean get() = { t<caret>his == 1 }\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cli.jvm.javac\n\nimport com.intellij.mock.MockProject\nimport com.sun.tools.javac.util.Context\nimport org.jetbrains.kotlin.asJava.LightClassGenerationSupport\nimport org.jetbrains.kotlin.cli.common.CLIConfigurationKeys\nimport org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.ERROR\nimport org.jetbrains.kotlin.cli.jvm.compiler.JvmPackagePartProvider\nimport org.jetbrains.kotlin.cli.jvm.config.jvmClasspathRoots\nimport org.jetbrains.kotlin.config.CompilerConfiguration\nimport org.jetbrains.kotlin.config.JVMConfigurationKeys\nimport org.jetbrains.kotlin.javac.JavacWrapper\nimport org.jetbrains.kotlin.psi.KtFile\nimport java.io.File\n\nobject JavacWrapperRegistrar {\n    private const val JAVAC_CONTEXT_CLASS = \"com.sun.tools.javac.util.Context\"\n\n    fun registerJavac(\n        project: MockProject,\n        configuration: CompilerConfiguration,\n        javaFiles: List<File>,\n        kotlinFiles: List<KtFile>,\n        arguments: Array<String>?,\n        bootClas"}
{"code": "spath: List<File>?,\n        sourcePath: List<File>?,\n        lightClassGenerationSupport: LightClassGenerationSupport,\n        packagePartsProviders: List<JvmPackagePartProvider>\n    ): Boolean {\n        val messageCollector = configuration.getNotNull(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY)\n\n        try {\n            Class.forName(JAVAC_CONTEXT_CLASS)\n        } catch (e: ClassNotFoundException) {\n            messageCollector.report(ERROR, \"'$JAVAC_CONTEXT_CLASS' class can't be found ('tools.jar' is not found)\")\n            return false\n        }\n\n        val context = Context()\n        JavacLogger.preRegister(context, messageCollector)\n\n        val jvmClasspathRoots = configuration.jvmClasspathRoots\n        val outputDirectory = configuration.get(JVMConfigurationKeys.OUTPUT_DIRECTORY)\n        val compileJava = configuration.getBoolean(JVMConfigurationKeys.COMPILE_JAVA)\n        val kotlinSupertypesResolver = JavacWrapperKotlinResolverImpl(lightClassGenerationSupport)\n\n        val ja"}
{"code": "vacWrapper = JavacWrapper(\n            javaFiles, kotlinFiles, arguments, jvmClasspathRoots, bootClasspath, sourcePath,\n            kotlinSupertypesResolver, packagePartsProviders, compileJava, outputDirectory, context\n        )\n\n        project.registerService(JavacWrapper::class.java, javacWrapper)\n\n        return true\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.fir.declarations.FirValueParameter\nimport org.jetbrains.kotlin.name.SpecialNames\n\nopen class FirValueParameterRenderer {\n    internal lateinit var components: FirRendererComponents\n    protected val printer get() = components.printer\n    protected val visitor get() = components.visitor\n    private val annotationRenderer get() = components.annotationRenderer\n    protected val declarationRenderer get() = components.declarationRenderer\n    private val modifierRenderer get() = components.modifierRenderer\n    protected val typeRenderer get() = components.typeRenderer\n\n    fun renderParameters(valueParameters: List<FirValueParameter>) {\n        printer.print(\"(\")\n        for ((index, valueParameter) in valueParameters.withIndex()) {\n            if (index > 0) {\n                printer.print(\", \")\n            }\n            renderParameter(valueParameter)\n        }\n        printer.print(\")\")\n    }\n\n    fun renderParameter"}
{"code": "(valueParameter: FirValueParameter) {\n        declarationRenderer?.renderPhaseAndAttributes(valueParameter)\n        annotationRenderer?.render(valueParameter)\n        modifierRenderer?.renderModifiers(valueParameter)\n        if (valueParameter.name != SpecialNames.NO_NAME_PROVIDED) {\n            printer.print(valueParameter.name.toString() + \": \")\n        }\n\n        renderParameterType(valueParameter)\n        renderDefaultValue(valueParameter)\n    }\n\n    protected open fun renderParameterType(valueParameter: FirValueParameter) {\n        valueParameter.returnTypeRef.accept(visitor)\n    }\n\n    protected open fun renderDefaultValue(valueParameter: FirValueParameter) {\n        valueParameter.defaultValue?.let {\n            printer.print(\" = \")\n            it.accept(visitor)\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.context\n\nimport kotlinx.collections.immutable.PersistentList\nimport kotlinx.collections.immutable.PersistentSet\nimport kotlinx.collections.immutable.persistentListOf\nimport kotlinx.collections.immutable.persistentSetOf\nimport org.jetbrains.kotlin.fir.FirAnnotationContainer\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.analysis.checkers.declaration.FirInlineDeclarationChecker\nimport org.jetbrains.kotlin.fir.analysis.checkers.declaration.createInlineFunctionBodyContext\nimport org.jetbrains.kotlin.fir.declarations.FirDeclaration\nimport org.jetbrains.kotlin.fir.declarations.FirFile\nimport org.jetbrains.kotlin.fir.declarations.FirFunction\nimport org.jetbrains.kotlin.fir.expressions.FirGetClassCall\nimport org.jetbrains.kotlin.fir.expressions.FirStatement\nimport org.jetbrains.kotlin.fir.resolve.PersistentImplicitReceiverStack\nimport org.jetbrains.kotlin.fir.resolve.SessionHolder\nimport org.jetbrains.kotlin.fir.r"}
{"code": "esolve.calls.ImplicitReceiverValue\nimport org.jetbrains.kotlin.fir.resolve.transformers.ReturnTypeCalculator\nimport org.jetbrains.kotlin.name.Name\n\nclass PersistentCheckerContext private constructor(\n    override val implicitReceiverStack: PersistentImplicitReceiverStack,\n    override val containingDeclarations: PersistentList<FirDeclaration>,\n    override val callsOrAssignments: PersistentList<FirStatement>,\n    override val getClassCalls: PersistentList<FirGetClassCall>,\n    override val annotationContainers: PersistentList<FirAnnotationContainer>,\n    override val containingElements: PersistentList<FirElement>,\n    override val isContractBody: Boolean,\n    override val inlineFunctionBodyContext: FirInlineDeclarationChecker.InlineFunctionBodyContext?,\n    sessionHolder: SessionHolder,\n    returnTypeCalculator: ReturnTypeCalculator,\n    override val suppressedDiagnostics: PersistentSet<String>,\n    allInfosSuppressed: Boolean,\n    allWarningsSuppressed: Boolean,\n    allErrorsSuppresse"}
{"code": "d: Boolean,\n    override val containingFile: FirFile?,\n) : CheckerContextForProvider(sessionHolder, returnTypeCalculator, allInfosSuppressed, allWarningsSuppressed, allErrorsSuppressed) {\n    constructor(sessionHolder: SessionHolder, returnTypeCalculator: ReturnTypeCalculator) : this(\n        PersistentImplicitReceiverStack(),\n        persistentListOf(),\n        persistentListOf(),\n        persistentListOf(),\n        persistentListOf(),\n        persistentListOf(),\n        isContractBody = false,\n        inlineFunctionBodyContext = null,\n        sessionHolder,\n        returnTypeCalculator,\n        persistentSetOf(),\n        allInfosSuppressed = false,\n        allWarningsSuppressed = false,\n        allErrorsSuppressed = false,\n        containingFile = null,\n    )\n\n    override fun addImplicitReceiver(name: Name?, value: ImplicitReceiverValue<*>): PersistentCheckerContext =\n        copy(implicitReceiverStack = implicitReceiverStack.add(name, value))\n\n    override fun addDeclaration(declar"}
{"code": "ation: FirDeclaration): PersistentCheckerContext =\n        copy(containingDeclarations = containingDeclarations.add(declaration))\n\n    override fun dropDeclaration() {}\n\n    override fun addCallOrAssignment(qualifiedAccessOrAnnotationCall: FirStatement): PersistentCheckerContext =\n        copy(\n            qualifiedAccessOrAssignmentsOrAnnotationCalls =\n            callsOrAssignments.add(qualifiedAccessOrAnnotationCall)\n        )\n\n    override fun dropCallOrAssignment() {}\n\n    override fun addGetClassCall(getClassCall: FirGetClassCall): PersistentCheckerContext =\n        copy(getClassCalls = getClassCalls.add(getClassCall))\n\n    override fun dropGetClassCall() {}\n\n    override fun addAnnotationContainer(annotationContainer: FirAnnotationContainer): PersistentCheckerContext =\n        copy(annotationContainers = annotationContainers.add(annotationContainer))\n\n    override fun dropAnnotationContainer() {}\n\n    override fun addElement(element: FirElement): PersistentCheckerContext =\n     "}
{"code": "   copy(containingElements = containingElements.add(element))\n\n    override fun dropElement() {}\n\n    override fun addSuppressedDiagnostics(\n        diagnosticNames: Collection<String>,\n        allInfosSuppressed: Boolean,\n        allWarningsSuppressed: Boolean,\n        allErrorsSuppressed: Boolean\n    ): CheckerContextForProvider {\n        if (diagnosticNames.isEmpty()) return this\n        return copy(\n            suppressedDiagnostics = suppressedDiagnostics.addAll(diagnosticNames),\n            allInfosSuppressed = this.allInfosSuppressed || allInfosSuppressed,\n            allWarningsSuppressed = this.allWarningsSuppressed || allWarningsSuppressed,\n            allErrorsSuppressed = this.allErrorsSuppressed || allErrorsSuppressed\n        )\n    }\n\n    private fun copy(\n        implicitReceiverStack: PersistentImplicitReceiverStack = this.implicitReceiverStack,\n        qualifiedAccessOrAssignmentsOrAnnotationCalls: PersistentList<FirStatement> = this.callsOrAssignments,\n        getClass"}
{"code": "Calls: PersistentList<FirGetClassCall> = this.getClassCalls,\n        annotationContainers: PersistentList<FirAnnotationContainer> = this.annotationContainers,\n        containingElements: PersistentList<FirElement> = this.containingElements,\n        containingDeclarations: PersistentList<FirDeclaration> = this.containingDeclarations,\n        isContractBody: Boolean = this.isContractBody,\n        inlineFunctionBodyContext: FirInlineDeclarationChecker.InlineFunctionBodyContext? = this.inlineFunctionBodyContext,\n        allInfosSuppressed: Boolean = this.allInfosSuppressed,\n        allWarningsSuppressed: Boolean = this.allWarningsSuppressed,\n        allErrorsSuppressed: Boolean = this.allErrorsSuppressed,\n        suppressedDiagnostics: PersistentSet<String> = this.suppressedDiagnostics,\n        containingFile: FirFile? = this.containingFile,\n    ): PersistentCheckerContext {\n        return PersistentCheckerContext(\n            implicitReceiverStack,\n            containingDeclarations,\n    "}
{"code": "        qualifiedAccessOrAssignmentsOrAnnotationCalls,\n            getClassCalls,\n            annotationContainers,\n            containingElements,\n            isContractBody,\n            inlineFunctionBodyContext,\n            sessionHolder,\n            returnTypeCalculator,\n            suppressedDiagnostics,\n            allInfosSuppressed, allWarningsSuppressed, allErrorsSuppressed, containingFile,\n        )\n    }\n\n    private fun toggleContractBody(newValue: Boolean): CheckerContextForProvider {\n        check(isContractBody != newValue)\n\n        return copy(isContractBody = newValue)\n    }\n\n    override fun enterContractBody(): CheckerContextForProvider = toggleContractBody(newValue = true)\n\n    override fun exitContractBody(): CheckerContextForProvider = toggleContractBody(newValue = false)\n\n    override fun setInlineFunctionBodyContext(context: FirInlineDeclarationChecker.InlineFunctionBodyContext) =\n        copy(inlineFunctionBodyContext = context)\n\n    override fun unsetInlineFun"}
{"code": "ctionBodyContext(): CheckerContextForProvider = copy(inlineFunctionBodyContext = null)\n\n    override fun enterFile(file: FirFile): CheckerContextForProvider = copy(containingFile = file)\n\n    override fun exitFile(file: FirFile): CheckerContextForProvider = copy(containingFile = null)\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.expressions\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.types.FirTypeProjection\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\n\nabstract class FirAnnotation : FirExpression() {\n    abstract override val source: KtSourceElement?\n    @UnresolvedExpressionTypeAccess\n    abstract override val coneTypeOrNull: ConeKotlinType?\n    abstract override val annotations: List<FirAnnotation>\n    abstract val useSiteTarget: AnnotationUseSiteTarget?\n    abstract val annotationTypeRef: FirTypeRef\n    abstract val argumentMapping: FirAnnota"}
{"code": "tionArgumentMapping\n    abstract val typeArguments: List<FirTypeProjection>\n\n    override fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitAnnotation(this, data)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transformer.transformAnnotation(this, data) as E\n\n    abstract override fun replaceConeTypeOrNull(newConeTypeOrNull: ConeKotlinType?)\n\n    abstract override fun replaceAnnotations(newAnnotations: List<FirAnnotation>)\n\n    abstract fun replaceUseSiteTarget(newUseSiteTarget: AnnotationUseSiteTarget?)\n\n    abstract fun replaceAnnotationTypeRef(newAnnotationTypeRef: FirTypeRef)\n\n    abstract fun replaceArgumentMapping(newArgumentMapping: FirAnnotationArgumentMapping)\n\n    abstract fun replaceTypeArguments(newTypeArguments: List<FirTypeProjection>)\n\n    abstract override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirAnnotation\n\n    abstract f"}
{"code": "un <D> transformAnnotationTypeRef(transformer: FirTransformer<D>, data: D): FirAnnotation\n\n    abstract fun <D> transformTypeArguments(transformer: FirTransformer<D>, data: D): FirAnnotation\n}\n"}
{"code": "package second\n\nclass MyClass {\n    val prop = object : B<String> {\n        override fun foo<caret>(x: String) = Unit\n    }\n}\n\n// FILE: B.kt\ninterface B<T>: C<T>, D<T>\n\n// FILE: C.kt\ninterface C<T> {\n    fun foo(x: T) = Unit\n}\n\n// FILE: D.kt\ninterface D<F> {\n    fun foo(x: F) = Unit\n}"}
{"code": "// SKIP_WHEN_OUT_OF_CONTENT_ROOT\n// MODULE: lib\n// MODULE_KIND: LibraryBinary\n// FILE: BaseKotlin.kt\nopen class BaseKotlin : BaseJava() {\n    override fun getSomething(): String = \"42\"\n}\n\n// FILE: BaseJava.java\npublic class BaseJava {\n    public String getSomething() {\n        return \"\";\n    }\n\n    public void setSomething(String s) {\n\n    }\n}\n\n// MODULE: main(lib)\n// MEMBER_NAME_FILTER: something\n// FILE: main.kt\nclass Deri<caret>ved : BaseKotlin() {\n    override fun setSomething(s: String) {\n\n    }\n}\n"}
{"code": "class A {\n    class B {\n        class C {\n            val x = 10\n        }\n    }\n}\n\nfun x() {\n    <expr>A.B</expr>.C().x\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.decompiler.stub.file\n\nimport com.intellij.openapi.vfs.VirtualFile\nimport org.jetbrains.kotlin.load.java.structure.JavaClass\nimport org.jetbrains.kotlin.load.java.structure.classId\nimport org.jetbrains.kotlin.load.kotlin.KotlinClassFinder\nimport org.jetbrains.kotlin.load.kotlin.KotlinClassFinder.Result.KotlinClass\nimport org.jetbrains.kotlin.metadata.jvm.deserialization.JvmMetadataVersion\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport java.io.InputStream\n\nclass DirectoryBasedClassFinder(\n    val packageDirectory: VirtualFile,\n    val directoryPackageFqName: FqName\n) : KotlinClassFinder {\n    override fun findKotlinClassOrContent(javaClass: JavaClass, jvmMetadataVersion: JvmMetadataVersion): KotlinClassFinder.Result? =\n        findKotlinClassOrContent(javaClass.classId!!, jvmMetadataVersion)\n\n    override fun findKotlinClassOrContent(classId: ClassId, jvmMetadataVersion: JvmMetadataVersion): KotlinClassFinde"}
{"code": "r.Result? {\n        if (classId.packageFqName != directoryPackageFqName) {\n            return null\n        }\n        val targetName = classId.relativeClassName.pathSegments().joinToString(\"$\", postfix = \".class\")\n        val virtualFile = packageDirectory.findChild(targetName)\n        if (virtualFile != null && isKotlinWithCompatibleAbiVersion(virtualFile, jvmMetadataVersion)) {\n            return ClsKotlinBinaryClassCache.getInstance().getKotlinBinaryClass(virtualFile)?.let(::KotlinClass)\n        }\n        return null\n    }\n\n    // TODO\n    override fun findMetadata(classId: ClassId): InputStream? = null\n\n    // TODO\n    override fun findMetadataTopLevelClassesInPackage(packageFqName: FqName): Set<String>? = null\n\n    // TODO\n    override fun hasMetadataPackage(fqName: FqName): Boolean = false\n\n    // TODO: load built-ins from packageDirectory?\n    override fun findBuiltInsData(packageFqName: FqName): InputStream? = null\n}\n\n\nprivate fun isKotlinWithCompatibleAbiVersion(file: VirtualFi"}
{"code": "le, jvmMetadataVersion: JvmMetadataVersion): Boolean {\n    val clsKotlinBinaryClassCache = ClsKotlinBinaryClassCache.getInstance()\n    if (!clsKotlinBinaryClassCache.isKotlinJvmCompiledFile(file)) return false\n\n    val kotlinClass = clsKotlinBinaryClassCache.getKotlinBinaryClassHeaderData(file)\n    return kotlinClass != null && kotlinClass.metadataVersion.isCompatible(jvmMetadataVersion)\n}\n\n\n"}
{"code": "class Foo {\n  fun invoke(vararg a: Any) {}\n}\n\nfun test(f: Foo) {\n  f <caret>{}\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cli.common\n\nimport com.intellij.ide.highlighter.JavaFileType\nimport com.intellij.openapi.project.Project\nimport org.jetbrains.kotlin.KtSourceFile\nimport org.jetbrains.kotlin.KtVirtualFileSourceFile\nimport org.jetbrains.kotlin.cli.common.config.kotlinSourceRoots\nimport org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity\nimport org.jetbrains.kotlin.cli.common.messages.MessageCollector\nimport org.jetbrains.kotlin.cli.jvm.compiler.VfsBasedProjectEnvironment\nimport org.jetbrains.kotlin.cli.jvm.compiler.forAllFiles\nimport org.jetbrains.kotlin.cli.jvm.compiler.getSourceRootsCheckingForDuplicates\nimport org.jetbrains.kotlin.config.CommonConfigurationKeys\nimport org.jetbrains.kotlin.config.CompilerConfiguration\nimport org.jetbrains.kotlin.idea.KotlinFileType\nimport java.util.TreeSet\n\nprivate const val kotlinFileExtensionWithDot = \".${KotlinFileType.EXTENSION}\"\nprivate const val javaFileExtensionWithDot = \".${JavaFileType.DEFAULT_EXTENSION}\"\n\ndata clas"}
{"code": "s GroupedKtSources(\n    val platformSources: Collection<KtSourceFile>,\n    val commonSources: Collection<KtSourceFile>,\n    val sourcesByModuleName: Map<String, Set<KtSourceFile>>,\n) {\n    fun isEmpty(): Boolean = platformSources.isEmpty() && commonSources.isEmpty()\n}\n\nfun collectSources(\n    compilerConfiguration: CompilerConfiguration,\n    projectEnvironment: VfsBasedProjectEnvironment,\n    messageCollector: MessageCollector\n): GroupedKtSources {\n    return collectSources(compilerConfiguration, projectEnvironment.project, messageCollector)\n}\n\nprivate val ktSourceFileComparator = Comparator<KtSourceFile> { o1, o2 ->\n    val path1 = o1.path ?: error(\"Expected a file with a well-defined path\")\n    val path2 = o2.path ?: error(\"Expected a file with a well-defined path\")\n    path1.compareTo(path2)\n}\n\nfun collectSources(\n    compilerConfiguration: CompilerConfiguration,\n    project: Project,\n    messageCollector: MessageCollector\n): GroupedKtSources {\n    val platformSources = TreeSet(ktSo"}
{"code": "urceFileComparator)\n    val commonSources = TreeSet(ktSourceFileComparator)\n    val sourcesByModuleName = mutableMapOf<String, MutableSet<KtSourceFile>>()\n\n    // TODO: the scripts checking should be part of the scripting plugin functionality, as it is implemented now in ScriptingProcessSourcesBeforeCompilingExtension\n    // TODO: implement in the next round of K2 scripting support (https://youtrack.jetbrains.com/issue/KT-55728)\n    val skipScriptsInLtMode = compilerConfiguration.getBoolean(CommonConfigurationKeys.USE_FIR) &&\n            compilerConfiguration.getBoolean(CommonConfigurationKeys.USE_LIGHT_TREE)\n    var skipScriptsInLtModeWarning = false\n\n    getSourceRootsCheckingForDuplicates(compilerConfiguration, messageCollector).forAllFiles(\n        compilerConfiguration,\n        project\n    ) { virtualFile, isCommon, moduleName ->\n        val file = KtVirtualFileSourceFile(virtualFile)\n        when {\n            file.path.endsWith(javaFileExtensionWithDot) -> {}\n            file.pa"}
{"code": "th.endsWith(kotlinFileExtensionWithDot) || !skipScriptsInLtMode -> {\n                if (isCommon) commonSources.add(file)\n                else platformSources.add(file)\n\n                if (moduleName != null) {\n                    sourcesByModuleName.getOrPut(moduleName) { mutableSetOf() }.add(file)\n                }\n            }\n            else -> {\n                // temporarily assume it is a script, see the TODO above\n                skipScriptsInLtModeWarning = true\n            }\n        }\n    }\n\n    if (skipScriptsInLtModeWarning) {\n        // TODO: remove then Scripts are supported in LT (probably different K2 extension should be written for handling the case properly)\n        messageCollector.report(\n            CompilerMessageSeverity.STRONG_WARNING,\n            \"Scripts are not yet supported with K2 in LightTree mode, consider using K1 or disable LightTree mode with -Xuse-fir-lt=false\"\n        )\n    }\n    return GroupedKtSources(platformSources, commonSources, sourcesByMo"}
{"code": "duleName)\n}\n"}
{"code": "class A(a: Int) {\n    constructor() : <caret>this(2)\n}\n"}
{"code": "class A<X> {\n   fun <Y> foo(x: X, y: Y): Map<X, Y>\n\n   val map: Map<X, String>\n}\n\nfun foo(a: A<Int>) {\n   println(<expr>a</expr>)\n}"}
{"code": "val i: Int\nval j = 1\nval s = \"\"\nfun procedure() {}\nfun procedure(i: Int) {}\nfun returnIntOne() = 1\nfun id(i: Int) = i\nfun throwException() = throw Exception()"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\", \"unused\")\n\npackage org.jetbrains.kotlin.fir.expressions.builder\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirLabel\nimport org.jetbrains.kotlin.fir.builder.FirBuilderDsl\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirBlock\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.expressions.FirLoop\n\n@FirBuilderDsl\ninterface FirLoopBuilder {\n    abstract var source: KtSourceElement?\n    abstract val annotations: MutableList<FirAnnotation>\n    abstract var block: FirBlock\n    abstract var condition: FirExpression\n    abstract var label: FirLabel?\n    fun build(): FirLoop\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.type\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.FirFunctionTypeParameter\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.defaultValueForParameter\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.resolve.diagnostics.ConeUnsupportedDefaultValueInFunctionType\n\nobject FirUnsupportedDefaultValueInFunctionTypeParameterChecker : FirFunctionalTypeParameterSyntaxChecker() {\n    override fun checkPsiOrLightTree(\n        element: FirFunctionTypeParameter,\n        source: KtSourceElement,\n        context: CheckerContext,\n        reporter: DiagnosticReporter\n    ) {\n        val defaultValue = source.defaultValueForParameter ?: return\n        report(defaultValue, reporter, context)\n    }\n\n"}
{"code": "    private fun report(defaultValueSource: KtSourceElement, reporter: DiagnosticReporter, context: CheckerContext) {\n        val diagnostic = ConeUnsupportedDefaultValueInFunctionType(defaultValueSource)\n        reporter.reportOn(diagnostic.source, FirErrors.UNSUPPORTED, diagnostic.reason, context)\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve\n\nimport com.google.common.collect.HashMultimap\nimport com.google.common.collect.Multimap\nimport org.jetbrains.kotlin.descriptors.ClassifierDescriptor\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.descriptors.MemberDescriptor\nimport org.jetbrains.kotlin.descriptors.PropertyDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.diagnostics.Errors.REDECLARATION\nimport org.jetbrains.kotlin.diagnostics.reportOnDeclaration\nimport org.jetbrains.kotlin.incremental.components.LookupLocation\nimport org.jetbrains.kotlin.incremental.components.NoLookupLocation\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtElement\nimport org.jetbrains.kotlin.psi.KtPackageDirective\nimport org.jetbrains.kotlin.resolve.lazy.FileScopeProvider\nimport org.jetbrains.kotlin.resolve.lazy.TopLevelDescriptorProvider\nimport org.jetbrains.kotlin.utils"}
{"code": ".addIfNotNull\nimport org.jetbrains.kotlin.utils.keysToMap\nimport java.util.*\n\nclass DeclarationResolver(\n    private val annotationResolver: AnnotationResolver,\n    private val trace: BindingTrace\n) {\n\n    fun resolveAnnotationsOnFiles(c: TopDownAnalysisContext, scopeProvider: FileScopeProvider) {\n        val filesToScope = c.files.keysToMap { scopeProvider.getFileResolutionScope(it) }\n        for ((file, fileScope) in filesToScope) {\n            annotationResolver.resolveAnnotationsWithArguments(fileScope, file.annotationEntries, trace)\n            annotationResolver.resolveAnnotationsWithArguments(fileScope, file.danglingAnnotations, trace)\n        }\n    }\n\n    fun checkRedeclarations(c: TopDownAnalysisContext) {\n        for (classDescriptor in c.declaredClasses.values) {\n            val descriptorMap = HashMultimap.create<Name, DeclarationDescriptor>()\n            for (desc in classDescriptor.unsubstitutedMemberScope.getContributedDescriptors()) {\n                if (desc is Classif"}
{"code": "ierDescriptor || desc is PropertyDescriptor) {\n                    descriptorMap.put(desc.name, desc)\n                }\n            }\n\n            reportRedeclarationsWithClassifiers(descriptorMap)\n        }\n    }\n\n    private fun reportRedeclarationsWithClassifiers(descriptorMap: Multimap<Name, DeclarationDescriptor>) {\n        for (name in descriptorMap.keySet()) {\n            val descriptors = descriptorMap[name]\n            if (descriptors.size > 1 && descriptors.any { it is ClassifierDescriptor }) {\n                for (descriptor in descriptors) {\n                    reportOnDeclaration(trace, descriptor) { REDECLARATION.on(it, descriptors) }\n                }\n            }\n        }\n    }\n\n    fun checkRedeclarationsInPackages(\n        topLevelDescriptorProvider: TopLevelDescriptorProvider,\n        topLevelFqNames: Multimap<FqName, KtElement>\n    ) {\n        for ((fqName, declarationsOrPackageDirectives) in topLevelFqNames.asMap()) {\n            if (fqName.isRoot) continue\n\n    "}
{"code": "        // TODO: report error on expected class and actual val, or vice versa\n            val (expected, actual) =\n                    getTopLevelDescriptorsByFqName(topLevelDescriptorProvider, fqName, NoLookupLocation.WHEN_CHECK_DECLARATION_CONFLICTS)\n                        .partition { it is MemberDescriptor && it.isExpect }\n\n            for (descriptors in listOf(expected, actual)) {\n                if (descriptors.size > 1) {\n                    for (directive in declarationsOrPackageDirectives) {\n                        val reportAt = (directive as? KtPackageDirective)?.nameIdentifier ?: directive\n                        trace.report(Errors.PACKAGE_OR_CLASSIFIER_REDECLARATION.on(reportAt, fqName.shortName().asString()))\n                    }\n                }\n            }\n        }\n    }\n\n    private fun getTopLevelDescriptorsByFqName(\n        topLevelDescriptorProvider: TopLevelDescriptorProvider,\n        fqName: FqName,\n        location: LookupLocation\n    ): Set<DeclarationDe"}
{"code": "scriptor> {\n        val descriptors = HashSet<DeclarationDescriptor>()\n\n        descriptors.addIfNotNull(topLevelDescriptorProvider.getPackageFragment(fqName))\n        descriptors.addAll(topLevelDescriptorProvider.getTopLevelClassifierDescriptors(fqName, location))\n        return descriptors\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental.storage\n\nimport junit.framework.TestCase.assertEquals\nimport junit.framework.TestCase.assertNull\nimport org.jetbrains.kotlin.incremental.IncrementalCompilationContext\nimport org.junit.After\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\nimport org.junit.rules.TemporaryFolder\nimport java.io.File\nimport kotlin.test.assertFailsWith\n\nclass SourceToOutputFilesMapTest {\n\n    @get:Rule\n    val tmpDir = TemporaryFolder()\n\n    private lateinit var srcDir: File\n    private lateinit var classesDir: File\n\n    private lateinit var stofMap: SourceToOutputFilesMap\n\n    private lateinit var fooDotKt: File\n    private lateinit var fooDotClass: File\n\n    @Before\n    fun setUp() {\n        val workingDir = tmpDir.root\n\n        srcDir = workingDir.resolve(\"src\")\n        classesDir = workingDir.resolve(\"classes\")\n\n        stofMap = SourceToOutputFilesMap(\n            storageFile = workingDir.resolve(\"stof.tab\"),\n            icContext = Incremen"}
{"code": "talCompilationContext(\n                pathConverterForSourceFiles = RelocatableFileToPathConverter(srcDir),\n                pathConverterForOutputFiles = RelocatableFileToPathConverter(classesDir),\n            )\n        )\n\n        fooDotKt = srcDir.resolve(\"Foo.kt\")\n        fooDotClass = classesDir.resolve(\"Foo.class\")\n    }\n\n    @After\n    fun tearDown() {\n        stofMap.close()\n    }\n\n    @Test\n    fun testNoSetGetReturnsNull() {\n        assertNull(stofMap[fooDotKt])\n    }\n\n    @Test\n    fun testSetOneGetReturnsOne() {\n        stofMap[fooDotKt] = setOf(fooDotClass)\n\n        assertEquals(setOf(fooDotClass), stofMap[fooDotKt])\n    }\n\n    @Test\n    fun testSetDupeGetReturnsUnique() {\n        stofMap.append(fooDotKt, fooDotClass)\n        stofMap.append(fooDotKt, fooDotClass)\n\n        assertEquals(setOf(fooDotClass), stofMap[fooDotKt])\n    }\n\n    @Test\n    fun testSetOverwriteGetReturnsNew() {\n        val fooKtDotClass = classesDir.resolve(\"FooKt.class\")\n        stofMap[fooDotKt] = setO"}
{"code": "f(fooDotClass)\n        stofMap[fooDotKt] = setOf(fooKtDotClass)\n\n        assertEquals(setOf(fooKtDotClass), stofMap[fooDotKt])\n    }\n\n    @Test\n    fun testSetRelativePathFails() {\n        assertFailsWith<IllegalStateException> {\n            stofMap[fooDotKt] = setOf(File(\"relativePath\"))\n        }\n        assertFailsWith<IllegalStateException> {\n            stofMap[File(\"relativePath\")] = setOf(fooDotClass)\n        }\n    }\n\n    @Test\n    fun testGetRelativePathFails() {\n        stofMap[fooDotKt] = setOf(fooDotClass)\n\n        assertFailsWith<IllegalStateException> {\n            stofMap[File(\"relativePath\")]\n        }\n    }\n\n    @Test\n    fun testGetAndRemove() {\n        stofMap[fooDotKt] = setOf(fooDotClass)\n\n        assertEquals(setOf(fooDotClass), stofMap.getAndRemove(fooDotKt))\n        assertNull(stofMap[fooDotKt])\n    }\n\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cfg\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.builtins.KotlinBuiltIns\nimport org.jetbrains.kotlin.cfg.pseudocode.Pseudocode\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.KtElementInstruction\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.eval.MagicInstruction\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.eval.MagicKind\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.eval.ReadValueInstruction\nimport org.jetbrains.kotlin.cfg.pseudocodeTraverser.TraversalOrder\nimport org.jetbrains.kotlin.cfg.pseudocodeTraverser.traverse\nimport org.jetbrains.kotlin.cfg.variable.PseudocodeVariablesData\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType\nimport org.jetbrains.kotlin.resolve.BindingContext\nimport org.jetbrains.kotlin.resolve.BindingTrace\nimport org.jetbrains.kotlin.types.express"}
{"code": "ions.OperatorConventions\n\nclass ConstructorConsistencyChecker private constructor(\n    private val classOrObject: KtClassOrObject,\n    private val classDescriptor: ClassDescriptor,\n    private val trace: BindingTrace,\n    private val pseudocode: Pseudocode,\n    private val variablesData: PseudocodeVariablesData\n) {\n    private val finalClass = classDescriptor.isFinalClass\n\n    private fun insideLValue(reference: KtReferenceExpression): Boolean {\n        val binary = reference.getStrictParentOfType<KtBinaryExpression>() ?: return false\n        if (binary.operationToken in KtTokens.ALL_ASSIGNMENTS) {\n            val binaryLeft = binary.left\n            var current: PsiElement = reference\n            while (current !== binaryLeft && current !== binary) {\n                current = current.parent ?: return false\n            }\n            return current === binaryLeft\n        }\n        return false\n    }\n\n    private fun safeReferenceUsage(reference: KtReferenceExpression): Boolean {\n       "}
{"code": " val descriptor = trace.get(BindingContext.REFERENCE_TARGET, reference)\n        if (descriptor is PropertyDescriptor) {\n            if (!finalClass && descriptor.isOverridable) {\n                trace.record(BindingContext.LEAKING_THIS, reference, LeakingThisDescriptor.NonFinalProperty(descriptor, classOrObject))\n                return true\n            }\n            if (descriptor.containingDeclaration != classDescriptor) return true\n            return if (insideLValue(reference)) descriptor.setter?.isDefault != false else descriptor.getter?.isDefault != false\n        }\n        return true\n    }\n\n    private fun safeThisUsage(expression: KtThisExpression): Boolean {\n        val referenceDescriptor = trace.get(BindingContext.REFERENCE_TARGET, expression.instanceReference)\n        if (referenceDescriptor != classDescriptor) return true\n        val parent = expression.parent\n        return when (parent) {\n            is KtQualifiedExpression -> (parent.selectorExpression as? KtSimpleNameE"}
{"code": "xpression)?.let { safeReferenceUsage(it) } ?: false\n            is KtBinaryExpression -> OperatorConventions.IDENTITY_EQUALS_OPERATIONS.contains(parent.operationToken)\n            else -> false\n        }\n    }\n\n    private fun safeCallUsage(expression: KtCallExpression): Boolean {\n        val callee = expression.calleeExpression\n        if (callee is KtReferenceExpression) {\n            val descriptor = trace.get(BindingContext.REFERENCE_TARGET, callee)\n            if (descriptor is FunctionDescriptor) {\n                val containingDescriptor = descriptor.containingDeclaration\n                if (containingDescriptor != classDescriptor) return true\n                if (!finalClass && descriptor.isOverridable) {\n                    trace.record(BindingContext.LEAKING_THIS, callee, LeakingThisDescriptor.NonFinalFunction(descriptor, classOrObject))\n                    return true\n                }\n            }\n        }\n        return false\n    }\n\n    fun check() {\n        // List of pr"}
{"code": "operties to initialize\n        val propertyDescriptors = variablesData.getDeclaredVariables(pseudocode, false)\n            .filterIsInstance<PropertyDescriptor>()\n            .filter { trace.get(BindingContext.BACKING_FIELD_REQUIRED, it) == true }\n        pseudocode.traverse(\n            TraversalOrder.FORWARD, variablesData.variableInitializers\n        ) { instruction, enterData, _ ->\n\n            fun firstUninitializedNotNullProperty() = propertyDescriptors.firstOrNull {\n                !it.type.isMarkedNullable && !KotlinBuiltIns.isPrimitiveType(it.type) &&\n                        !it.isLateInit && !(enterData.getOrNull(it)?.definitelyInitialized() ?: false)\n            }\n\n            fun handleLeakingThis(expression: KtExpression) {\n                if (!finalClass) {\n                    trace.record(\n                        BindingContext.LEAKING_THIS, target(expression),\n                        LeakingThisDescriptor.NonFinalClass(classDescriptor, classOrObject)\n                   "}
{"code": " )\n                } else {\n                    val uninitializedProperty = firstUninitializedNotNullProperty()\n                    if (uninitializedProperty != null) {\n                        trace.record(\n                            BindingContext.LEAKING_THIS, target(expression),\n                            LeakingThisDescriptor.PropertyIsNull(uninitializedProperty, classOrObject)\n                        )\n                    }\n                }\n            }\n\n            if (instruction.owner != pseudocode) {\n                return@traverse\n            }\n\n            if (instruction is KtElementInstruction) {\n                val element = instruction.element\n                when (instruction) {\n                    is ReadValueInstruction ->\n                        if (element is KtThisExpression) {\n                            if (!safeThisUsage(element)) {\n                                handleLeakingThis(element)\n                            }\n                        }\n            "}
{"code": "        is MagicInstruction ->\n                        if (instruction.kind == MagicKind.IMPLICIT_RECEIVER) {\n                            if (element is KtCallExpression) {\n                                if (!safeCallUsage(element)) {\n                                    handleLeakingThis(element)\n                                }\n                            } else if (element is KtReferenceExpression) {\n                                if (!safeReferenceUsage(element)) {\n                                    handleLeakingThis(element)\n                                }\n                            }\n                        }\n                }\n            }\n        }\n    }\n\n    companion object {\n\n        @JvmStatic\n        fun check(\n            constructor: KtSecondaryConstructor,\n            trace: BindingTrace,\n            pseudocode: Pseudocode,\n            pseudocodeVariablesData: PseudocodeVariablesData\n        ) = check(constructor.getContainingClassOrObject(), trace, pseudocode, ps"}
{"code": "eudocodeVariablesData)\n\n        @JvmStatic\n        fun check(\n            classOrObject: KtClassOrObject,\n            trace: BindingTrace,\n            pseudocode: Pseudocode,\n            pseudocodeVariablesData: PseudocodeVariablesData\n        ) {\n            val classDescriptor = trace.get(BindingContext.CLASS, classOrObject) ?: return\n            ConstructorConsistencyChecker(classOrObject, classDescriptor, trace, pseudocode, pseudocodeVariablesData).check()\n        }\n\n        private fun target(expression: KtExpression): KtExpression = when (expression) {\n            is KtThisExpression -> {\n                val selectorOrThis = (expression.parent as? KtQualifiedExpression)?.let {\n                    if (it.receiverExpression === expression) it.selectorExpression else null\n                } ?: expression\n                if (selectorOrThis === expression) selectorOrThis else target(selectorOrThis)\n            }\n            is KtCallExpression -> expression.let { it.calleeExpression ?:"}
{"code": " it }\n            else -> expression\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.providers\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.search.GlobalSearchScope\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.platform.TargetPlatform\n\n\npublic abstract class KotlinPackageProvider : KotlinComposableProvider {\n    \n    public abstract fun doesPackageExist(packageFqName: FqName, platform: TargetPlatform): Boolean\n\n    \n    public abstract fun doesKotlinOnlyPackageExist(packageFqName: FqName): Boolean\n\n    \n    public abstract fun doesPlatformSpecificPackageExist(packageFqName: FqName, platform: TargetPlatform): Boolean\n\n\n    \n    public abstract fun getSubPackageFqNames(\n        packageFqName: FqName,\n        platform: TargetPlatform,\n        nameFilter: (Name) -> Boolean\n    ): Set<Name>\n\n    \n    public abstract fun getKotlinOnlySubPackagesFqNames(packageFqName: FqName, nameFilter: (Name) -> Boolean): Set<Name>\n\n    \n    public abstract fun getPlat"}
{"code": "formSpecificSubPackagesFqNames(\n        packageFqName: FqName,\n        platform: TargetPlatform,\n        nameFilter: (Name) -> Boolean\n    ): Set<Name>\n}\n\npublic abstract class KotlinPackageProviderFactory {\n    public abstract fun createPackageProvider(searchScope: GlobalSearchScope): KotlinPackageProvider\n}\n\n\npublic abstract class KotlinPackageProviderMerger : KotlinComposableProviderMerger<KotlinPackageProvider> {\n    public companion object {\n        public fun getInstance(project: Project): KotlinPackageProviderMerger = project.getService(KotlinPackageProviderMerger::class.java)\n    }\n}\n\npublic fun Project.createPackageProvider(searchScope: GlobalSearchScope): KotlinPackageProvider =\n    this.getService(KotlinPackageProviderFactory::class.java)\n        .createPackageProvider(searchScope)\n\npublic fun Project.mergePackageProviders(packageProviders: List<KotlinPackageProvider>): KotlinPackageProvider =\n    KotlinPackageProviderMerger.getInstance(this).merge(packageProviders)\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve\n\nenum class ForbiddenNamedArgumentsTarget(private val description: String) {\n    NON_KOTLIN_FUNCTION(\"non-Kotlin functions\"),  // a function provided by non-Kotlin artifact, ex: Java function\n    INVOKE_ON_FUNCTION_TYPE(\"function types\"),\n    EXPECTED_CLASS_MEMBER(\"members of expected classes\"),\n    // TODO: add the following when MPP support is available\n//     INTEROP_FUNCTION(\"interop functions with ambiguous parameter names\"),  // deserialized Kotlin function that serves as a bridge to a function written in another language, ex: Obj-C\n    ;\n\n    override fun toString(): String = description\n}\n"}
{"code": "// FILE: A.java\n\nclass A {\n    public static final A VALUE = new A();\n}\n\n// FILE: B.java\n\nclass B extends A {\n    public static final B VALUE = new B();\n}\n\n// FILE: main.kt\n\nfun main() {\n    val b = B.VALUE // <- should be B\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.resolve\n\nimport com.intellij.lang.java.JavaLanguage\nimport com.intellij.mock.MockProject\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.*\nimport com.intellij.psi.impl.file.PsiPackageImpl\nimport com.intellij.psi.impl.light.LightMethodBuilder\nimport com.intellij.psi.impl.light.LightModifierList\nimport com.intellij.psi.impl.light.LightPsiClassBase\nimport com.intellij.psi.search.GlobalSearchScope\nimport com.intellij.psi.search.PsiSearchScopeUtil\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.DiagnosticCheckerFilter\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.collectDiagnosticsForFile\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.resolveWithClearCaches\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators.AnalysisApiFirSourceTestConfigurator\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.anal"}
{"code": "ysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.test.framework.test.configurators.AnalysisApiTestServiceRegistrar\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.TestInfrastructureInternals\nimport org.jetbrains.kotlin.test.impl.testConfiguration\nimport org.jetbrains.kotlin.test.services.TestServices\nimport kotlin.test.fail\n\nabstract class AbstractErrorResistanceTest : AbstractAnalysisApiBasedTest() {\n    override val configurator: AnalysisApiFirSourceTestConfigurator = ErrorResistanceConfigurator\n\n    override fun doTestByMainFile(mainFile: KtFile, mainModule: KtTestModule, testServices: TestServices) {\n        resolveWithClearCaches(mainFile) { firResolveSession ->\n            ENABLE_INTERRUPTION.set(true)\n\n            try {\n                mainFile.collectDiagnosticsForFile(firResolveSession, DiagnosticCheckerFilter.ONLY_COMMON_CHECKERS)\n                fail(\"Analysis should be interrupted\")\n            } catch (e: Throw"}
{"code": "able) {\n                val errors = generateSequence(e) { it.cause }\n                if (errors.none { it is AnalysisInterruptedException }) {\n                    throw e\n                }\n            }\n\n            ENABLE_INTERRUPTION.set(false)\n\n            val diagnostics = mainFile.collectDiagnosticsForFile(firResolveSession, DiagnosticCheckerFilter.ONLY_COMMON_CHECKERS)\n            assert(diagnostics.isEmpty()) {\n                val messages = diagnostics.map { it.factoryName }\n                \"There should be no diagnostics, found:\\n\" + messages.joinToString(\"\\n\")\n            }\n        }\n    }\n}\n\nprivate object ErrorResistanceConfigurator : AnalysisApiFirSourceTestConfigurator(analyseInDependentSession = false) {\n    override val serviceRegistrars: List<AnalysisApiTestServiceRegistrar>\n        get() = buildList {\n            addAll(super.serviceRegistrars)\n            add(ErrorResistanceServiceRegistrar)\n        }\n}\n\nprivate object ErrorResistanceServiceRegistrar : AnalysisApiTe"}
{"code": "stServiceRegistrar() {\n    @OptIn(TestInfrastructureInternals::class)\n    override fun registerProjectModelServices(project: MockProject, testServices: TestServices) {\n        with(PsiElementFinder.EP.getPoint(project)) {\n            registerExtension(BrokenLibraryElementFinder(project), testServices.testConfiguration.rootDisposable)\n        }\n    }\n}\n\nprivate class AnalysisInterruptedException : RuntimeException()\n\nprivate var ENABLE_INTERRUPTION = ThreadLocal.withInitial { false }\n\nprivate fun interruptAnalysis() {\n    if (ENABLE_INTERRUPTION.get()) {\n        throw AnalysisInterruptedException()\n    }\n}\n\nprivate class BrokenLibraryElementFinder(project: Project) : PsiElementFinder() {\n    private val manager = PsiManager.getInstance(project)\n    private val brokenPackage = BrokenPackage(\"broken.lib\", manager)\n    private val brokenClass = BrokenClass(brokenPackage.qualifiedName, \"Foo\", manager)\n\n    override fun findPackage(qualifiedName: String): PsiPackage? {\n        return when (q"}
{"code": "ualifiedName) {\n            brokenPackage.qualifiedName -> brokenPackage\n            else -> null\n        }\n    }\n\n    override fun findClass(qualifiedName: String, scope: GlobalSearchScope): PsiClass? {\n        val klass = when (qualifiedName) {\n            brokenClass.qualifiedName -> brokenClass\n            else -> null\n        }\n\n        return klass?.takeIf { PsiSearchScopeUtil.isInScope(scope, it) }\n    }\n\n    override fun findClasses(qualifiedName: String, scope: GlobalSearchScope): Array<PsiClass> {\n        val klass = findClass(qualifiedName, scope) ?: return PsiClass.EMPTY_ARRAY\n        return arrayOf(klass)\n    }\n}\n\nprivate class BrokenPackage(packageName: String, manager: PsiManager) : PsiPackageImpl(manager, packageName) {\n    override fun isValid(): Boolean = true\n}\n\nprivate class BrokenClass(\n    private val packageName: String,\n    name: String,\n    manager: PsiManager,\n) : LightPsiClassBase(manager, JavaLanguage.INSTANCE, name) {\n    private val modifierList: PsiModifi"}
{"code": "erList = LightModifierList(manager, JavaLanguage.INSTANCE, PsiModifier.PUBLIC)\n    private val methods: Array<PsiMethod> = arrayOf(ConstructorMethod(this), GetterMethod(this))\n\n    override fun getQualifiedName(): String = \"$packageName.$name\"\n    override fun getModifierList(): PsiModifierList = modifierList\n    override fun getContainingClass(): PsiClass? = null\n    override fun getTypeParameterList(): PsiTypeParameterList? = null\n\n    override fun getMethods(): Array<PsiMethod> {\n        return methods\n    }\n\n    override fun getFields(): Array<PsiField> {\n        return PsiField.EMPTY_ARRAY\n    }\n\n    override fun getInnerClasses(): Array<PsiClass> = PsiClass.EMPTY_ARRAY\n    override fun getInitializers(): Array<PsiClassInitializer> = PsiClassInitializer.EMPTY_ARRAY\n\n    override fun getExtendsList(): PsiReferenceList? = null\n    override fun getImplementsList(): PsiReferenceList? = null\n\n    override fun getScope(): PsiElement? = null\n\n    private class ConstructorMethod(owner: Ps"}
{"code": "iClass) : LightMethodBuilder(owner, JavaLanguage.INSTANCE) {\n        init {\n            isConstructor = true\n            setModifiers(PsiModifier.PUBLIC)\n\n            val projectScope = GlobalSearchScope.allScope(manager.project)\n            addParameter(\"first\", PsiType.getJavaLangString(manager, projectScope))\n            addParameter(\"second\", PsiType.INT)\n        }\n    }\n\n    private class GetterMethod(owner: PsiClass) : LightMethodBuilder(owner.manager, \"getResult\") {\n        init {\n            containingClass = owner\n            setModifiers(PsiModifier.PUBLIC)\n            setMethodReturnType(PsiType.BOOLEAN)\n        }\n\n        override fun getTypeParameterList(): PsiTypeParameterList? {\n            interruptAnalysis()\n            return super.getTypeParameterList()\n        }\n\n        override fun getTypeParameters(): Array<PsiTypeParameter> {\n            interruptAnalysis()\n            return super.getTypeParameters()\n        }\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.type\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.expression.FirArrayOfNothingQualifierChecker.isArrayOfNothing\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPEALIAS_EXPANDS_TO_ARRAY_OF_NOTHINGS\nimport org.jetbrains.kotlin.fir.declarations.FirTypeAlias\nimport org.jetbrains.kotlin.fir.declarations.FirValueParameter\nimport org.jetbrains.kotlin.fir.resolve.fullyExpandedType\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.types.coneTypeOrNull\n\nobject FirArrayOfNothingTypeChecker : FirTypeRefChecker(MppCheckerKind.Common) {\n    override fun check(typeRef: FirTypeRef, context: Ch"}
{"code": "eckerContext, reporter: DiagnosticReporter) {\n        \n        if (context.containingDeclarations.lastOrNull() is FirTypeAlias) return\n        val coneType = typeRef.coneTypeOrNull ?: return\n        val fullyExpandedType = coneType.fullyExpandedType(context.session)\n\n        \n        val isVararg = (context.containingDeclarations.lastOrNull() as? FirValueParameter)?.isVararg ?: false\n        if (!isVararg && fullyExpandedType.isArrayOfNothing()) {\n            reporter.reportOn(typeRef.source, FirErrors.UNSUPPORTED, \"Array<Nothing> is illegal\", context)\n        }\n    }\n}\n"}
{"code": "import kotlin.reflect.KClass\n\nenum class SomeEnum {\n    A, B\n}\n\nannotation class MyAnnotation(\n    val intValue: Int,\n    val stringValue: String,\n    val enumValue: SomeEnum,\n    val kClasses: Array<out KClass<*>>,\n    val annotation: MyOtherAnnotation\n)\nannotation class MyOtherAnnotation(val intValue: Int, val stringValue: String)\n\nconst val constInt = 10\nconst val constString = \"\"\n\n@MyAnnotation(\n    intValue = 10,\n    stringValue = constString,\n    enumValue = SomeEnum.A,\n    kClasses = [String::class, <!ANNOTATION_ARGUMENT_MUST_BE_KCLASS_LITERAL!>constString::class<!>],\n\n    annotation = MyOtherAnnotation(\n        intValue = constInt,\n        stringValue = \"hello\"\n    )\n)\nfun foo() {}\n"}
{"code": "// FILE: K1.kt\nopen class KFirst<T: java.io.Serializable>() {\n    fun foo(t: T): T = t\n}\n\n// FILE: J1.java\npublic class J1 extends KFirst<Integer> {\n    void baz() {}\n}\n\n// FILE: K2.kt\nclass K2: J1() {\n    fun bar() {\n        foo(1)\n        baz()\n    }\n}"}
{"code": "// FILE: Named.java\n\npublic interface Named {\n    String getName();\n}\n\n// FILE: Psi.java\n\npublic interface Psi<D> {\n\n}\n\n// FILE: Member.java\n\npublic interface Member<D> extends Psi<D> {\n}\n\n// FILE: TypeParametersOwner.java\n\nimport java.util.List;\n\npublic interface TypeParametersOwner {\n    public List<String> getTypeParameters();\n}\n\n// FILE: Klass.java\n\npublic interface Klass extends TypeParametersOwner {\n}\n\n// FILE: Test.kt\n\nfun List<String>.single(): String = \"\"\nfun List<Int>.single(): Int = 2\n\nfun listOf(): List<String> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\npublic open class LightMember<D> : Member<D>, Light() {\n    override fun getName(): String = \"Light\"\n}\n\npublic <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class LightClassWrapper<!> : Light(), Klass {\n    fun test() = typeParameters.single()\n}\n\npublic abstract class Light : Field, TypeParametersOwner {\n    fun <!VIRTUAL_MEMBER_HIDDEN!>getTypeParameters<!>() = listOf()\n}\n\npublic interface Field : Named\n\npublic class LightField<D>"}
{"code": " : LightMember<Any>(), Field {\n    fun test(other: Any?) {\n        if (other is LightField<*>) {\n            other.name\n        }\n    }\n}\n\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.declarations\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.FirModuleData\nimport org.jetbrains.kotlin.fir.diagnostics.ConeDiagnostic\nimport org.jetbrains.kotlin.fir.diagnostics.FirDiagnosticHolder\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.symbols.impl.FirErrorPropertySymbol\nimport org.jetbrains.kotlin.fir.types.ConeSimpleKotlinType\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedContainerSource\n\n\nabstract class FirErrorProperty : Fi"}
{"code": "rVariable(), FirDiagnosticHolder {\n    abstract override val source: KtSourceElement?\n    abstract override val moduleData: FirModuleData\n    abstract override val origin: FirDeclarationOrigin\n    abstract override val attributes: FirDeclarationAttributes\n    abstract override val typeParameters: List<FirTypeParameterRef>\n    abstract override val status: FirDeclarationStatus\n    abstract override val returnTypeRef: FirTypeRef\n    abstract override val receiverParameter: FirReceiverParameter?\n    abstract override val deprecationsProvider: DeprecationsProvider\n    abstract override val containerSource: DeserializedContainerSource?\n    abstract override val dispatchReceiverType: ConeSimpleKotlinType?\n    abstract override val contextReceivers: List<FirContextReceiver>\n    abstract override val name: Name\n    abstract override val initializer: FirExpression?\n    abstract override val delegate: FirExpression?\n    abstract override val isVar: Boolean\n    abstract override val isVal: Boolea"}
{"code": "n\n    abstract override val getter: FirPropertyAccessor?\n    abstract override val setter: FirPropertyAccessor?\n    abstract override val backingField: FirBackingField?\n    abstract override val annotations: List<FirAnnotation>\n    abstract override val diagnostic: ConeDiagnostic\n    abstract override val symbol: FirErrorPropertySymbol\n\n    override fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitErrorProperty(this, data)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transformer.transformErrorProperty(this, data) as E\n\n    abstract override fun replaceStatus(newStatus: FirDeclarationStatus)\n\n    abstract override fun replaceReturnTypeRef(newReturnTypeRef: FirTypeRef)\n\n    abstract override fun replaceReceiverParameter(newReceiverParameter: FirReceiverParameter?)\n\n    abstract override fun replaceDeprecationsProvider(newDeprecationsProvider: DeprecationsProvider)\n\n    "}
{"code": "abstract override fun replaceContextReceivers(newContextReceivers: List<FirContextReceiver>)\n\n    abstract override fun replaceInitializer(newInitializer: FirExpression?)\n\n    abstract override fun replaceDelegate(newDelegate: FirExpression?)\n\n    abstract override fun replaceGetter(newGetter: FirPropertyAccessor?)\n\n    abstract override fun replaceSetter(newSetter: FirPropertyAccessor?)\n\n    abstract override fun replaceAnnotations(newAnnotations: List<FirAnnotation>)\n\n    abstract override fun <D> transformTypeParameters(transformer: FirTransformer<D>, data: D): FirErrorProperty\n\n    abstract override fun <D> transformStatus(transformer: FirTransformer<D>, data: D): FirErrorProperty\n\n    abstract override fun <D> transformReturnTypeRef(transformer: FirTransformer<D>, data: D): FirErrorProperty\n\n    abstract override fun <D> transformReceiverParameter(transformer: FirTransformer<D>, data: D): FirErrorProperty\n\n    abstract override fun <D> transformInitializer(transformer: FirTransfor"}
{"code": "mer<D>, data: D): FirErrorProperty\n\n    abstract override fun <D> transformDelegate(transformer: FirTransformer<D>, data: D): FirErrorProperty\n\n    abstract override fun <D> transformGetter(transformer: FirTransformer<D>, data: D): FirErrorProperty\n\n    abstract override fun <D> transformSetter(transformer: FirTransformer<D>, data: D): FirErrorProperty\n\n    abstract override fun <D> transformBackingField(transformer: FirTransformer<D>, data: D): FirErrorProperty\n\n    abstract override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirErrorProperty\n\n    abstract override fun <D> transformOtherChildren(transformer: FirTransformer<D>, data: D): FirErrorProperty\n}\n"}
{"code": "typealias Resolve<caret>Me<T : Int, K> = Map<T, K>"}
{"code": "fun x() <expr> {\n\n}\n</expr>"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.declarations.renderers.classifiers\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.renderer.declarations.KtDeclarationRenderer\nimport org.jetbrains.kotlin.analysis.api.renderer.declarations.renderAnnotationsModifiersAndContextReceivers\nimport org.jetbrains.kotlin.analysis.api.symbols.KtTypeAliasSymbol\nimport org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter\nimport org.jetbrains.kotlin.lexer.KtTokens\n\npublic interface KtTypeAliasSymbolRenderer {\n    context(KtAnalysisSession, KtDeclarationRenderer)\n    public fun renderSymbol(symbol: KtTypeAliasSymbol, printer: PrettyPrinter)\n\n    public object AS_SOURCE : KtTypeAliasSymbolRenderer {\n        context(KtAnalysisSession, KtDeclarationRenderer)\n        override fun renderSymbol(symbol: KtTypeAliasSymbol, printer: PrettyPrinter): Unit = printer {\n            \" \".separated(\n                { renderAnnotationsModifiersAndContextRec"}
{"code": "eivers(symbol, printer, KtTokens.TYPE_ALIAS_KEYWORD) },\n                {\n                    \" = \".separated(\n                        {\n                            nameRenderer.renderName(symbol, printer)\n                            typeParametersRenderer.renderTypeParameters(symbol, printer)\n                        },\n                        { typeRenderer.renderType(symbol.expandedType, printer) })\n                }\n            )\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.checkers\n\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.descriptors.ClassKind\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.descriptors.TypeAliasDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtTypeAlias\nimport org.jetbrains.kotlin.resolve.calls.mpp.ActualTypealiasToSpecialAnnotationUtils.isAnnotationProhibitedInActualTypeAlias\nimport org.jetbrains.kotlin.resolve.descriptorUtil.classId\n\ninternal object ActualTypealiasToSpecialAnnotationChecker : DeclarationChecker {\n    override fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n        if (!context.languageVersionSettings.supportsFeature(LanguageFeature.MultiplatformRestrictions)) return\n        if (declaration !is KtTypeAlias || descriptor !is TypeAliasDescriptor || !descri"}
{"code": "ptor.isActual) {\n            return\n        }\n        val classDescriptor = descriptor.classDescriptor ?: return\n        if (classDescriptor.kind != ClassKind.ANNOTATION_CLASS) {\n            return\n        }\n        val classId = classDescriptor.classId ?: return\n        if (isAnnotationProhibitedInActualTypeAlias(classId)) {\n            context.trace.report(Errors.ACTUAL_TYPEALIAS_TO_SPECIAL_ANNOTATION.on(declaration, classId))\n        }\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.scopes.impl\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.FirCallableDeclaration\nimport org.jetbrains.kotlin.fir.resolve.substitution.ConeSubstitutor\nimport org.jetbrains.kotlin.fir.resolve.substitution.substitutorByMap\nimport org.jetbrains.kotlin.fir.scopes.FirOverrideChecker\nimport org.jetbrains.kotlin.fir.types.impl.ConeTypeParameterTypeImpl\n\nabstract class FirAbstractOverrideChecker : FirOverrideChecker {\n\n    protected abstract fun buildTypeParametersSubstitutorIfCompatible(\n        overrideCandidate: FirCallableDeclaration,\n        baseDeclaration: FirCallableDeclaration\n    ): ConeSubstitutor?\n}\n\nfun buildSubstitutorForOverridesCheck(\n    overrideCandidate: FirCallableDeclaration,\n    baseDeclaration: FirCallableDeclaration,\n    useSiteSession: FirSession\n): ConeSubstitutor? {\n    if (overrideCandidate.typeParameters.size != baseDeclaration.typeParameters.size) return null\n\n    if (baseDeclaration.type"}
{"code": "Parameters.isEmpty()) return ConeSubstitutor.Empty\n    val types = baseDeclaration.typeParameters.map {\n        ConeTypeParameterTypeImpl(it.symbol.toLookupTag(), false)\n    }\n    return substitutorByMap(overrideCandidate.typeParameters.map { it.symbol }.zip(types).toMap(), useSiteSession)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.tree.generator\n\nimport org.jetbrains.kotlin.fir.tree.generator.context.AbstractFirTreeBuilder\nimport org.jetbrains.kotlin.fir.tree.generator.model.Element\nimport org.jetbrains.kotlin.fir.tree.generator.printer.*\nimport org.jetbrains.kotlin.generators.tree.printer.generateTree\nimport org.jetbrains.kotlin.utils.bind\nimport java.io.File\n\ninternal const val BASE_PACKAGE = \"org.jetbrains.kotlin.fir\"\ninternal const val VISITOR_PACKAGE = \"$BASE_PACKAGE.visitors\"\n\ntypealias Model = org.jetbrains.kotlin.generators.tree.Model<Element>\n\nfun main(args: Array<String>) {\n    val generationPath = args.firstOrNull()?.let { File(it) }\n        ?: File(\"../../tree/gen\").canonicalFile\n    NodeConfigurator.configureFields()\n    val model = Model(FirTreeBuilder.elements, AbstractFirTreeBuilder.baseFirElement)\n    generateTree(\n        generationPath,\n        \"compiler/fir/tree/tree-generator/Readme.md\",\n        model,\n        pureAbstractElementType,\n        ::ElementPrint"}
{"code": "er,\n        listOf(\n            firVisitorType to ::VisitorPrinter.bind(false),\n            firDefaultVisitorType to ::VisitorPrinter.bind(true),\n            firVisitorVoidType to ::VisitorVoidPrinter,\n            firDefaultVisitorVoidType to ::DefaultVisitorVoidPrinter,\n            firTransformerType to ::TransformerPrinter.bind(model.rootElement),\n        ),\n        ImplementationConfigurator,\n        BuilderConfigurator,\n        ::ImplementationPrinter,\n        ::BuilderPrinter,\n    )\n}\n"}
{"code": "fun test(obj: Any): String {\n    return when {\n        obj !is Iterable<*> -> \"not iterable\"\n        <expr>obj</expr> !is Collection<*> -> \"not collection\"\n        else -> \"unknown\"\n    }\n}"}
{"code": "fun (): Int = <expr>doSmth</expr>(\"str\")\n\nfun doSmth(i: String) = 4"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve\n\nimport com.intellij.openapi.progress.ProcessCanceledException\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtVisitorVoid\nimport org.jetbrains.kotlin.util.KotlinFrontEndException\n\nclass ExceptionWrappingKtVisitorVoid(private val delegate: KtVisitorVoid) : KtVisitorVoid() {\n    override fun visitElement(element: PsiElement) {\n        element.accept(delegate)\n    }\n\n    override fun visitDeclaration(dcl: KtDeclaration) {\n        try {\n            dcl.accept(delegate)\n        } catch (e: ProcessCanceledException) {\n            throw e\n        } catch (e: KotlinFrontEndException) {\n            throw e\n        } catch (t: Throwable) {\n            val name = try {\n                dcl.name\n            } catch (e: Throwable) {\n                \"- error: ${e.message}\"\n            }\n            throw KotlinFrontEndException(\"Failed to analyze declaration $name\", t, dcl)\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen\n\ndata class SyntheticInnerClassInfo(val internalName: String, val flags: Int)"}
{"code": "\n\npackage org.jetbrains.kotlin.cfg\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.builtins.KotlinBuiltIns\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.config.LanguageVersionSettings\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.ClassKind\nimport org.jetbrains.kotlin.descriptors.Modality\nimport org.jetbrains.kotlin.diagnostics.DiagnosticSink\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.diagnostics.WhenMissingCase\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.resolve.BindingContext\nimport org.jetbrains.kotlin.resolve.BindingContext.SMARTCAST\nimport org.jetbrains.kotlin.resolve.BindingContext.VARIABLE\nimport org.jetbrains.kotlin.resolve.BindingTrace\nimport org.jetbrains.kotlin.resolve.CompileTimeConstantUtils\nimport org.jetbrains.kotlin.resolve.DescriptorUtils"}
{"code": "\nimport org.jetbrains.kotlin.resolve.DescriptorUtils.isEnumClass\nimport org.jetbrains.kotlin.resolve.DescriptorUtils.isEnumEntry\nimport org.jetbrains.kotlin.resolve.constants.CompileTimeConstant\nimport org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator\nimport org.jetbrains.kotlin.resolve.descriptorUtil.classId\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.kotlin.types.TypeUtils\nimport org.jetbrains.kotlin.utils.addIfNotNull\nimport org.jetbrains.kotlin.utils.addToStdlib.runIf\n\n\nval List<WhenMissingCase>.hasUnknown: Boolean\n    get() = firstOrNull() == WhenMissingCase.Unknown\n\nprivate interface WhenExhaustivenessChecker {\n    fun getMissingCases(\n        expression: KtWhenExpression,\n        context: BindingContext,\n        subjectDescriptor: ClassDescriptor?,\n        nullable: Boolean\n    ): List<WhenMissingCase>\n\n    fun isApplicable(subjectType: KotlinType): Boolean = false\n}\n\n// It's not a regular exhaustiveness checker, invoke it only ins"}
{"code": "ide other checkers\nprivate object WhenOnExpectExhaustivenessChecker {\n    fun getMissingCase(subjectDescriptor: ClassDescriptor?): WhenMissingCase? {\n        return runIf(subjectDescriptor?.isExpect == true) {\n            when (subjectDescriptor!!.kind) {\n                ClassKind.CLASS -> WhenMissingCase.ConditionTypeIsExpect.SealedClass\n                ClassKind.INTERFACE -> WhenMissingCase.ConditionTypeIsExpect.SealedInterface\n                ClassKind.ENUM_CLASS -> WhenMissingCase.ConditionTypeIsExpect.Enum\n                else -> WhenMissingCase.Unknown\n            }\n        }\n    }\n}\n\n\n// It's not a regular exhaustiveness checker, invoke it only inside other checkers\nprivate object WhenOnNullableExhaustivenessChecker  {\n    fun getMissingCases(expression: KtWhenExpression, context: BindingContext, nullable: Boolean) =\n        if (nullable) getNullCaseIfMissing(expression, context) else listOf()\n\n    private fun getNullCaseIfMissing(expression: KtWhenExpression, context: BindingCo"}
{"code": "ntext): List<WhenMissingCase> {\n        for (entry in expression.entries) {\n            for (condition in entry.conditions) {\n                if (condition is KtWhenConditionWithExpression) {\n                    condition.expression?.let {\n                        val type = context.getType(it)\n                        if (type != null && KotlinBuiltIns.isNullableNothing(type)) {\n                            return listOf()\n                        }\n                    }\n                }\n            }\n        }\n        return listOf(WhenMissingCase.NullIsMissing)\n    }\n}\n\n\nprivate object WhenOnBooleanExhaustivenessChecker : WhenExhaustivenessChecker {\n    override fun getMissingCases(\n        expression: KtWhenExpression,\n        context: BindingContext,\n        subjectDescriptor: ClassDescriptor?,\n        nullable: Boolean\n    ): List<WhenMissingCase> {\n        // It's assumed (and not checked) that expression is of the boolean type\n        var containsFalse = false\n        var contains"}
{"code": "True = false\n        for (whenEntry in expression.entries) {\n            for (whenCondition in whenEntry.conditions) {\n                if (whenCondition is KtWhenConditionWithExpression) {\n                    val whenExpression = whenCondition.expression\n                    if (CompileTimeConstantUtils.canBeReducedToBooleanConstant(whenExpression, context, true)) containsTrue = true\n                    if (CompileTimeConstantUtils.canBeReducedToBooleanConstant(whenExpression, context, false)) containsFalse = true\n                }\n            }\n        }\n        return (if (!containsTrue) listOf(WhenMissingCase.BooleanIsMissing.TrueIsMissing) else listOf()) +\n                (if (!containsFalse) listOf(WhenMissingCase.BooleanIsMissing.FalseIsMissing) else listOf()) +\n                WhenOnNullableExhaustivenessChecker.getMissingCases(expression, context, nullable)\n    }\n\n    override fun isApplicable(subjectType: KotlinType): Boolean {\n        return KotlinBuiltIns.isBoolean(TypeUtils."}
{"code": "makeNotNullable(subjectType))\n    }\n}\n\n\ninternal abstract class WhenOnClassExhaustivenessChecker : WhenExhaustivenessChecker {\n    private fun getReference(expression: KtExpression?): KtSimpleNameExpression? =\n        when (expression) {\n            is KtSimpleNameExpression -> expression\n            is KtQualifiedExpression -> getReference(expression.selectorExpression)\n            else -> null\n        }\n\n    protected val ClassDescriptor.enumEntries: Set<ClassDescriptor>\n        get() = DescriptorUtils.getAllDescriptors(this.unsubstitutedInnerClassesScope)\n            .filter(::isEnumEntry)\n            .filterIsInstance<ClassDescriptor>()\n            .toSet()\n\n\n    protected val ClassDescriptor.deepSealedSubclasses: Set<ClassDescriptor>\n        get() = this.sealedSubclasses.flatMapTo(mutableSetOf()) {\n            it.subclasses\n        }\n\n    private val ClassDescriptor.subclasses: Set<ClassDescriptor>\n        get() = when {\n            this.modality == Modality.SEALED -> this.deepSea"}
{"code": "ledSubclasses\n            this.kind == ClassKind.ENUM_CLASS -> this.enumEntries\n            else -> setOf(this)\n        }\n\n    private val KtWhenCondition.negated\n        get() = (this as? KtWhenConditionIsPattern)?.isNegated ?: false\n\n    private fun KtWhenCondition.isRelevant(checkedDescriptor: ClassDescriptor) =\n        this !is KtWhenConditionWithExpression ||\n                DescriptorUtils.isObject(checkedDescriptor) ||\n                DescriptorUtils.isEnumEntry(checkedDescriptor)\n\n    private fun KtWhenCondition.getCheckedDescriptor(context: BindingContext): ClassDescriptor? {\n        return when (this) {\n            is KtWhenConditionIsPattern -> {\n                val checkedType = context.get(BindingContext.TYPE, typeReference) ?: return null\n                TypeUtils.getClassDescriptor(checkedType)\n            }\n            is KtWhenConditionWithExpression -> {\n                val reference = expression?.let { getReference(it) } ?: return null\n                context.get(Bin"}
{"code": "dingContext.REFERENCE_TARGET, reference) as? ClassDescriptor\n            }\n            else -> {\n                null\n            }\n        }\n    }\n\n    protected fun getMissingClassCases(\n        whenExpression: KtWhenExpression,\n        subclasses: Set<ClassDescriptor>,\n        context: BindingContext\n    ): List<WhenMissingCase> {\n        // when on empty enum / sealed is considered non-exhaustive, see test whenOnEmptySealed\n        if (subclasses.isEmpty()) return listOf(WhenMissingCase.Unknown)\n\n        val checkedDescriptors = linkedSetOf<ClassDescriptor>()\n        for (whenEntry in whenExpression.entries) {\n            for (condition in whenEntry.conditions) {\n                val negated = condition.negated\n                val checkedDescriptor = condition.getCheckedDescriptor(context) ?: continue\n                val checkedDescriptorSubclasses = checkedDescriptor.subclasses\n\n                // Checks are important only for nested subclasses of the sealed class\n                /"}
{"code": "/ In additional, check without \"is\" is important only for objects\n                if (checkedDescriptorSubclasses.none { subclasses.contains(it) } ||\n                    !condition.isRelevant(checkedDescriptor)) {\n                    continue\n                }\n                if (negated) {\n                    if (checkedDescriptors.containsAll(checkedDescriptorSubclasses)) return listOf()\n                    checkedDescriptors.addAll(subclasses)\n                    checkedDescriptors.removeAll(checkedDescriptorSubclasses)\n                } else {\n                    checkedDescriptors.addAll(checkedDescriptorSubclasses)\n                }\n            }\n        }\n        return (subclasses - checkedDescriptors).map(::createWhenMissingCaseForClassOrEnum)\n    }\n\n    private fun createWhenMissingCaseForClassOrEnum(classDescriptor: ClassDescriptor): WhenMissingCase {\n        val classId = DescriptorUtils.getClassIdForNonLocalClass(classDescriptor)\n        return if (classDescriptor.kind != "}
{"code": "ClassKind.ENUM_ENTRY) {\n            WhenMissingCase.IsTypeCheckIsMissing(\n                classId = DescriptorUtils.getClassIdForNonLocalClass(classDescriptor),\n                isSingleton = classDescriptor.kind.isSingleton\n            )\n        } else {\n            val enumClassId = classId.outerClassId ?: error(\"Enum should have class id\")\n            WhenMissingCase.EnumCheckIsMissing(CallableId(enumClassId, classId.shortClassName))\n        }\n    }\n}\n\nprivate object WhenOnEnumExhaustivenessChecker : WhenOnClassExhaustivenessChecker() {\n    override fun getMissingCases(\n        expression: KtWhenExpression,\n        context: BindingContext,\n        subjectDescriptor: ClassDescriptor?,\n        nullable: Boolean\n    ): List<WhenMissingCase> {\n        assert(isEnumClass(subjectDescriptor)) { \"isWhenOnEnumExhaustive should be called with an enum class descriptor\" }\n        return buildList {\n            addAll(getMissingClassCases(expression, subjectDescriptor!!.enumEntries, context))\n   "}
{"code": "         addAll(WhenOnNullableExhaustivenessChecker.getMissingCases(expression, context, nullable))\n            addIfNotNull(WhenOnExpectExhaustivenessChecker.getMissingCase(subjectDescriptor))\n        }\n    }\n\n    override fun isApplicable(subjectType: KotlinType): Boolean {\n        return WhenChecker.getClassDescriptorOfTypeIfEnum(subjectType) != null\n    }\n}\n\ninternal object WhenOnSealedExhaustivenessChecker : WhenOnClassExhaustivenessChecker() {\n    override fun getMissingCases(\n        expression: KtWhenExpression,\n        context: BindingContext,\n        subjectDescriptor: ClassDescriptor?,\n        nullable: Boolean\n    ): List<WhenMissingCase> {\n        assert(DescriptorUtils.isSealedClass(subjectDescriptor)) {\n            \"isWhenOnSealedClassExhaustive should be called with a sealed class descriptor: $subjectDescriptor\"\n        }\n\n        val allSubclasses = subjectDescriptor!!.deepSealedSubclasses\n        return buildList {\n            addAll(getMissingClassCases(expression, a"}
{"code": "llSubclasses.toSet(), context))\n            addAll(WhenOnNullableExhaustivenessChecker.getMissingCases(expression, context, nullable))\n            addIfNotNull(WhenOnExpectExhaustivenessChecker.getMissingCase(subjectDescriptor))\n        }\n    }\n\n    override fun isApplicable(subjectType: KotlinType): Boolean {\n        return DescriptorUtils.isSealedClass(TypeUtils.getClassDescriptor(subjectType))\n    }\n}\n\n\nobject WhenChecker {\n\n    private val exhaustivenessCheckers = listOf(\n        WhenOnBooleanExhaustivenessChecker,\n        WhenOnEnumExhaustivenessChecker,\n        WhenOnSealedExhaustivenessChecker\n    )\n\n    @JvmStatic\n    fun getClassIdForEnumSubject(expression: KtWhenExpression, context: BindingContext) =\n        getClassIdForTypeIfEnum(whenSubjectType(expression, context))\n\n    @JvmStatic\n    fun getClassIdForTypeIfEnum(type: KotlinType?) =\n        getClassDescriptorOfTypeIfEnum(type)?.classId\n\n    @JvmStatic\n    fun getClassDescriptorOfTypeIfEnum(type: KotlinType?): ClassDescrip"}
{"code": "tor? {\n        if (type == null) return null\n        val classDescriptor = TypeUtils.getClassDescriptor(type) ?: return null\n        if (classDescriptor.kind != ClassKind.ENUM_CLASS) return null\n\n        return classDescriptor\n    }\n\n    @JvmStatic\n    fun getClassDescriptorOfTypeIfSealed(type: KotlinType?): ClassDescriptor? =\n        type?.let { TypeUtils.getClassDescriptor(it) }?.takeIf { DescriptorUtils.isSealedClass(it) }\n\n\n    @JvmStatic\n    fun whenSubjectType(expression: KtWhenExpression, context: BindingContext): KotlinType? {\n        val subjectVariable = expression.subjectVariable\n        val subjectExpression = expression.subjectExpression\n        return when {\n            subjectVariable != null -> context.get(VARIABLE, subjectVariable)?.type\n            subjectExpression != null -> context.get(SMARTCAST, subjectExpression)?.defaultType ?: context.getType(subjectExpression)\n            else -> null\n        }\n    }\n\n    fun whenSubjectTypeWithoutSmartCasts(expression: KtWhen"}
{"code": "Expression, context: BindingContext): KotlinType? {\n        val subjectVariable = expression.subjectVariable\n        val subjectExpression = expression.subjectExpression\n        return when {\n            subjectVariable != null -> context.get(VARIABLE, subjectVariable)?.type\n            subjectExpression != null -> context.getType(subjectExpression)\n            else -> null\n        }\n    }\n\n    @JvmStatic\n    fun getEnumMissingCases(\n        expression: KtWhenExpression,\n        context: BindingContext,\n        enumClassDescriptor: ClassDescriptor\n    ) = WhenOnEnumExhaustivenessChecker.getMissingCases(expression, context, enumClassDescriptor, false)\n\n    @JvmStatic\n    fun getSealedMissingCases(\n        expression: KtWhenExpression,\n        context: BindingContext,\n        sealedClassDescriptor: ClassDescriptor\n    ) = WhenOnSealedExhaustivenessChecker.getMissingCases(expression, context, sealedClassDescriptor, false)\n\n    fun getMissingCases(expression: KtWhenExpression, context: Bin"}
{"code": "dingContext): List<WhenMissingCase> {\n        val type = whenSubjectType(expression, context) ?: return listOf(WhenMissingCase.Unknown)\n        val nullable = type.isMarkedNullable\n        val checkers = exhaustivenessCheckers.filter { it.isApplicable(type) }\n        if (checkers.isEmpty()) return listOf(WhenMissingCase.Unknown)\n        return checkers.map { it.getMissingCases(expression, context, TypeUtils.getClassDescriptor(type), nullable) }.flatten()\n    }\n\n    @JvmStatic\n    fun isWhenExhaustive(expression: KtWhenExpression, trace: BindingTrace) =\n        if (getMissingCases(expression, trace.bindingContext).isEmpty()) {\n            trace.record(BindingContext.EXHAUSTIVE_WHEN, expression)\n            true\n        } else {\n            false\n        }\n\n    fun containsNullCase(expression: KtWhenExpression, context: BindingContext) =\n        WhenOnNullableExhaustivenessChecker.getMissingCases(expression, context, true).isEmpty()\n\n    fun checkDuplicatedLabels(\n        expression: KtW"}
{"code": "henExpression,\n        trace: BindingTrace,\n        languageVersionSettings: LanguageVersionSettings,\n    ) {\n        if (expression.subjectExpression == null) return\n\n        val checkedTypes = HashSet<Pair<KotlinType, Boolean>>()\n        \n        val checkedConstants = mutableMapOf<CompileTimeConstant<*>, Boolean>()\n        val notTrivialBranches = mutableMapOf<CompileTimeConstant<*>, KtExpression>()\n        for (entry in expression.entries) {\n            if (entry.isElse) continue\n\n            conditions@ for (condition in entry.conditions) {\n                when (condition) {\n                    is KtWhenConditionWithExpression -> {\n                        val constantExpression = condition.expression ?: continue@conditions\n                        val constant = ConstantExpressionEvaluator.getConstant(\n                            constantExpression, trace.bindingContext\n                        ) ?: continue@conditions\n\n                        fun report(reportOn: KtExpression) {\n  "}
{"code": "                          trace.report(Errors.DUPLICATE_LABEL_IN_WHEN.on(reportOn))\n                        }\n\n                        when (checkedConstants[constant]) {\n                            true -> {\n                                // already found trivial constant in previous branches\n                                report(constantExpression)\n                            }\n                            false -> {\n                                // already found bad constant in previous branches\n                                val isTrivial = constant.isTrivial(constantExpression, languageVersionSettings)\n                                if (isTrivial) {\n                                    // this constant is trivial -> report on first non trivial constant\n                                    val reportOn = notTrivialBranches.remove(constant)!!\n                                    report(reportOn)\n                                    checkedConstants[constant] = true\n                "}
{"code": "                } else {\n                                    // this constant is also not trivial -> report on it\n                                    report(constantExpression)\n                                }\n                            }\n                            null -> {\n                                // met constant for a first time\n                                val isTrivial = constant.isTrivial(constantExpression, languageVersionSettings)\n                                checkedConstants[constant] = isTrivial\n                                if (!isTrivial) {\n                                    notTrivialBranches[constant] = constantExpression\n                                }\n                            }\n                        }\n\n                    }\n                    is KtWhenConditionIsPattern -> {\n                        val typeReference = condition.typeReference ?: continue@conditions\n                        val type = trace.get(BindingContext.TYPE, typeReference)"}
{"code": " ?: continue@conditions\n                        val typeWithIsNegation = type to condition.isNegated\n                        if (checkedTypes.contains(typeWithIsNegation)) {\n                            trace.report(Errors.DUPLICATE_LABEL_IN_WHEN.on(typeReference))\n                        } else {\n                            checkedTypes.add(typeWithIsNegation)\n                        }\n                    }\n                    else -> {\n                    }\n                }\n            }\n        }\n    }\n\n    private fun CompileTimeConstant<*>.isTrivial(\n        expression: KtExpression,\n        languageVersionSettings: LanguageVersionSettings\n    ): Boolean {\n        if (usesVariableAsConstant) return false\n        if (!languageVersionSettings.supportsFeature(LanguageFeature.ProhibitSimplificationOfNonTrivialConstBooleanExpressions)) {\n            return !ConstantExpressionEvaluator.isComplexBooleanConstant(expression, this)\n        }\n        return true\n    }\n\n    fun checkDeprecate"}
{"code": "dWhenSyntax(trace: BindingTrace, expression: KtWhenExpression) {\n        if (expression.subjectExpression != null) return\n\n        for (entry in expression.entries) {\n            if (entry.isElse) continue\n            var child: PsiElement? = entry.firstChild\n            while (child != null) {\n                if (child.node.elementType === KtTokens.COMMA) {\n                    trace.report(Errors.COMMA_IN_WHEN_CONDITION_WITHOUT_ARGUMENT.on(child))\n                }\n                if (child.node.elementType === KtTokens.ARROW) break\n                child = child.nextSibling\n            }\n        }\n    }\n\n    fun checkSealedWhenIsReserved(sink: DiagnosticSink, element: PsiElement) {\n        KtPsiUtil.getPreviousWord(element, \"sealed\")?.let {\n            sink.report(Errors.UNSUPPORTED_SEALED_WHEN.on(it))\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.providers.topics\n\nimport org.jetbrains.kotlin.analysis.project.structure.KtModule\n\npublic fun interface KotlinGlobalSourceOutOfBlockModificationListener {\n    \n    public fun onModification()\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.js.checkers.expression\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.expression.FirCallChecker\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.js.FirJsErrors\nimport org.jetbrains.kotlin.fir.declarations.hasAnnotation\nimport org.jetbrains.kotlin.fir.declarations.utils.isEffectivelyExternal\nimport org.jetbrains.kotlin.fir.expressions.FirCall\nimport org.jetbrains.kotlin.fir.expressions.resolvedArgumentMapping\nimport org.jetbrains.kotlin.fir.expressions.unwrapArgument\nimport org.jetbrains.kotlin.fir.types.ConeDynamicType\nimport org.jetbrains.kotlin.fir.types.resolvedType\nimport org.jetbrains.kotlin.fir.types.toRegularClassSymbol\nimport org.jetbrains.kotlin.name.JsStandardClassIds.Annotations.JsE"}
{"code": "xternalArgument\n\nobject FirJsExternalArgumentCallChecker : FirCallChecker(MppCheckerKind.Common) {\n    override fun check(expression: FirCall, context: CheckerContext, reporter: DiagnosticReporter) {\n        val arguments = expression.resolvedArgumentMapping ?: return\n        for ((argument, parameter) in arguments) {\n            if (parameter.hasAnnotation(JsExternalArgument, context.session)) {\n                val unwrappedArg = argument.unwrapArgument()\n                val type = unwrappedArg.resolvedType\n                val symbol = type.toRegularClassSymbol(context.session)\n                if (symbol?.isEffectivelyExternal(context.session) == false || type is ConeDynamicType) {\n                    reporter.reportOn(\n                        unwrappedArg.source,\n                        FirJsErrors.JS_EXTERNAL_ARGUMENT,\n                        type,\n                        context\n                    )\n                }\n            }\n        }\n    }\n}\n"}
{"code": "interface FirTypeScope\n\ninterface AbstractFirBasedSymbol<E> where E : FirSymbolOwner<E>, E : FirDeclaration {\n    val fir: E\n}\n\ninterface FirCallableSymbol<D : FirCallableDeclaration<D>> : AbstractFirBasedSymbol<D>\n\ninterface FirElement\ninterface FirSymbolOwner<E> : FirElement where E : FirSymbolOwner<E>, E : FirDeclaration {\n    val symbol:  AbstractFirBasedSymbol<E>\n}\ninterface FirDeclaration : FirElement\ninterface FirCallableDeclaration<F : FirCallableDeclaration<F>> : FirDeclaration, FirSymbolOwner<F>\ninterface FirCallableMemberDeclaration<F : FirCallableMemberDeclaration<F>> : FirCallableDeclaration<F>\n\nprivate inline fun <reified S : FirCallableSymbol<*>> computeBaseSymbols(\n    symbol: S,\n    basedSymbol: S,\n    directOverridden: FirTypeScope.(S) -> List<S>\n) {}\n\nfun FirCallableSymbol<*>.dispatchReceiverClassOrNull(): Boolean? = true\n\nprivate inline fun <reified D : FirCallableMemberDeclaration<D>, reified S : FirCallableSymbol<D>> createFakeOverriddenIfNeeded(\n    originalSymbo"}
{"code": "l: FirCallableSymbol<*>,\n    basedSymbol: S,\n    computeDirectOverridden: FirTypeScope.(S) -> List<S>,\n    someCondition: Boolean\n) {\n    if (originalSymbol !is S) return\n    if (originalSymbol.dispatchReceiverClassOrNull() == true && someCondition) return\n    computeBaseSymbols(originalSymbol, basedSymbol, computeDirectOverridden)\n}\n"}
{"code": "\n\nclass Bar {\n    fun FooBar.invoke(): Bar = <!RETURN_TYPE_MISMATCH!>this<!>\n}\n\nclass Buz\n\nclass FooBar\n\nclass Foo {\n    val Buz.foobar: Bar get() = Bar()\n\n    fun FooBar.chk(buz: Buz) {\n        // NB: really this example is unresolvable (in old FE too)\n        // local/buz is extension receiver of foobar\n        // this@Foo is dispatch receiver of foobar\n        // Foo/foobar is dispatch receiver of invoke\n        // this@chk is extension receiver of invoke\n        buz.<!FUNCTION_EXPECTED!>foobar<!>()\n    }\n}\n"}
{"code": "annotation class Ann(val x: Int, val y: String, val z: String = \"z\")\n\n@Ann(y = \"y\", x = 10)\nclass A\n\nannotation class AnnVarargs(val x: Int, vararg val y: String, val z: Int)\n\n@AnnVarargs(1, \"a\", \"b\", \"c\", <!NO_VALUE_FOR_PARAMETER!><!ARGUMENT_TYPE_MISMATCH!>2<!>)<!>\nclass B\n"}
{"code": "fun function(vararg a: Int) {}\n\nfun call() {\n    val args = intArrayOf(1, 2, 3)\n    <expr>function(*args)</expr>\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.extensions\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.FirSessionComponent\nimport org.jetbrains.kotlin.fir.caches.*\nimport org.jetbrains.kotlin.fir.declarations.validate\nimport org.jetbrains.kotlin.fir.ownerGenerator\nimport org.jetbrains.kotlin.fir.render\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolNamesProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProviderInternals\nimport org.jetbrains.kotlin.fir.resolve.providers.symbolProvider\nimport org.jetbrains.kotlin.fir.scopes.impl.nestedClassifierScope\nimport org.jetbrains.kotlin.fir.scopes.processClassifiersByName\nimport org.jetbrains.kotlin.fir.symbols.impl.*\nimport org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.utils.addToStdlib.flatGrou"}
{"code": "pBy\n\n@OptIn(FirExtensionApiInternals::class, ExperimentalTopLevelDeclarationsGenerationApi::class)\nclass FirExtensionDeclarationsSymbolProvider private constructor(\n    session: FirSession,\n    cachesFactory: FirCachesFactory,\n    private val extensions: List<FirDeclarationGenerationExtension>\n) : FirSymbolProvider(session), FirSessionComponent {\n    companion object {\n        fun createIfNeeded(session: FirSession): FirExtensionDeclarationsSymbolProvider? {\n            val extensions = session.extensionService.declarationGenerators\n            if (extensions.isEmpty()) return null\n            return FirExtensionDeclarationsSymbolProvider(session, session.firCachesFactory, extensions)\n        }\n    }\n\n    // ------------------------------------------ caches ------------------------------------------\n\n    private val classCache: FirCache<ClassId, FirClassLikeSymbol<*>?, Nothing?> = cachesFactory.createCache { classId, _ ->\n        generateClassLikeDeclaration(classId)\n    }\n\n    private"}
{"code": " val functionCache: FirCache<CallableId, List<FirNamedFunctionSymbol>, Nothing?> = cachesFactory.createCache { callableId, _ ->\n        generateTopLevelFunctions(callableId)\n    }\n\n    private val propertyCache: FirCache<CallableId, List<FirPropertySymbol>, Nothing?> = cachesFactory.createCache { callableId, _ ->\n        generateTopLevelProperties(callableId)\n    }\n\n    private val packageCache: FirCache<FqName, Boolean, Nothing?> = cachesFactory.createCache { packageFqName, _ ->\n        hasPackage(packageFqName)\n    }\n\n    private val callableNamesInPackageCache: FirLazyValue<Map<FqName, Set<Name>>> =\n        cachesFactory.createLazyValue {\n            computeNamesGroupedByPackage(\n                FirDeclarationGenerationExtension::getTopLevelCallableIds,\n                CallableId::packageName, CallableId::callableName\n            )\n        }\n\n    private val classNamesInPackageCache: FirLazyValue<Map<FqName, Set<Name>>> =\n        cachesFactory.createLazyValue {\n            computeNa"}
{"code": "mesGroupedByPackage(\n                FirDeclarationGenerationExtension::getTopLevelClassIds,\n                ClassId::packageFqName,\n                ClassId::shortClassName,\n            )\n        }\n\n    private fun <I, N> computeNamesGroupedByPackage(\n        ids: FirDeclarationGenerationExtension.() -> Collection<I>,\n        packageFqName: (I) -> FqName,\n        shortName: (I) -> N,\n    ): Map<FqName, Set<N>> =\n        buildMap<FqName, MutableSet<N>> {\n            for (extension in extensions) {\n                for (id in extension.ids()) {\n                    getOrPut(packageFqName(id)) { mutableSetOf() }.add(shortName(id))\n                }\n            }\n        }\n\n    private val extensionsByTopLevelClassId: FirLazyValue<Map<ClassId, List<FirDeclarationGenerationExtension>>> =\n        session.firCachesFactory.createLazyValue {\n            extensions.flatGroupBy { it.topLevelClassIdsCache.getValue() }\n        }\n\n    private val extensionsByTopLevelCallableId: FirLazyValue<Map<Callab"}
{"code": "leId, List<FirDeclarationGenerationExtension>>> =\n        session.firCachesFactory.createLazyValue {\n            extensions.flatGroupBy { it.topLevelCallableIdsCache.getValue() }\n        }\n\n    // ------------------------------------------ generators ------------------------------------------\n\n    private fun generateClassLikeDeclaration(classId: ClassId): FirClassLikeSymbol<*>? {\n        return when {\n            classId.isLocal -> null\n            classId.isNestedClass -> {\n                val owner = session.symbolProvider.getClassLikeSymbolByClassId(classId.outerClassId!!) as? FirClassSymbol<*> ?: return null\n                val nestedClassifierScope = session.nestedClassifierScope(owner.fir) ?: return null\n                var result: FirClassLikeSymbol<*>? = null\n                nestedClassifierScope.processClassifiersByName(classId.shortClassName) {\n                    if (it is FirClassLikeSymbol<*>) {\n                        result = it\n                    }\n                }\n "}
{"code": "               result\n            }\n            else -> {\n                val matchedExtensions = extensionsByTopLevelClassId.getValue()[classId] ?: return null\n                val generatedClasses = matchedExtensions\n                    .mapNotNull { generatorExtension ->\n                        generatorExtension.generateTopLevelClassLikeDeclaration(classId)?.also { symbol ->\n                            symbol.fir.ownerGenerator = generatorExtension\n                        }\n                    }\n                    .onEach { it.fir.validate() }\n                when (generatedClasses.size) {\n                    0 -> null\n                    1 -> generatedClasses.first()\n                    else -> error(\"Multiple plugins generated classes with same classId $classId\\n${generatedClasses.joinToString(\"\\n\") { it.fir.render() }}\")\n                }\n            }\n        }\n    }\n\n    private fun generateTopLevelFunctions(callableId: CallableId): List<FirNamedFunctionSymbol> {\n        retur"}
{"code": "n extensionsByTopLevelCallableId.getValue()[callableId].orEmpty()\n            .flatMap { it.generateFunctions(callableId, context = null) }\n            .onEach { it.fir.validate() }\n    }\n\n    private fun generateTopLevelProperties(callableId: CallableId): List<FirPropertySymbol> {\n        return extensionsByTopLevelCallableId.getValue()[callableId].orEmpty()\n            .flatMap { it.generateProperties(callableId, context = null) }\n            .onEach { it.fir.validate() }\n    }\n\n    private fun hasPackage(packageFqName: FqName): Boolean {\n        return extensions.any { it.hasPackage(packageFqName) }\n    }\n\n    // ------------------------------------------ provider methods ------------------------------------------\n\n    override val symbolNamesProvider: FirSymbolNamesProvider = object : FirSymbolNamesProvider() {\n        override val hasSpecificClassifierPackageNamesComputation: Boolean get() = true\n\n        override fun getPackageNamesWithTopLevelClassifiers(): Set<String>? =\n      "}
{"code": "      buildSet {\n                extensions.forEach { extension ->\n                    extension.topLevelClassIdsCache.getValue().mapTo(this) { it.packageFqName.asString() }\n                }\n            }\n\n        override fun getTopLevelClassifierNamesInPackage(packageFqName: FqName): Set<Name> =\n            classNamesInPackageCache.getValue()[packageFqName] ?: emptySet()\n\n        override val hasSpecificCallablePackageNamesComputation: Boolean get() = true\n\n        override fun getPackageNamesWithTopLevelCallables(): Set<String> =\n            buildSet {\n                extensions.forEach { extension ->\n                    extension.topLevelCallableIdsCache.getValue().mapTo(this) { it.packageName.asString() }\n                }\n            }\n\n        override fun getTopLevelCallableNamesInPackage(packageFqName: FqName): Set<Name> =\n            callableNamesInPackageCache.getValue()[packageFqName].orEmpty()\n    }\n\n    override fun getClassLikeSymbolByClassId(classId: ClassId): FirClass"}
{"code": "LikeSymbol<*>? {\n        return classCache.getValue(classId)\n    }\n\n    @FirSymbolProviderInternals\n    override fun getTopLevelCallableSymbolsTo(destination: MutableList<FirCallableSymbol<*>>, packageFqName: FqName, name: Name) {\n        val callableId = CallableId(packageFqName, name)\n        destination += functionCache.getValue(callableId)\n        destination += propertyCache.getValue(callableId)\n    }\n\n    @FirSymbolProviderInternals\n    override fun getTopLevelFunctionSymbolsTo(destination: MutableList<FirNamedFunctionSymbol>, packageFqName: FqName, name: Name) {\n        destination += functionCache.getValue(CallableId(packageFqName, name))\n    }\n\n    @FirSymbolProviderInternals\n    override fun getTopLevelPropertySymbolsTo(destination: MutableList<FirPropertySymbol>, packageFqName: FqName, name: Name) {\n        destination += propertyCache.getValue(CallableId(packageFqName, name))\n    }\n\n    override fun getPackage(fqName: FqName): FqName? {\n        return fqName.takeIf { packag"}
{"code": "eCache.getValue(fqName, null) }\n    }\n}\n"}
{"code": "// FILE: main.kt\npackage foo.www.ddd\n\nclass BBD {\n    class Bwd\n}\nclass Check {\n    class BBD {\n        class Bwd {\n            fun dad() {\n                val Bwd = 42\n\n                val a = <expr>foo.www.ddd.Check.BBD.Bwd::class.java.annotatedInterfaces.size</expr>\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.impl.base.test.cases.types\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.types.KtType\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.builders.TestConfigurationBuilder\nimport org.jetbrains.kotlin.test.directives.model.SimpleDirectivesContainer\nimport org.jetbrains.kotlin.test.directives.model.singleValue\nimport org.jetbrains.kotlin.test.services.TestServices\nimport java.util.Locale\n\nabstract class AbstractBuiltInTypeTest : AbstractTypeTest() {\n\n    override fun configureTest(builder: TestConfigurationBuilder) {\n        super.configureTest(builder)\n        builder.apply {\n            useDirectives(Directives)\n        }\n    }\n\n    context(KtAnalysisSession)\n    override fun getType(ktFile: KtFile, module: KtTestModule, testServices: TestServices): KtType {\n        val builtInTypeName ="}
{"code": " module.testModule.directives.singleValue(Directives.BUILTIN_TYPE_NAME)\n        val typeMethod = builtinTypes::class.java.methods.singleOrNull {\n            it.name == \"get${builtInTypeName.uppercase(Locale.US)}\"\n        }!!\n        typeMethod.isAccessible = true\n        return typeMethod.invoke(builtinTypes) as KtType\n    }\n\n    object Directives : SimpleDirectivesContainer() {\n        val BUILTIN_TYPE_NAME by stringDirective(\"name of built in type\")\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.classes\n\nimport com.intellij.psi.PsiManager\nimport com.intellij.psi.PsiMethod\nimport com.intellij.psi.PsiModifierList\nimport com.intellij.psi.PsiReferenceList\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.symbols.*\nimport org.jetbrains.kotlin.analysis.api.symbols.pointers.KtSymbolPointer\nimport org.jetbrains.kotlin.analysis.api.symbols.pointers.symbolPointerOfType\nimport org.jetbrains.kotlin.analysis.project.structure.KtModule\nimport org.jetbrains.kotlin.analysis.project.structure.KtSourceModule\nimport org.jetbrains.kotlin.asJava.builder.LightMemberOriginForDeclaration\nimport org.jetbrains.kotlin.asJava.classes.METHOD_INDEX_BASE\nimport org.jetbrains.kotlin.asJava.classes.METHOD_INDEX_FOR_NON_ORIGIN_METHOD\nimport org.jetbrains.kotlin.asJava.classes.lazyPub\nimport org.jetbrains.kotlin.asJava.elements.KtLightField\nimport org.jetbrains.kotlin.asJava.elements.KtLightMethod\nimport org.je"}
{"code": "tbrains.kotlin.builtins.StandardNames\nimport org.jetbrains.kotlin.builtins.StandardNames.HASHCODE_NAME\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.light.classes.symbol.annotations.GranularAnnotationsBox\nimport org.jetbrains.kotlin.light.classes.symbol.annotations.SymbolAnnotationsProvider\nimport org.jetbrains.kotlin.light.classes.symbol.cachedValue\nimport org.jetbrains.kotlin.light.classes.symbol.fields.SymbolLightField\nimport org.jetbrains.kotlin.light.classes.symbol.fields.SymbolLightFieldForEnumEntry\nimport org.jetbrains.kotlin.light.classes.symbol.fields.SymbolLightFieldForObject\nimport org.jetbrains.kotlin.light.classes.symbol.methods.SymbolLightSimpleMethod\nimport org.jetbrains.kotlin.light.classes.symbol.modifierLists.GranularModifiersBox\nimport org.jetbrains.kotlin.light.classes.symbol.modifierLists.SymbolLightClassModifierList\nimport org.jetbrains.kotlin.load.java.JvmAbi\nimport org.jetbrains.kotlin.name.JvmStandardClassIds\nimport org.jetbrain"}
{"code": "s.kotlin.psi.*\nimport org.jetbrains.kotlin.resolve.DataClassResolver\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOriginKind\nimport org.jetbrains.kotlin.util.OperatorNameConventions.EQUALS\nimport org.jetbrains.kotlin.util.OperatorNameConventions.TO_STRING\nimport org.jetbrains.kotlin.utils.addToStdlib.applyIf\n\ninternal open class SymbolLightClassForClassOrObject : SymbolLightClassForNamedClassLike {\n    constructor(\n        ktAnalysisSession: KtAnalysisSession,\n        ktModule: KtModule,\n        classOrObjectSymbol: KtNamedClassOrObjectSymbol,\n        manager: PsiManager,\n    ) : super(\n        ktAnalysisSession = ktAnalysisSession,\n        ktModule = ktModule,\n        classOrObjectSymbol = classOrObjectSymbol,\n        manager = manager,\n    ) {\n        require(classOrObjectSymbol.classKind != KtClassKind.INTERFACE && classOrObjectSymbol.classKind != KtClassKind.ANNOTATION_CLASS)\n    }\n\n    constructor(\n        classOrObject: KtClassOrObject,\n        ktModule: KtMo"}
{"code": "dule,\n    ) : this(\n        classOrObjectDeclaration = classOrObject,\n        classOrObjectSymbolPointer = classOrObject.symbolPointerOfType(),\n        ktModule = ktModule,\n        manager = classOrObject.manager,\n    ) {\n        require(classOrObject !is KtClass || !classOrObject.isInterface() && !classOrObject.isAnnotation())\n    }\n\n    protected constructor(\n        classOrObjectDeclaration: KtClassOrObject?,\n        classOrObjectSymbolPointer: KtSymbolPointer<KtNamedClassOrObjectSymbol>,\n        ktModule: KtModule,\n        manager: PsiManager,\n    ) : super(\n        classOrObjectDeclaration = classOrObjectDeclaration,\n        classOrObjectSymbolPointer = classOrObjectSymbolPointer,\n        ktModule = ktModule,\n        manager = manager,\n    )\n\n    private val _modifierList: PsiModifierList by lazyPub {\n        SymbolLightClassModifierList(\n            containingDeclaration = this,\n            modifiersBox = GranularModifiersBox(computer = ::computeModifiers),\n            annotation"}
{"code": "sBox = GranularAnnotationsBox(\n                annotationsProvider = SymbolAnnotationsProvider(ktModule, classOrObjectSymbolPointer)\n            ),\n        )\n    }\n\n    override fun getModifierList(): PsiModifierList? = _modifierList\n    override fun getExtendsList(): PsiReferenceList? = _extendsList\n    override fun getImplementsList(): PsiReferenceList? = _implementsList\n\n    private val _extendsList by lazyPub {\n        withClassOrObjectSymbol { classOrObjectSymbol ->\n            createInheritanceList(forExtendsList = true, classOrObjectSymbol.superTypes)\n        }\n    }\n\n    private val _implementsList by lazyPub {\n        withClassOrObjectSymbol { classOrObjectSymbol ->\n            createInheritanceList(forExtendsList = false, classOrObjectSymbol.superTypes)\n        }\n    }\n\n    override fun getOwnMethods(): List<PsiMethod> = cachedValue {\n        withClassOrObjectSymbol { classOrObjectSymbol ->\n            val result = mutableListOf<KtLightMethod>()\n\n            // We should use "}
{"code": "the combined declared member scope here because an enum class may contain static callables.\n            val declaredMemberScope = classOrObjectSymbol.getCombinedDeclaredMemberScope()\n\n            val visibleDeclarations = declaredMemberScope.getCallableSymbols()\n                .applyIf(classKind().isObject) {\n                    filterNot {\n                        it is KtKotlinPropertySymbol && it.isConst\n                    }\n                }.applyIf(classOrObjectSymbol.isData) {\n                    // Technically, synthetic members of `data` class, such as `componentN` or `copy`, are visible.\n                    // They're just needed to be added later (to be in a backward-compatible order of members).\n                    filterNot { function ->\n                        function is KtFunctionSymbol && function.origin == KtSymbolOrigin.SOURCE_MEMBER_GENERATED\n                    }\n                }.applyIf(isEnum && isEnumEntriesDisabled()) {\n                    filterNot {\n        "}
{"code": "                it is KtKotlinPropertySymbol && it.origin == KtSymbolOrigin.SOURCE_MEMBER_GENERATED && it.name == StandardNames.ENUM_ENTRIES\n                    }\n                }\n                .filterNot {\n                    it.hasTypeForValueClassInSignature()\n                }\n\n            val suppressStatic = classKind() == KtClassKind.COMPANION_OBJECT\n            createMethods(visibleDeclarations, result, suppressStatic = suppressStatic)\n\n            createConstructors(declaredMemberScope.getConstructors(), result)\n\n\n            addMethodsFromCompanionIfNeeded(result, classOrObjectSymbol)\n\n            addMethodsFromDataClass(result, classOrObjectSymbol)\n            addDelegatesToInterfaceMethods(result, classOrObjectSymbol)\n\n            result\n        }\n    }\n\n    private fun isEnumEntriesDisabled(): Boolean {\n        return (ktModule as? KtSourceModule)\n            ?.languageVersionSettings\n            ?.supportsFeature(LanguageFeature.EnumEntries) != true\n    }\n\n    context("}
{"code": "KtAnalysisSession)\n    private fun addMethodsFromDataClass(result: MutableList<KtLightMethod>, classOrObjectSymbol: KtNamedClassOrObjectSymbol) {\n        if (!classOrObjectSymbol.isData) return\n\n        fun createMethodFromAny(ktFunctionSymbol: KtFunctionSymbol) {\n            // Similar to `copy`, synthetic members from `Any` should refer to `data` class as origin, not the function in `Any`.\n            val lightMemberOrigin = classOrObjectDeclaration?.let { LightMemberOriginForDeclaration(it, JvmDeclarationOriginKind.OTHER) }\n            result.add(\n                SymbolLightSimpleMethod(\n                    ktAnalysisSession = this@KtAnalysisSession,\n                    ktFunctionSymbol,\n                    lightMemberOrigin,\n                    this,\n                    METHOD_INDEX_BASE,\n                    false,\n                    suppressStatic = false,\n                )\n            )\n        }\n\n        // NB: componentN and copy are added during RAW FIR, but synthetic members"}
{"code": " from `Any` are not.\n        // That's why we use declared scope for 'component*' and 'copy', and member scope for 'equals/hashCode/toString'\n        val componentAndCopyFunctions = classOrObjectSymbol.getDeclaredMemberScope()\n            .getCallableSymbols { name -> DataClassResolver.isCopy(name) || DataClassResolver.isComponentLike(name) }\n            .filter { it.origin == KtSymbolOrigin.SOURCE_MEMBER_GENERATED }\n            .filterIsInstance<KtFunctionSymbol>()\n\n        createMethods(componentAndCopyFunctions, result)\n\n        // Compiler will generate 'equals/hashCode/toString' for data class if they are not final.\n        // We want to mimic that.\n        val generatedFunctionsFromAny = classOrObjectSymbol.getMemberScope()\n            .getCallableSymbols(EQUALS, HASHCODE_NAME, TO_STRING)\n            .filterIsInstance<KtFunctionSymbol>()\n            .filter { it.origin == KtSymbolOrigin.SOURCE_MEMBER_GENERATED }\n\n        val functionsFromAnyByName = generatedFunctionsFromAny.asso"}
{"code": "ciateBy { it.name }\n\n        // NB: functions from `Any` are not in an alphabetic order.\n        functionsFromAnyByName[TO_STRING]?.let { createMethodFromAny(it) }\n        functionsFromAnyByName[HASHCODE_NAME]?.let { createMethodFromAny(it) }\n        functionsFromAnyByName[EQUALS]?.let { createMethodFromAny(it) }\n    }\n\n    context(KtAnalysisSession)\n    private fun addDelegatesToInterfaceMethods(result: MutableList<KtLightMethod>, classOrObjectSymbol: KtNamedClassOrObjectSymbol) {\n        fun createDelegateMethod(ktFunctionSymbol: KtFunctionSymbol) {\n            val kotlinOrigin = ktFunctionSymbol.psiSafe<KtDeclaration>() ?: classOrObjectDeclaration\n            val lightMemberOrigin = kotlinOrigin?.let { LightMemberOriginForDeclaration(it, JvmDeclarationOriginKind.DELEGATION) }\n            result.add(\n                SymbolLightSimpleMethod(\n                    ktAnalysisSession = this@KtAnalysisSession,\n                    ktFunctionSymbol,\n                    lightMemberOrigin,\n    "}
{"code": "                this,\n                    METHOD_INDEX_FOR_NON_ORIGIN_METHOD,\n                    false,\n                    argumentsSkipMask = null,\n                    suppressStatic = false,\n                )\n            )\n        }\n\n        classOrObjectSymbol.getDelegatedMemberScope().getCallableSymbols().forEach { functionSymbol ->\n            if (functionSymbol is KtFunctionSymbol) {\n                createDelegateMethod(functionSymbol)\n            }\n        }\n    }\n\n    override fun getOwnFields(): List<KtLightField> = cachedValue {\n        withClassOrObjectSymbol { classOrObjectSymbol ->\n            val result = mutableListOf<KtLightField>()\n\n            // First, add static fields: companion object and fields from companion object\n            addCompanionObjectFieldIfNeeded(result, classOrObjectSymbol)\n            val nameGenerator = SymbolLightField.FieldNameGenerator()\n            addFieldsFromCompanionIfNeeded(result, classOrObjectSymbol, nameGenerator)\n\n            // The"}
{"code": "n, add instance fields: properties from parameters, and then member properties\n            addPropertyBackingFields(result, classOrObjectSymbol, nameGenerator)\n\n            // Next, add INSTANCE field if non-local named object\n            addInstanceFieldIfNeeded(result, classOrObjectSymbol)\n\n            // Last, add fields for enum entries\n            addFieldsForEnumEntries(result, classOrObjectSymbol)\n\n            result\n        }\n    }\n\n    context(KtAnalysisSession)\n    private fun addInstanceFieldIfNeeded(result: MutableList<KtLightField>, namedClassOrObjectSymbol: KtNamedClassOrObjectSymbol) {\n        if (classKind() != KtClassKind.OBJECT || isLocal) return\n\n        result.add(\n            SymbolLightFieldForObject(\n                ktAnalysisSession = this@KtAnalysisSession,\n                objectSymbol = namedClassOrObjectSymbol,\n                containingClass = this,\n                name = JvmAbi.INSTANCE_FIELD,\n                lightMemberOrigin = null,\n                isComp"}
{"code": "anion = false,\n            )\n        )\n    }\n\n    context(KtAnalysisSession)\n    private fun addFieldsForEnumEntries(result: MutableList<KtLightField>, classOrObjectSymbol: KtNamedClassOrObjectSymbol) {\n        if (!isEnum) return\n\n        classOrObjectSymbol.getStaticDeclaredMemberScope().getCallableSymbols()\n            .filterIsInstance<KtEnumEntrySymbol>()\n            .mapNotNullTo(result) {\n                val enumEntry = it.sourcePsiSafe<KtEnumEntry>()\n                val name = enumEntry?.name ?: return@mapNotNullTo null\n                SymbolLightFieldForEnumEntry(\n                    enumEntry = enumEntry,\n                    enumEntryName = name,\n                    containingClass = this,\n                )\n            }\n    }\n\n    override fun isInterface(): Boolean = false\n    override fun isAnnotationType(): Boolean = false\n    override fun classKind(): KtClassKind = _classKind\n\n    private val _classKind: KtClassKind by lazyPub {\n        when (classOrObjectDeclaration) {\n"}
{"code": "            is KtObjectDeclaration -> {\n                if (classOrObjectDeclaration.isCompanion()) KtClassKind.COMPANION_OBJECT else KtClassKind.OBJECT\n            }\n\n            is KtClass -> {\n                if (classOrObjectDeclaration.isEnum()) KtClassKind.ENUM_CLASS else KtClassKind.CLASS\n            }\n\n            else -> withClassOrObjectSymbol { it.classKind }\n        }\n    }\n\n    override fun isRecord(): Boolean {\n        return _modifierList.hasAnnotation(JvmStandardClassIds.Annotations.JvmRecord.asFqNameString())\n    }\n\n    override fun copy(): SymbolLightClassForClassOrObject =\n        SymbolLightClassForClassOrObject(classOrObjectDeclaration, classOrObjectSymbolPointer, ktModule, manager)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.declarations.renderers.callables\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.renderer.declarations.KtDeclarationRenderer\nimport org.jetbrains.kotlin.analysis.api.symbols.KtKotlinPropertySymbol\nimport org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter\nimport org.jetbrains.kotlin.lexer.KtTokens\n\npublic interface KtKotlinPropertySymbolRenderer {\n    context(KtAnalysisSession, KtDeclarationRenderer)\n    public fun renderSymbol(symbol: KtKotlinPropertySymbol, printer: PrettyPrinter)\n\n    public object AS_SOURCE : KtKotlinPropertySymbolRenderer {\n        context(KtAnalysisSession, KtDeclarationRenderer)\n        override fun renderSymbol(symbol: KtKotlinPropertySymbol, printer: PrettyPrinter): Unit = printer {\n            val mutabilityKeyword = if (symbol.isVal) KtTokens.VAL_KEYWORD else KtTokens.VAR_KEYWORD\n            callableSignatureRenderer.renderCallableSignature(symbol,"}
{"code": " mutabilityKeyword, printer)\n            variableInitializerRenderer.renderInitializer(symbol, printer)\n            propertyAccessorsRenderer.renderAccessors(symbol, printer)\n        }\n    }\n}"}
{"code": "// FILE: Node.java\n\npublic interface Node<R> {\n    R result();\n}\n\n// FILE: foo.kt\n\nfun foo(): Boolean {\n    object : Node<Boolean> {\n        private var result = false\n\n        fun bar(): Boolean {\n            return !result\n        }\n\n        // Cannot see private member of local class / anonymous object\n        override fun result() = result\n    }\n\n    val some = true\n    return !some\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.scopes.impl\n\nimport org.jetbrains.kotlin.descriptors.Visibilities\nimport org.jetbrains.kotlin.descriptors.Visibility\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.declarations.utils.isSuspend\nimport org.jetbrains.kotlin.fir.declarations.utils.visibility\nimport org.jetbrains.kotlin.fir.resolve.substitution.ConeSubstitutor\nimport org.jetbrains.kotlin.fir.resolve.transformers.ensureResolvedTypeDeclaration\nimport org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol\nimport org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.types.AbstractTypeChecker\n\nclass FirStandardOverrideChecker(private val session: FirSession) : FirAbstractOverrideChecker() {\n    private val context = session.typeContext\n\n    private fun isEqualTypes(candidateType: ConeKotli"}
{"code": "nType, baseType: ConeKotlinType, substitutor: ConeSubstitutor): Boolean {\n        val substitutedCandidateType = substitutor.substituteOrSelf(candidateType)\n        val substitutedBaseType = substitutor.substituteOrSelf(baseType)\n        return AbstractTypeChecker.equalTypes(context, substitutedCandidateType, substitutedBaseType)\n    }\n\n    fun isEqualTypes(candidateTypeRef: FirTypeRef, baseTypeRef: FirTypeRef, substitutor: ConeSubstitutor): Boolean {\n        candidateTypeRef.ensureResolvedTypeDeclaration(session, requiredPhase = FirResolvePhase.TYPES)\n        baseTypeRef.ensureResolvedTypeDeclaration(session, requiredPhase = FirResolvePhase.TYPES)\n        if (candidateTypeRef is FirErrorTypeRef && baseTypeRef is FirErrorTypeRef) {\n            return maybeEqualErrorTypes(candidateTypeRef, baseTypeRef)\n        }\n        return isEqualTypes(candidateTypeRef.coneType, baseTypeRef.coneType, substitutor)\n    }\n\n    private fun maybeEqualErrorTypes(ref1: FirErrorTypeRef, ref2: FirErrorTypeRe"}
{"code": "f): Boolean {\n        val delegated1 = ref1.delegatedTypeRef as? FirUserTypeRef ?: return false\n        val delegated2 = ref2.delegatedTypeRef as? FirUserTypeRef ?: return false\n        if (delegated1.qualifier.size != delegated2.qualifier.size) return false\n        return delegated1.qualifier.zip(delegated2.qualifier).all { (l, r) -> l.name == r.name }\n    }\n\n\n    \n    private fun isEqualBound(\n        overrideBound: FirTypeRef,\n        baseBound: FirTypeRef,\n        overrideTypeParameter: FirTypeParameter,\n        baseTypeParameter: FirTypeParameter,\n        substitutor: ConeSubstitutor\n    ): Boolean {\n        val substitutedOverrideType = substitutor.substituteOrSelf(overrideBound.coneType)\n        val substitutedBaseType = substitutor.substituteOrSelf(baseBound.coneType)\n\n        if (AbstractTypeChecker.equalTypes(context, substitutedOverrideType, substitutedBaseType)) return true\n\n        return overrideTypeParameter.symbol.resolvedBounds.any { bound ->\n            isEqualTypes(\n"}
{"code": "                bound.coneType,\n                substitutedBaseType,\n                substitutor\n            )\n        } &&\n                baseTypeParameter.symbol.resolvedBounds.any { bound -> isEqualTypes(bound.coneType, substitutedOverrideType, substitutor) }\n    }\n\n    private fun isCompatibleTypeParameters(\n        overrideCandidate: FirTypeParameterRef,\n        baseDeclaration: FirTypeParameterRef,\n        substitutor: ConeSubstitutor\n    ): Boolean {\n        if (overrideCandidate.symbol == baseDeclaration.symbol) return true\n        if (overrideCandidate !is FirTypeParameter || baseDeclaration !is FirTypeParameter) return false\n        if (overrideCandidate.bounds.size != baseDeclaration.bounds.size) return false\n        return overrideCandidate.symbol.resolvedBounds.zip(baseDeclaration.symbol.resolvedBounds)\n            .all { (aBound, bBound) -> isEqualBound(aBound, bBound, overrideCandidate, baseDeclaration, substitutor) }\n    }\n\n    override fun buildTypeParametersSubstitut"}
{"code": "orIfCompatible(\n        overrideCandidate: FirCallableDeclaration,\n        baseDeclaration: FirCallableDeclaration\n    ): ConeSubstitutor? {\n        overrideCandidate.lazyResolveToPhase(FirResolvePhase.TYPES)\n        baseDeclaration.lazyResolveToPhase(FirResolvePhase.TYPES)\n        val substitutor = buildSubstitutorForOverridesCheck(overrideCandidate, baseDeclaration, session) ?: return null\n        if (\n            overrideCandidate.typeParameters.isNotEmpty() &&\n            overrideCandidate.typeParameters.zip(baseDeclaration.typeParameters).any { (override, base) ->\n                !isCompatibleTypeParameters(override, base, substitutor)\n            }\n        ) return null\n        return substitutor\n    }\n\n    private fun isEqualReceiverTypes(candidateTypeRef: FirTypeRef?, baseTypeRef: FirTypeRef?, substitutor: ConeSubstitutor): Boolean {\n        return when {\n            candidateTypeRef != null && baseTypeRef != null -> isEqualTypes(candidateTypeRef, baseTypeRef, substitutor)\n    "}
{"code": "        else -> candidateTypeRef == null && baseTypeRef == null\n        }\n    }\n\n    override fun isOverriddenFunction(overrideCandidate: FirSimpleFunction, baseDeclaration: FirSimpleFunction): Boolean {\n        return isOverriddenFunction(overrideCandidate, baseDeclaration, ignoreVisibility = false)\n    }\n\n    fun isOverriddenFunction(overrideCandidate: FirSimpleFunction, baseDeclaration: FirSimpleFunction, ignoreVisibility: Boolean): Boolean {\n        if (overrideCandidate.valueParameters.size != baseDeclaration.valueParameters.size) return false\n        if (overrideCandidate.isSuspend != baseDeclaration.isSuspend) return false\n        if (baseDeclaration.isHiddenToOvercomeSignatureClash == true) return false\n\n        val substitutor = buildTypeParametersSubstitutorIfCompatible(overrideCandidate, baseDeclaration) ?: return false\n\n        if (!commonCallableChecks(overrideCandidate, baseDeclaration, substitutor, ignoreVisibility)) return false\n\n        return overrideCandidate.valuePa"}
{"code": "rameters.zip(baseDeclaration.valueParameters).all { (memberParam, selfParam) ->\n            isEqualTypes(memberParam.returnTypeRef, selfParam.returnTypeRef, substitutor)\n        }\n    }\n\n    override fun isOverriddenProperty(overrideCandidate: FirCallableDeclaration, baseDeclaration: FirProperty): Boolean {\n        return isOverriddenProperty(overrideCandidate, baseDeclaration, ignoreVisibility = false)\n    }\n\n    fun isOverriddenProperty(\n        overrideCandidate: FirCallableDeclaration,\n        baseDeclaration: FirProperty,\n        ignoreVisibility: Boolean,\n    ): Boolean {\n        if (overrideCandidate !is FirProperty) return false\n        val substitutor = buildTypeParametersSubstitutorIfCompatible(overrideCandidate, baseDeclaration) ?: return false\n        return commonCallableChecks(overrideCandidate, baseDeclaration, substitutor, ignoreVisibility)\n    }\n\n    private fun FirStandardOverrideChecker.commonCallableChecks(\n        overrideCandidate: FirCallableDeclaration,\n        "}
{"code": "baseDeclaration: FirCallableDeclaration,\n        substitutor: ConeSubstitutor,\n        // Overload-ability is used to filter out equivalent calls (see ConeEquivalentCallConflictResolver) in which case visibility\n        // must be ignored.\n        ignoreVisibility: Boolean,\n    ): Boolean {\n        if (!ignoreVisibility && Visibilities.isPrivate(baseDeclaration.visibility)) return false\n        if (overrideCandidate.contextReceivers.size != baseDeclaration.contextReceivers.size) return false\n\n        overrideCandidate.lazyResolveToPhase(FirResolvePhase.TYPES)\n        baseDeclaration.lazyResolveToPhase(FirResolvePhase.TYPES)\n\n        return isEqualReceiverTypes(\n            overrideCandidate.receiverParameter?.typeRef,\n            baseDeclaration.receiverParameter?.typeRef,\n            substitutor\n        ) && overrideCandidate.contextReceivers.zip(baseDeclaration.contextReceivers).all { (memberParam, selfParam) ->\n            isEqualTypes(memberParam.typeRef, selfParam.typeRef, substit"}
{"code": "utor)\n        }\n    }\n\n    override fun chooseIntersectionVisibility(\n        overrides: Collection<FirCallableSymbol<*>>,\n        dispatchClassSymbol: FirRegularClassSymbol?,\n    ): Visibility {\n        return chooseIntersectionVisibilityOrNull(overrides) ?: Visibilities.Unknown\n    }\n}\n"}
{"code": "fun main() {\n    kotlin.collections.<expr>List<String></expr>\n}"}
{"code": "package test\n\nclass A(val n: Any) {\n    override infix fun equals(other: Any?): Boolean = other is A && other.n <caret>!= n\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.tree.generator.util\n\nimport org.jetbrains.kotlin.generators.util.GeneratorsFileUtil\nimport org.jetbrains.kotlin.utils.SmartPrinter\nimport java.io.File\n\ninline fun File.writeToFileUsingSmartPrinterIfFileContentChanged(block: SmartPrinter.() -> Unit) {\n    val newText = buildString { SmartPrinter(this).block() }\n    GeneratorsFileUtil.writeFileIfContentChanged(this, newText, logNotChanged = false)\n}\n"}
{"code": "// FILE: main.kt\ninterface MyInterface {\n    class Nested\n\n    <expr>val prop: MyInterface.Nested get() = MyInterface.Nested()</expr>\n}\n"}
{"code": "fun test() {\n    var i = 0\n    while (<expr>i < 100</expr>) {\n        i++\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.providers.impl\n\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.*\n\ninternal class KotlinStaticDeclarationIndex {\n    internal val facadeFileMap: MutableMap<FqName, MutableSet<KtFile>> = mutableMapOf()\n    internal val multiFileClassPartMap: MutableMap<FqName, MutableSet<KtFile>> = mutableMapOf()\n    internal val scriptMap: MutableMap<FqName, MutableSet<KtScript>> = mutableMapOf()\n    internal val classMap: MutableMap<FqName, MutableSet<KtClassOrObject>> = mutableMapOf()\n    internal val typeAliasMap: MutableMap<FqName, MutableSet<KtTypeAlias>> = mutableMapOf()\n    internal val topLevelFunctionMap: MutableMap<FqName, MutableSet<KtNamedFunction>> = mutableMapOf()\n    internal val topLevelPropertyMap: MutableMap<FqName, MutableSet<KtProperty>> = mutableMapOf()\n\n    \n    internal val classesBySupertypeName: MutableMap<Name, MutableSet<KtClassOrObject>> = mutableMapOf()\n\n    \n    internal v"}
{"code": "al inheritableTypeAliasesByAliasedName: MutableMap<Name, MutableSet<KtTypeAlias>> = mutableMapOf()\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\")\n\npackage org.jetbrains.kotlin.fir.declarations.impl\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirImplementationDetail\nimport org.jetbrains.kotlin.fir.FirModuleData\nimport org.jetbrains.kotlin.fir.MutableOrEmptyList\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirBlock\nimport org.jetbrains.kotlin.fir.references.FirControlFlowGraphReference\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirAnonymousInitializerSymbol\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.fir.visitors.transformInplace\n\n@OptIn(Fir"}
{"code": "ImplementationDetail::class, ResolveStateAccess::class)\ninternal class FirAnonymousInitializerImpl(\n    override val source: KtSourceElement?,\n    resolvePhase: FirResolvePhase,\n    override var annotations: MutableOrEmptyList<FirAnnotation>,\n    override val moduleData: FirModuleData,\n    override val origin: FirDeclarationOrigin,\n    override val attributes: FirDeclarationAttributes,\n    override var body: FirBlock?,\n    override val symbol: FirAnonymousInitializerSymbol,\n    override val containingDeclarationSymbol: FirBasedSymbol<*>?,\n) : FirAnonymousInitializer() {\n    override var controlFlowGraphReference: FirControlFlowGraphReference? = null\n\n    init {\n        symbol.bind(this)\n        resolveState = resolvePhase.asResolveState()\n    }\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {\n        annotations.forEach { it.accept(visitor, data) }\n        controlFlowGraphReference?.accept(visitor, data)\n        body?.accept(visitor, data)\n    }\n\n    overri"}
{"code": "de fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirAnonymousInitializerImpl {\n        transformAnnotations(transformer, data)\n        controlFlowGraphReference = controlFlowGraphReference?.transform(transformer, data)\n        body = body?.transform(transformer, data)\n        return this\n    }\n\n    override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirAnonymousInitializerImpl {\n        annotations.transformInplace(transformer, data)\n        return this\n    }\n\n    override fun replaceAnnotations(newAnnotations: List<FirAnnotation>) {\n        annotations = newAnnotations.toMutableOrEmpty()\n    }\n\n    override fun replaceControlFlowGraphReference(newControlFlowGraphReference: FirControlFlowGraphReference?) {\n        controlFlowGraphReference = newControlFlowGraphReference\n    }\n\n    override fun replaceBody(newBody: FirBlock?) {\n        body = newBody\n    }\n}\n"}
{"code": "// !OPT_IN: kotlin.RequiresOptIn\nimport kotlin.contracts.*\n\n@OptIn(ExperimentalContracts::class)\nfun foo(x: String?): Any? {\n    <!WRONG_IMPLIES_CONDITION!>contract {\n        returns(null) implies (x != null)\n    }<!>\n\n    if (true) {\n        throw java.lang.IllegalArgumentException()\n    }\n\n    return x\n}\n\n@OptIn(ExperimentalContracts::class)\nfun bar(x: String?): Any? {\n    <!WRONG_IMPLIES_CONDITION!>contract {\n        returns() implies (x != null)\n    }<!>\n\n    if (x == null) {\n        return x\n    }\n    return x\n}\n\n@OptIn(ExperimentalContracts::class)\nfun baz(x: String?): Any? {\n    <!WRONG_IMPLIES_CONDITION!>contract {\n        returns(null) implies (x != null)\n    }<!>\n\n    return x\n}"}
{"code": "// IGNORE_FE10\n\nfun <T : Any, Z> createTuple(a: T, b: Z&Any): Pair<T, Z&Any> {\n    return Pair(a, b)\n}\n\nfun main()\nvar (<caret>val1, val2) = createTuple<String, Int?>(\"a\", 1)\n}"}
{"code": "// SKIP_JAVAC\n// This directive is needed to skip this test in LazyBodyIsNotTouchedTilContractsPhaseTestGenerated,\n//  because it fails to parse module structure of multimodule test\n\n// MODULE: lib\npackage lib\n\nabstract class FirstBase {\n    interface Result\n}\n\nabstract class SecondBase : FirstBase()\n\nabstract class Test : SecondBase() {\n    class Success : Result\n}\n\n// MODULE: main(lib)\npackage main\n\nimport lib.Test\n\nclass Main : Test() {\n    fun usage(): Result {\n        return Success()\n    }\n}"}
{"code": "fun foo(@ParameterAnnotation(\"param\") param1: @ParameterTypeAnnotation(\"$prop\") List<@NestedParameterTypeAnnotation(\"nested $prop\") Collection<@NestedNestedParameterTypeAnnotation(\"nested nested $prop\") String>> = @DefaultValueAnnotation fun(i: @Anno(\"anonymousFunction parameter type $prop\") Int): @Anno(\"anonymousFunction return type $prop\") Int {}) = param1"}
{"code": "\n\npackage org.jetbrains.kotlin.build.report.statistics.file\n\nimport java.util.*\nimport kotlin.math.max\n\ninternal fun printMap(p: Printer, name: String, mapping: Map<String, Int>) {\n    if (mapping.isEmpty()) return\n\n    if (mapping.size == 1) {\n        p.println(\"$name: ${mapping.keys.single()}\")\n        return\n    }\n\n    p.withIndent(\"$name:\") {\n        val sortedEnumMap = mapping.toSortedMap()\n        for ((k, v) in sortedEnumMap) {\n            p.println(\"$k($v)\")\n        }\n    }\n}\n\ninternal class TextTable(vararg columnNames: String) {\n    private val rows = ArrayList<List<String>>()\n    private val columnsCount = columnNames.size\n    private val maxLengths = IntArray(columnsCount) { columnNames[it].length }\n\n    init {\n        rows.add(columnNames.toList())\n    }\n\n    fun addRow(vararg row: String) {\n        check(row.size == columnsCount) { \"Row size ${row.size} differs from columns count $columnsCount\" }\n        rows.add(row.toList())\n\n        for ((i, col) in row.withIndex()) {\n"}
{"code": "            maxLengths[i] = max(maxLengths[i], col.length)\n        }\n    }\n\n    fun printTo(p: Printer) {\n        for (row in rows) {\n            val rowStr = row.withIndex().joinToString(\"|\") { (i, col) -> col.padEnd(maxLengths[i], ' ') }\n            p.println(rowStr)\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.sessions\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.LLFirModuleResolveComponents\nimport org.jetbrains.kotlin.analysis.project.structure.KtNotUnderContentRootModule\nimport org.jetbrains.kotlin.fir.BuiltinTypes\nimport org.jetbrains.kotlin.fir.PrivateSessionConstructor\n\ninternal class LLFirNotUnderContentRootResolvableModuleSession @PrivateSessionConstructor constructor(\n    ktModule: KtNotUnderContentRootModule,\n    override val moduleComponents: LLFirModuleResolveComponents,\n    builtinTypes: BuiltinTypes,\n) : LLFirResolvableModuleSession(ktModule, builtinTypes)\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.dfa\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\n\nabstract class VariableStorage {\n    abstract fun getRealVariableWithoutUnwrappingAlias(fir: FirElement, unwrapAlias: (RealVariable, FirElement) -> RealVariable?): RealVariable?\n    abstract fun getLocalVariable(symbol: FirBasedSymbol<*>): RealVariable?\n    abstract fun get(fir: FirElement, unwrapAlias: (RealVariable, FirElement) -> RealVariable?): DataFlowVariable?\n}\n"}
{"code": "\n\n// FILE: A.java\n\npublic class A {\n    public String getVMParameters() {\n        return null;\n    }\n}\n\n// FILE: B.java\n\npublic class B {\n    public Integer getVmParameters() {\n        return null;\n    }\n}\n\n// FILE: C.java\n\npublic class C {\n    public String getVMParameters() {\n        return null;\n    }\n\n    public Integer getVmParameters() {\n        return null;\n    }\n}\n\n// FILE: D.java\n\npublic class D {\n    public boolean isGood() {\n        return true;\n    }\n}\n\n// FILE: main.kt\n\nfun test_1(x: A) {\n    val str1 = x.vmParameters // OK\n    val str2 = x.<!UNRESOLVED_REFERENCE!>vMParameters<!> // should be error\n}\n\nfun test_2(x: B) {\n    val int = x.vmParameters // OK\n    val error = x.<!UNRESOLVED_REFERENCE!>vMParameters<!> // should be error\n}\n\nfun test_3(x: C) {\n    val error = x.<!OVERLOAD_RESOLUTION_AMBIGUITY!>vmParameters<!> // should be error\n    val int = x.<!UNRESOLVED_REFERENCE!>vMParameters<!> // should be error\n}\n\nclass Foo {\n    fun getX(): Int = 1\n}\n\nfun test_4(foo: Foo) {"}
{"code": "\n    foo.<!UNRESOLVED_REFERENCE!>x<!> // should be error\n}\n\nfun test_5(x: D) {\n    x.isGood\n}\n"}
{"code": "fun resolveMe() {\n    receive(property)\n}\n\nval property: Number\n    field: Int = 10\n\nfun receive(s: Int) {}\n"}
{"code": "fun x() {\n    while(x<caret>y){\n}\n\n"}
{"code": "fun foo() {\n    var x = 0\n    val y = 0\n    <!ASSIGNED_VALUE_IS_NEVER_READ!>x<!> = y / x + 0\n}\n"}
{"code": "annotation class Anno(val s: String)\n\n@Deprecated(\"FirstClass\")\n@Anno(\"FirstClass\")\nclass Fir<caret>stClass @Deprecated(\"constructor\") @Anno(\"constructor\") constructor(@Deprecated(\"constructorProperty\") @Anno(\"constructorProperty\") val a: Int) {\n    @Deprecated(\"memberFunction\")\n    @Anno(\"memberFunction\")\n    fun memberFunction() {\n    }\n\n    @Deprecated(\"memberProperty\")\n    @Anno(\"memberProperty\")\n    val memberProperty = 32\n\n    @Deprecated(\"NestedClass\")\n    @Anno(\"NestedClass\")\n    class NestedClass @Deprecated(\"constructor\") @Anno(\"constructor\") constructor(@Deprecated(\"constructorProperty\") @Anno(\"constructorProperty\") val a: Int) {\n        @Deprecated(\"memberFunction\")\n        @Anno(\"memberFunction\")\n        fun memberFunction() {\n        }\n\n        @Deprecated(\"memberProperty\")\n        @Anno(\"memberProperty\")\n        val memberProperty = 32\n    }\n\n    @Deprecated(\"companion\")\n    @Anno(\"companion\")\n    companion object {\n        @Deprecated(\"memberFunction\")\n        @Anno(\"me"}
{"code": "mberFunction\")\n        fun memberFunction() {\n        }\n\n        @Deprecated(\"memberProperty\")\n        @Anno(\"memberProperty\")\n        val memberProperty = 32\n    }\n}\n\n@Deprecated(\"AnotherClass\")\n@Anno(\"AnotherClass\")\nclass AnotherClass {\n    @Deprecated(\"memberFunction\")\n    @Anno(\"memberFunction\")\n    fun memberFunction() {\n    }\n}"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\", \"unused\")\n\npackage org.jetbrains.kotlin.fir.declarations.builder\n\nimport kotlin.contracts.*\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.builder.FirBuilderDsl\nimport org.jetbrains.kotlin.fir.declarations.FirContextReceiver\nimport org.jetbrains.kotlin.fir.declarations.impl.FirContextReceiverImpl\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.name.Name\n\n@FirBuilderDsl\nclass FirContextReceiverBuilder {\n    var source: KtSourceElement? = null\n    lateinit var typeRef: FirTypeRef\n    var customLabelName: Name? = null\n    var labelNameFromTypeRef: Name? = null\n\n    fun build(): FirContextReceiver {\n        return FirContextReceiverImpl(\n            source,\n            typeRef,\n            customLabelName,\n            labelNameFromTypeRef,\n        )\n    }\n\n}\n\n@OptIn(ExperimentalC"}
{"code": "ontracts::class)\ninline fun buildContextReceiver(init: FirContextReceiverBuilder.() -> Unit): FirContextReceiver {\n    contract {\n        callsInPlace(init, InvocationKind.EXACTLY_ONCE)\n    }\n    return FirContextReceiverBuilder().apply(init).build()\n}\n\n@OptIn(ExperimentalContracts::class)\ninline fun buildContextReceiverCopy(original: FirContextReceiver, init: FirContextReceiverBuilder.() -> Unit): FirContextReceiver {\n    contract {\n        callsInPlace(init, InvocationKind.EXACTLY_ONCE)\n    }\n    val copyBuilder = FirContextReceiverBuilder()\n    copyBuilder.source = original.source\n    copyBuilder.typeRef = original.typeRef\n    copyBuilder.customLabelName = original.customLabelName\n    copyBuilder.labelNameFromTypeRef = original.labelNameFromTypeRef\n    return copyBuilder.apply(init).build()\n}\n"}
{"code": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE\nclass X<T> {\n    inner class Y<T1>\n    class Z<T2>\n\n    fun <T3> foo() {\n        class U<T4> {\n            inner class K<T5>\n            class C<T6>\n            class X<T> {\n                inner class Y<T1>\n                class Z<T2>\n\n                fun <T3> foo() {\n                    class U<T4> {\n                        inner class K<T5>\n                        class C<T6>\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.contracts\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.contracts.builder.buildContractElementDeclaration\nimport org.jetbrains.kotlin.fir.contracts.builder.buildEffectDeclaration\nimport org.jetbrains.kotlin.fir.contracts.description.ConeContractDescriptionElement\nimport org.jetbrains.kotlin.fir.contracts.description.ConeEffectDeclaration\n\nval FirContractDescription.effects: List<FirEffectDeclaration>?\n    get() = (this as? FirResolvedContractDescription)?.effects\n\nfun ConeEffectDeclaration.toFirElement(source: KtSourceElement? = null): FirEffectDeclaration =\n    buildEffectDeclaration {\n        if (source != null) {\n            this.source = source\n        }\n        effect = this@toFirElement\n    }\n\n\nfun ConeContractDescriptionElement.toFirElement(source: KtSourceElement? = null): FirContractElementDeclaration =\n    buildContractElementDeclaration {\n        if (source != null) {\n            this.source = source\n        }"}
{"code": "\n        effect = this@toFirElement\n    }\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen\n\nimport org.jetbrains.kotlin.storage.LockBasedStorageManager\n\nclass ClassBuilderOnDemand(createClassBuilder: () -> ClassBuilder) : DelegatingClassBuilder() {\n    private val classBuilder = LockBasedStorageManager.NO_LOCKS.createLazyValue(createClassBuilder)\n\n    val isComputed: Boolean\n        get() = classBuilder.isComputed()\n\n    override fun getDelegate() = classBuilder()\n\n    fun ensureGenerated() {\n        classBuilder()\n    }\n\n    override fun done(generateSmapCopyToAnnotation: Boolean) {\n        if (isComputed) {\n            classBuilder().done(generateSmapCopyToAnnotation)\n        }\n    }\n}\n"}
{"code": "// MODULE: context\n\n// FILE: context.kt\nclass Test {\n    private var a: String = \"foo\"\n\n    fun test() {\n        <caret_context>val x = 0\n    }\n}\n\n\n// MODULE: main\n// MODULE_KIND: CodeFragment\n// CONTEXT_MODULE: context\n\n// FILE: fragment.kt\n// CODE_FRAGMENT_KIND: EXPRESSION\n@Suppress(\"INVISIBLE_SETTER\")\na = \"bar\""}
{"code": "interface Foo<T> {\n    fun foo(value: T)\n}\n\nfun test() {\n    consume(<expr>Foo<Int>::foo</expr>)\n}\n\nfun consume(f: (Foo<Int>, Int) -> Unit) {}"}
{"code": "fun <From, To> copyNotNull(from: List<From>, to: List<To>) where <caret>From : To, To : Any {\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.impl.base.test.cases.components.scopeProvider\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.impl.base.test.SymbolByFqName\nimport org.jetbrains.kotlin.analysis.api.impl.base.test.cases.symbols.AbstractSymbolByFqNameTest\nimport org.jetbrains.kotlin.analysis.api.impl.base.test.cases.symbols.SymbolsData\nimport org.jetbrains.kotlin.analysis.api.symbols.KtDeclarationSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolWithMembers\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.services.TestServices\n\nabstract class AbstractMemberScopeTestBase : AbstractSymbolByFqNameTest() {\n    context(KtAnalysisSession)\n    protected abstract fun KtSymbolWithMembers.getSymbolsFromScope(): Sequence<KtDeclarationSymbol>\n\n    override fun KtAnalysisSession.collectSymbols(ktFile: KtFile, testServices: TestServices): SymbolsData {\n        val symbolData = SymbolByFqName.ge"}
{"code": "tSymbolDataFromFile(testDataPath)\n        val symbols = with(symbolData) { toSymbols(ktFile) }\n        val symbolWithMembers = symbols.singleOrNull() as? KtSymbolWithMembers\n            ?: error(\"Should be a single `${KtSymbolWithMembers::class.simpleName}`, but $symbols found.\")\n        return SymbolsData(symbolWithMembers.getSymbolsFromScope().toList())\n    }\n}\n\nabstract class AbstractMemberScopeTest : AbstractMemberScopeTestBase() {\n    context(KtAnalysisSession)\n    override fun KtSymbolWithMembers.getSymbolsFromScope(): Sequence<KtDeclarationSymbol> = getMemberScope().getAllSymbols()\n}\n\nabstract class AbstractStaticMemberScopeTest : AbstractMemberScopeTestBase() {\n    context(KtAnalysisSession)\n    override fun KtSymbolWithMembers.getSymbolsFromScope(): Sequence<KtDeclarationSymbol> = getStaticMemberScope().getAllSymbols()\n}\n\nabstract class AbstractDeclaredMemberScopeTest : AbstractMemberScopeTestBase() {\n    context(KtAnalysisSession)\n    override fun KtSymbolWithMembers.getSymbo"}
{"code": "lsFromScope(): Sequence<KtDeclarationSymbol> = getDeclaredMemberScope().getAllSymbols()\n}\n\nabstract class AbstractStaticDeclaredMemberScopeTest : AbstractMemberScopeTestBase() {\n    context(KtAnalysisSession)\n    override fun KtSymbolWithMembers.getSymbolsFromScope(): Sequence<KtDeclarationSymbol> = getStaticDeclaredMemberScope().getAllSymbols()\n}\n\nabstract class AbstractCombinedDeclaredMemberScopeTest : AbstractMemberScopeTestBase() {\n    context(KtAnalysisSession)\n    override fun KtSymbolWithMembers.getSymbolsFromScope(): Sequence<KtDeclarationSymbol> = getCombinedDeclaredMemberScope().getAllSymbols()\n}\n\nabstract class AbstractDelegateMemberScopeTest : AbstractMemberScopeTestBase() {\n    context(KtAnalysisSession)\n    override fun KtSymbolWithMembers.getSymbolsFromScope(): Sequence<KtDeclarationSymbol> = getDelegatedMemberScope().getCallableSymbols()\n}\n"}
{"code": "// FILE: B.kt\ninterface B: A<String> {\n    fun foo(): String?\n}\n// FILE: A.java\npublic interface A<T> {\n    T f<caret>oo();\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.base\n\nimport com.intellij.psi.PsiClass\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.test.framework.test.configurators.AnalysisApiTestConfigurator\nimport org.jetbrains.kotlin.light.classes.symbol.base.service.getLightClassesFromFile\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.services.TestServices\n\nopen class AbstractSymbolLightClassesEqualityByPsiTest(\n    configurator: AnalysisApiTestConfigurator,\n    currentExtension: String,\n    stopIfCompilationErrorDirectivePresent: Boolean\n) : AbstractSymbolLightClassesEqualityTestBase(configurator, currentExtension, stopIfCompilationErrorDirectivePresent) {\n    override fun lightClassesToCheck(ktFiles: List<KtFile>, module: KtTestModule, testServices: TestServices): Collection<PsiClass> {\n        return ktFiles.flatMap { getLightClassesFromFile(it) }\n    }\n}\n"}
{"code": "// LOOK_UP_FOR_ELEMENT_OF_TYPE: org.jetbrains.kotlin.psi.KtAnnotationEntry\n// WITH_STDLIB\n\n<expr>@file:Suppress(\"\")</expr>"}
{"code": "class Generic<T>\nclass Klass<T> {\n    var mutableProperty: Generic<T> = Generic()\n\n    fun testWithinClass() {\n        val mutableProperty = Klass<T>::mutableProperty\n        mutableProperty.set(this, Generic<T>())\n    }\n}\n\nfun testConcreteType() {\n    val mutableProperty = Klass<Int>::mutableProperty\n    mutableProperty.set(Klass<Int>(), Generic<Int>())\n}\n\nfun <A> testGenericType() {\n    val mutableProperty = Klass<A>::mutableProperty\n    mutableProperty.set(Klass<A>(), Generic<A>())\n}\n\nfun <S: CharSequence> testGenericTypeWithBounds() {\n    val mutableProperty = Klass<S>::mutableProperty\n    mutableProperty.set(Klass<S>(), Generic<S>())\n}"}
{"code": "fun call(x: Function2<@ParameterName(\"a\") Int, @ParameterName(\"b\") String, Unit>) {\n    <expr>x(1, \"\")</expr>\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.lazy\n\nimport org.jetbrains.kotlin.config.LanguageVersionSettings\nimport org.jetbrains.kotlin.descriptors.ModuleDescriptor\nimport org.jetbrains.kotlin.descriptors.SupertypeLoopChecker\nimport org.jetbrains.kotlin.incremental.components.LookupTracker\nimport org.jetbrains.kotlin.resolve.*\nimport org.jetbrains.kotlin.resolve.calls.components.InferenceSession\nimport org.jetbrains.kotlin.resolve.extensions.SyntheticResolveExtension\nimport org.jetbrains.kotlin.resolve.lazy.declarations.DeclarationProviderFactory\nimport org.jetbrains.kotlin.resolve.sam.SamConversionResolver\nimport org.jetbrains.kotlin.storage.StorageManager\nimport org.jetbrains.kotlin.types.WrappedTypeFactory\nimport org.jetbrains.kotlin.types.checker.NewKotlinTypeChecker\n\ninterface LazyClassContext {\n    val declarationScopeProvider: DeclarationScopeProvider\n    val inferenceSession: InferenceSession?\n\n    val storageManager: StorageManager\n    val trace: BindingTrace\n    val moduleDescrip"}
{"code": "tor: ModuleDescriptor\n    val descriptorResolver: DescriptorResolver\n    val functionDescriptorResolver: FunctionDescriptorResolver\n    val typeResolver: TypeResolver\n    val declarationProviderFactory: DeclarationProviderFactory\n    val annotationResolver: AnnotationResolver\n    val lookupTracker: LookupTracker\n    val supertypeLoopChecker: SupertypeLoopChecker\n    val languageVersionSettings: LanguageVersionSettings\n    val syntheticResolveExtension: SyntheticResolveExtension\n    val delegationFilter: DelegationFilter\n    val wrappedTypeFactory: WrappedTypeFactory\n    val samConversionResolver: SamConversionResolver\n    val additionalClassPartsProvider: AdditionalClassPartsProvider\n    val sealedClassInheritorsProvider: SealedClassInheritorsProvider\n\n    \n    val kotlinTypeCheckerOfOwnerModule: NewKotlinTypeChecker\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\")\n\npackage org.jetbrains.kotlin.fir.expressions.impl\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.MutableOrEmptyList\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.expressions.FirSpreadArgumentExpression\nimport org.jetbrains.kotlin.fir.expressions.UnresolvedExpressionTypeAccess\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.fir.visitors.transformInplace\n\ninternal class FirSpreadArgumentExpressionImpl(\n    override val source: KtSourceElement?,\n    override var annotations: MutableOrEmptyList<FirAnnotation>,\n "}
{"code": "   override var expression: FirExpression,\n    override val isNamed: Boolean,\n    override val isFakeSpread: Boolean,\n) : FirSpreadArgumentExpression() {\n    @OptIn(UnresolvedExpressionTypeAccess::class)\n    override val coneTypeOrNull: ConeKotlinType?\n        get() = expression.coneTypeOrNull\n    override val isSpread: Boolean\n        get() = true\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {\n        annotations.forEach { it.accept(visitor, data) }\n        expression.accept(visitor, data)\n    }\n\n    override fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirSpreadArgumentExpressionImpl {\n        transformAnnotations(transformer, data)\n        expression = expression.transform(transformer, data)\n        return this\n    }\n\n    override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirSpreadArgumentExpressionImpl {\n        annotations.transformInplace(transformer, data)\n        return this\n    }\n\n    override f"}
{"code": "un replaceConeTypeOrNull(newConeTypeOrNull: ConeKotlinType?) {}\n\n    override fun replaceAnnotations(newAnnotations: List<FirAnnotation>) {\n        annotations = newAnnotations.toMutableOrEmpty()\n    }\n}\n"}
{"code": "// FILE: main.kt\npackage a.b.c\n\nfun <T, E, D> foo(a: T, b: E, c: D) = a.hashCode() + b.hashCode() + c.hashCode()\n\nfun <E> E.foo() = hashCode()\n\nclass Outer {\n    fun <E> E.foo(x: E, y: E, z: E) = x.hashCode() + y.hashCode() + z.hashCode()\n\n    class Inner {\n        fun foo(a: Int, b: Boolean, c: String) = c + a + b\n\n        fun test(): Int {\n            fun foo(a: Int, b: Boolean, c: Int) = a + b.hashCode() + c\n            return <expr>Inner.foo(1, false, \"bar\")</expr>\n        }\n\n        companion object {\n            fun <T, E, D> foo(a: T, b: E, c: D) = a.hashCode() + b.hashCode() + c.hashCode()\n        }\n    }\n}\n"}
{"code": "// Issue: KT-18583\n\nsealed class Maybe<T> {\n    class Nope<T>(val reasonForLog: String, val reasonForUI: String) : Maybe<T>()\n    class Yeah<T>(val meat: T) : Maybe<T>()\n\n    fun unwrap() = when (this) {\n        is Nope -> throw Exception(\"\")\n        is Yeah -> meat\n    }\n}\n"}
{"code": "package dependency\n\nclass D {\n    inner class Inner {\n        inner class Inner\n    }\n    open class Nested {\n        class Nested\n    }\n\n    companion object {\n        class NestedInClassObject\n    }\n}\n"}
{"code": "// WITH_STDLIB\n\nval p : UInt = <expr>42u</expr>\n"}
{"code": "// FILE: JavaClass.java\nimport org.jetbrains.annotations.Nullable;\n\npublic class JavaClass {\n    private String myFoo = \"\";\n    public String getFoo() { return myFoo; }\n    public void setFoo(@Nullable String s) { myFoo = s; }\n}\n\n// FILE: main.kt\nfun main(j: JavaClass) {\n    j.foo += \"OK\"\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.checkers\n\nimport org.jetbrains.kotlin.builtins.StandardNames\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtEnumEntry\n\nobject EnumEntriesRedeclarationChecker : DeclarationChecker {\n    override fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n        if (declaration !is KtEnumEntry || declaration.name != StandardNames.ENUM_ENTRIES.asString()) return\n\n        context.trace.report(Errors.DEPRECATED_DECLARATION_OF_ENUM_ENTRY.on(declaration))\n    }\n}"}
{"code": "val x = -<expr>1</expr>\n"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.decompiled\n\nimport org.jetbrains.kotlin.light.classes.symbol.base.AbstractSymbolLightClassesEqualityByFqNameTest\nimport org.jetbrains.kotlin.light.classes.symbol.decompiled.test.configurators.AnalysisApiSymbolLightClassesDecompiledTestConfigurator\n\nabstract class AbstractSymbolLightClassesEqualityByFqNameForLibraryTest :\n    AbstractSymbolLightClassesEqualityByFqNameTest(\n        AnalysisApiSymbolLightClassesDecompiledTestConfigurator,\n        EXTENSIONS.LIB_JAVA,\n        stopIfCompilationErrorDirectivePresent = true\n    )\n"}
{"code": "// WITH_STDLIB\n// ISSUE: KT-58604\n\nfun nonInPlaceRun(block: () -> Unit) {}\n\nfun test_0(a: Any) {\n    var b = a is String\n    if (b) {\n        a.<!UNRESOLVED_REFERENCE!>length<!> // can be ok\n    }\n    nonInPlaceRun {\n        if (b) {\n            a.<!UNRESOLVED_REFERENCE!>length<!> // can be ok\n        }\n    }\n    if (b) {\n        a.<!UNRESOLVED_REFERENCE!>length<!> // can be ok\n    }\n}\n\nfun test_1(a: Any) {\n    var b = a is String\n    if (b) {\n        a.<!UNRESOLVED_REFERENCE!>length<!> // can be ok\n    }\n    nonInPlaceRun {\n        if (b) {\n            a.<!UNRESOLVED_REFERENCE!>length<!> // not ok\n        }\n    }\n    b = true\n}\n\nfun test_2(a: Any) {\n    var b = a is String\n    if (b) {\n        a.<!UNRESOLVED_REFERENCE!>length<!> // can be ok\n    }\n    nonInPlaceRun {\n        b = true\n    }\n    if (b) {\n        a.<!UNRESOLVED_REFERENCE!>length<!> // not ok\n    }\n}\n\nfun test_3(a: Any) {\n    var b = a is String\n    if (b) {\n        a.<!UNRESOLVED_REFERENCE!>length<!> // // can be ok\n    "}
{"code": "}\n    run {\n        if (b) {\n            a.<!UNRESOLVED_REFERENCE!>length<!> // // can be ok\n        }\n    }\n    b = true\n}\n\nfun test_4(a: Any) {\n    var b = a is String\n    if (b) {\n        a.<!UNRESOLVED_REFERENCE!>length<!> // // can be ok\n    }\n    run {\n        b = true\n    }\n    if (b) {\n        a.<!UNRESOLVED_REFERENCE!>length<!> // not ok\n    }\n}\n\nfun test_5(a: Any) {\n    var b = a is String\n    while (b) {\n        if (b) {\n            a.<!UNRESOLVED_REFERENCE!>length<!> // not ok\n        }\n        b = a is String\n    }\n    if (b) {\n        a.<!UNRESOLVED_REFERENCE!>length<!> // // can be ok\n    }\n}\n\nfun test_6(a: String?) {\n    var b = a?.length\n    if (b != null) {\n        a<!UNSAFE_CALL!>.<!>length // can be ok\n    }\n    nonInPlaceRun {\n        b = 0\n    }\n    if (b != null) {\n        a<!UNSAFE_CALL!>.<!>length // not ok\n    }\n}\n"}
{"code": "interface A {\n    fun foo(b: Boolean = false): A\n    fun foo(block: () -> Boolean): A\n}\n\nfun test(a: A) {\n    a.foo { true }\n}\n"}
{"code": "class Resolve<caret>Me<T : Int, K>()"}
{"code": "// WITH_STDLIB\n// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE_K1\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\n\n@OptIn(ExperimentalContracts::class)\nfun (() -> Unit).referenceReceiverInContract() {\n    contr<caret>act {\n        callsInPlace(this@referenceReceiverInContract, InvocationKind.EXACTLY_ONCE)\n    }\n    this()\n}\n"}
{"code": "fun test() {\n    val x = 5\n    val y = x + 1\n}"}
{"code": "annotation class A(vararg val strings: String)\nannotation class AArray(vararg val value: A)\n\n@AArray(A(strings = [\"foo\", \"bar\"]))\nclass F<caret>oo"}
{"code": "\n\npackage org.jetbrains.kotlin.asJava.elements\n\nimport com.intellij.psi.JavaElementVisitor\nimport com.intellij.psi.PsiElementVisitor\nimport com.intellij.psi.PsiParameter\nimport com.intellij.psi.PsiParameterList\nimport org.jetbrains.kotlin.asJava.classes.lazyPub\nimport org.jetbrains.kotlin.psi.KtElement\nimport org.jetbrains.kotlin.psi.KtFunction\n\nclass KtLightParameterList(\n    private val parent: KtLightMethod,\n    private val parametersCount: Int,\n    computeParameters: () -> List<PsiParameter>\n) : KtLightElementBase(parent), PsiParameterList {\n\n    override val kotlinOrigin: KtElement?\n        get() = (parent.kotlinOrigin as? KtFunction)?.valueParameterList\n\n    private val _parameters: Array<PsiParameter> by lazyPub { computeParameters().toTypedArray() }\n    override fun getParameters() = _parameters\n\n    override fun getParameterIndex(parameter: PsiParameter) = _parameters.indexOf(parameter)\n\n    override fun getParametersCount() = parametersCount\n\n    override fun accept(visitor: "}
{"code": "PsiElementVisitor) {\n        if (visitor is JavaElementVisitor) {\n            visitor.visitParameterList(this)\n        }\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (javaClass != other?.javaClass) return false\n        other as KtLightParameterList\n        if (parent != other.parent) return false\n        return true\n    }\n\n    override fun hashCode(): Int = parent.hashCode()\n\n}\n"}
{"code": "class B {\n    fun append() {}\n}\n\nclass A {\n    val message = B()\n\n    fun foo(w: Boolean) {\n        if (w) {\n            val message = \"\"\n            message.toString()\n        } else {\n            message.append() // message here should relate to the class-level property\n        }\n    }\n}\n"}
{"code": "fun foo(x: Int, vararg y: String) {}\nfun bar(x: Int, vararg y: String, z: Boolean) {}\n\nfun test() {\n    foo(1)\n    foo(1, \"\")\n    foo(1, \"my\", \"yours\")\n    foo(1, *arrayOf(\"my\", \"yours\"))\n\n    foo(<!ARGUMENT_TYPE_MISMATCH!>\"\"<!>)\n    foo(1, <!ARGUMENT_TYPE_MISMATCH!>2<!>)\n\n    bar(1, z = true, y = *<!REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_FUNCTION!>arrayOf(\"my\", \"yours\")<!>)\n\n    bar(0, z = false, y = <!ARGUMENT_TYPE_MISMATCH, ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>\"\"<!>, <!ARGUMENT_PASSED_TWICE!>y<!> = \"other\")\n    bar(0, \"\", <!NO_VALUE_FOR_PARAMETER!><!ARGUMENT_TYPE_MISMATCH!>true<!>)<!>\n    bar(0, z = false, y = <!ARGUMENT_TYPE_MISMATCH, ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>\"\"<!>, <!ARGUMENT_PASSED_TWICE!>y<!> = \"other\", <!ARGUMENT_PASSED_TWICE!>y<!> = \"yet other\")\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.jvm.modules\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.openapi.vfs.VirtualFile\nimport org.jetbrains.kotlin.load.java.JavaModuleAnnotationsProvider\nimport org.jetbrains.kotlin.name.FqName\n\ninterface JavaModuleResolver : JavaModuleAnnotationsProvider {\n    fun checkAccessibility(fileFromOurModule: VirtualFile?, referencedFile: VirtualFile, referencedPackage: FqName?): AccessError?\n\n    sealed class AccessError {\n        object ModuleDoesNotReadUnnamedModule : AccessError()\n        data class ModuleDoesNotReadModule(val dependencyModuleName: String) : AccessError()\n        data class ModuleDoesNotExportPackage(val dependencyModuleName: String) : AccessError()\n    }\n\n    companion object SERVICE {\n        fun getInstance(project: Project): JavaModuleResolver = project.getService(JavaModuleResolver::class.java)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.extended\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.SourceNavigator\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.toClassLikeSymbol\nimport org.jetbrains.kotlin.fir.analysis.checkers.type.FirTypeRefChecker\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_NULLABLE\nimport org.jetbrains.kotlin.fir.symbols.impl.FirTypeAliasSymbol\nimport org.jetbrains.kotlin.fir.types.*\n\nobject RedundantNullableChecker : FirTypeRefChecker(MppCheckerKind.Common) {\n    override fun check(typeRef: FirTypeRef, context: CheckerContext, reporter: DiagnosticReporter) {\n        if (typeRef !is FirResolvedTypeRef || typeRef.isMarkedNullable != true) return\n\n        var symbol = typeRef.to"}
{"code": "ClassLikeSymbol(context.session)\n        if (symbol is FirTypeAliasSymbol) {\n            while (symbol is FirTypeAliasSymbol) {\n                val resolvedExpandedTypeRef = symbol.resolvedExpandedTypeRef\n                if (resolvedExpandedTypeRef.type.isMarkedNullable) {\n                    reporter.reportOn(typeRef.source, REDUNDANT_NULLABLE, context)\n                    break\n                } else {\n                    symbol = resolvedExpandedTypeRef.toClassLikeSymbol(context.session)\n                }\n            }\n        } else {\n            with(SourceNavigator.forElement(typeRef)) {\n                if (typeRef.isRedundantNullable()) {\n                    reporter.reportOn(typeRef.source, REDUNDANT_NULLABLE, context)\n                }\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cfg.pseudocode.instructions.eval\n\nimport org.jetbrains.kotlin.psi.KtExpression\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.InstructionWithNext\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.InstructionVisitor\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.BlockScope\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.InstructionImpl\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.InstructionVisitorWithResult\n\nclass LoadUnitValueInstruction(\n    expression: KtExpression,\n    blockScope: BlockScope\n) : InstructionWithNext(expression, blockScope) {\n    override fun accept(visitor: InstructionVisitor) {\n        visitor.visitLoadUnitValue(this)\n    }\n\n    override fun <R> accept(visitor: InstructionVisitorWithResult<R>): R {\n        return visitor.visitLoadUnitValue(this)\n    }\n\n    override fun toString(): String =\n        \"read (Unit)\"\n\n    override fun createCopy(): InstructionImpl =\n        LoadUnitValueInstruction"}
{"code": "(element as KtExpression, blockScope)\n}\n"}
{"code": "// MODULE: dependency\n// MODULE_KIND: Source\n// FILE: Declaration.kt\nprivate class Declaration\n\n// MODULE: main(dependency)\n// FILE: main.kt\nfun foo() {\n    p<caret>rintln()\n}\n\n// class: Declaration\n"}
{"code": "fun interface A {\n    operator fun invoke()\n}\n\nfun foo(param: A) {\n    param.invo<caret>ke()\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.util\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun <K, V> MutableMap<K, MutableList<V>>.addValueFor(element: K, value: V) {\n    getOrPut(element) { mutableListOf() } += value\n}\n\ninternal fun <T> MutableList<T>.replaceFirst(from: T, to: T) {\n    val index = indexOf(from)\n    if (index < 0) {\n        error(\"$from was not found in $this\")\n    }\n    set(index, to)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.types.impl\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.StandardClassIds\n\nsealed class FirImplicitBuiltinTypeRef(\n    override val source: KtSourceElement?,\n    val id: ClassId,\n    typeArguments: Array<out ConeTypeProjection> = emptyArray(),\n    isNullable: Boolean = false\n) : FirResolvedTypeRef() {\n    override val annotations: List<FirAnnotation>\n        get() = emptyList()\n\n    override val type: ConeClassLikeType = ConeClassLikeTypeImpl(id.toLookupTag(), typeArguments, isNullable)\n\n    override val delegatedTypeRef: FirTypeRef?\n        get() = null\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {}\n\n  "}
{"code": "  override fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirElement {\n        return this\n    }\n\n    override fun replaceAnnotations(newAnnotations: List<FirAnnotation>) {\n        throw AssertionError(\"Replacing annotations in FirImplicitBuiltinTypeRef is not supported\")\n    }\n\n    override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirResolvedTypeRef {\n        return this\n    }\n}\n\nclass FirImplicitUnitTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Unit)\n\nclass FirImplicitAnyTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Any)\n\nclass FirImplicitNullableAnyTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Any, isNullable = true)\n\nclass FirImplicitEnumTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Enum)\n\nclass FirImplicitAnnotationTypeRef(\n    source: KtSourceEl"}
{"code": "ement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Annotation)\n\nclass FirImplicitBooleanTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Boolean)\n\nclass FirImplicitNumberTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Number)\n\nclass FirImplicitByteTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Byte)\n\nclass FirImplicitShortTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Short)\n\nclass FirImplicitIntTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Int)\n\nclass FirImplicitLongTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Long)\n\nclass FirImplicitDoubleTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Double)\n\nclass FirImplicitFloatTypeRef(\n    source: KtSourceElement?\n) : "}
{"code": "FirImplicitBuiltinTypeRef(source, StandardClassIds.Float)\n\nclass FirImplicitUIntTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.UInt)\n\nclass FirImplicitULongTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.ULong)\n\nclass FirImplicitUShortTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.UShort)\n\nclass FirImplicitUByteTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.UByte)\n\nclass FirImplicitNothingTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Nothing)\n\nclass FirImplicitNullableNothingTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Nothing, isNullable = true)\n\nclass FirImplicitCharTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Char)\n\nclass FirImplicitStringTypeRef(\n    source: KtS"}
{"code": "ourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.String)\n\nclass FirImplicitThrowableTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.Throwable)\n\nclass FirImplicitCharSequenceTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.CharSequence)\n\nclass FirImplicitCharIteratorTypeRef(\n    source: KtSourceElement?\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.CharIterator)\n\nclass FirImplicitKPropertyTypeRef(\n    source: KtSourceElement?,\n    typeArgument: ConeTypeProjection\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.KProperty, arrayOf(typeArgument))\n\nclass FirImplicitKProperty0TypeRef(\n    source: KtSourceElement?,\n    propertyTypeArgument: ConeTypeProjection\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.KProperty0, arrayOf(propertyTypeArgument))\n\nclass FirImplicitKMutableProperty0TypeRef(\n    source: KtSourceElement?,\n    propertyTypeArgument: ConeTypeProjecti"}
{"code": "on\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.KMutableProperty0, arrayOf(propertyTypeArgument))\n\nclass FirImplicitKProperty1TypeRef(\n    source: KtSourceElement?,\n    receiverTypeArgument: ConeTypeProjection,\n    propertyTypeArgument: ConeTypeProjection\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.KProperty1, arrayOf(receiverTypeArgument, propertyTypeArgument))\n\nclass FirImplicitKMutableProperty1TypeRef(\n    source: KtSourceElement?,\n    receiverTypeArgument: ConeTypeProjection,\n    propertyTypeArgument: ConeTypeProjection\n) : FirImplicitBuiltinTypeRef(source, StandardClassIds.KMutableProperty1, arrayOf(receiverTypeArgument, propertyTypeArgument))\n\nclass FirImplicitKProperty2TypeRef(\n    source: KtSourceElement?,\n    dispatchReceiverTypeArgument: ConeTypeProjection,\n    extensionReceiverTypeArgument: ConeTypeProjection,\n    propertyTypeArgument: ConeTypeProjection\n) : FirImplicitBuiltinTypeRef(\n    source, StandardClassIds.KProperty2,\n    arrayOf(dispatchReceiverT"}
{"code": "ypeArgument, extensionReceiverTypeArgument, propertyTypeArgument)\n)\n\nclass FirImplicitKMutableProperty2TypeRef(\n    source: KtSourceElement?,\n    dispatchReceiverTypeArgument: ConeTypeProjection,\n    extensionReceiverTypeArgument: ConeTypeProjection,\n    propertyTypeArgument: ConeTypeProjection\n) : FirImplicitBuiltinTypeRef(\n    source, StandardClassIds.KMutableProperty2,\n    arrayOf(dispatchReceiverTypeArgument, extensionReceiverTypeArgument, propertyTypeArgument)\n)\n\nfun FirImplicitBuiltinTypeRef.withNewSource(newSource: KtSourceElement?): FirImplicitBuiltinTypeRef {\n    val source = source ?: return this\n    if (source.kind == newSource?.kind) return this\n    return when (this) {\n        is FirImplicitUnitTypeRef -> FirImplicitUnitTypeRef(newSource)\n        is FirImplicitAnyTypeRef -> FirImplicitAnyTypeRef(newSource)\n        is FirImplicitNullableAnyTypeRef -> FirImplicitNullableAnyTypeRef(newSource)\n        is FirImplicitEnumTypeRef -> FirImplicitEnumTypeRef(newSource)\n        is Fi"}
{"code": "rImplicitAnnotationTypeRef -> FirImplicitAnnotationTypeRef(newSource)\n        is FirImplicitBooleanTypeRef -> FirImplicitBooleanTypeRef(newSource)\n        is FirImplicitByteTypeRef -> FirImplicitByteTypeRef(newSource)\n        is FirImplicitNumberTypeRef -> FirImplicitNumberTypeRef(newSource)\n        is FirImplicitShortTypeRef -> FirImplicitShortTypeRef(newSource)\n        is FirImplicitIntTypeRef -> FirImplicitIntTypeRef(newSource)\n        is FirImplicitLongTypeRef -> FirImplicitLongTypeRef(newSource)\n        is FirImplicitDoubleTypeRef -> FirImplicitDoubleTypeRef(newSource)\n        is FirImplicitFloatTypeRef -> FirImplicitFloatTypeRef(newSource)\n        is FirImplicitUIntTypeRef -> FirImplicitUIntTypeRef(newSource)\n        is FirImplicitULongTypeRef -> FirImplicitULongTypeRef(newSource)\n        is FirImplicitNothingTypeRef -> FirImplicitNothingTypeRef(newSource)\n        is FirImplicitNullableNothingTypeRef -> FirImplicitNullableNothingTypeRef(newSource)\n        is FirImplicitCharTypeRe"}
{"code": "f -> FirImplicitCharTypeRef(newSource)\n        is FirImplicitStringTypeRef -> FirImplicitStringTypeRef(newSource)\n        is FirImplicitThrowableTypeRef -> FirImplicitThrowableTypeRef(newSource)\n        is FirImplicitCharSequenceTypeRef -> FirImplicitCharSequenceTypeRef(newSource)\n        is FirImplicitCharIteratorTypeRef -> FirImplicitCharIteratorTypeRef(newSource)\n        is FirImplicitKPropertyTypeRef -> FirImplicitKPropertyTypeRef(\n            newSource,\n            typeArgument = type.typeArguments[0]\n        )\n        is FirImplicitKProperty0TypeRef -> FirImplicitKProperty0TypeRef(\n            newSource,\n            propertyTypeArgument = type.typeArguments[0]\n        )\n        is FirImplicitKMutableProperty0TypeRef -> FirImplicitKMutableProperty0TypeRef(\n            newSource,\n            propertyTypeArgument = type.typeArguments[0]\n        )\n        is FirImplicitKProperty1TypeRef -> FirImplicitKProperty1TypeRef(\n            newSource,\n            receiverTypeArgument = type.ty"}
{"code": "peArguments[0],\n            propertyTypeArgument = type.typeArguments[1]\n        )\n        is FirImplicitKMutableProperty1TypeRef -> FirImplicitKMutableProperty1TypeRef(\n            newSource,\n            receiverTypeArgument = type.typeArguments[0],\n            propertyTypeArgument = type.typeArguments[1]\n        )\n        is FirImplicitKProperty2TypeRef -> FirImplicitKProperty2TypeRef(\n            newSource,\n            dispatchReceiverTypeArgument = type.typeArguments[0],\n            extensionReceiverTypeArgument = type.typeArguments[1],\n            propertyTypeArgument = type.typeArguments[2]\n        )\n        is FirImplicitKMutableProperty2TypeRef -> FirImplicitKMutableProperty2TypeRef(\n            newSource,\n            dispatchReceiverTypeArgument = type.typeArguments[0],\n            extensionReceiverTypeArgument = type.typeArguments[1],\n            propertyTypeArgument = type.typeArguments[2]\n        )\n        is FirImplicitUByteTypeRef -> FirImplicitUByteTypeRef(newSource)\n   "}
{"code": "     is FirImplicitUShortTypeRef -> FirImplicitUShortTypeRef(newSource)\n    }\n}\n"}
{"code": "fun <T, R> use(x: (T) -> R): (T) -> R = x\n\nfun foo() = use(::bar)\nfun bar(x: String) = 1\n\nfun loop1() = <!CANNOT_INFER_PARAMETER_TYPE, CANNOT_INFER_PARAMETER_TYPE!>use<!>(::<!INAPPLICABLE_CANDIDATE!>loop2<!>)\nfun loop2() = loop1()\n"}
{"code": "// DO_NOT_CHECK_SYMBOL_RESTORE_K1\nclass Foo(vararg val ints: ) {\n\n}\n"}
{"code": "// @ParameterName annotation is ignored when not used in function type\nfun call(a: @ParameterName(\"notMe\") Int, b: @ParameterName(\"meNeither\") String) {\n    <expr>call(1, \"\")</expr>\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.caches\n\nimport org.jetbrains.kotlin.fir.caches.FirCache\n\ninternal interface FirCacheWithInvalidation<K : Any, V, CONTEXT> {\n    \n    fun fixInconsistentValue(\n        key: K,\n        context: CONTEXT & Any,\n        inconsistencyMessage: String,\n        mapping: (oldValue: V, newValue: V & Any) -> V & Any,\n    ): V & Any\n}\n\n\ninternal fun <KEY : Any, VALUE, CONTEXT> FirCache<KEY, VALUE, CONTEXT>.getNotNullValueForNotNullContext(\n    key: KEY,\n    context: CONTEXT,\n): VALUE {\n    val value = getValue(key, context)\n    @Suppress(\"CANNOT_CHECK_FOR_ERASED\")\n    return if (value != null ||\n        context == null ||\n        this !is FirCacheWithInvalidation<KEY, VALUE, CONTEXT>\n    ) {\n        value\n    } else {\n        fixInconsistentValue(\n            key = key,\n            context = context,\n            inconsistencyMessage = \"Inconsistency in the cache. Someone without context put a null value in the cache\",\n            mapping = {"}
{"code": " old, new -> old ?: new },\n        )\n    }\n}\n"}
{"code": "// FILE: main.kt\n\nabstract class Outer {\n    abstract class Nested : Outer()\n\n    class Foo(<expr>val param: Outer.Nested = Outer.Nested()</expr>) : Outer.Nested()\n}\n"}
{"code": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE\n// DO_NOT_CHECK_SYMBOL_RESTORE_K1\npackage test\n\nclass SomeClass\n\nfun <Outer> topLevel() {\n    open class Base<T> {\n        fun withOuter(): Outer? = null\n        fun withOuterAndOwn(t: T): Outer? = null\n    }\n\n    class <caret>Child : Base<SomeClass>() {\n        fun noGenerics() {}\n    }\n}\n"}
{"code": "fun test() {\n\n    val x = <expr>four@4</expr>\n\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.annotations\n\nimport org.jetbrains.kotlin.analysis.api.annotations.KtAnnotationApplicationInfo\nimport org.jetbrains.kotlin.analysis.api.annotations.KtAnnotationApplicationWithArgumentsInfo\nimport org.jetbrains.kotlin.name.ClassId\n\ninternal object EmptyAnnotationsProvider : AnnotationsProvider {\n    override fun annotationInfos(): List<KtAnnotationApplicationInfo> = emptyList()\n    override fun get(classId: ClassId): Collection<KtAnnotationApplicationWithArgumentsInfo> = emptyList()\n    override fun contains(classId: ClassId): Boolean = false\n    override fun ownerClassId(): ClassId? = null\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cli.common.arguments\n\nimport com.intellij.util.text.VersionComparatorUtil\nimport java.lang.reflect.Modifier\nimport kotlin.reflect.KClass\nimport kotlin.reflect.KMutableProperty1\nimport kotlin.reflect.KProperty1\nimport kotlin.reflect.KVisibility\nimport kotlin.reflect.full.declaredMemberProperties\nimport kotlin.reflect.full.memberProperties\nimport kotlin.reflect.jvm.javaField\n\nfun <T : Any> copyBean(bean: T): T = copyBeanTo(bean, bean::class.java.newInstance())\n\n@Suppress(\"UNCHECKED_CAST\")\nfun <T : Any> copyBeanTo(from: T, to: T, filter: ((KProperty1<T, Any?>, Any?) -> Boolean)? = null) =\n    copyProperties(from, to, true, collectProperties(from::class as KClass<T>, false), filter)\n\nfun <From : Any, To : From> mergeBeans(from: From, to: To): To {\n    // TODO: rewrite when updated version of com.intellij.util.xmlb is available on TeamCity\n    @Suppress(\"UNCHECKED_CAST\")\n    return copyProperties(from, to, false, collectProperties(from::class as KClass<From>, "}
{"code": "false))\n}\n\n@Suppress(\"UNCHECKED_CAST\")\nfun <From : Any, To : Any> copyInheritedFields(from: From, to: To) =\n    copyProperties(from, to, true, collectProperties(from::class as KClass<From>, true))\n\n@Suppress(\"UNCHECKED_CAST\")\nfun <From : Any, To : Any> copyFieldsSatisfying(from: From, to: To, predicate: (KProperty1<From, Any?>) -> Boolean) =\n    copyProperties(from, to, true, collectProperties(from::class as KClass<From>, false).filter(predicate))\n\nprivate fun <From : Any, To : Any> copyProperties(\n    from: From,\n    to: To,\n    deepCopyWhenNeeded: Boolean,\n    propertiesToCopy: List<KProperty1<From, Any?>>,\n    filter: ((KProperty1<From, Any?>, Any?) -> Boolean)? = null\n): To {\n    if (from == to) return to\n\n    val toMemberProperties = to::class.memberProperties.associateBy { it.name }\n\n    for (fromProperty in propertiesToCopy) {\n        @Suppress(\"UNCHECKED_CAST\")\n        val toProperty = toMemberProperties[fromProperty.name] as? KMutableProperty1<To, Any?>\n            ?: continue"}
{"code": "\n        val fromValue = fromProperty.get(from)\n        if (filter != null && !filter(fromProperty, fromValue)) continue\n        toProperty.set(to, if (deepCopyWhenNeeded) fromValue?.copyValueIfNeeded() else fromValue)\n    }\n    return to\n}\n\nprivate fun Any.copyValueIfNeeded(): Any {\n    @Suppress(\"UNCHECKED_CAST\")\n    return when (this) {\n        is ByteArray -> this.copyOf(size)\n        is CharArray -> this.copyOf(size)\n        is ShortArray -> this.copyOf(size)\n        is IntArray -> this.copyOf(size)\n        is LongArray -> this.copyOf(size)\n        is FloatArray -> this.copyOf(size)\n        is DoubleArray -> this.copyOf(size)\n        is BooleanArray -> this.copyOf(size)\n\n        is Array<*> -> java.lang.reflect.Array.newInstance(this::class.java.componentType, size).apply {\n            this as Array<Any?>\n            (this@copyValueIfNeeded as Array<Any?>).forEachIndexed { i, value -> this[i] = value?.copyValueIfNeeded() }\n        }\n\n        is MutableCollection<*> -> (this as Col"}
{"code": "lection<Any?>).mapTo(this::class.java.newInstance() as MutableCollection<Any?>) { it?.copyValueIfNeeded() }\n\n        is MutableMap<*, *> -> (this::class.java.newInstance() as MutableMap<Any?, Any?>).apply {\n            for ((k, v) in this@copyValueIfNeeded.entries) {\n                put(k?.copyValueIfNeeded(), v?.copyValueIfNeeded())\n            }\n        }\n\n        else -> this\n    }\n}\n\nfun <T : Any> collectProperties(kClass: KClass<T>, inheritedOnly: Boolean): List<KProperty1<T, Any?>> {\n    val properties = ArrayList(kClass.memberProperties)\n    if (inheritedOnly) {\n        properties.removeAll(kClass.declaredMemberProperties)\n    }\n    return properties.filter { property ->\n        property.visibility == KVisibility.PUBLIC && (property.javaField?.modifiers?.let { Modifier.isTransient(it) } != true)\n    }\n}\n\nfun CommonCompilerArguments.setApiVersionToLanguageVersionIfNeeded() {\n    if (languageVersion != null && VersionComparatorUtil.compare(languageVersion, apiVersion) < 0) {\n     "}
{"code": "   apiVersion = languageVersion\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.daemon.common\n\nimport org.jetbrains.kotlin.cli.common.repl.ILineId\nimport java.rmi.Remote\nimport java.rmi.RemoteException\n\ninterface ReplStateFacade : Remote {\n\n    @Throws(RemoteException::class)\n    fun getId(): Int\n\n    @Throws(RemoteException::class)\n    fun getHistorySize(): Int\n\n    @Throws(RemoteException::class)\n    fun historyGet(index: Int): ILineId\n\n    @Throws(RemoteException::class)\n    fun historyReset(): List<ILineId>\n\n    @Throws(RemoteException::class)\n    fun historyResetTo(id: ILineId): List<ILineId>\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.impl.base.test.cases.references\n\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.test.framework.services.expressionMarkerProvider\nimport org.jetbrains.kotlin.idea.references.mainReference\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.psi.KtSimpleNameExpression\nimport org.jetbrains.kotlin.test.builders.TestConfigurationBuilder\nimport org.jetbrains.kotlin.test.directives.model.SimpleDirectivesContainer\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.assertions\n\nabstract class AbstractReferenceImportAliasTest : AbstractAnalysisApiBasedTest() {\n    override fun configureTest(builder: TestConfigurationBuilder) {\n        super.configureTest(builder)\n        with(builder) {\n            useDirectives(Directives)\n        }\n    "}
{"code": "}\n\n    override fun doTestByMainFile(mainFile: KtFile, mainModule: KtTestModule, testServices: TestServices) {\n        val element = testServices.expressionMarkerProvider.getElementOfTypeAtCaret<KtSimpleNameExpression>(mainFile)\n        val alias = element.mainReference.getImportAlias()\n        val expectedAlias = mainModule.testModule.directives[Directives.TYPE_ALIAS].joinToString(\" \")\n        testServices.assertions.assertEquals(expectedAlias, alias?.text)\n    }\n\n    private object Directives : SimpleDirectivesContainer() {\n        val TYPE_ALIAS by stringDirective(\n            description = \"Type alias for selected reference\"\n        )\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.cli.common.messages\n\nimport org.jetbrains.kotlin.analyzer.CompilationErrorException\nimport org.jetbrains.kotlin.cli.common.CLIConfigurationKeys\nimport org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.*\nimport org.jetbrains.kotlin.config.CompilerConfiguration\nimport org.jetbrains.kotlin.util.Logger\n\n\nprivate class CompilerLoggerAdapter(\n    private val messageCollector: MessageCollector,\n    private val treatWarningsAsErrors: Boolean\n) : Logger {\n    override fun log(message: String) = messageCollector.report(LOGGING, message, null)\n    override fun warning(message: String) = messageCollector.report(if (treatWarningsAsErrors) ERROR else STRONG_WARNING, message, null)\n    override fun error(message: String) = messageCollector.report(ERROR, message, null)\n\n    @Deprecated(Logger.FATAL_DEPRECATION_MESSAGE, ReplaceWith(Logger.FATAL_REPLACEMENT))\n    override fun fatal(message: String): Nothing {\n        error(message)\n        (messageCollector "}
{"code": "as? GroupingMessageCollector)?.flush()\n        throw CompilationErrorException()\n    }\n}\n\nfun MessageCollector.toLogger(treatWarningsAsErrors: Boolean = false): Logger =\n    CompilerLoggerAdapter(this, treatWarningsAsErrors)\n\nfun CompilerConfiguration.getLogger(treatWarningsAsErrors: Boolean = false): Logger =\n    getNotNull(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY).toLogger(treatWarningsAsErrors)\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.jvm.checkers.expression\n\nimport org.jetbrains.kotlin.config.JvmTarget\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.expression.FirQualifiedAccessExpressionChecker\nimport org.jetbrains.kotlin.fir.analysis.checkers.isLhsOfAssignment\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.jvm.FirJvmErrors\nimport org.jetbrains.kotlin.fir.containingClassLookupTag\nimport org.jetbrains.kotlin.fir.declarations.utils.isInline\nimport org.jetbrains.kotlin.fir.declarations.utils.sourceElement\nimport org.jetbrains.kotlin.fir.expressions.FirQualifiedAccessExpression\nimport org.jetbrains.kotlin.fir.expressions.toReference\nimport org.jetbrains.kotlin.fir.java.jvmTargetProvi"}
{"code": "der\nimport org.jetbrains.kotlin.fir.references.toResolvedCallableSymbol\nimport org.jetbrains.kotlin.fir.resolve.toFirRegularClassSymbol\nimport org.jetbrains.kotlin.fir.symbols.SymbolInternals\nimport org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirFunctionSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol\nimport org.jetbrains.kotlin.load.kotlin.FileBasedKotlinClass\nimport org.jetbrains.kotlin.load.kotlin.JvmPackagePartSource\nimport org.jetbrains.kotlin.load.kotlin.KotlinJvmBinarySourceElement\n\nobject FirJvmInlineTargetQualifiedAccessChecker : FirQualifiedAccessExpressionChecker(MppCheckerKind.Common) {\n    override fun check(expression: FirQualifiedAccessExpression, context: CheckerContext, reporter: DiagnosticReporter) {\n        val callableSymbol = expression.calleeReference.toResolvedCallableSymbol() ?: return\n        if (callableSymbol.origin.fromSource) return\n\n        val isInline = when (callableSymbol) {\n"}
{"code": "            is FirFunctionSymbol<*> -> callableSymbol.isInline\n            is FirPropertySymbol -> {\n                val accessor = if (expression.isLhsOfAssignment(context)) callableSymbol.setterSymbol else callableSymbol.getterSymbol\n                accessor != null && accessor.isInline\n            }\n            else -> false\n        }\n\n        if (isInline) {\n            checkInlineTargetVersion(callableSymbol, context, reporter, expression)\n        }\n    }\n\n    private fun checkInlineTargetVersion(\n        callableSymbol: FirCallableSymbol<*>,\n        context: CheckerContext,\n        reporter: DiagnosticReporter,\n        element: FirElement,\n    ) {\n        val currentJvmTarget = context.session.jvmTargetProvider?.jvmTarget ?: return\n\n        val containingClass = callableSymbol.containingClassLookupTag()\n        val binaryClass = if (containingClass != null) {\n            val containingClassSymbol = containingClass.toFirRegularClassSymbol(context.session) ?: return\n\n            @O"}
{"code": "ptIn(SymbolInternals::class)\n            val sourceElement = containingClassSymbol.fir.sourceElement as? KotlinJvmBinarySourceElement ?: return\n            sourceElement.binaryClass\n        } else {\n            val containerSource = callableSymbol.containerSource as? JvmPackagePartSource ?: return\n            containerSource.knownJvmBinaryClass\n        }\n\n        val inlinedVersion = (binaryClass as? FileBasedKotlinClass)?.classVersion ?: return\n        val currentVersion = currentJvmTarget.majorVersion\n\n        if (currentVersion < inlinedVersion) {\n            reporter.reportOn(\n                element.toReference(context.session)?.source ?: element.source,\n                FirJvmErrors.INLINE_FROM_HIGHER_PLATFORM,\n                JvmTarget.getDescription(inlinedVersion),\n                JvmTarget.getDescription(currentVersion),\n                context,\n            )\n        }\n    }\n}\n"}
{"code": "val a = {<caret>  } as java.lang.Runnable\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.providers\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.project.structure.llFirModuleData\nimport org.jetbrains.kotlin.analysis.project.structure.KtModule\nimport org.jetbrains.kotlin.analysis.project.structure.ProjectStructureProvider\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProvider\nimport org.jetbrains.kotlin.utils.mapToIndex\n\n\nabstract class LLFirSelectingCombinedSymbolProvider<PROVIDER : FirSymbolProvider>(\n    session: FirSession,\n    project: Project,\n    protected val providers: List<PROVIDER>,\n) : FirSymbolProvider(session) {\n    protected val providersByKtModule: Map<KtModule, PROVIDER> =\n        providers\n            .groupingBy { it.session.llFirModuleData.ktModule }\n            // `reduce` invokes the `error` operation if it encounters a second element.\n            .redu"}
{"code": "ce { module, _, _ -> error(\"$module must have a unique symbol provider.\") }\n\n    \n    private val modulePrecedenceMap: Map<KtModule, Int> = providers.map { it.session.llFirModuleData.ktModule }.mapToIndex()\n\n    \n    private val projectStructureProvider: ProjectStructureProvider = ProjectStructureProvider.getInstance(project)\n\n    private val contextualModule = session.llFirModuleData.ktModule\n\n    protected fun getModule(element: PsiElement): KtModule {\n        return projectStructureProvider.getModule(element, contextualModule)\n    }\n\n    \n    protected fun <CANDIDATE> selectFirstElementInClasspathOrder(\n        candidates: Collection<CANDIDATE>,\n        getElement: (CANDIDATE) -> PsiElement?,\n    ): Pair<CANDIDATE, PROVIDER>? {\n        if (candidates.isEmpty()) return null\n\n        // We're using a custom implementation instead of `minBy` so that `ktModule` doesn't need to be fetched twice.\n        var currentCandidate: CANDIDATE? = null\n        var currentPrecedence: Int = Int.MAX_"}
{"code": "VALUE\n        var currentKtModule: KtModule? = null\n\n        for (candidate in candidates) {\n            val element = getElement(candidate) ?: continue\n            val ktModule = getModule(element)\n\n            // If `ktModule` cannot be found in the map, `candidate` cannot be processed by any of the available providers, because none of\n            // them belong to the correct module. We can skip in that case, because iterating through all providers wouldn't lead to any\n            // results for `candidate`.\n            val precedence = modulePrecedenceMap[ktModule] ?: continue\n            if (precedence < currentPrecedence) {\n                currentCandidate = candidate\n                currentPrecedence = precedence\n                currentKtModule = ktModule\n            }\n        }\n\n        val candidate = currentCandidate ?: return null\n        val ktModule = currentKtModule ?: error(\"`currentKtModule` must not be `null` when `currentCandidate` has been found.\")\n\n        // The pr"}
{"code": "ovider will always be found at this point, because `modulePrecedenceMap` contains the same keys as `providersByKtModule`\n        // and a precedence for `currentKtModule` must have been found in the previous step.\n        val provider = providersByKtModule.getValue(ktModule)\n\n        return Pair(candidate, provider)\n    }\n}\n"}
{"code": "package test\n\nclass A\n\nclass Test {\n    fun some(vararg a: <caret>A) = 12\n}\n\n"}
{"code": "// WITH_STDLIB\nfun foo() {\n    println(<expr>uintArrayOf(42u)</expr>)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.coroutines\n\nimport org.jetbrains.kotlin.builtins.StandardNames\nimport org.jetbrains.kotlin.codegen.optimization.boxing.isPrimitiveBoxing\nimport org.jetbrains.kotlin.codegen.optimization.common.asSequence\nimport org.jetbrains.kotlin.codegen.optimization.transformer.MethodTransformer\nimport org.jetbrains.kotlin.codegen.topLevelClassInternalName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.resolve.jvm.JvmPrimitiveType\nimport org.jetbrains.kotlin.utils.sure\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.tree.MethodInsnNode\nimport org.jetbrains.org.objectweb.asm.tree.MethodNode\n\nprivate val BOXING_CLASS_INTERNAL_NAME =\n    StandardNames.COROUTINES_JVM_INTERNAL_PACKAGE_FQ_NAME.child(Name.identifier(\"Boxing\")).topLevelClassInternalName()\n\nobject ChangeBoxingMethodTransformer : MethodTransformer() {\n    private val wrapperToInternalBoxing: Map<String, String>\n\n    init {\n        val map = hashMap"}
{"code": "Of<String, String>()\n        for (primitiveType in JvmPrimitiveType.entries) {\n            val name = primitiveType.wrapperFqName.topLevelClassInternalName()\n            map[name] = \"box${primitiveType.javaKeywordName.replaceFirstChar(Char::uppercaseChar)}\"\n        }\n        wrapperToInternalBoxing = map\n    }\n\n    override fun transform(internalClassName: String, methodNode: MethodNode) {\n        for (boxing in methodNode.instructions.asSequence().filter { it.isPrimitiveBoxing() }) {\n            assert(boxing.opcode == Opcodes.INVOKESTATIC) {\n                \"boxing shall be INVOKESTATIC wrapper.valueOf\"\n            }\n            boxing as MethodInsnNode\n            val methodName = wrapperToInternalBoxing[boxing.owner].sure {\n                \"expected primitive wrapper, but got ${boxing.owner}\"\n            }\n            methodNode.instructions.set(\n                boxing,\n                MethodInsnNode(boxing.opcode, BOXING_CLASS_INTERNAL_NAME, methodName, boxing.desc, false)\n       "}
{"code": "     )\n        }\n    }\n}\n"}
{"code": "// WITH_STDLIB\n\nimport broken.lib.Foo\n\nval x = run {\n    Foo(\"foo\", 1).result\n}"}
{"code": "// FILE: main.kt\nclass A {\n    fun foo() {\n        <caret>JavaClass(\"\")\n    }\n}\n\n// FILE: JavaClass.java\nimport org.jetbrains.annotations.NotNull;\n\npublic class JavaClass {\n    public JavaClass(@NotNull String s) {\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.types\n\nimport org.jetbrains.kotlin.analysis.api.KtTypeProjection\nimport org.jetbrains.kotlin.analysis.api.annotations.KtAnnotationsList\nimport org.jetbrains.kotlin.analysis.api.fir.KtSymbolByFirBuilder\nimport org.jetbrains.kotlin.analysis.api.fir.annotations.KtFirAnnotationListForType\nimport org.jetbrains.kotlin.analysis.api.fir.types.qualifiers.UsualClassTypeQualifierBuilder\nimport org.jetbrains.kotlin.analysis.api.fir.utils.cached\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken\nimport org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion\nimport org.jetbrains.kotlin.analysis.api.symbols.KtClassLikeSymbol\nimport org.jetbrains.kotlin.analysis.api.types.KtTypeNullability\nimport org.jetbrains.kotlin.analysis.api.types.KtUsualClassType\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.util.errorWithFirSpecificEntries\nimport org.jetbrains.kotlin.fir.types.impl.ConeClassLikeTypeImpl\nimport org.jetbrains.kotlin."}
{"code": "fir.types.renderForDebugging\nimport org.jetbrains.kotlin.name.ClassId\n\ninternal class KtFirUsualClassType(\n    override val coneType: ConeClassLikeTypeImpl,\n    private val builder: KtSymbolByFirBuilder,\n) : KtUsualClassType(), KtFirType {\n    override val token: KtLifetimeToken get() = builder.token\n    override val classId: ClassId get() = withValidityAssertion { coneType.lookupTag.classId }\n    override val classSymbol: KtClassLikeSymbol\n        get() = withValidityAssertion {\n            builder.classifierBuilder.buildClassLikeSymbolByLookupTag(coneType.lookupTag)\n                ?: errorWithFirSpecificEntries(\"Class was not found\", coneType = coneType)\n        }\n\n    override val qualifiers by cached {\n        UsualClassTypeQualifierBuilder.buildQualifiers(coneType, builder)\n    }\n\n    override val ownTypeArguments: List<KtTypeProjection> get() = withValidityAssertion { qualifiers.last().typeArguments }\n\n    override val annotationsList: KtAnnotationsList by cached {\n        KtFir"}
{"code": "AnnotationListForType.create(coneType, builder)\n    }\n\n    override val nullability: KtTypeNullability get() = withValidityAssertion { coneType.nullability.asKtNullability() }\n    override fun asStringForDebugging(): String = withValidityAssertion { coneType.renderForDebugging() }\n    override fun equals(other: Any?) = typeEquals(other)\n    override fun hashCode() = typeHashcode()\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.test.framework.project.structure\n\nimport com.intellij.openapi.project.Project\nimport org.jetbrains.kotlin.analysis.test.framework.test.configurators.TestModuleKind\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.model.TestModule\nimport org.jetbrains.kotlin.test.services.TestServices\nimport java.nio.file.Path\n\n\nobject KtScriptTestModuleFactory : KtTestModuleFactory {\n    override fun createModule(\n        testModule: TestModule,\n        contextModule: KtTestModule?,\n        dependencyBinaryRoots: Collection<Path>,\n        testServices: TestServices,\n        project: Project,\n    ): KtTestModule {\n        val ktFile = TestModuleStructureFactory.createSourcePsiFiles(testModule, testServices, project).single() as KtFile\n        val module = KtScriptModuleImpl(\n            ktFile,\n            testModule.targetPlatform,\n            testModule.languageVersionSettings,\n            project,\n        )\n\n        return KtTestModule(Te"}
{"code": "stModuleKind.ScriptSource, testModule, module, listOf(ktFile))\n    }\n}\n"}
{"code": "// WITH_STDLIB\n// FILE: JavaClass.java\npublic class JavaClass {\n    public static void foo1(kotlin.jvm.functions.Function0<Integer> x) {}\n    public static void foo2(kotlin.jvm.functions.Function1<Integer, String> x) {}\n    public static <T> void foo3(kotlin.jvm.functions.Function1<T, String> x, T y) {}\n}\n\n// FILE: main.kt\n\nfun main() {\n    JavaClass.foo1 { 123 }\n\n\n    JavaClass.foo2 { (it + 2).toString() }\n    JavaClass.foo2({ (it + 3).toString() })\n    val y = { x: Int -> x.toString() }\n    JavaClass.foo2(y)\n\n\n    JavaClass.foo3({ (it + 4).toString() }, 5)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.decompiler.stub.file\n\nimport com.intellij.openapi.diagnostic.Logger\nimport com.intellij.openapi.vfs.VirtualFile\nimport com.intellij.psi.compiled.ClsStubBuilder\nimport com.intellij.psi.impl.compiled.ClassFileStubBuilder\nimport com.intellij.psi.stubs.PsiFileStub\nimport com.intellij.util.indexing.FileContent\nimport org.jetbrains.kotlin.SpecialJvmAnnotations\nimport org.jetbrains.kotlin.analysis.decompiler.stub.*\nimport org.jetbrains.kotlin.constant.ConstantValue\nimport org.jetbrains.kotlin.constant.KClassValue\nimport org.jetbrains.kotlin.descriptors.SourceElement\nimport org.jetbrains.kotlin.load.java.JvmAnnotationNames\nimport org.jetbrains.kotlin.load.kotlin.*\nimport org.jetbrains.kotlin.load.kotlin.header.KotlinClassHeader\nimport org.jetbrains.kotlin.metadata.ProtoBuf\nimport org.jetbrains.kotlin.metadata.deserialization.Flags\nimport org.jetbrains.kotlin.metadata.deserialization.NameResolver\nimport org.jetbrains.kotlin.metadata.deserialization.TypeTa"}
{"code": "ble\nimport org.jetbrains.kotlin.metadata.jvm.deserialization.JvmMetadataVersion\nimport org.jetbrains.kotlin.metadata.jvm.deserialization.JvmProtoBufUtil\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.psi.stubs.KotlinStubVersions\nimport org.jetbrains.kotlin.psi.stubs.impl.createConstantValue\nimport org.jetbrains.kotlin.serialization.deserialization.builtins.BuiltInSerializerProtocol\n\nimport org.jetbrains.kotlin.serialization.deserialization.getClassId\nimport org.jetbrains.kotlin.serialization.deserialization.getName\nimport org.jetbrains.kotlin.storage.LockBasedStorageManager\n\nopen class KotlinClsStubBuilder : ClsStubBuilder() {\n    override fun getStubVersion() = ClassFileStubBuilder.STUB_VERSION + KotlinStubVersions.CLASSFILE_STUB_VERSION\n\n    override fun buildFileStub(content: FileContent): PsiFileStub<*>? {\n        val virtualFile = content.file\n"}
{"code": "\n        if (ClsClassFinder.isKotlinInternalCompiledFile(virtualFile, content.content)) {\n            return null\n        }\n\n        if (isVersioned(virtualFile)) {\n            // Kotlin can't build stubs for versioned class files, because list of versioned inner classes\n            // might be incomplete\n            return null\n        }\n\n        return doBuildFileStub(virtualFile, content.content)\n    }\n\n    private fun doBuildFileStub(file: VirtualFile, fileContent: ByteArray): PsiFileStub<KtFile>? {\n        val kotlinClass = ClsKotlinBinaryClassCache.getInstance().getKotlinBinaryClass(file, fileContent)\n            ?: error(\"Can't find binary class for Kotlin file: $file\")\n        val header = kotlinClass.classHeader\n        val classId = kotlinClass.classId\n        val packageFqName = header.packageName?.let { FqName(it) } ?: classId.packageFqName\n\n        if (!header.metadataVersion.isCompatibleWithCurrentCompilerVersion()) {\n            return createIncompatibleAbiVersionFileStu"}
{"code": "b()\n        }\n\n        val components = createStubBuilderComponents(file, packageFqName, fileContent, header.metadataVersion)\n        if (header.kind == KotlinClassHeader.Kind.MULTIFILE_CLASS) {\n            val partFiles = ClsClassFinder.findMultifileClassParts(file, classId, header.multifilePartNames)\n            return createMultifileClassStub(header, partFiles, classId.asSingleFqName(), components)\n        }\n\n        val annotationData = header.data\n        if (annotationData == null) {\n            LOG.error(\"Corrupted kotlin header for file ${file.name}\")\n            return null\n        }\n        val strings = header.strings\n        if (strings == null) {\n            LOG.error(\"String table not found in file ${file.name}\")\n            return null\n        }\n        return when (header.kind) {\n            KotlinClassHeader.Kind.CLASS -> {\n                if (classId.isLocal) return null\n                val (nameResolver, classProto) = JvmProtoBufUtil.readClassDataFrom(annotationData,"}
{"code": " strings)\n                if (Flags.VISIBILITY.get(classProto.flags) == ProtoBuf.Visibility.LOCAL) {\n                    // Older Kotlin compiler versions didn't put 'INNERCLASS' attributes in some cases (e.g. for cross-inline lambdas),\n                    // so 'ClassFileViewProvider.isInnerClass()' pre-check won't find them (EA-105730).\n                    // Example: `Timer().schedule(1000) { foo () }`.\n                    return null\n                }\n\n                val context = components.createContext(nameResolver, packageFqName, TypeTable(classProto.typeTable))\n                createTopLevelClassStub(classId, classProto, KotlinJvmBinarySourceElement(kotlinClass), context, header.isScript)\n            }\n            KotlinClassHeader.Kind.FILE_FACADE -> {\n                val (nameResolver, packageProto) = JvmProtoBufUtil.readPackageDataFrom(annotationData, strings)\n                val context = components.createContext(nameResolver, packageFqName, TypeTable(packageProto.typeTab"}
{"code": "le))\n                val fqName = header.packageName?.let { ClassId(FqName(it), classId.relativeClassName, classId.isLocal).asSingleFqName() }\n                    ?: classId.asSingleFqName()\n                createFileFacadeStub(packageProto, fqName, context)\n            }\n            else -> throw IllegalStateException(\"Should have processed \" + file.path + \" with header $header\")\n        }\n    }\n\n    private fun createStubBuilderComponents(\n        file: VirtualFile,\n        packageFqName: FqName,\n        fileContent: ByteArray,\n        jvmMetadataVersion: JvmMetadataVersion\n    ): ClsStubBuilderComponents {\n        val classFinder = DirectoryBasedClassFinder(file.parent!!, packageFqName)\n        val classDataFinder = DirectoryBasedDataFinder(classFinder, LOG, jvmMetadataVersion)\n        val annotationLoader = AnnotationLoaderForClassFileStubBuilder(classFinder, file, fileContent, jvmMetadataVersion)\n        return ClsStubBuilderComponents(classDataFinder, annotationLoader, file, Buil"}
{"code": "tInSerializerProtocol, classFinder, jvmMetadataVersion)\n    }\n\n    companion object {\n        val LOG = Logger.getInstance(KotlinClsStubBuilder::class.java)\n\n        // Archive separator + META-INF + versions\n        private val VERSIONED_PATH_MARKER = \"!/META-INF/versions/\"\n\n        fun isVersioned(virtualFile: VirtualFile): Boolean {\n            return virtualFile.path.contains(VERSIONED_PATH_MARKER)\n        }\n    }\n}\n\nprivate class AnnotationLoaderForClassFileStubBuilder(\n    kotlinClassFinder: KotlinClassFinder,\n    private val cachedFile: VirtualFile,\n    private val cachedFileContent: ByteArray,\n    override val jvmMetadataVersion: JvmMetadataVersion\n) : AbstractBinaryClassAnnotationLoader<AnnotationWithArgs, AnnotationsContainerWithConstants<AnnotationWithArgs, ConstantValue<*>>>(\n    kotlinClassFinder\n) {\n\n    private val storage =\n        LockBasedStorageManager.NO_LOCKS.createMemoizedFunction<KotlinJvmBinaryClass, AnnotationsContainerWithConstants<AnnotationWithArgs, Constant"}
{"code": "Value<*>>> { kotlinClass ->\n            loadAnnotationsAndInitializers(kotlinClass)\n        }\n\n    override fun getAnnotationsContainer(binaryClass: KotlinJvmBinaryClass): AnnotationsContainerWithConstants<AnnotationWithArgs, ConstantValue<*>> {\n        return storage(binaryClass)\n    }\n\n    override fun getCachedFileContent(kotlinClass: KotlinJvmBinaryClass): ByteArray? {\n        if ((kotlinClass as? VirtualFileKotlinClass)?.file == cachedFile) {\n            return cachedFileContent\n        }\n        return null\n    }\n\n    override fun loadAnnotation(proto: ProtoBuf.Annotation, nameResolver: NameResolver): AnnotationWithArgs {\n        val args = proto.argumentList.associate { nameResolver.getName(it.nameId) to createConstantValue(it.value, nameResolver) }\n        return AnnotationWithArgs(nameResolver.getClassId(proto.id), args)\n    }\n\n    override fun loadAnnotation(\n        annotationClassId: ClassId, source: SourceElement, result: MutableList<AnnotationWithArgs>\n    ): KotlinJvmBin"}
{"code": "aryClass.AnnotationArgumentVisitor {\n        return object : AnnotationMemberDefaultValueVisitor() {\n            override fun visitEnd() {\n                if (!isRepeatableWithImplicitContainer(annotationClassId, args)) {\n                    result.add(AnnotationWithArgs(annotationClassId, args))\n                }\n            }\n        }\n    }\n\n    protected fun isRepeatableWithImplicitContainer(annotationClassId: ClassId, arguments: Map<Name, ConstantValue<*>>): Boolean {\n        if (annotationClassId != SpecialJvmAnnotations.JAVA_LANG_ANNOTATION_REPEATABLE) return false\n\n        val containerKClassValue = arguments[JvmAnnotationNames.DEFAULT_ANNOTATION_MEMBER_NAME] as? KClassValue ?: return false\n        return isImplicitRepeatableContainer((containerKClassValue.value as KClassValue.Value.NormalClass).classId)\n    }\n\n    private fun loadAnnotationsAndInitializers(kotlinClass: KotlinJvmBinaryClass): AnnotationsContainerWithConstants<AnnotationWithArgs, ConstantValue<*>> {\n        val "}
{"code": "memberAnnotations = HashMap<MemberSignature, MutableList<AnnotationWithArgs>>()\n        val propertyConstants = HashMap<MemberSignature, ConstantValue<*>>()\n        val annotationParametersDefaultValues = HashMap<MemberSignature, ConstantValue<*>>()\n\n        kotlinClass.visitMembers(object : KotlinJvmBinaryClass.MemberVisitor {\n            override fun visitMethod(name: Name, desc: String): KotlinJvmBinaryClass.MethodAnnotationVisitor {\n                return AnnotationVisitorForMethod(MemberSignature.fromMethodNameAndDesc(name.asString(), desc))\n            }\n\n            override fun visitField(name: Name, desc: String, initializer: Any?): KotlinJvmBinaryClass.AnnotationVisitor {\n                val signature = MemberSignature.fromFieldNameAndDesc(name.asString(), desc)\n                return MemberAnnotationVisitor(signature)\n            }\n\n            inner class AnnotationVisitorForMethod(signature: MemberSignature) : MemberAnnotationVisitor(signature),\n                KotlinJvmBi"}
{"code": "naryClass.MethodAnnotationVisitor {\n\n                override fun visitParameterAnnotation(\n                    index: Int, classId: ClassId, source: SourceElement\n                ): KotlinJvmBinaryClass.AnnotationArgumentVisitor? {\n                    val paramSignature = MemberSignature.fromMethodSignatureAndParameterIndex(signature, index)\n                    var result = memberAnnotations[paramSignature]\n                    if (result == null) {\n                        result = ArrayList()\n                        memberAnnotations[paramSignature] = result\n                    }\n                    return loadAnnotationIfNotSpecial(classId, source, result)\n                }\n\n                override fun visitAnnotationMemberDefaultValue(): KotlinJvmBinaryClass.AnnotationArgumentVisitor? {\n                    return null\n                }\n            }\n\n            open inner class MemberAnnotationVisitor(protected val signature: MemberSignature) : KotlinJvmBinaryClass.AnnotationVisit"}
{"code": "or {\n                private val result = ArrayList<AnnotationWithArgs>()\n\n                override fun visitAnnotation(classId: ClassId, source: SourceElement): KotlinJvmBinaryClass.AnnotationArgumentVisitor? {\n                    return loadAnnotationIfNotSpecial(classId, source, result)\n                }\n\n                override fun visitEnd() {\n                    if (result.isNotEmpty()) {\n                        memberAnnotations[signature] = result\n                    }\n                }\n            }\n        }, getCachedFileContent(kotlinClass))\n\n        return AnnotationsContainerWithConstants(\n            memberAnnotations,\n            propertyConstants,\n            annotationParametersDefaultValues\n        )\n    }\n}"}
{"code": "interface AnnotationsOnParenthesizedTypes {\n    fun B<(@A C)>.receiverArgument() {}\n\n    fun parameter(a: (@A C)) {}\n\n    fun parameterArgument(a: B<(@A C)>) {}\n\n    fun returnValue(): (@A C)\n\n    fun <T> returnTypeParameterValue(): (@A T)\n\n    fun returnArgument(): B<(@A C)>\n\n    val lambdaType: (@A() (() -> C))\n\n    val lambdaParameter: ((@A C)) -> C\n\n    val lambdaReturnValue: () -> (@A C)\n\n    val lambdaReceiver: (@A C).() -> C\n\n    val lambdaParameterNP: (@A C) -> C\n}\n\n@Target(AnnotationTarget.TYPE, AnnotationTarget.TYPE_PARAMETER)\nannotation class A\n\ninterface B<T>\ninterface C"}
{"code": "import <!UNRESOLVED_IMPORT!>incorrect<!>.directory.Your\n\ntypealias My = <!UNRESOLVED_REFERENCE!>incorrect<!>.directory.My\n\ntypealias Your = <!RECURSIVE_TYPEALIAS_EXPANSION!>Your<!>\n"}
{"code": "// SKIP_WHEN_OUT_OF_CONTENT_ROOT\n// MEMBER_NAME_FILTER: something\n// FILE: Derived.kt\nclass Der<caret>ived : Base() {\n    @Anno(\"number: ${prop}\")\n    override fun getSomething() = \"body: ${propertyFromBody}\"\n}\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)\nannotation class Anno(val s: String)\nval prop = 2.let { it + 1 }\nval propertyFromBody = \"str\" + 1.toString()\n\n// FILE: Base.java\npublic class Base {\n    public String getSomething() {\n        return \"\";\n    }\n}"}
{"code": "package test\n\nclass FunInterfaceDeclaration {\n    @Suppress(\"UNSUPPORTED_FEATURE\")\n    fun interface KRunnable {\n        fun invoke()\n    }\n\n    @Suppress(\"UNSUPPORTED_FEATURE\")\n    fun interface GenericKRunnable<T, R> {\n        fun invoke(t: T): R\n    }\n}\n"}
{"code": "// SKIP_WHEN_OUT_OF_CONTENT_ROOT\n// MODULE: dependency\n// FILE: dependency.kt\npackage org.example\n\ninterface Base\n\nabstract class Foo : Base\n\n// MODULE: usage(dependency)\n// FILE: usage.kt\npackage org.example\n\ninterface Base {\n    fun bar()\n}\n\nabstract class FooImpl : Foo() {\n    fun b<caret>az() {\n\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.coroutines\n\nimport com.intellij.openapi.project.Project\nimport org.jetbrains.kotlin.backend.common.COROUTINE_SUSPENDED_NAME\nimport org.jetbrains.kotlin.backend.common.isBuiltInSuspendCoroutineUninterceptedOrReturn\nimport org.jetbrains.kotlin.builtins.StandardNames\nimport org.jetbrains.kotlin.builtins.StandardNames.COROUTINES_INTRINSICS_PACKAGE_FQ_NAME\nimport org.jetbrains.kotlin.builtins.StandardNames.COROUTINES_JVM_INTERNAL_PACKAGE_FQ_NAME\nimport org.jetbrains.kotlin.builtins.isBuiltinFunctionalClassDescriptor\nimport org.jetbrains.kotlin.codegen.*\nimport org.jetbrains.kotlin.codegen.binding.CodegenBinding\nimport org.jetbrains.kotlin.codegen.inline.addFakeContinuationMarker\nimport org.jetbrains.kotlin.codegen.state.GenerationState\nimport org.jetbrains.kotlin.codegen.state.KotlinTypeMapper\nimport org.jetbrains.kotlin.coroutines.isSuspendLambda\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.descriptors.annotations.Annotations\n"}
{"code": "import org.jetbrains.kotlin.descriptors.impl.AnonymousFunctionDescriptor\nimport org.jetbrains.kotlin.descriptors.impl.ValueParameterDescriptorImpl\nimport org.jetbrains.kotlin.incremental.components.NoLookupLocation\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtExpression\nimport org.jetbrains.kotlin.psi.KtPsiFactory\nimport org.jetbrains.kotlin.resolve.*\nimport org.jetbrains.kotlin.resolve.calls.checkers.isBuiltInCoroutineContext\nimport org.jetbrains.kotlin.resolve.calls.model.*\nimport org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo\nimport org.jetbrains.kotlin.resolve.calls.tasks.TracingStrategy\nimport org.jetbrains.kotlin.resolve.calls.tower.NewResolvedCallImpl\nimport org.jetbrains.kotlin.resolve.descriptorUtil.builtIns\nimport org.jetbrains.kotlin.resolve.descriptorUtil.module\nimport org.jetbrains.kotlin.resolve.descriptorUtil.resolveTopLevelClass\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes\nimport org.jetb"}
{"code": "rains.kotlin.resolve.jvm.AsmTypes.OBJECT_TYPE\nimport org.jetbrains.kotlin.types.*\nimport org.jetbrains.kotlin.types.error.ErrorTypeKind\nimport org.jetbrains.kotlin.types.error.ErrorUtils\nimport org.jetbrains.kotlin.types.typeUtil.asTypeProjection\nimport org.jetbrains.kotlin.types.typeUtil.makeNotNullable\nimport org.jetbrains.kotlin.util.OperatorNameConventions\nimport org.jetbrains.org.objectweb.asm.Label\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\nimport org.jetbrains.org.objectweb.asm.commons.Method\nimport org.jetbrains.org.objectweb.asm.tree.MethodNode\n\nconst val COROUTINE_LABEL_FIELD_NAME = \"label\"\nconst val SUSPEND_FUNCTION_CREATE_METHOD_NAME = \"create\"\nconst val INVOKE_SUSPEND_METHOD_NAME = \"invokeSuspend\"\nconst val CONTINUATION_RESULT_FIELD_NAME = \"result\"\n\nprivate const val GET_CONTEXT_METHOD_NAME = \"getContext\"\n\nval DEBUG_METADATA_ANNOTATION_ASM_TYPE: Type =\n    CORO"}
{"code": "UTINES_JVM_INTERNAL_PACKAGE_FQ_NAME.child(Name.identifier(\"DebugMetadata\")).topLevelClassAsmType()\n\nfun coroutineContextAsmType(): Type =\n    StandardNames.COROUTINES_PACKAGE_FQ_NAME.child(Name.identifier(\"CoroutineContext\")).topLevelClassAsmType()\n\nfun String.isCoroutineSuperClass(): Boolean =\n    COROUTINES_JVM_INTERNAL_PACKAGE_FQ_NAME.identifiedChild(\"ContinuationImpl\") == this ||\n            COROUTINES_JVM_INTERNAL_PACKAGE_FQ_NAME.identifiedChild(\"RestrictedContinuationImpl\") == this ||\n            COROUTINES_JVM_INTERNAL_PACKAGE_FQ_NAME.identifiedChild(\"SuspendLambda\") == this ||\n            COROUTINES_JVM_INTERNAL_PACKAGE_FQ_NAME.identifiedChild(\"RestrictedSuspendLambda\") == this\n\nprivate fun FqName.identifiedChild(name: String) = child(Name.identifier(name)).topLevelClassInternalName()\n\nprivate val coroutinesIntrinsicsFileFacadeInternalName: Type =\n    COROUTINES_INTRINSICS_PACKAGE_FQ_NAME.child(Name.identifier(\"IntrinsicsKt\")).topLevelClassAsmType()\n\ndata class ResolvedCallWith"}
{"code": "RealDescriptor(val resolvedCall: ResolvedCall<*>, val fakeContinuationExpression: KtExpression)\n\n@JvmField\nval INITIAL_DESCRIPTOR_FOR_SUSPEND_FUNCTION = object : CallableDescriptor.UserDataKey<FunctionDescriptor> {}\n\n@JvmField\nval INITIAL_SUSPEND_DESCRIPTOR_FOR_INVOKE_SUSPEND = object : CallableDescriptor.UserDataKey<FunctionDescriptor> {}\n\nval CONTINUATION_PARAMETER_NAME = Name.identifier(\"continuation\")\n\nconst val CONTINUATION_VARIABLE_NAME = \"\\$continuation\"\n\n// Resolved calls to suspension function contain descriptors as they visible within coroutines:\n// E.g. `fun <V> await(f: CompletableFuture<V>): V` instead of `fun <V> await(f: CompletableFuture<V>, machine: Continuation<V>): Unit`\n// See `createJvmSuspendFunctionView` and it's usages for clarification\n// But for call generation it's convenient to have `machine` (continuation) parameter/argument within resolvedCall.\n// So this function returns resolved call with descriptor looking like `fun <V> await(f: CompletableFuture<V>, ma"}
{"code": "chine: Continuation<V>): Unit`\n// and fake `this` expression that used as argument for second parameter\nfun ResolvedCall<*>.replaceSuspensionFunctionWithRealDescriptor(\n    project: Project,\n    bindingContext: BindingContext\n): ResolvedCallWithRealDescriptor? {\n    if (this is VariableAsFunctionResolvedCall) {\n        val replacedFunctionCall =\n            functionCall.replaceSuspensionFunctionWithRealDescriptor(project, bindingContext)\n                ?: return null\n\n        @Suppress(\"UNCHECKED_CAST\")\n        return replacedFunctionCall.copy(\n            resolvedCall = VariableAsFunctionResolvedCallImpl(\n                replacedFunctionCall.resolvedCall as MutableResolvedCall<FunctionDescriptor>,\n                variableCall.asMutableResolvedCall(bindingContext)\n            )\n        )\n    }\n    val function = candidateDescriptor as? FunctionDescriptor ?: return null\n    if (!function.isSuspend || function.getUserData(INITIAL_DESCRIPTOR_FOR_SUSPEND_FUNCTION) != null) return null\n\n  "}
{"code": "  val newCandidateDescriptor =\n        when (function) {\n            is FunctionImportedFromObject ->\n                getOrCreateJvmSuspendFunctionView(function.callableFromObject, bindingContext).asImportedFromObject()\n            is SimpleFunctionDescriptor ->\n                getOrCreateJvmSuspendFunctionView(function, bindingContext)\n            else ->\n                throw AssertionError(\"Unexpected suspend function descriptor: $function\")\n        }\n\n    val newCall = ResolvedCallImpl(\n        call,\n        newCandidateDescriptor,\n        dispatchReceiver, extensionReceiver, explicitReceiverKind,\n        null, DelegatingBindingTrace(BindingTraceContext(null).bindingContext, \"Temporary trace for unwrapped suspension function\"),\n        TracingStrategy.EMPTY, MutableDataFlowInfoForArguments.WithoutArgumentsCheck(DataFlowInfo.EMPTY)\n    )\n\n    this.valueArguments.forEach {\n        newCall.recordValueArgument(newCandidateDescriptor.valueParameters[it.key.index], it.value)\n    }\n\n    v"}
{"code": "al psiFactory = KtPsiFactory(project, markGenerated = false)\n    val arguments = psiFactory.createCallArguments(\"(this)\").arguments.single()\n    val thisExpression = arguments.getArgumentExpression()!!\n    newCall.recordValueArgument(\n        newCandidateDescriptor.valueParameters.last(),\n        ExpressionValueArgument(arguments)\n    )\n\n    val newTypeArguments = newCandidateDescriptor.typeParameters.associateWith {\n        typeArguments[candidateDescriptor.typeParameters[it.index]]!!.asTypeProjection()\n    }\n\n    newCall.setSubstitutor(\n        TypeConstructorSubstitution.createByParametersMap(newTypeArguments).buildSubstitutor()\n    )\n\n    return ResolvedCallWithRealDescriptor(newCall, thisExpression)\n}\n\nfun ResolvedCall<*>.replaceSuspensionFunctionWithRealDescriptor(state: GenerationState): ResolvedCallWithRealDescriptor? =\n    replaceSuspensionFunctionWithRealDescriptor(\n        state.project,\n        state.bindingContext\n    )\n\nprivate fun ResolvedCall<VariableDescriptor>.asMutab"}
{"code": "leResolvedCall(bindingContext: BindingContext): MutableResolvedCall<VariableDescriptor> {\n    return when (this) {\n        is ResolvedCallImpl<*> -> this as MutableResolvedCall<VariableDescriptor>\n        is NewResolvedCallImpl<*> -> (this as NewResolvedCallImpl<VariableDescriptor>).asDummyOldResolvedCall(bindingContext)\n        else -> throw IllegalStateException(\"No mutable resolved call for $this\")\n    }\n}\n\nprivate fun NewResolvedCallImpl<VariableDescriptor>.asDummyOldResolvedCall(bindingContext: BindingContext): ResolvedCallImpl<VariableDescriptor> {\n    return ResolvedCallImpl(\n        call,\n        candidateDescriptor,\n        dispatchReceiver, extensionReceiver, explicitReceiverKind,\n        null, DelegatingBindingTrace(bindingContext, \"Trace for old call\"),\n        TracingStrategy.EMPTY, MutableDataFlowInfoForArguments.WithoutArgumentsCheck(DataFlowInfo.EMPTY)\n    )\n}\n\nenum class SuspensionPointKind { NEVER, NOT_INLINE, ALWAYS }\n\nfun ResolvedCall<*>.isSuspensionPoint(codegen: E"}
{"code": "xpressionCodegen): SuspensionPointKind {\n    val functionDescriptor = resultingDescriptor as? FunctionDescriptor ?: return SuspensionPointKind.NEVER\n    if (!functionDescriptor.unwrapInitialDescriptorForSuspendFunction().isSuspend) return SuspensionPointKind.NEVER\n    if (functionDescriptor.isBuiltInSuspendCoroutineUninterceptedOrReturnInJvm()) return SuspensionPointKind.ALWAYS\n    if (functionDescriptor.isInline) return SuspensionPointKind.NEVER\n\n    val parameter = (this as? VariableAsFunctionResolvedCall)?.variableCall?.resultingDescriptor as? ValueParameterDescriptor\n    val isInlineLambda = parameter != null &&\n            (parameter.isCrossinline || (!parameter.isNoinline && codegen.context.functionDescriptor.isInline))\n    return if (isInlineLambda) SuspensionPointKind.NOT_INLINE else SuspensionPointKind.ALWAYS\n}\n\nfun CallableDescriptor.isSuspendFunctionNotSuspensionView(): Boolean {\n    if (this !is FunctionDescriptor) return false\n    return this.isSuspend && this.getUserData("}
{"code": "INITIAL_DESCRIPTOR_FOR_SUSPEND_FUNCTION) == null\n}\n\nfun <D : FunctionDescriptor> getOrCreateJvmSuspendFunctionView(function: D, state: GenerationState): D = getOrCreateJvmSuspendFunctionView(\n    function,\n    state.bindingContext\n)\n\n// Suspend functions have irregular signatures on JVM, containing an additional last parameter with type `Continuation<return-type>`,\n// and return type Any?\n// This function returns a function descriptor reflecting how the suspend function looks from point of view of JVM\n@JvmOverloads\nfun <D : FunctionDescriptor> getOrCreateJvmSuspendFunctionView(\n    function: D,\n    bindingContext: BindingContext? = null\n): D {\n    assert(function.isSuspend) {\n        \"Suspended function is expected, but $function was found\"\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    bindingContext?.get(CodegenBinding.SUSPEND_FUNCTION_TO_JVM_VIEW, function)?.let { return it as D }\n\n    val continuationParameter = ValueParameterDescriptorImpl(\n        containingDeclaration = function,\n  "}
{"code": "      original = null,\n        index = function.valueParameters.size,\n        annotations = Annotations.EMPTY,\n        name = CONTINUATION_PARAMETER_NAME,\n        // Add j.l.Object to invoke(), because that is the type of parameters we have in FunctionN+1\n        outType = if ((function.containingDeclaration as? ClassDescriptor)?.isBuiltinFunctionalClassDescriptor == true)\n            function.builtIns.nullableAnyType\n        else\n            function.getContinuationParameterTypeOfSuspendFunction(),\n        declaresDefaultValue = false, isCrossinline = false,\n        isNoinline = false, varargElementType = null,\n        source = SourceElement.NO_SOURCE\n    )\n\n    return function.createCustomCopy {\n        setDropOriginalInContainingParts()\n        setPreserveSourceElement()\n        setReturnType(function.builtIns.nullableAnyType)\n        setValueParameters(it.valueParameters + continuationParameter)\n        putUserData(INITIAL_DESCRIPTOR_FOR_SUSPEND_FUNCTION, it)\n    }\n}\n\ntypealias Fun"}
{"code": "ctionDescriptorCopyBuilderToFunctionDescriptorCopyBuilder =\n        FunctionDescriptor.CopyBuilder<out FunctionDescriptor>.(FunctionDescriptor)\n        -> FunctionDescriptor.CopyBuilder<out FunctionDescriptor>\n\nfun <D : FunctionDescriptor> D.createCustomCopy(\n    copySettings: FunctionDescriptorCopyBuilderToFunctionDescriptorCopyBuilder\n): D {\n\n    val newOriginal =\n        if (original !== this)\n            original.createCustomCopy(copySettings)\n        else\n            null\n\n    val result = newCopyBuilder().copySettings(this).setOriginal(newOriginal).build()!!\n\n    result.overriddenDescriptors = this.overriddenDescriptors.map { it.createCustomCopy(copySettings) }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return result as D\n}\n\nprivate fun FunctionDescriptor.getContinuationParameterTypeOfSuspendFunction() = module.getContinuationOfTypeOrAny(returnType!!)\n\nfun ModuleDescriptor.getResult(kotlinType: KotlinType) =\n    module.resolveTopLevelClass(\n        StandardNames.RESULT_FQ_NAME,\n       "}
{"code": " NoLookupLocation.FROM_BACKEND\n    )?.defaultType?.let {\n        KotlinTypeFactory.simpleType(\n            it,\n            arguments = listOf(kotlinType.asTypeProjection())\n        )\n    } ?: ErrorUtils.createErrorType(ErrorTypeKind.TYPE_FOR_RESULT)\n\nfun FunctionDescriptor.isBuiltInSuspendCoroutineUninterceptedOrReturnInJvm() =\n    getUserData(INITIAL_DESCRIPTOR_FOR_SUSPEND_FUNCTION)?.isBuiltInSuspendCoroutineUninterceptedOrReturn() == true\n\nfun createMethodNodeForCoroutineContext(functionDescriptor: FunctionDescriptor): MethodNode {\n    assert(functionDescriptor.isBuiltInCoroutineContext()) {\n        \"functionDescriptor must be kotlin.coroutines.intrinsics.coroutineContext property getter\"\n    }\n\n    val node =\n        MethodNode(\n            Opcodes.API_VERSION,\n            Opcodes.ACC_STATIC,\n            \"fake\",\n            Type.getMethodDescriptor(coroutineContextAsmType()),\n            null, null\n        )\n\n    val v = InstructionAdapter(node)\n\n    addFakeContinuationMarker(v)\n\n  "}
{"code": "  v.invokeGetContext()\n\n    node.visitMaxs(1, 1)\n\n    return node\n}\n\nfun createMethodNodeForSuspendCoroutineUninterceptedOrReturn(): MethodNode {\n    val node =\n        MethodNode(\n            Opcodes.API_VERSION,\n            Opcodes.ACC_STATIC,\n            \"fake\",\n            Type.getMethodDescriptor(OBJECT_TYPE, AsmTypes.FUNCTION1, CONTINUATION_ASM_TYPE),\n            null, null\n        )\n\n    with(InstructionAdapter(node)) {\n        load(0, OBJECT_TYPE) // block\n        load(1, OBJECT_TYPE) // continuation\n\n        // block.invoke(continuation)\n        invokeinterface(\n            AsmTypes.FUNCTION1.internalName,\n            OperatorNameConventions.INVOKE.identifier,\n            \"($OBJECT_TYPE)$OBJECT_TYPE\"\n        )\n\n        val elseLabel = Label()\n        // if (result === COROUTINE_SUSPENDED) {\n        dup()\n        loadCoroutineSuspendedMarker()\n        ifacmpne(elseLabel)\n        //   DebugProbesKt.probeCoroutineSuspended(continuation)\n        load(1, OBJECT_TYPE) // continuatio"}
{"code": "n\n        checkcast(CONTINUATION_ASM_TYPE)\n        invokestatic(\n            COROUTINES_JVM_INTERNAL_PACKAGE_FQ_NAME.child(Name.identifier(\"DebugProbesKt\")).topLevelClassAsmType().internalName,\n            \"probeCoroutineSuspended\",\n            \"($CONTINUATION_ASM_TYPE)V\",\n            false\n        )\n        // }\n        mark(elseLabel)\n    }\n\n    node.visitInsn(Opcodes.ARETURN)\n    node.visitMaxs(3, 2)\n\n    return node\n}\n\n\nprivate fun InstructionAdapter.invokeGetContext() {\n    invokeinterface(\n        CONTINUATION_ASM_TYPE.internalName,\n        GET_CONTEXT_METHOD_NAME,\n        Type.getMethodDescriptor(coroutineContextAsmType())\n    )\n    areturn(coroutineContextAsmType())\n}\n\n@Suppress(\"UNCHECKED_CAST\")\nfun <D : CallableDescriptor?> D.unwrapInitialDescriptorForSuspendFunction(): D =\n    (this as? SimpleFunctionDescriptor)?.getUserData(INITIAL_DESCRIPTOR_FOR_SUSPEND_FUNCTION) as D ?: this\n\nfun FunctionDescriptor.getOriginalSuspendFunctionView(bindingContext: BindingContext): FunctionDe"}
{"code": "scriptor =\n    if (isSuspend)\n        getOrCreateJvmSuspendFunctionView(unwrapInitialDescriptorForSuspendFunction().original, bindingContext)\n    else\n        this\n\n// For each suspend function, we have a corresponding JVM view function that has an extra continuation parameter,\n// and, more importantly, returns 'kotlin.Any' (so that it can return as a reference value or a special COROUTINE_SUSPENDED object).\n// This also causes boxing of primitives and inline class values.\n// If we have a function returning an inline class value that is mapped to a reference type, we want to avoid boxing.\n// However, we have to do that consistently both on declaration site and on call site.\nfun FunctionDescriptor.originalReturnTypeOfSuspendFunctionReturningUnboxedInlineClass(typeMapper: KotlinTypeMapper): KotlinType? {\n    if (!isSuspend) return null\n    // Suspend lambdas cannot return unboxed inline class\n    if (this is AnonymousFunctionDescriptor) return null\n    val originalDescriptor = unwrapInit"}
{"code": "ialDescriptorForSuspendFunction().original\n    val originalReturnType = originalDescriptor.returnType ?: return null\n    if (!originalReturnType.isInlineClassType()) return null\n    // Force boxing for primitives\n    if (AsmUtil.isPrimitive(typeMapper.mapType(originalReturnType.makeNotNullable()))) return null\n    // Force boxing for nullable inline class types with nullable underlying type\n    if (originalReturnType.isMarkedNullable && originalReturnType.isNullableUnderlyingType()) return null\n    // Force boxing if the function overrides function with different type modulo nullability\n    if (originalDescriptor.overriddenDescriptors.any {\n            (it.original.returnType?.isMarkedNullable == true && it.original.returnType?.isNullableUnderlyingType() == true) ||\n                    // We do not care about type parameters, just main class type\n                    it.original.returnType?.constructor?.declarationDescriptor != originalReturnType.constructor.declarationDescriptor\n      "}
{"code": "  }) return null\n    // Don't box other inline classes\n    return originalReturnType\n}\n\nfun InstructionAdapter.loadCoroutineSuspendedMarker() {\n    invokestatic(\n        coroutinesIntrinsicsFileFacadeInternalName.internalName,\n        \"get$COROUTINE_SUSPENDED_NAME\",\n        Type.getMethodDescriptor(OBJECT_TYPE),\n        false\n    )\n}\n\nfun InstructionAdapter.generateCoroutineSuspendedCheck() {\n    dup()\n    loadCoroutineSuspendedMarker()\n    val elseLabel = Label()\n    ifacmpne(elseLabel)\n    areturn(OBJECT_TYPE)\n    mark(elseLabel)\n}\n\nfun InstructionAdapter.invokeInvokeSuspendWithUnit(thisName: String) {\n    StackValue.putUnitInstance(this)\n\n    invokevirtual(\n        thisName,\n        INVOKE_SUSPEND_METHOD_NAME,\n        Type.getMethodDescriptor(OBJECT_TYPE, OBJECT_TYPE),\n        false\n    )\n}\n\nconst val SUSPEND_IMPL_NAME_SUFFIX = \"\\$suspendImpl\"\n\nfun Method.getImplForOpenMethod(ownerInternalName: String) =\n    Method(name + SUSPEND_IMPL_NAME_SUFFIX, returnType, arrayOf(Type.getObjectT"}
{"code": "ype(ownerInternalName)) + argumentTypes)\n\nfun FunctionDescriptor.isSuspendLambdaOrLocalFunction() = this.isSuspend && when (this) {\n    is AnonymousFunctionDescriptor -> this.isSuspendLambda\n    is SimpleFunctionDescriptor -> this.visibility == DescriptorVisibilities.LOCAL\n    else -> false\n}\n\nfun FunctionDescriptor.isLocalSuspendFunctionNotSuspendLambda(): Boolean =\n    isSuspendLambdaOrLocalFunction() && this !is AnonymousFunctionDescriptor\n\n@JvmField\nval CONTINUATION_ASM_TYPE = StandardNames.CONTINUATION_INTERFACE_FQ_NAME.topLevelClassAsmType()\n\nfun FunctionDescriptor.isInvokeSuspendOfLambda(): Boolean {\n    if (this !is SimpleFunctionDescriptor) return false\n    if (valueParameters.size != 1 ||\n        valueParameters[0].name.asString() != SUSPEND_CALL_RESULT_NAME ||\n        name.asString() != INVOKE_SUSPEND_METHOD_NAME\n    ) return false\n    return containingDeclaration is SyntheticClassDescriptorForLambda\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.scopes.jvm\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.FirSimpleFunction\nimport org.jetbrains.kotlin.fir.scopes.FirPlatformDeclarationFilter\nimport org.jetbrains.kotlin.fir.scopes.FirTypeScope\n\ninternal object FirJvmPlatformDeclarationFilter {\n    fun isFunctionAvailable(function: FirSimpleFunction, javaClassScope: FirTypeScope, session: FirSession): Boolean {\n        if (FirPlatformDeclarationFilter.isFunctionAvailable(function, session)) return true\n\n        var isFunctionPresentInJavaAnalogue = false\n        val jvmDescriptorOfKotlinFunction = function.computeJvmDescriptor()\n        javaClassScope.processFunctionsByName(function.name) { javaAnalogueFunctionSymbol ->\n            if (javaAnalogueFunctionSymbol.fir.computeJvmDescriptor() == jvmDescriptorOfKotlinFunction) {\n                isFunctionPresentInJavaAnalogue = true\n            }\n        }\n        return isFunctionPresentInJavaAnalogue\n    }\n}\n"}
{"code": "import kotlin.properties.Delegates\nimport kotlin.properties.ReadWriteProperty\n\ninterface ClassifierNamePolicy {\n    object SOURCE_CODE_QUALIFIED : ClassifierNamePolicy\n}\n\ninterface KotlinType\n\nclass A(val isLocked: Boolean) {\n    private fun <T> property(initialValue: T): ReadWriteProperty<A, T> {\n        return Delegates.vetoable(initialValue) { _, _, _ ->\n            if (isLocked) {\n                throw IllegalStateException(\"Cannot modify readonly DescriptorRendererOptions\")\n            }\n            else {\n                true\n            }\n        }\n    }\n\n    var classifierNamePolicy: ClassifierNamePolicy by property(ClassifierNamePolicy.SOURCE_CODE_QUALIFIED)\n    // getter has INAPPLICABLE diagnostic, see dump\n\n    var typeNormalizer by property<(KotlinType) -> KotlinType>({ it })\n}\n"}
{"code": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE_K1\n\nenum class MyEnumClass {\n    FirstEntry {\n        val a: Int = 1\n    },\n    SecondEntry,\n    ThirdEntry {\n        val b = 2\n        val Int.d get() = 2\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.range\n\nimport org.jetbrains.kotlin.codegen.ExpressionCodegen\nimport org.jetbrains.kotlin.codegen.StackValue\nimport org.jetbrains.kotlin.codegen.generateCallReceiver\nimport org.jetbrains.kotlin.codegen.range.comparison.IntComparisonGenerator\nimport org.jetbrains.kotlin.codegen.range.forLoop.ForInDefinitelySafeSimpleProgressionLoopGenerator\nimport org.jetbrains.kotlin.codegen.range.forLoop.ForInSimpleProgressionLoopGenerator\nimport org.jetbrains.kotlin.codegen.range.forLoop.ForLoopGenerator\nimport org.jetbrains.kotlin.descriptors.CallableDescriptor\nimport org.jetbrains.kotlin.psi.KtForExpression\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.org.objectweb.asm.Type\n\nclass ArrayIndicesRangeValue(rangeCall: ResolvedCall<out CallableDescriptor>) :\n    PrimitiveNumberRangeIntrinsicRangeValue(rangeCall), ReversableRangeValue {\n\n    private val expectedReceiverType: KotlinType "}
{"code": "= ExpressionCodegen.getExpectedReceiverType(rangeCall)\n\n    override fun getBoundedValue(codegen: ExpressionCodegen) =\n        BoundedValue(\n            StackValue.constant(0, codegen.asmType(elementKotlinType), elementKotlinType),\n            true,\n            StackValue.operation(Type.INT_TYPE) { v ->\n                codegen.generateCallReceiver(rangeCall).put(codegen.asmType(expectedReceiverType), expectedReceiverType, v)\n                v.arraylength()\n            },\n            false\n        )\n\n    override fun createForLoopGenerator(codegen: ExpressionCodegen, forExpression: KtForExpression) =\n        ForInSimpleProgressionLoopGenerator.fromBoundedValueWithStep1(\n            codegen, forExpression, getBoundedValue(codegen), IntComparisonGenerator\n        )\n\n    override fun createForInReversedLoopGenerator(codegen: ExpressionCodegen, forExpression: KtForExpression): ForLoopGenerator =\n        ForInDefinitelySafeSimpleProgressionLoopGenerator.fromBoundedValueWithStepMinus1(\n      "}
{"code": "      codegen, forExpression, getBoundedValue(codegen), IntComparisonGenerator\n        )\n}"}
{"code": "package test\n\nopen class Base {\n    class Nested\n}\n\ncontext(<expr>Base</expr>)\nclass Child : Base() {}"}
{"code": "// FILE: KotlinClass.kt\nclass Kotlin<caret_useSite>Class\n\n// FILE: A.java\npublic interface A<T> {\n    T f<caret>oo();\n}\n"}
{"code": "package dependency\n\ntypealias A = () -> Unit\n\nfun foo(a: A) {\n    a.invoke()\n}\n\nclass SomeClass"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.providers\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.search.GlobalSearchScope\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.caches.NullableCaffeineCache\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.java.JavaSymbolProvider\nimport org.jetbrains.kotlin.fir.java.hasMetadataAnnotation\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolNamesProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolNamesProviderWithoutCallables\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProviderInternals\nimport org.jetbrains.kotlin.fir.symbols.impl.*\nimport org.jetbrains.kotlin.load.java.JavaClassFinder\nimport org.jetbrains.kotlin.load.java.createJavaClassFinder\nimport org.jetbrains.kotlin.load.java.structure.JavaClass\nimport org.jetbrains.kotlin.load.java.structure.impl.JavaClassImpl\nimp"}
{"code": "ort org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\n\n\ninternal class LLFirCombinedJavaSymbolProvider private constructor(\n    session: FirSession,\n    project: Project,\n    providers: List<JavaSymbolProvider>,\n    private val javaClassFinder: JavaClassFinder,\n) : LLFirSelectingCombinedSymbolProvider<JavaSymbolProvider>(session, project, providers) {\n    \n    private val classCache: NullableCaffeineCache<ClassId, FirRegularClassSymbol> = NullableCaffeineCache { it.maximumSize(2500) }\n\n    override val symbolNamesProvider: FirSymbolNamesProvider = object : FirSymbolNamesProviderWithoutCallables() {\n        override val hasSpecificClassifierPackageNamesComputation: Boolean get() = false\n\n        override fun getTopLevelClassifierNamesInPackage(packageFqName: FqName): Set<Name>? = null\n        override fun mayHaveTopLevelClassifier(classId: ClassId): Boolean = true\n    }\n\n    override fun getClassLikeSymbolByClassId(classId: C"}
{"code": "lassId): FirClassLikeSymbol<*>? =\n        classCache.get(classId) { computeClassLikeSymbolByClassId(it) }\n\n    private fun computeClassLikeSymbolByClassId(classId: ClassId): FirRegularClassSymbol? {\n        val javaClasses = javaClassFinder.findClasses(classId).filterNot(JavaClass::hasMetadataAnnotation)\n        if (javaClasses.isEmpty()) return null\n\n        val (javaClass, provider) = selectFirstElementInClasspathOrder(javaClasses) { javaClass ->\n            // `JavaClass` doesn't know anything about PSI, but we can be sure that `findClasses` returns a `JavaClassImpl` because it's\n            // using `KotlinJavaPsiFacade`. The alternative to this hack would be to change the interface of either `JavaClass` (yet the\n            // module should hardly depend on PSI), or to have `KotlinJavaPsiFacade` and `JavaClassFinderImpl` return `JavaClassImpl` and to\n            // return `JavaClassFinderImpl` from `createJavaClassFinder`.\n            check(javaClass is JavaClassImpl) { \"`findClas"}
{"code": "ses` as used here should return `JavaClassImpl` results.\" }\n            javaClass.psi\n        } ?: return null\n\n        return provider.getClassLikeSymbolByClassId(classId, javaClass)\n    }\n\n    @FirSymbolProviderInternals\n    override fun getTopLevelCallableSymbolsTo(destination: MutableList<FirCallableSymbol<*>>, packageFqName: FqName, name: Name) {\n    }\n\n    @FirSymbolProviderInternals\n    override fun getTopLevelFunctionSymbolsTo(destination: MutableList<FirNamedFunctionSymbol>, packageFqName: FqName, name: Name) {\n    }\n\n    @FirSymbolProviderInternals\n    override fun getTopLevelPropertySymbolsTo(destination: MutableList<FirPropertySymbol>, packageFqName: FqName, name: Name) {\n    }\n\n    override fun getPackage(fqName: FqName): FqName? = providers.firstNotNullOfOrNull { it.getPackage(fqName) }\n\n    companion object {\n        fun merge(session: FirSession, project: Project, providers: List<LLFirJavaSymbolProvider>): FirSymbolProvider? =\n            if (providers.size > 1) {\n     "}
{"code": "           val combinedScope = GlobalSearchScope.union(providers.map { it.searchScope })\n                val javaClassFinder = project.createJavaClassFinder(combinedScope)\n                LLFirCombinedJavaSymbolProvider(session, project, providers, javaClassFinder)\n            } else providers.singleOrNull()\n    }\n}\n"}
{"code": "interface Node {\n    val parent: Node?\n}\n\nfun test(initial: Node) { \n    var current = initial\n    \n    while (current != null) {\n        <expr>consume(current)</expr>\n        current = current.parent\n    }\n}\n\nfun consume(node: Node) {}"}
{"code": "// FILE: main.kt\n\nfun foo(p: Processor<in CharSequence>, s: String?) {\n    p.process(s)\n}\n\n// FILE: Processor.java\npublic interface Processor<T> {\n    boolean process(T t);\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.backend\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.backend.generators.*\nimport org.jetbrains.kotlin.fir.declarations.FirFile\nimport org.jetbrains.kotlin.fir.resolve.ScopeSession\nimport org.jetbrains.kotlin.fir.signaturer.FirBasedSignatureComposer\nimport org.jetbrains.kotlin.ir.IrLock\nimport org.jetbrains.kotlin.ir.declarations.IrFactory\nimport org.jetbrains.kotlin.ir.linkage.IrProvider\nimport org.jetbrains.kotlin.ir.overrides.IrFakeOverrideBuilder\nimport org.jetbrains.kotlin.ir.util.KotlinMangler\nimport org.jetbrains.kotlin.ir.util.SymbolTable\n\ninterface Fir2IrComponents {\n    val session: FirSession\n    val scopeSession: ScopeSession\n\n    \n    val firProvider: FirProviderWithGeneratedFiles\n\n    val converter: Fir2IrConverter\n\n    val symbolTable: SymbolTable\n    val irBuiltIns: IrBuiltInsOverFir\n    val builtIns: Fir2IrBuiltIns\n    val manglers: Manglers\n\n    val irFactory: IrFactory\n    val irProviders: List<IrProvid"}
{"code": "er>\n    val lock: IrLock\n\n    val classifierStorage: Fir2IrClassifierStorage\n    val declarationStorage: Fir2IrDeclarationStorage\n\n    val typeConverter: Fir2IrTypeConverter\n    val signatureComposer: FirBasedSignatureComposer\n    val visibilityConverter: Fir2IrVisibilityConverter\n\n    val callablesGenerator: Fir2IrCallableDeclarationsGenerator\n    val classifiersGenerator: Fir2IrClassifiersGenerator\n    val lazyDeclarationsGenerator: Fir2IrLazyDeclarationsGenerator\n\n    val annotationGenerator: AnnotationGenerator\n    val callGenerator: CallAndReferenceGenerator\n    @FirBasedFakeOverrideGenerator\n    val fakeOverrideGenerator: FakeOverrideGenerator\n    val delegatedMemberGenerator: DelegatedMemberGenerator\n    val fakeOverrideBuilder: IrFakeOverrideBuilder\n    val symbolsMappingForLazyClasses: Fir2IrSymbolsMappingForLazyClasses\n\n    val extensions: Fir2IrExtensions\n    val configuration: Fir2IrConfiguration\n\n    val annotationsFromPluginRegistrar: Fir2IrIrGeneratedDeclarationsRegistra"}
{"code": "r\n\n    \n    val filesBeingCompiled: Set<FirFile>?\n\n    interface Manglers {\n        val irMangler: KotlinMangler.IrMangler\n        val firMangler: FirMangler\n    }\n}\n"}
{"code": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE_K1\nfun <X> foo(x: X) {}\n"}
{"code": "class SomeClass\n\n@Suppress(\"CONFLICTING_OVERLOADS\")\nfun someFun(): SomeClass {\n    return SomeClass()\n}\n\n@Suppress(\"CONFLICTING_OVERLOADS\")\nfun someFun() {\n}\n"}
{"code": "package one\n\ninterface Interface {\n    fun foo(param: String)\n}\n\nopen class ClassWithParameter(i: Interface)\n\nclass TopLevelClass : ClassWithParameter(object : Interface {\n    override fun fo<caret>o(param: String) {\n    }\n})"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.checkers.generator\n\nimport kotlin.reflect.KClass\nimport kotlin.reflect.full.allSuperclasses\n\nclass CheckersConfiguration(\n    val aliases: Map<KClass<*>, String>,\n    val additionalCheckers: MutableMap<String, String>\n) {\n    val parentsMap: Map<KClass<*>, List<KClass<*>>>\n\n    init {\n        val parents: MutableMap<KClass<*>, List<KClass<*>>> = mutableMapOf()\n        for (firKClass in aliases.keys) {\n            val allParents = mutableListOf<KClass<*>>()\n            bfs(\n                firKClass,\n                childrenExtractor = { it.allSuperclasses }\n            ) {\n                if (it in aliases) {\n                    allParents += it\n                }\n                true\n            }\n            parents[firKClass] = allParents\n        }\n        parentsMap = parents\n    }\n}\n\nprivate fun <T> bfs(start: T, childrenExtractor: (T) -> Collection<T>, process: (T) -> Boolean) {\n    val queue = ArrayDeque<T>()\n    val visited = mutableSetOf<T>()\n"}
{"code": "    val levels = mutableMapOf(start to 0)\n    queue.addLast(start)\n    var levelToStop: Int? = null\n    while (queue.isNotEmpty()) {\n        val element = queue.removeFirst()\n        if (!visited.add(element)) continue\n        val level = levels.getValue(element)\n        if (levelToStop != null && level > levelToStop) continue\n        val shouldContinue = if (level > 0) process(element) else true\n        if (shouldContinue) {\n            val children = childrenExtractor(element)\n            for (child in children) {\n                levels[child] = level + 1\n                queue.addLast(child)\n            }\n        } else {\n            levelToStop = level\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.native.checkers\n\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.KtDiagnosticFactory1\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.declaration.FirFunctionChecker\nimport org.jetbrains.kotlin.fir.analysis.checkers.declaration.PlatformConflictDeclarationsDiagnosticDispatcher\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.native.FirNativeErrors\nimport org.jetbrains.kotlin.fir.backend.native.interop.getObjCMethodInfoFromOverriddenFunctions\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirFunctionSymbol\nimport org.jetbrains.kotlin.name.NativeStandardInter"}
{"code": "opNames.Annotations.objCSignatureOverrideClassId\nimport org.jetbrains.kotlin.utils.SmartSet\n\nprivate fun FirFunctionSymbol<*>.isInheritedFromObjc(context: CheckerContext): Boolean {\n    return getObjCMethodInfoFromOverriddenFunctions(context.session, context.scopeSession) != null\n}\n\n\nprivate fun FirFunctionSymbol<*>.hasDifferentParameterNames(other: FirFunctionSymbol<*>) : Boolean {\n    return valueParameterSymbols.drop(1).map { it.name } != other.valueParameterSymbols.drop(1).map { it.name }\n}\n\nobject NativeConflictDeclarationsDiagnosticDispatcher : PlatformConflictDeclarationsDiagnosticDispatcher {\n    override fun getDiagnostic(\n        conflictingDeclaration: FirBasedSymbol<*>,\n        symbols: SmartSet<FirBasedSymbol<*>>,\n        context: CheckerContext\n    ): KtDiagnosticFactory1<Collection<FirBasedSymbol<*>>>? {\n        if (context.languageVersionSettings.supportsFeature(LanguageFeature.ObjCSignatureOverrideAnnotation)) {\n            if (conflictingDeclaration is FirFunctionSymb"}
{"code": "ol<*> && symbols.all { it is FirFunctionSymbol<*> }) {\n                if (conflictingDeclaration.isInheritedFromObjc(context) && symbols.all { (it as FirFunctionSymbol<*>).isInheritedFromObjc(context) }) {\n                    if (symbols.all { (it as FirFunctionSymbol<*>).hasDifferentParameterNames(conflictingDeclaration) }) {\n                        if (conflictingDeclaration.hasAnnotation(objCSignatureOverrideClassId, context.session)) {\n                            return null\n                        } else {\n                            return FirNativeErrors.CONFLICTING_OBJC_OVERLOADS\n                        }\n                    }\n                }\n            }\n        }\n        return PlatformConflictDeclarationsDiagnosticDispatcher.DEFAULT.getDiagnostic(conflictingDeclaration, symbols, context)\n    }\n}\n\nobject FirNativeObjcOverrideApplicabilityChecker : FirFunctionChecker(MppCheckerKind.Platform) {\n    override fun check(\n        declaration: FirFunction,\n        context: Check"}
{"code": "erContext,\n        reporter: DiagnosticReporter,\n    ) {\n        if (declaration.hasAnnotation(objCSignatureOverrideClassId, context.session)) {\n            if (!declaration.symbol.isInheritedFromObjc(context)) {\n                reporter.reportOn(declaration.getAnnotationByClassId(objCSignatureOverrideClassId, context.session)?.source, FirNativeErrors.INAPPLICABLE_OBJC_OVERRIDE, context)\n            }\n        }\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.backend.jvm\n\nimport org.jetbrains.kotlin.backend.common.serialization.signature.PublicIdSignatureComputer\nimport org.jetbrains.kotlin.backend.jvm.*\nimport org.jetbrains.kotlin.backend.jvm.overrides.IrJavaIncompatibilityRulesOverridabilityCondition\nimport org.jetbrains.kotlin.config.CompilerConfiguration\nimport org.jetbrains.kotlin.config.JVMConfigurationKeys\nimport org.jetbrains.kotlin.config.JvmSerializeIrMode\nimport org.jetbrains.kotlin.config.languageVersionSettings\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.backend.Fir2IrComponents\nimport org.jetbrains.kotlin.fir.backend.Fir2IrConversionScope\nimport org.jetbrains.kotlin.fir.backend.Fir2IrExtensions\nimport org.jetbrains.kotlin.fir.backend.InjectedValue\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.references.FirReference\nimport org.jetbrains.kotlin.ir.IrBuiltIns\nimport org.jetbrains.kotlin.ir.declarations.*\nimport org.jetbrains.kotlin"}
{"code": ".ir.declarations.impl.IrExternalPackageFragmentImpl\nimport org.jetbrains.kotlin.ir.declarations.impl.IrFactoryImpl\nimport org.jetbrains.kotlin.ir.overrides.IrExternalOverridabilityCondition\nimport org.jetbrains.kotlin.ir.symbols.impl.DescriptorlessExternalPackageFragmentSymbol\nimport org.jetbrains.kotlin.ir.util.*\nimport org.jetbrains.kotlin.load.java.JvmAnnotationNames\nimport org.jetbrains.kotlin.load.kotlin.FacadeClassSource\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.StandardClassIds\nimport org.jetbrains.kotlin.resolve.jvm.JvmClassName\n\nclass JvmFir2IrExtensions(\n    configuration: CompilerConfiguration,\n    private val irDeserializer: JvmIrDeserializer,\n    private val mangler: KotlinMangler.IrMangler,\n) : Fir2IrExtensions, JvmGeneratorExtensions {\n    override val parametersAreAssignable: Boolean get() = true\n    override val externalOverridabilityConditions: List<IrExternalOverridabilityCondition>\n        get() = listOf(IrJavaIncompatibilityRulesOverr"}
{"code": "idabilityCondition())\n\n    override val classNameOverride: MutableMap<IrClass, JvmClassName> = mutableMapOf()\n    override val cachedFields = CachedFieldsForObjectInstances(IrFactoryImpl, configuration.languageVersionSettings)\n\n    private val kotlinIrInternalPackage =\n        IrExternalPackageFragmentImpl(DescriptorlessExternalPackageFragmentSymbol(), IrBuiltIns.KOTLIN_INTERNAL_IR_FQN)\n\n    private val kotlinJvmInternalPackage =\n        IrExternalPackageFragmentImpl(DescriptorlessExternalPackageFragmentSymbol(), JvmAnnotationNames.KOTLIN_JVM_INTERNAL)\n\n    private val specialAnnotationConstructors = mutableListOf<IrConstructor>()\n\n    private val rawTypeAnnotationClass =\n        createSpecialAnnotationClass(JvmSymbols.RAW_TYPE_ANNOTATION_FQ_NAME, kotlinIrInternalPackage)\n\n    override val rawTypeAnnotationConstructor: IrConstructor =\n        rawTypeAnnotationClass.constructors.single()\n\n    init {\n        createSpecialAnnotationClass(JvmAnnotationNames.ENHANCED_NULLABILITY_ANNOTATION,"}
{"code": " kotlinJvmInternalPackage)\n        createSpecialAnnotationClass(JvmSymbols.FLEXIBLE_NULLABILITY_ANNOTATION_FQ_NAME, kotlinIrInternalPackage)\n        createSpecialAnnotationClass(JvmSymbols.FLEXIBLE_MUTABILITY_ANNOTATION_FQ_NAME, kotlinIrInternalPackage)\n    }\n\n    private fun createSpecialAnnotationClass(fqn: FqName, parent: IrPackageFragment) =\n        IrFactoryImpl.createSpecialAnnotationClass(fqn, parent).apply {\n            specialAnnotationConstructors.add(constructors.single())\n        }\n\n    override fun registerDeclarations(symbolTable: SymbolTable) {\n        val signatureComputer = PublicIdSignatureComputer(mangler)\n        specialAnnotationConstructors.forEach { constructor ->\n            symbolTable.declareConstructorWithSignature(signatureComputer.composePublicIdSignature(constructor, false), constructor.symbol)\n        }\n    }\n\n    override fun findInjectedValue(calleeReference: FirReference, conversionScope: Fir2IrConversionScope): InjectedValue? {\n        return null\n   "}
{"code": " }\n\n    override val irNeedsDeserialization: Boolean =\n        configuration.get(JVMConfigurationKeys.SERIALIZE_IR, JvmSerializeIrMode.NONE) != JvmSerializeIrMode.NONE\n\n    override fun generateOrGetFacadeClass(declaration: IrMemberWithContainerSource, components: Fir2IrComponents): IrClass? {\n        val deserializedSource = declaration.containerSource ?: return null\n        if (deserializedSource !is FacadeClassSource) return null\n        val facadeName = deserializedSource.facadeClassName ?: deserializedSource.className\n        return JvmFileFacadeClass(\n            if (deserializedSource.facadeClassName != null) IrDeclarationOrigin.JVM_MULTIFILE_CLASS else IrDeclarationOrigin.FILE_CLASS,\n            facadeName.fqNameForTopLevelClassMaybeWithDollars.shortName(),\n            deserializedSource,\n            deserializeIr = { irClass -> deserializeToplevelClass(irClass, components) }\n        ).also {\n            it.createParameterDeclarations()\n            classNameOverride[it] = facad"}
{"code": "eName\n        }\n    }\n\n    override fun deserializeToplevelClass(irClass: IrClass, components: Fir2IrComponents): Boolean =\n        irDeserializer.deserializeTopLevelClass(\n            irClass, components.irBuiltIns, components.symbolTable, components.irProviders, this\n        )\n\n    override fun hasBackingField(property: FirProperty, session: FirSession): Boolean =\n        property.origin is FirDeclarationOrigin.Java || Fir2IrExtensions.Default.hasBackingField(property, session)\n\n    override fun isTrueStatic(declaration: FirCallableDeclaration, session: FirSession): Boolean =\n        declaration.hasAnnotation(StandardClassIds.Annotations.jvmStatic, session) ||\n                (declaration as? FirPropertyAccessor)?.propertySymbol?.fir?.hasAnnotation(StandardClassIds.Annotations.jvmStatic, session) == true\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.asJava\n\nimport com.intellij.lang.jvm.JvmModifier\nimport com.intellij.psi.*\nimport com.intellij.psi.search.GlobalSearchScope\nimport org.jetbrains.kotlin.analysis.project.structure.KtSourceModule\nimport org.jetbrains.kotlin.asJava.classes.KtFakeLightClass\nimport org.jetbrains.kotlin.asJava.classes.KtLightClass\nimport org.jetbrains.kotlin.asJava.elements.*\nimport org.jetbrains.kotlin.builtins.jvm.JavaToKotlinClassMap\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.load.java.JvmAbi\nimport org.jetbrains.kotlin.load.java.propertyNameByGetMethodName\nimport org.jetbrains.kotlin.load.java.propertyNameBySetMethodName\nimport org.jetbrains.kotlin.load.java.propertyNamesBySetMethodName\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.name.NameUtils\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.psi.psiUtil.*\n\n\nfun KtClassOrObject.toLightClass(): KtLightClass? = KotlinAsJavaS"}
{"code": "upport.getInstance(project).getLightClass(this)\n\nfun KtClassOrObject.toLightClassWithBuiltinMapping(): PsiClass? {\n    toLightClass()?.let { return it }\n\n    val fqName = fqName ?: return null\n    val javaClassFqName = JavaToKotlinClassMap.mapKotlinToJava(fqName.toUnsafe())?.asSingleFqName() ?: return null\n    val searchScope = useScope as? GlobalSearchScope ?: return null\n    return JavaPsiFacade.getInstance(project).findClass(javaClassFqName.asString(), searchScope)\n}\n\nfun KtClassOrObject.toFakeLightClass(): KtFakeLightClass = KotlinAsJavaSupport.getInstance(project).getFakeLightClass(this)\n\nfun KtFile.findFacadeClass(): KtLightClass? = KotlinAsJavaSupport.getInstance(project).getLightFacade(this)\n\nfun KtScript.toLightClass(): KtLightClass? = KotlinAsJavaSupport.getInstance(project).getLightClassForScript(this)\n\nfun KtElement.toLightElements(): List<PsiNamedElement> = when (this) {\n    is KtClassOrObject -> listOfNotNull(toLightClass())\n    is KtNamedFunction,\n    is KtConstructor<*>"}
{"code": " -> LightClassUtil.getLightClassMethods(this as KtFunction)\n    is KtProperty -> LightClassUtil.getLightClassPropertyMethods(this).allDeclarations\n    is KtPropertyAccessor -> listOfNotNull(LightClassUtil.getLightClassAccessorMethod(this))\n    is KtParameter -> mutableListOf<PsiNamedElement>().also { elements ->\n        toPsiParameters().toCollection(elements)\n        LightClassUtil.getLightClassPropertyMethods(this).toCollection(elements)\n        toAnnotationLightMethod()?.let(elements::add)\n    }\n\n    is KtTypeParameter -> toPsiTypeParameters()\n    is KtFile -> listOfNotNull(findFacadeClass())\n    else -> listOf()\n}\n\nfun PsiElement.toLightMethods(): List<PsiMethod> = when (this) {\n    is KtFunction -> LightClassUtil.getLightClassMethods(this)\n    is KtProperty -> LightClassUtil.getLightClassPropertyMethods(this).toList()\n    is KtParameter -> LightClassUtil.getLightClassPropertyMethods(this).toList()\n    is KtPropertyAccessor -> LightClassUtil.getLightClassAccessorMethods(this)\n    i"}
{"code": "s KtClass -> listOfNotNull(toLightClass()?.constructors?.firstOrNull())\n    is PsiMethod -> listOf(this)\n    else -> listOf()\n}\n\nfun PsiElement.getRepresentativeLightMethod(): PsiMethod? = when (this) {\n    is KtFunction -> LightClassUtil.getLightClassMethod(this)\n    is KtProperty -> LightClassUtil.getLightClassPropertyMethods(this).getter\n    is KtParameter -> LightClassUtil.getLightClassPropertyMethods(this).getter\n    is KtPropertyAccessor -> LightClassUtil.getLightClassAccessorMethod(this)\n    is PsiMethod -> this\n    else -> null\n}\n\nfun KtParameter.toPsiParameters(): Collection<PsiParameter> {\n    val paramList = getNonStrictParentOfType<KtParameterList>() ?: return emptyList()\n\n    val paramIndex = paramList.parameters.indexOf(this)\n    if (paramIndex < 0) return emptyList()\n    val owner = paramList.parent\n    val lightParamIndex = if (owner is KtDeclaration && owner.isExtensionDeclaration()) paramIndex + 1 else paramIndex\n\n    val methods: Collection<PsiMethod> = when (owner) "}
{"code": "{\n        is KtFunction -> LightClassUtil.getLightClassMethods(owner)\n        is KtPropertyAccessor -> LightClassUtil.getLightClassAccessorMethods(owner)\n        else -> null\n    } ?: return emptyList()\n\n    return methods.mapNotNull { it.parameterList.parameters.getOrNull(lightParamIndex) }\n}\n\nprivate fun KtParameter.toAnnotationLightMethod(): PsiMethod? {\n    val parent = ownerFunction as? KtPrimaryConstructor ?: return null\n    val containingClass = parent.getContainingClassOrObject()\n    if (!containingClass.isAnnotation()) return null\n\n    return LightClassUtil.getLightClassMethod(this)\n}\n\nfun KtParameter.toLightGetter(): PsiMethod? = LightClassUtil.getLightClassPropertyMethods(this).getter\n\nfun KtParameter.toLightSetter(): PsiMethod? = LightClassUtil.getLightClassPropertyMethods(this).setter\n\nfun KtTypeParameter.toPsiTypeParameters(): List<PsiTypeParameter> {\n    val paramList = getNonStrictParentOfType<KtTypeParameterList>() ?: return listOf()\n\n    val paramIndex = paramList.par"}
{"code": "ameters.indexOf(this)\n    val ktDeclaration = paramList.getNonStrictParentOfType<KtDeclaration>() ?: return listOf()\n    val lightOwners = ktDeclaration.toLightElements()\n\n    return lightOwners.mapNotNull { lightOwner ->\n        (lightOwner as? PsiTypeParameterListOwner)?.typeParameters?.getOrNull(paramIndex)\n    }\n}\n\n// Returns original declaration if given PsiElement is a Kotlin light element, and element itself otherwise\nval PsiElement.unwrapped: PsiElement?\n    get() = when (this) {\n        is PsiElementWithOrigin<*> -> origin\n        is KtLightElement<*, *> -> kotlinOrigin\n        is KtLightElementBase -> kotlinOrigin\n        else -> this\n    }\n\nval PsiElement.namedUnwrappedElement: PsiNamedElement?\n    get() = unwrapped?.getNonStrictParentOfType()\n\n\nval KtClassOrObject.hasInterfaceDefaultImpls: Boolean\n    get() = this is KtClass && isInterface() && hasNonAbstractMembers(this)\n\nval KtClassOrObject.hasRepeatableAnnotationContainer: Boolean\n    get() = this is KtClass &&\n         "}
{"code": "   isAnnotation() &&\n            run {\n                var hasRepeatableAnnotation = false\n                for (annotation in annotationEntries) when (annotation.shortName?.asString()) {\n                    \"JvmRepeatable\" -> return false\n                    \"Repeatable\" -> {\n                        if (annotation.valueArgumentList != null) return false\n                        hasRepeatableAnnotation = true\n                    }\n                }\n\n                return hasRepeatableAnnotation\n            }\n\nprivate fun hasNonAbstractMembers(ktInterface: KtClass): Boolean = ktInterface.declarations.any(::isNonAbstractMember)\n\nprivate fun isNonAbstractMember(member: KtDeclaration?): Boolean =\n    (member is KtNamedFunction && member.hasBody()) ||\n            (member is KtProperty && (member.hasDelegateExpressionOrInitializer() || member.getter?.hasBody() ?: false || member.setter?.hasBody() ?: false))\n\nprivate val DEFAULT_IMPLS_CLASS_NAME = Name.identifier(JvmAbi.DEFAULT_IMPLS_CLASS_NAM"}
{"code": "E)\nfun FqName.defaultImplsChild() = child(DEFAULT_IMPLS_CLASS_NAME)\n\nprivate val REPEATABLE_ANNOTATION_CONTAINER_NAME = Name.identifier(JvmAbi.REPEATABLE_ANNOTATION_CONTAINER_NAME)\nfun FqName.repeatableAnnotationContainerChild() = child(REPEATABLE_ANNOTATION_CONTAINER_NAME)\n\n@Suppress(\"unused\")\nfun KtElement.toLightAnnotation(): PsiAnnotation? {\n    val ktDeclaration = getStrictParentOfType<KtModifierList>()?.parent as? KtDeclaration ?: return null\n    for (lightElement in ktDeclaration.toLightElements()) {\n        if (lightElement !is PsiModifierListOwner) continue\n        for (rootAnnotation in lightElement.modifierList?.annotations ?: continue) {\n            for (annotation in rootAnnotation.withNestedAnnotations()) {\n                if (annotation is KtLightElement<*, *> && annotation.kotlinOrigin == this)\n                    return annotation\n            }\n        }\n    }\n    return null\n}\n\nprivate fun PsiAnnotation.withNestedAnnotations(): Sequence<PsiAnnotation> {\n    fun handle"}
{"code": "Value(memberValue: PsiAnnotationMemberValue?): Sequence<PsiAnnotation> = when (memberValue) {\n        is PsiArrayInitializerMemberValue -> memberValue.initializers.asSequence().flatMap { handleValue(it) }\n        is PsiAnnotation -> memberValue.withNestedAnnotations()\n        else -> emptySequence()\n    }\n\n    return sequenceOf(this) + parameterList.attributes.asSequence().flatMap { handleValue(it.value) }\n}\n\nfun demangleInternalName(name: String): String? {\n    val indexOfDollar = name.indexOf('$')\n    return if (indexOfDollar >= 0) name.substring(0, indexOfDollar) else null\n}\n\nfun mangleInternalName(name: String, module: KtSourceModule): String {\n    val moduleName = (module.stableModuleName ?: module.moduleName).removeSurrounding(\"<\", \">\")\n    return name + \"$\" + NameUtils.sanitizeAsJavaIdentifier(moduleName)\n}\n\nfun KtLightMethod.checkIsMangled(): Boolean {\n    val demangledName = demangleInternalName(name) ?: return false\n    val originalName = propertyNameByAccessor(demangledName,"}
{"code": " this) ?: demangledName\n    return originalName == kotlinOrigin?.name\n}\n\nfun propertyNameByAccessor(name: String, accessor: KtLightMethod): String? {\n    val toRename = accessor.kotlinOrigin ?: return null\n    if (toRename !is KtProperty && toRename !is KtParameter) return null\n\n    val methodName = Name.guessByFirstCharacter(name)\n    val propertyName = toRename.name ?: \"\"\n    return when {\n        JvmAbi.isGetterName(name) -> propertyNameByGetMethodName(methodName)\n        JvmAbi.isSetterName(name) -> propertyNameBySetMethodName(methodName, propertyName.startsWith(\"is\"))\n        else -> methodName\n    }?.asString()\n}\n\nfun accessorNameByPropertyName(name: String, accessor: KtLightMethod): String? = accessor.name.let { methodName ->\n    when {\n        JvmAbi.isGetterName(methodName) -> JvmAbi.getterName(name)\n        JvmAbi.isSetterName(methodName) -> JvmAbi.setterName(name)\n        else -> null\n    }\n}\n\nfun getAccessorNamesCandidatesByPropertyName(name: String): List<String> {\n    ret"}
{"code": "urn listOf(JvmAbi.setterName(name), JvmAbi.getterName(name))\n}\n\nfun fastCheckIsNullabilityApplied(lightElement: KtLightElement<*, PsiModifierListOwner>): Boolean {\n    val elementIsApplicable = lightElement is KtLightMember<*> || lightElement is LightParameter\n    if (!elementIsApplicable) return false\n\n    val annotatedElement = lightElement.kotlinOrigin ?: return true\n\n    // all data-class generated members are not-null\n    if (annotatedElement is KtClass && annotatedElement.isData()) return true\n\n    // backing fields for lateinit props are skipped\n    if (lightElement is KtLightField && annotatedElement is KtProperty && annotatedElement.hasModifier(KtTokens.LATEINIT_KEYWORD)) return false\n\n    if (lightElement is KtLightMethod && (annotatedElement as? KtModifierListOwner)?.isPrivate() == true) {\n        return false\n    }\n\n    if (annotatedElement is KtParameter) {\n        val containingClassOrObject = annotatedElement.containingClassOrObject\n        if (containingClassOrObject?.i"}
{"code": "sAnnotation() == true) return false\n        if ((containingClassOrObject as? KtClass)?.isEnum() == true) {\n            if (annotatedElement.parent.parent is KtPrimaryConstructor) return false\n        }\n\n        when (val parent = annotatedElement.parent.parent) {\n            is KtConstructor<*> -> if (lightElement is KtLightParameter && parent.isPrivate()) return false\n            is KtNamedFunction -> return !parent.isPrivate()\n            is KtPropertyAccessor -> return (parent.parent as? KtProperty)?.isPrivate() != true\n        }\n    }\n\n    return true\n}\n\nprivate val PsiMethod.canBeGetter: Boolean\n    get() = JvmAbi.isGetterName(name) && parameters.isEmpty() && returnTypeElement?.textMatches(\"void\") != true\n\nprivate val PsiMethod.canBeSetter: Boolean\n    get() = JvmAbi.isSetterName(name) && parameters.size == 1 && returnTypeElement?.textMatches(\"void\") != false\n\nprivate val PsiMethod.probablyCanHaveSyntheticAccessors: Boolean\n    get() = probablyCanHaveSyntheticAccessors()\n\nprivate "}
{"code": "fun PsiMethod.probablyCanHaveSyntheticAccessors(withoutOverrideCheck: Boolean = false): Boolean {\n    return (withoutOverrideCheck || canHaveOverride) && !hasTypeParameters() && !isFinalProperty\n}\n\nprivate val PsiMethod.getterName: Name? get() = propertyNameByGetMethodName(Name.identifier(name))\nprivate val PsiMethod.setterNames: Collection<Name>? get() = propertyNamesBySetMethodName(Name.identifier(name)).takeIf { it.isNotEmpty() }\n\nprivate val PsiMethod.isFinalProperty: Boolean\n    get() {\n        val property = unwrapped as? KtProperty ?: return false\n        if (property.hasModifier(KtTokens.OVERRIDE_KEYWORD)) return false\n        val containingClassOrObject = property.containingClassOrObject ?: return true\n        return containingClassOrObject is KtObjectDeclaration\n    }\n\nprivate val PsiMethod.isTopLevelDeclaration: Boolean get() = unwrapped?.isTopLevelKtOrJavaMember() == true\n\nval PsiMethod.syntheticAccessors: Collection<Name> get() = syntheticAccessors()\n\nfun PsiMethod.synthet"}
{"code": "icAccessors(withoutOverrideCheck: Boolean = false): Collection<Name> {\n    if (!probablyCanHaveSyntheticAccessors(withoutOverrideCheck)) return emptyList()\n\n    return when {\n        canBeGetter -> listOfNotNull(getterName)\n        canBeSetter -> setterNames.orEmpty()\n        else -> emptyList()\n    }\n}\n\nval PsiMethod.canHaveSyntheticAccessors: Boolean get() = probablyCanHaveSyntheticAccessors && (canBeGetter || canBeSetter)\n\nval PsiMethod.canHaveSyntheticGetter: Boolean get() = probablyCanHaveSyntheticAccessors && canBeGetter\n\nval PsiMethod.canHaveSyntheticSetter: Boolean get() = probablyCanHaveSyntheticAccessors && canBeSetter\n\nval PsiMethod.syntheticGetter: Name? get() = if (canHaveSyntheticGetter) getterName else null\n\nval PsiMethod.syntheticSetters: Collection<Name>? get() = if (canHaveSyntheticSetter) setterNames else null\n\n\nval PsiMethod.canHaveOverride: Boolean get() = !hasModifier(JvmModifier.STATIC) && !isConstructor && !isTopLevelDeclaration\n"}
{"code": "// ISSUE: KT-64501\nimport kotlin.contracts.*\n\n@OptIn(ExperimentalContracts::class)\ninline fun myRun(f: () -> Unit) {\n    contract { callsInPlace(f, InvocationKind.EXACTLY_ONCE) }\n    f()\n}\n\n@OptIn(ExperimentalContracts::class)\ninline fun test_1(g: () -> Unit) {\n    contract { callsInPlace(g, InvocationKind.EXACTLY_ONCE) }\n    myRun(f = g)\n}\n\n@OptIn(ExperimentalContracts::class)\ninline fun test_2(g: () -> Unit) {\n    contract { callsInPlace(g, InvocationKind.EXACTLY_ONCE) }\n    myRun(g)\n}\n"}
{"code": "// COMPILATION_ERRORS\nannotation class Ann0\ninterface I\nclass Foo {\n    fun foo() {\n        val i = object : I {\n            @<caret>Ann0 @Suppress\n        }\n    }\n}"}
{"code": "// WITH_STDLIB\n\nval list1: List<Int> = listOf(1)\nval list = list1.<!USELESS_CALL_ON_NOT_NULL!>orEmpty()<!>"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.declarations\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.descriptors.ClassKind\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.FirModuleData\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.references.FirControlFlowGraphReference\nimport org.jetbrains.kotlin.fir.scopes.FirScopeProvider\nimport org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.name.Name\n\n\nabstract class FirRegularClass : FirClass() {\n    abstract override val source: KtSourceElement?\n    abstract override val moduleData: FirModuleData\n    abstract override val origin: FirDeclaration"}
{"code": "Origin\n    abstract override val attributes: FirDeclarationAttributes\n    abstract override val typeParameters: List<FirTypeParameterRef>\n    abstract override val status: FirDeclarationStatus\n    abstract override val deprecationsProvider: DeprecationsProvider\n    abstract override val controlFlowGraphReference: FirControlFlowGraphReference?\n    abstract override val classKind: ClassKind\n    abstract override val declarations: List<FirDeclaration>\n    abstract override val annotations: List<FirAnnotation>\n    abstract override val scopeProvider: FirScopeProvider\n    abstract val name: Name\n    abstract override val symbol: FirRegularClassSymbol\n    abstract val hasLazyNestedClassifiers: Boolean\n    abstract val companionObjectSymbol: FirRegularClassSymbol?\n    abstract override val superTypeRefs: List<FirTypeRef>\n    abstract val contextReceivers: List<FirContextReceiver>\n\n    override fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitRegularClass(this, d"}
{"code": "ata)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transformer.transformRegularClass(this, data) as E\n\n    abstract override fun replaceStatus(newStatus: FirDeclarationStatus)\n\n    abstract override fun replaceDeprecationsProvider(newDeprecationsProvider: DeprecationsProvider)\n\n    abstract override fun replaceControlFlowGraphReference(newControlFlowGraphReference: FirControlFlowGraphReference?)\n\n    abstract override fun replaceAnnotations(newAnnotations: List<FirAnnotation>)\n\n    abstract fun replaceCompanionObjectSymbol(newCompanionObjectSymbol: FirRegularClassSymbol?)\n\n    abstract override fun replaceSuperTypeRefs(newSuperTypeRefs: List<FirTypeRef>)\n\n    abstract override fun <D> transformTypeParameters(transformer: FirTransformer<D>, data: D): FirRegularClass\n\n    abstract override fun <D> transformStatus(transformer: FirTransformer<D>, data: D): FirRegularClass\n\n    abstract override fun <D> "}
{"code": "transformDeclarations(transformer: FirTransformer<D>, data: D): FirRegularClass\n\n    abstract override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirRegularClass\n\n    abstract override fun <D> transformSuperTypeRefs(transformer: FirTransformer<D>, data: D): FirRegularClass\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.annotations\n\n\ninternal interface ReferenceInformationProvider {\n    \n    val referenceName: String?\n}\n\n\ninternal class ReferenceInformationHolder(override val referenceName: String?) : ReferenceInformationProvider"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.jvm.checkers\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.config.JvmTarget\nimport org.jetbrains.kotlin.descriptors.CallableMemberDescriptor\nimport org.jetbrains.kotlin.descriptors.ClassOrPackageFragmentDescriptor\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.descriptors.PropertyDescriptor\nimport org.jetbrains.kotlin.load.kotlin.FileBasedKotlinClass\nimport org.jetbrains.kotlin.load.kotlin.KotlinJvmBinaryPackageSourceElement\nimport org.jetbrains.kotlin.load.kotlin.KotlinJvmBinarySourceElement\nimport org.jetbrains.kotlin.resolve.DescriptorUtils\nimport org.jetbrains.kotlin.resolve.calls.checkers.CallChecker\nimport org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\nimport org.jetbrains.kotlin.resolve.inline.InlineUtil\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm\nimport org.jetbrains.kotlin.serializatio"}
{"code": "n.deserialization.descriptors.DeserializedCallableMemberDescriptor\n\nclass InlinePlatformCompatibilityChecker(val jvmTarget: JvmTarget) : CallChecker {\n    override fun check(resolvedCall: ResolvedCall<*>, reportOn: PsiElement, context: CallCheckerContext) {\n        val resultingDescriptor = resolvedCall.resultingDescriptor as? CallableMemberDescriptor ?: return\n        // TODO (KT-60971): distinguish the case when one property accessor is inline and the other isn't.\n        if (!InlineUtil.isInline(resultingDescriptor) &&\n            (resultingDescriptor !is PropertyDescriptor || !InlineUtil.isInline(resultingDescriptor.getter))\n        ) {\n            return\n        }\n\n        val propertyOrFun = DescriptorUtils.getDirectMember(resultingDescriptor)\n\n        val inliningBytecodeVersion = getBytecodeVersionIfDeserializedDescriptor(propertyOrFun) ?: return\n\n        if (jvmTarget.majorVersion < inliningBytecodeVersion) {\n            context.trace.report(\n                ErrorsJvm.INLINE_F"}
{"code": "ROM_HIGHER_PLATFORM.on(\n                    reportOn,\n                    JvmTarget.getDescription(inliningBytecodeVersion),\n                    JvmTarget.getDescription(jvmTarget.majorVersion)\n                )\n            )\n        }\n    }\n\n    companion object {\n        private fun getBytecodeVersionIfDeserializedDescriptor(funOrProperty: DeclarationDescriptor): Int? {\n            if (funOrProperty !is DeserializedCallableMemberDescriptor) return null\n\n            val containingDeclaration =\n                funOrProperty.getConcreteDeclarationForInline().containingDeclaration as ClassOrPackageFragmentDescriptor\n\n            val source = containingDeclaration.source\n            val binaryClass =\n                when (source) {\n                    is KotlinJvmBinarySourceElement -> source.binaryClass\n                    is KotlinJvmBinaryPackageSourceElement -> source.getContainingBinaryClass(funOrProperty)\n                    else -> null\n                } as? FileBasedKotlinClass ?:"}
{"code": " return null\n\n            return binaryClass.classVersion\n        }\n\n        private fun CallableMemberDescriptor.getConcreteDeclarationForInline(): CallableMemberDescriptor {\n            if (!this.kind.isReal) {\n                val superImplementation = overriddenDescriptors.firstOrNull {\n                    val containingDeclaration = it.containingDeclaration\n                    !DescriptorUtils.isInterface(containingDeclaration) && !DescriptorUtils.isAnnotationClass(containingDeclaration)\n                }\n                if (superImplementation != null) {\n                    return superImplementation.getConcreteDeclarationForInline()\n                }\n            }\n            return this\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.expressions\n\nimport org.jetbrains.kotlin.diagnostics.WhenMissingCase\n\nsealed class ExhaustivenessStatus {\n\n    \n    object ProperlyExhaustive : ExhaustivenessStatus()\n\n    \n    object ExhaustiveAsNothing : ExhaustivenessStatus()\n\n    class NotExhaustive(val reasons: List<WhenMissingCase>) : ExhaustivenessStatus() {\n        companion object {\n            val NO_ELSE_BRANCH = NotExhaustive(listOf(WhenMissingCase.Unknown))\n        }\n    }\n}\n\n\nval FirWhenExpression.isExhaustive: Boolean\n    get() = exhaustivenessStatus == ExhaustivenessStatus.ProperlyExhaustive || exhaustivenessStatus == ExhaustivenessStatus.ExhaustiveAsNothing\n\nval FirWhenExpression.isProperlyExhaustive: Boolean\n    get() = exhaustivenessStatus == ExhaustivenessStatus.ProperlyExhaustive"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental.classpathDiff\n\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.test.KotlinTestUtils\nimport org.junit.Rule\nimport org.junit.Test\nimport org.junit.rules.TemporaryFolder\nimport java.io.File\nimport kotlin.test.assertEquals\n\nclass BasicClassInfoTest {\n\n    @get:Rule\n    val tmpDir = TemporaryFolder()\n\n    @Test\n    fun `compute BasicClassInfo`() {\n        val compiledClasses = compileJava(className, sourceCode)\n        val classIds = compiledClasses.map { BasicClassInfo.compute(it).classId }\n\n        assertEquals(\n            listOf(\n                classId(\"com.example\", \"TopLevelClass\", local = false),\n                classId(\"com.example\", \"TopLevelClass$1\", local = true),\n                classId(\"com.example\", \"TopLevelClass$1LocalClass\", local = true),\n                classId(\"com.example\", \"TopLevelClass$1LocalClass$1LocalClassWithinLocalClass\", local = true),\n                classI"}
{"code": "d(\"com.example\", \"TopLevelClass$1LocalClass.InnerClassWithinLocalClass\", local = true),\n                classId(\"com.example\", \"TopLevelClass$2\", local = true),\n                classId(\"com.example\", \"TopLevelClass.InnerClass\", local = false),\n                classId(\"com.example\", \"TopLevelClass\\$InnerClass\\$1LocalClassWithinInnerClass\", local = true),\n                classId(\"com.example\", \"TopLevelClass.InnerClass.InnerClassWithinInnerClass\", local = false),\n                classId(\"com.example\", \"TopLevelClass.InnerClassWith\\$Sign\", local = false),\n                classId(\"com.example\", \"TopLevelClass.InnerClassWith\\$Sign.InnerClassWith\\$SignLevel2\", local = false),\n                classId(\"com.example\", \"TopLevelClass.StaticNestedClass\", local = false)\n            ),\n            classIds\n        )\n    }\n\n    @Suppress(\"SameParameterValue\")\n    private fun compileJava(className: String, sourceCode: String): List<ByteArray> {\n        val sourceFile = File(tmpDir.newFolder(), \"$class"}
{"code": "Name.java\").apply {\n            parentFile.mkdirs()\n            writeText(sourceCode)\n        }\n        val classesDir = tmpDir.newFolder()\n\n        KotlinTestUtils.compileJavaFiles(listOf(sourceFile), listOf(\"-d\", classesDir.path))\n\n        return classesDir.walk().toList()\n            .filter { it.isFile }\n            .sortedBy { it.path.substringBefore(\".class\") }\n            .map { it.readBytes() }\n    }\n\n    private fun classId(@Suppress(\"SameParameterValue\") packageFqName: String, relativeClassName: String, local: Boolean) =\n        ClassId(FqName(packageFqName), FqName(relativeClassName), isLocal = local)\n}\n\nprivate const val className = \"com/example/TopLevelClass\"\nprivate val sourceCode = \"\"\"\npackage com.example;\n\npublic class TopLevelClass {\n\n    public class InnerClass {\n        public class InnerClassWithinInnerClass {\n        }\n        public void someMethod() {\n            class LocalClassWithinInnerClass {\n            }\n        }\n    }\n\n    public static class StaticNeste"}
{"code": "dClass {\n    }\n\n    public void methodWithinTopLevelClass() {\n        class LocalClass {\n            class InnerClassWithinLocalClass {\n            }\n            public void methodWithinLocalClass() {\n                class LocalClassWithinLocalClass {\n                }\n            }\n        }\n        Runnable anonymousLocalClassInstance = new Runnable() {\n            @Override\n            public void run() {\n            }\n        };\n    }\n\n    private Runnable anonymousNonLocalClassInstance = new Runnable() {\n        @Override\n        public void run() {\n        }\n    };\n\n    public class InnerClassWith${'$'}Sign {\n        public class InnerClassWith${'$'}SignLevel2 {\n        }\n    }\n}\n\"\"\".trimIndent()\n"}
{"code": "package jvmTest\n\nimport common.greetEachOther\nimport some.example.Person\n\nprivate class MyPerson(\n    name: String\n) : Person(name) {\n    override fun greet() = \"Hi\"\n}\n\nfun test() {\n    greetEachOther(\n        listOf(\n            Person(\"Alice\"),\n            MyPerson(\"Bob\"),\n        )\n    )\n}"}
{"code": "class SomeClass() {}\n\nfun someFun() {\n    when {\n        is <caret>SomeClass\n    }\n}\n"}
{"code": "fun test() {\n\n    <expr>four@4</expr>\n\n}"}
{"code": "operator fun Int.invoke() : Long = 1L\noperator fun Long.invoke() : Double = 1.0\noperator fun Double.invoke() {}\nfun test(i: Int) {\n    <expr>i()()()</expr>\n}"}
{"code": "import java.util.AbstractSet\n\nclass SmartSet<T> : AbstractSet<T>() {\n    override var size: Int = 0\n    override fun iterator(): MutableIterator<T> = TODO()\n    override fun add(element: T): Boolean = true\n    override fun clear() {}\n    override fun contains(element: T): Boolean = false\n}\n\nfun foo(x: Any) {\n    val s = SmartSet<Any>()\n    s.add(x)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.symbols\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.components.KtAnalysisSessionComponent\nimport org.jetbrains.kotlin.analysis.api.components.KtAnalysisSessionMixIn\nimport org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.*\n\npublic abstract class KtSymbolProvider : KtAnalysisSessionComponent() {\n    public open fun getSymbol(psi: KtDeclaration): KtDeclarationSymbol = when (psi) {\n        is KtParameter -> getParameterSymbol(psi)\n        is KtNamedFunction -> getFunctionLikeSymbol(psi)\n        is KtConstructor<*> -> getConstructorSymbol(psi)\n        is KtTypeParameter -> getTypeParameterSymbol(psi)\n        is KtTypeAlias -> getTypeAliasSymbol(psi)\n        is KtEnumEntry -> getEnumEntrySymbol(psi)\n        is KtFunctionLiteral"}
{"code": " -> getAnonymousFunctionSymbol(psi)\n        is KtProperty -> getVariableSymbol(psi)\n        is KtClassOrObject -> {\n            val literalExpression = (psi as? KtObjectDeclaration)?.parent as? KtObjectLiteralExpression\n            literalExpression?.let(::getAnonymousObjectSymbol) ?: getClassOrObjectSymbol(psi)!!\n        }\n        is KtPropertyAccessor -> getPropertyAccessorSymbol(psi)\n        is KtClassInitializer -> getClassInitializerSymbol(psi)\n        is KtDestructuringDeclarationEntry -> getDestructuringDeclarationEntrySymbol(psi)\n        is KtScript -> getScriptSymbol(psi)\n        is KtScriptInitializer -> getScriptSymbol(psi.containingDeclaration)\n        is KtDestructuringDeclaration -> getDestructuringDeclarationSymbol(psi)\n        else -> error(\"Cannot build symbol for ${psi::class}\")\n    }\n\n    public abstract fun getParameterSymbol(psi: KtParameter): KtVariableLikeSymbol\n    public abstract fun getFileSymbol(psi: KtFile): KtFileSymbol\n    public abstract fun getScriptSymb"}
{"code": "ol(psi: KtScript): KtScriptSymbol\n    public abstract fun getFunctionLikeSymbol(psi: KtNamedFunction): KtFunctionLikeSymbol\n    public abstract fun getConstructorSymbol(psi: KtConstructor<*>): KtConstructorSymbol\n    public abstract fun getTypeParameterSymbol(psi: KtTypeParameter): KtTypeParameterSymbol\n    public abstract fun getTypeAliasSymbol(psi: KtTypeAlias): KtTypeAliasSymbol\n    public abstract fun getEnumEntrySymbol(psi: KtEnumEntry): KtEnumEntrySymbol\n    public abstract fun getAnonymousFunctionSymbol(psi: KtNamedFunction): KtAnonymousFunctionSymbol\n    public abstract fun getAnonymousFunctionSymbol(psi: KtFunctionLiteral): KtAnonymousFunctionSymbol\n    public abstract fun getVariableSymbol(psi: KtProperty): KtVariableSymbol\n    public abstract fun getAnonymousObjectSymbol(psi: KtObjectLiteralExpression): KtAnonymousObjectSymbol\n    public abstract fun getClassOrObjectSymbol(psi: KtClassOrObject): KtClassOrObjectSymbol?\n    public abstract fun getNamedClassOrObjectSymbol(psi: "}
{"code": "KtClassOrObject): KtNamedClassOrObjectSymbol?\n    public abstract fun getPropertyAccessorSymbol(psi: KtPropertyAccessor): KtPropertyAccessorSymbol\n    public abstract fun getClassInitializerSymbol(psi: KtClassInitializer): KtClassInitializerSymbol\n    public abstract fun getDestructuringDeclarationEntrySymbol(psi: KtDestructuringDeclarationEntry): KtLocalVariableSymbol\n    public abstract fun getDestructuringDeclarationSymbol(psi: KtDestructuringDeclaration): KtDestructuringDeclarationSymbol\n\n    public abstract fun getPackageSymbolIfPackageExists(packageFqName: FqName): KtPackageSymbol?\n\n    public abstract fun getClassOrObjectSymbolByClassId(classId: ClassId): KtClassOrObjectSymbol?\n\n    public abstract fun getTypeAliasByClassId(classId: ClassId): KtTypeAliasSymbol?\n\n    public abstract fun getTopLevelCallableSymbols(packageFqName: FqName, name: Name): Sequence<KtCallableSymbol>\n\n    @Suppress(\"PropertyName\")\n    public abstract val ROOT_PACKAGE_SYMBOL: KtPackageSymbol\n}\n\npublic inte"}
{"code": "rface KtSymbolProviderMixIn : KtAnalysisSessionMixIn {\n    public fun KtDeclaration.getSymbol(): KtDeclarationSymbol =\n        withValidityAssertion { analysisSession.symbolProvider.getSymbol(this) }\n\n    \n    public fun KtParameter.getParameterSymbol(): KtVariableLikeSymbol =\n        withValidityAssertion { analysisSession.symbolProvider.getParameterSymbol(this) }\n\n    \n    public fun KtNamedFunction.getFunctionLikeSymbol(): KtFunctionLikeSymbol =\n        withValidityAssertion { analysisSession.symbolProvider.getFunctionLikeSymbol(this) }\n\n    public fun KtConstructor<*>.getConstructorSymbol(): KtConstructorSymbol =\n        withValidityAssertion { analysisSession.symbolProvider.getConstructorSymbol(this) }\n\n    public fun KtTypeParameter.getTypeParameterSymbol(): KtTypeParameterSymbol =\n        withValidityAssertion { analysisSession.symbolProvider.getTypeParameterSymbol(this) }\n\n    public fun KtTypeAlias.getTypeAliasSymbol(): KtTypeAliasSymbol =\n        withValidityAssertion { analy"}
{"code": "sisSession.symbolProvider.getTypeAliasSymbol(this) }\n\n    public fun KtEnumEntry.getEnumEntrySymbol(): KtEnumEntrySymbol =\n        withValidityAssertion { analysisSession.symbolProvider.getEnumEntrySymbol(this) }\n\n    public fun KtNamedFunction.getAnonymousFunctionSymbol(): KtAnonymousFunctionSymbol =\n        withValidityAssertion { analysisSession.symbolProvider.getAnonymousFunctionSymbol(this) }\n\n    public fun KtFunctionLiteral.getAnonymousFunctionSymbol(): KtAnonymousFunctionSymbol =\n        withValidityAssertion { analysisSession.symbolProvider.getAnonymousFunctionSymbol(this) }\n\n    public fun KtProperty.getVariableSymbol(): KtVariableSymbol =\n        withValidityAssertion { analysisSession.symbolProvider.getVariableSymbol(this) }\n\n    public fun KtObjectLiteralExpression.getAnonymousObjectSymbol(): KtAnonymousObjectSymbol =\n        withValidityAssertion { analysisSession.symbolProvider.getAnonymousObjectSymbol(this) }\n\n    \n    public fun KtClassOrObject.getClassOrObjectSymbol()"}
{"code": ": KtClassOrObjectSymbol? =\n        withValidityAssertion { analysisSession.symbolProvider.getClassOrObjectSymbol(this) }\n\n    \n    public fun KtClassOrObject.getNamedClassOrObjectSymbol(): KtNamedClassOrObjectSymbol? =\n        withValidityAssertion { analysisSession.symbolProvider.getNamedClassOrObjectSymbol(this) }\n\n    public fun KtPropertyAccessor.getPropertyAccessorSymbol(): KtPropertyAccessorSymbol =\n        withValidityAssertion { analysisSession.symbolProvider.getPropertyAccessorSymbol(this) }\n\n    public fun KtFile.getFileSymbol(): KtFileSymbol =\n        withValidityAssertion { analysisSession.symbolProvider.getFileSymbol(this) }\n\n    public fun KtScript.getScriptSymbol(): KtScriptSymbol =\n        withValidityAssertion { analysisSession.symbolProvider.getScriptSymbol(this) }\n\n    \n    public fun getPackageSymbolIfPackageExists(packageFqName: FqName): KtPackageSymbol? =\n        withValidityAssertion { analysisSession.symbolProvider.getPackageSymbolIfPackageExists(packageFqName) "}
{"code": "}\n\n    \n    public fun getClassOrObjectSymbolByClassId(classId: ClassId): KtClassOrObjectSymbol? =\n        withValidityAssertion { analysisSession.symbolProvider.getClassOrObjectSymbolByClassId(classId) }\n\n    \n    public fun getTypeAliasByClassId(classId: ClassId): KtTypeAliasSymbol? =\n        withValidityAssertion { analysisSession.symbolProvider.getTypeAliasByClassId(classId) }\n\n    \n    public fun getTopLevelCallableSymbols(packageFqName: FqName, name: Name): Sequence<KtCallableSymbol> =\n        withValidityAssertion { analysisSession.symbolProvider.getTopLevelCallableSymbols(packageFqName, name) }\n\n    \n    public fun KtDestructuringDeclarationEntry.getDestructuringDeclarationEntrySymbol(): KtLocalVariableSymbol =\n        analysisSession.symbolProvider.getDestructuringDeclarationEntrySymbol(this)\n\n    @Suppress(\"PropertyName\")\n    public val ROOT_PACKAGE_SYMBOL: KtPackageSymbol\n        get() = withValidityAssertion { analysisSession.symbolProvider.ROOT_PACKAGE_SYMBOL }\n}\n\ncontext("}
{"code": "KtAnalysisSession)\npublic inline fun <reified S : KtSymbol> KtDeclaration.getSymbolOfType(): S =\n    withValidityAssertion { getSymbol() } as S\n\ncontext(KtAnalysisSession)\npublic inline fun <reified S : KtSymbol> KtDeclaration.getSymbolOfTypeSafe(): S? =\n    withValidityAssertion { getSymbol() } as? S\n\n\n\n"}
{"code": "class AA {\n    companion object BB {\n        fun x() = 10\n    }\n}\nfun main() {\n    AA.B<caret>B.x()\n}\n\n"}
{"code": "object Foo {\n    operator fun invoke(i: Int): String {}\n}\n\nfun take() {\n    <expr>Foo</expr>(10)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir\n\nimport com.intellij.openapi.roots.ProjectRootModificationTracker\nimport com.intellij.psi.util.PsiModificationTracker\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.diagnostics.DiagnosticsCollector\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.element.builder.FirElementBuilder\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.file.builder.LLFirFileBuilder\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.file.builder.ModuleFileCache\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.file.builder.ModuleFileCacheImpl\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.file.structure.FileStructureCache\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.lazy.resolve.LLFirModuleLazyDeclarationResolver\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.sessions.LLFirResolvableModuleSession\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.util.LLFirScopeSessionProvider\nimport org.jetbrain"}
{"code": "s.kotlin.analysis.project.structure.KtModule\nimport org.jetbrains.kotlin.fir.scopes.FirScopeProvider\n\ninternal class LLFirModuleResolveComponents(\n    val module: KtModule,\n    val globalResolveComponents: LLFirGlobalResolveComponents,\n    val scopeProvider: FirScopeProvider\n) {\n    val cache: ModuleFileCache = ModuleFileCacheImpl(this)\n    val firFileBuilder: LLFirFileBuilder = LLFirFileBuilder(this)\n    val firModuleLazyDeclarationResolver = LLFirModuleLazyDeclarationResolver(this)\n\n    val scopeSessionProvider: LLFirScopeSessionProvider = LLFirScopeSessionProvider.create(\n        globalResolveComponents.project,\n        invalidationTrackers = listOf(\n            PsiModificationTracker.MODIFICATION_COUNT,\n            ProjectRootModificationTracker.getInstance(globalResolveComponents.project),\n        )\n    )\n\n    val fileStructureCache: FileStructureCache = FileStructureCache(this)\n    val elementsBuilder = FirElementBuilder(this)\n    val diagnosticsCollector = DiagnosticsCollector(f"}
{"code": "ileStructureCache)\n\n    lateinit var session: LLFirResolvableModuleSession\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.tree.generator.printer\n\nimport org.jetbrains.kotlin.fir.tree.generator.*\nimport org.jetbrains.kotlin.fir.tree.generator.context.AbstractFirTreeBuilder\nimport org.jetbrains.kotlin.fir.tree.generator.model.Element\nimport org.jetbrains.kotlin.fir.tree.generator.model.Field\nimport org.jetbrains.kotlin.generators.tree.*\nimport org.jetbrains.kotlin.generators.tree.printer.*\nimport org.jetbrains.kotlin.utils.SmartPrinter\n\nprivate val elementsWithReplaceSource = setOf(\n    FirTreeBuilder.qualifiedAccessExpression,\n    FirTreeBuilder.delegatedConstructorCall,\n)\n\ninternal class ElementPrinter(printer: SmartPrinter) : AbstractElementPrinter<Element, Field>(printer) {\n\n    override fun makeFieldPrinter(printer: SmartPrinter) = object : AbstractFieldPrinter<Field>(printer) {}\n\n    context(ImportCollector)\n    override fun SmartPrinter.printAdditionalMethods(element: Element) {\n        val kind = element.kind ?: error(\"Expected non-null element kind\")\n        with("}
{"code": "element) {\n            val treeName = \"FIR\"\n            printAcceptMethod(element, firVisitorType, hasImplementation = true, treeName = treeName)\n\n            printTransformMethod(\n                element = element,\n                transformerClass = firTransformerType,\n                implementation = \"transformer.transform${element.name}(this, data)\",\n                returnType = TypeVariable(\"E\", listOf(AbstractFirTreeBuilder.baseFirElement)),\n                treeName = treeName,\n            )\n\n            fun Field.replaceDeclaration(override: Boolean, overridenType: TypeRefWithNullability? = null, forceNullable: Boolean = false) {\n                println()\n                if (name == \"source\") {\n                    println(\"@\", firImplementationDetailType.render())\n                }\n                replaceFunctionDeclaration(this, override, kind, overridenType, forceNullable)\n                println()\n            }\n\n            allFields.filter { it.withReplace }.forEach {\n       "}
{"code": "         val override = overriddenFieldsHaveSameClass[it, it] && !(it.name == \"source\" && element in elementsWithReplaceSource)\n                it.replaceDeclaration(override, forceNullable = it.useNullableForReplace)\n                for (overriddenType in it.overriddenTypes) {\n                    it.replaceDeclaration(true, overriddenType)\n                }\n            }\n\n            for (field in allFields) {\n                if (!field.needsSeparateTransform) continue\n                println()\n                transformFunctionDeclaration(field, element, override = field.fromParent && field.parentHasSeparateTransform, kind)\n                println()\n            }\n            if (needTransformOtherChildren) {\n                println()\n                transformOtherChildrenFunctionDeclaration(\n                    element,\n                    override = element.elementParents.any { it.element.needTransformOtherChildren },\n                    kind,\n                )\n                printl"}
{"code": "n()\n            }\n\n            if (element.isRootElement) {\n                println()\n                printAcceptVoidMethod(firVisitorVoidType, treeName)\n                printAcceptChildrenMethod(\n                    element = element,\n                    visitorClass = firVisitorType,\n                    visitorResultType = TypeVariable(\"R\"),\n                )\n                println()\n                println()\n                printAcceptChildrenVoidMethod(firVisitorVoidType)\n                printTransformChildrenMethod(\n                    element = element,\n                    transformerClass = firTransformerType,\n                    returnType = AbstractFirTreeBuilder.baseFirElement,\n                )\n                println()\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.symbols.pointers\n\nimport org.jetbrains.kotlin.analysis.api.fir.KtFirAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.symbols.KtConstructorSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolWithMembers\nimport org.jetbrains.kotlin.analysis.api.symbols.pointers.KtSymbolPointer\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.FirConstructor\nimport org.jetbrains.kotlin.fir.scopes.FirScope\n\ninternal class KtFirConstructorSymbolPointer(\n    ownerPointer: KtSymbolPointer<KtSymbolWithMembers>,\n    private val isPrimary: Boolean,\n    private val signature: FirCallableSignature,\n) : KtFirMemberSymbolPointer<KtConstructorSymbol>(ownerPointer) {\n    override fun KtFirAnalysisSession.chooseCandidateAndCreateSymbol(\n        candidates: FirScope,\n        firSession: FirSession,\n    ): KtConstructorSymbol? {\n        val firConstruc"}
{"code": "tor = candidates.findDeclarationWithSignature<FirConstructor>(signature) {\n            processDeclaredConstructors(it)\n        } ?: return null\n\n        if (firConstructor.isPrimary != isPrimary) return null\n        return firSymbolBuilder.functionLikeBuilder.buildConstructorSymbol(firConstructor.symbol)\n    }\n\n    override fun pointsToTheSameSymbolAs(other: KtSymbolPointer<KtSymbol>): Boolean = other === this ||\n            other is KtFirConstructorSymbolPointer &&\n            other.signature == signature &&\n            other.isPrimary == isPrimary &&\n            hasTheSameOwner(other)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.lazy.resolve\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.FirElementWithResolveState\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\ninternal object LLFirPhaseUpdater {\n    fun updateDeclarationInternalsPhase(\n        target: FirElementWithResolveState,\n        newPhase: FirResolvePhase,\n        updateForLocalDeclarations: Boolean,\n    ) {\n        updatePhaseForNonLocals(target, newPhase, isTargetDeclaration = true)\n\n        if (updateForLocalDeclarations) {\n            when (target) {\n                is FirFunction -> target.body?.accept(PhaseUpdatingTransformer, newPhase)\n                is FirVariable -> {\n                    target.initializer?.accept(PhaseUpdatingTransformer, newPhase)\n                    target.delegate?.accept(PhaseUpdatingTransformer, newPhase)\n                    target.getter?.body?.accept(PhaseUpdatingTransformer, newPh"}
{"code": "ase)\n                    target.setter?.body?.accept(PhaseUpdatingTransformer, newPhase)\n                    target.backingField?.initializer?.accept(PhaseUpdatingTransformer, newPhase)\n                }\n\n                is FirAnonymousInitializer -> target.body?.accept(PhaseUpdatingTransformer, newPhase)\n                is FirCodeFragment -> target.block.accept(PhaseUpdatingTransformer, newPhase)\n            }\n        }\n    }\n\n\n    private fun updatePhaseForNonLocals(element: FirElementWithResolveState, newPhase: FirResolvePhase, isTargetDeclaration: Boolean) {\n        if (element.resolvePhase >= newPhase) return\n        if (!isTargetDeclaration) {\n            // phase update for target declaration happens as a declaration publication event after resolve is finished\n            @OptIn(ResolveStateAccess::class)\n            element.resolveState = newPhase.asResolveState()\n        }\n\n        if (element is FirTypeParameterRefsOwner) {\n            element.typeParameters.forEach { typePar"}
{"code": "ameter ->\n                // if it is not a type parameter of outer declaration\n                if (typeParameter is FirTypeParameter) {\n                    updatePhaseForNonLocals(typeParameter, newPhase, isTargetDeclaration = false)\n                }\n            }\n        }\n\n        when (element) {\n            is FirFunction -> element.valueParameters.forEach { updatePhaseForNonLocals(it, newPhase, isTargetDeclaration = false) }\n            is FirProperty -> {\n                element.getter?.let { updatePhaseForNonLocals(it, newPhase, isTargetDeclaration = false) }\n                element.setter?.let { updatePhaseForNonLocals(it, newPhase, isTargetDeclaration = false) }\n                element.backingField?.let { updatePhaseForNonLocals(it, newPhase, isTargetDeclaration = false) }\n            }\n            else -> {}\n        }\n    }\n}\n\nprivate object PhaseUpdatingTransformer : FirVisitor<Unit, FirResolvePhase>() {\n    override fun visitElement(element: FirElement, data: FirResolvePh"}
{"code": "ase) {\n        if (element is FirElementWithResolveState) {\n            @OptIn(ResolveStateAccess::class)\n            element.resolveState = data.asResolveState()\n        }\n\n        element.acceptChildren(this, data)\n    }\n}\n"}
{"code": "// ISSUE: KT-59649\n<!PROPERTY_WITH_NO_TYPE_NO_INITIALIZER!>val prop<!>\n    get() {\n        fun smth(s: String) = 1\n        return smth(\"awd\")\n    }\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\", \"unused\")\n\npackage org.jetbrains.kotlin.fir.types.builder\n\nimport kotlin.contracts.*\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.builder.FirAnnotationContainerBuilder\nimport org.jetbrains.kotlin.fir.builder.FirBuilderDsl\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.types.FirDynamicTypeRef\nimport org.jetbrains.kotlin.fir.types.impl.FirDynamicTypeRefImpl\n\n@FirBuilderDsl\nclass FirDynamicTypeRefBuilder : FirAnnotationContainerBuilder {\n    override var source: KtSourceElement? = null\n    override val annotations: MutableList<FirAnnotation> = mutableListOf()\n    var isMarkedNullable: Boolean by kotlin.properties.Delegates.notNull<Boolean>()\n\n    override fun build(): FirDynamicTypeRef {\n        return FirD"}
{"code": "ynamicTypeRefImpl(\n            source,\n            annotations.toMutableOrEmpty(),\n            isMarkedNullable,\n        )\n    }\n\n}\n\n@OptIn(ExperimentalContracts::class)\ninline fun buildDynamicTypeRef(init: FirDynamicTypeRefBuilder.() -> Unit): FirDynamicTypeRef {\n    contract {\n        callsInPlace(init, InvocationKind.EXACTLY_ONCE)\n    }\n    return FirDynamicTypeRefBuilder().apply(init).build()\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.js.checkers.expression\n\nimport org.jetbrains.kotlin.AbstractKtSourceElement\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.expression.FirQualifiedAccessExpressionChecker\nimport org.jetbrains.kotlin.fir.analysis.checkers.getContainingClassSymbol\nimport org.jetbrains.kotlin.fir.analysis.js.checkers.checkJsModuleUsage\nimport org.jetbrains.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.references.toResolvedBaseSymbol\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\nimport org.jetbrains.kotlin.fir.types.toRegularClassSymbol\n\nobject FirJsModuleQualifiedAccessChecker : FirQualifiedAccessExpressionChecker(MppCheckerKind.Common) {\n    override fun check(expression: FirQualifiedAccessExpression, context: CheckerContext, reporter: Diagnostic"}
{"code": "Reporter) {\n        checkReifiedTypeParameters(expression, context, reporter)\n\n        val calleeSymbols = extractModuleCalleeSymbols(expression)\n        for ((calleeSymbol, source) in calleeSymbols) {\n            checkJsModuleUsage(calleeSymbol, context, reporter, source ?: expression.source)\n        }\n    }\n\n    private fun extractModuleCalleeSymbols(\n        expression: FirQualifiedAccessExpression\n    ): List<Pair<FirBasedSymbol<*>, AbstractKtSourceElement?>> {\n        val calleeSymbol = expression.calleeReference.toResolvedBaseSymbol()\n        if (calleeSymbol != null && calleeSymbol.getContainingClassSymbol(calleeSymbol.moduleData.session) == null) {\n            return listOf(calleeSymbol to expression.calleeReference.source)\n        }\n\n        return when (val receiver = expression.dispatchReceiver) {\n            null -> listOfNotNull(calleeSymbol?.to(expression.calleeReference.source))\n            is FirResolvedQualifier -> {\n                val classSymbol = receiver.symbol\n  "}
{"code": "              if (expression is FirCallableReferenceAccess) {\n                    listOfNotNull(classSymbol?.to(receiver.source), calleeSymbol?.to(expression.calleeReference.source))\n                } else {\n                    listOfNotNull(classSymbol?.to(expression.calleeReference.source))\n                }\n            }\n            else -> emptyList()\n        }\n    }\n\n    private fun checkReifiedTypeParameters(expr: FirQualifiedAccessExpression, context: CheckerContext, reporter: DiagnosticReporter) {\n        (expr as? FirFunctionCall)?.forAllReifiedTypeParameters { type, typeArgument ->\n            val typeArgumentClass = type.toRegularClassSymbol(context.session) ?: return@forAllReifiedTypeParameters\n            val source = typeArgument.source ?: expr.calleeReference.source ?: expr.source\n            checkJsModuleUsage(typeArgumentClass, context, reporter, source)\n        }\n    }\n}\n\n\n"}
{"code": "// MODULE: L1\n// MODULE_KIND: LibraryBinary\n// FILE: l1.kt\n\n// MODULE: L2\n// MODULE_KIND: LibraryBinary\n// FILE: l2.kt\n\n// MODULE: G\n\n// MODULE: F(L1)\n\n// MODULE: E\n\n// MODULE: D\n\n// MODULE: C(F, G, L2)\n\n// MODULE: B(D, E)\n\n// MODULE: A(B, C)\n// WILDCARD_MODIFICATION_EVENT\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.isSubtypeOfThrowable\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.declarations.utils.classId\nimport org.jetbrains.kotlin.fir.declarations.utils.isInner\nimport org.jetbrains.kotlin.fir.declarations.utils.isLocal\nimport org.jetbrains.kotlin.fir.declarations.utils.superConeTypes\nimport org.jetbrains.kotlin.fir.types.ConeErrorType\n\nobject FirThrowableSubclassChecker : FirClassChecker(MppCheckerKind.Common) {\n    override fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {\n        if (!declaration.hasTh"}
{"code": "rowableSupertype(context))\n            return\n\n        if (declaration.typeParameters.isNotEmpty()) {\n            declaration.typeParameters.firstOrNull()?.source?.let {\n                reporter.reportOn(it, FirErrors.GENERIC_THROWABLE_SUBCLASS, context)\n            }\n\n            val shouldReport = when (declaration) {\n                is FirRegularClass -> declaration.isInner || declaration.isLocal\n                is FirAnonymousObject -> true\n                else -> false\n            }\n\n            if (shouldReport) {\n                reporter.reportOn(declaration.source, FirErrors.INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS, context)\n            }\n        } else if (declaration.hasGenericOuterDeclaration(context)) {\n            reporter.reportOn(declaration.source, FirErrors.INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS, context)\n        }\n    }\n\n    private fun FirClass.hasThrowableSupertype(context: CheckerContext) =\n        superConeTypes.any { it !is ConeErrorType && it.isSubtypeOfThro"}
{"code": "wable(context.session) }\n\n    private fun FirClass.hasGenericOuterDeclaration(context: CheckerContext): Boolean {\n        if (!classId.isLocal) return false\n        for (containingDeclaration in context.containingDeclarations.asReversed()) {\n            if (containingDeclaration is FirTypeParameterRefsOwner && containingDeclaration.typeParameters.isNotEmpty()) {\n                return true\n            }\n            if (containingDeclaration is FirRegularClass && !containingDeclaration.isLocal && !containingDeclaration.isInner) {\n                return false\n            }\n        }\n        return false\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental\n\nimport org.jetbrains.kotlin.build.report.ICReporter\nimport org.jetbrains.kotlin.cli.common.arguments.K2JSCompilerArguments\nimport org.jetbrains.kotlin.cli.common.messages.MessageCollector\nimport org.jetbrains.kotlin.incremental.multiproject.ModulesApiHistoryJs\nimport org.jetbrains.kotlin.incremental.testingUtils.BuildLogFinder\nimport org.jetbrains.kotlin.library.KLIB_FILE_EXTENSION\nimport java.io.File\n\nabstract class AbstractIncrementalK1JsKlibMultiModuleCompilerRunnerTest :\n    AbstractIncrementalMultiModuleCompilerRunnerTest<K2JSCompilerArguments, ModulesApiHistoryJs>() {\n\n    override fun createCompilerArguments(destinationDir: File, testDir: File): K2JSCompilerArguments =\n        K2JSCompilerArguments().apply {\n            libraries = STDLIB_DEPENDENCY\n            outputDir = destinationDir.path\n            moduleName = testDir.name\n            sourceMap = false\n            irProduceKlibDir = false\n            irProduceKlibFile = true\n   "}
{"code": "         irOnly = true\n            languageVersion = \"1.9\"\n        }\n\n    override val buildLogFinder: BuildLogFinder\n        get() = super.buildLogFinder.copy(isFirEnabled = false, isKlibEnabled = true)\n\n    override fun makeForSingleModule(\n        moduleCacheDir: File,\n        sourceRoots: Iterable<File>,\n        args: K2JSCompilerArguments,\n        moduleBuildHistoryFile: File,\n        messageCollector: MessageCollector,\n        reporter: ICReporter,\n        scopeExpansion: CompileScopeExpansionMode,\n        modulesApiHistory: ModulesApiHistoryJs,\n        providedChangedFiles: ChangedFiles?\n    ) {\n        makeJsIncrementally(\n            moduleCacheDir,\n            sourceRoots,\n            args,\n            moduleBuildHistoryFile,\n            messageCollector,\n            reporter,\n            scopeExpansionMode,\n            modulesApiHistory,\n            providedChangedFiles\n        )\n    }\n\n    override val modulesApiHistory: ModulesApiHistoryJs by lazy {\n        ModulesApiHisto"}
{"code": "ryJs(workingDir, incrementalModuleInfo)\n    }\n\n    override val scopeExpansionMode: CompileScopeExpansionMode get() = CompileScopeExpansionMode.NEVER\n\n    override fun String.asOutputFileName(): String = klib\n    override fun String.asArtifactFileName(): String = klib\n\n    override fun transformToDependency(moduleName: String, rawArtifact: File): File {\n        val dependencyFile = File(repository, moduleName.klib)\n        rawArtifact.copyTo(dependencyFile)\n        return dependencyFile\n    }\n\n    override fun K2JSCompilerArguments.updateForSingleModule(moduleDependencies: List<String>, outFile: File) {\n        val additionalDeps = moduleDependencies.joinToString(File.pathSeparator) {\n            File(repository, it.klib).absolutePath\n        }\n\n        val sb = StringBuilder(STDLIB_DEPENDENCY)\n        if (additionalDeps.isNotBlank()) {\n            sb.append(File.pathSeparator)\n            sb.append(additionalDeps)\n        }\n\n        libraries = sb.toString()\n        outputDir = outFil"}
{"code": "e.parentFile.path\n        moduleName = outFile.nameWithoutExtension\n    }\n\n    companion object {\n        private val String.klib: String get() = \"$this.$KLIB_FILE_EXTENSION\"\n\n        private const val STDLIB_DEPENDENCY = \"build/js-ir-runtime/full-runtime.klib\"\n    }\n}\n\nabstract class AbstractIncrementalK2JsKlibMultiModuleCompilerRunnerTest :\n    AbstractIncrementalK1JsKlibMultiModuleCompilerRunnerTest() {\n\n    override fun createCompilerArguments(destinationDir: File, testDir: File): K2JSCompilerArguments {\n        return super.createCompilerArguments(destinationDir, testDir).apply {\n            languageVersion = \"2.0\"\n        }\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir\n\nimport org.jetbrains.kotlin.test.WrappedException\nimport org.jetbrains.kotlin.test.directives.model.DirectivesContainer\nimport org.jetbrains.kotlin.test.directives.model.SimpleDirectivesContainer\nimport org.jetbrains.kotlin.test.directives.model.StringDirective\nimport org.jetbrains.kotlin.test.model.AfterAnalysisChecker\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.moduleStructure\n\nabstract class TestByDirectiveSuppressor(\n    val suppressDirective: StringDirective,\n    directivesContainer: DirectivesContainer,\n    testServices: TestServices,\n) : AfterAnalysisChecker(testServices) {\n    init {\n        require(suppressDirective in directivesContainer)\n    }\n\n    override val directiveContainers: List<DirectivesContainer> = listOf(directivesContainer)\n\n    override fun suppressIfNeeded(failedAssertions: List<WrappedException>): List<WrappedException> {\n        if (!isDisabled()) "}
{"code": "{\n            return failedAssertions\n        }\n\n        return if (failedAssertions.isEmpty()) {\n            listOf(\n                AssertionError(\n                    \"Test contains $suppressDirective directive but no errors was reported. Please remove directive\",\n                ).wrap()\n            )\n        } else {\n            emptyList()\n        }\n    }\n\n    private fun isDisabled(): Boolean = suppressDirective in testServices.moduleStructure.allDirectives\n}\n\nclass LLFirTestSuppressor(\n    testServices: TestServices,\n) : TestByDirectiveSuppressor(\n    suppressDirective = Directives.MUTE_LL_FIR,\n    directivesContainer = Directives,\n    testServices\n) {\n\n    private object Directives : SimpleDirectivesContainer() {\n        val MUTE_LL_FIR by stringDirective(\"Temporary mute Low Level FIR implementation due to some error. YT ticket must be provided\")\n    }\n}\n\nclass LLFirOnlyReversedTestSuppressor(\n    testServices: TestServices,\n) : TestByDirectiveSuppressor(\n    suppressDirective"}
{"code": " = Directives.IGNORE_REVERSED_RESOLVE,\n    directivesContainer = Directives,\n    testServices\n) {\n    private object Directives : SimpleDirectivesContainer() {\n        val IGNORE_REVERSED_RESOLVE by stringDirective(\"Temporary disables reversed resolve checks until the issue is fixed. YT ticket must be provided\")\n    }\n}\n\nclass LLFirOnlyNonReversedTestSuppressor(\n    testServices: TestServices,\n) : TestByDirectiveSuppressor(\n    suppressDirective = Directives.IGNORE_NON_REVERSED_RESOLVE,\n    directivesContainer = Directives,\n    testServices\n) {\n    private object Directives : SimpleDirectivesContainer() {\n        val IGNORE_NON_REVERSED_RESOLVE by stringDirective(\"Temporary disables non-reversed resolve checks until the issue is fixed. YT ticket must be provided\")\n    }\n}"}
{"code": "interface Foo1 {\n    fun foo()\n    fun bar()\n    val str: String\n}\n\ninterface Foo2 : Foo1 {\n    fun foo(i: Int)\n    fun bar(s: String)\n    val isBoo: Boolean\n}\n\nabstract class Usag<caret>e : Foo2 {\n    override fun foo() {}\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.providers.impl\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.NoMutableState\nimport org.jetbrains.kotlin.fir.caches.createCache\nimport org.jetbrains.kotlin.fir.caches.firCachesFactory\nimport org.jetbrains.kotlin.fir.caches.getValue\nimport org.jetbrains.kotlin.fir.resolve.providers.FirCompositeCachedSymbolNamesProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolNamesProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProviderInternals\nimport org.jetbrains.kotlin.fir.resolve.providers.impl.FirSyntheticFunctionInterfaceProviderBase.Companion.isNameForFunctionClass\nimport org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol\nim"}
{"code": "port org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\n\n@NoMutableState\nclass FirCachingCompositeSymbolProvider(\n    session: FirSession,\n    val providers: List<FirSymbolProvider>,\n    // This property is necessary just to make sure we don't use the hack at `createCopyWithCleanCaches` more than once or in cases\n    // we are not assumed to use it.\n    private val expectedCachesToBeCleanedOnce: Boolean = false,\n) : FirSymbolProvider(session) {\n\n    private val classLikeCache = session.firCachesFactory.createCache(::computeClass)\n    private val topLevelCallableCache = session.firCachesFactory.createCache(::computeTopLevelCallables)\n    private val topLevelFunctionCache = session.firCachesFactory.createCache(::computeTopLevelFunctions)\n    private val topLevelPropertyCache = session.firCachesFactory.createCache(::computeTopLevelProperties)\n    private val packageCache = session.firC"}
{"code": "achesFactory.createCache(::computePackage)\n\n    override val symbolNamesProvider: FirSymbolNamesProvider = object : FirCompositeCachedSymbolNamesProvider(\n        session,\n        providers.map { it.symbolNamesProvider },\n    ) {\n        override fun computeTopLevelClassifierNames(packageFqName: FqName): Set<Name>? =\n            super.computeTopLevelClassifierNames(packageFqName).also {\n                ensureNotNull(it) { \"classifier names in package $packageFqName\" }\n            }\n\n        override val hasSpecificCallablePackageNamesComputation: Boolean get() = true\n\n        override fun computePackageNamesWithTopLevelCallables(): Set<String>? =\n            super.computePackageNamesWithTopLevelCallables().also {\n                ensureNotNull(it) { \"package names with top-level callables\" }\n            }\n\n        override fun computeTopLevelCallableNames(packageFqName: FqName): Set<Name>? =\n            super.computeTopLevelCallableNames(packageFqName).also {\n                ensureNotNu"}
{"code": "ll(it) { \"callable names in package $packageFqName\" }\n            }\n\n        @OptIn(FirSymbolProviderInternals::class)\n        override fun mayHaveSyntheticFunctionType(classId: ClassId): Boolean {\n            // We know that `session` is the same as the sessions of all `providers`, so we can take a shortcut here.\n            return classId.isNameForFunctionClass(session)\n        }\n\n        // The compiler does not compute classifier and general package name sets because it is too expensive, so we can disable them.\n        // `FirCachingCompositeSymbolProvider` is only used by the compiler.\n        override fun computePackageNames(): Set<String>? = null\n        override fun computePackageNamesWithTopLevelClassifiers(): Set<String>? = null\n\n        override val hasSpecificClassifierPackageNamesComputation: Boolean get() = false\n\n        // Avoid cache accesses.\n        override fun getPackageNames(): Set<String>? = null\n        override fun getPackageNamesWithTopLevelClassifiers(): Set<"}
{"code": "String>? = null\n\n        override fun getTopLevelClassifierNamesInPackage(packageFqName: FqName): Set<Name>? =\n            super.getTopLevelClassifierNamesInPackageSkippingPackageCheck(packageFqName)\n    }\n\n    private inline fun ensureNotNull(v: Any?, representation: () -> String) {\n        require(v != null || expectedCachesToBeCleanedOnce) {\n            \"${representation()} is expected to be not null in CLI\"\n        }\n    }\n\n    // Unfortunately, this is a part of a hack for overcoming the problem of plugin's generated entities\n    // (for more details see its usage at org.jetbrains.kotlin.fir.resolve.transformers.plugin.FirCompilerRequiredAnnotationsResolveProcessor.afterPhase)\n    fun createCopyWithCleanCaches(): FirCachingCompositeSymbolProvider {\n        require(expectedCachesToBeCleanedOnce) { \"Unexpected caches clearing\" }\n        return FirCachingCompositeSymbolProvider(session, providers, expectedCachesToBeCleanedOnce = false)\n    }\n\n    override fun getTopLevelCallableSymbo"}
{"code": "ls(packageFqName: FqName, name: Name): List<FirCallableSymbol<*>> {\n        if (!symbolNamesProvider.mayHaveTopLevelCallable(packageFqName, name)) return emptyList()\n        return topLevelCallableCache.getValue(CallableId(packageFqName, name))\n    }\n\n    @FirSymbolProviderInternals\n    override fun getTopLevelCallableSymbolsTo(destination: MutableList<FirCallableSymbol<*>>, packageFqName: FqName, name: Name) {\n        destination += getTopLevelCallableSymbols(packageFqName, name)\n    }\n\n    @FirSymbolProviderInternals\n    override fun getTopLevelFunctionSymbolsTo(destination: MutableList<FirNamedFunctionSymbol>, packageFqName: FqName, name: Name) {\n        if (!symbolNamesProvider.mayHaveTopLevelCallable(packageFqName, name)) return\n        destination += topLevelFunctionCache.getValue(CallableId(packageFqName, name))\n    }\n\n    @FirSymbolProviderInternals\n    override fun getTopLevelPropertySymbolsTo(destination: MutableList<FirPropertySymbol>, packageFqName: FqName, name: Name) {\n  "}
{"code": "      if (!symbolNamesProvider.mayHaveTopLevelCallable(packageFqName, name)) return\n        destination += topLevelPropertyCache.getValue(CallableId(packageFqName, name))\n    }\n\n    override fun getPackage(fqName: FqName): FqName? {\n        return packageCache.getValue(fqName)\n    }\n\n    override fun getClassLikeSymbolByClassId(classId: ClassId): FirClassLikeSymbol<*>? {\n        if (!symbolNamesProvider.mayHaveTopLevelClassifier(classId)) return null\n        return classLikeCache.getValue(classId)\n    }\n\n    @OptIn(FirSymbolProviderInternals::class)\n    private fun computeTopLevelCallables(callableId: CallableId): List<FirCallableSymbol<*>> = buildList {\n        providers.forEach { it.getTopLevelCallableSymbolsTo(this, callableId.packageName, callableId.callableName) }\n    }\n\n    @OptIn(FirSymbolProviderInternals::class)\n    private fun computeTopLevelFunctions(callableId: CallableId): List<FirNamedFunctionSymbol> = buildList {\n        providers.forEach { it.getTopLevelFunctionSymbolsT"}
{"code": "o(this, callableId.packageName, callableId.callableName) }\n    }\n\n    @OptIn(FirSymbolProviderInternals::class)\n    private fun computeTopLevelProperties(callableId: CallableId): List<FirPropertySymbol> = buildList {\n        providers.forEach { it.getTopLevelPropertySymbolsTo(this, callableId.packageName, callableId.callableName) }\n    }\n\n    private fun computePackage(it: FqName): FqName? =\n        providers.firstNotNullOfOrNull { provider -> provider.getPackage(it) }\n\n    private fun computeClass(classId: ClassId): FirClassLikeSymbol<*>? =\n        providers.firstNotNullOfOrNull { provider -> provider.getClassLikeSymbolByClassId(classId) }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cfg.pseudocode.instructions.special\n\nimport org.jetbrains.kotlin.psi.KtElement\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.BlockScope\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.InstructionWithNext\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.InstructionVisitor\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.InstructionVisitorWithResult\n\nclass MarkInstruction(\n    element: KtElement,\n    blockScope: BlockScope\n) : InstructionWithNext(element, blockScope) {\n\n    override fun accept(visitor: InstructionVisitor) {\n        visitor.visitMarkInstruction(this)\n    }\n\n    override fun <R> accept(visitor: InstructionVisitorWithResult<R>): R = visitor.visitMarkInstruction(this)\n\n    override fun createCopy() = MarkInstruction(element, blockScope)\n\n    override fun toString() = \"mark(${render(element)})\"\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental\n\nimport org.jetbrains.kotlin.build.report.DoNothingBuildReporter\nimport org.jetbrains.kotlin.compilerRunner.OutputItemsCollector\nimport org.junit.jupiter.api.Assertions.*\nimport org.junit.jupiter.api.Test\nimport org.junit.jupiter.api.io.TempDir\nimport java.io.File\nimport java.nio.file.Files\nimport java.nio.file.Path\n\nclass TransactionOutputsRegistrarTest {\n    @TempDir\n    private lateinit var stashDir: Path\n\n    @TempDir\n    private lateinit var workingDir: Path\n\n    private class MockOutputItemsCollector : OutputItemsCollector {\n        val addedOutputItems = mutableSetOf<Pair<Collection<File>, File>>()\n\n        override fun add(sourceFiles: Collection<File>, outputFile: File) {\n            addedOutputItems.add(sourceFiles to outputFile)\n        }\n    }\n\n    @Test\n    fun testSuccessfulTransaction() {\n        val mockCollector = MockOutputItemsCollector()\n        val srcFile = workingDir.resolve(\"a.kt\")\n        val outputFile = workingDir.re"}
{"code": "solve(\"AKt.class\")\n        RecoverableCompilationTransaction(DoNothingBuildReporter, stashDir).use {\n            val registrar = TransactionOutputsRegistrar(it, mockCollector)\n            registrar.add(listOf(srcFile.toFile()), outputFile.toFile())\n            Files.write(outputFile, \"blah-blah\".toByteArray())\n            it.markAsSuccessful()\n        }\n        assertIterableEquals(\n            setOf(listOf(srcFile.toFile()) to outputFile.toFile()),\n            mockCollector.addedOutputItems,\n            \"TransactionOutputsRegistrar should call the origin\"\n        )\n        assertEquals(\"blah-blah\", String(Files.readAllBytes(outputFile)))\n    }\n\n    @Test\n    fun testFailedTransaction() {\n        val mockCollector = MockOutputItemsCollector()\n        val srcFile = workingDir.resolve(\"a.kt\")\n        val outputFile = workingDir.resolve(\"AKt.class\")\n        RecoverableCompilationTransaction(DoNothingBuildReporter, stashDir).use {\n            val registrar = TransactionOutputsRegistrar(it,"}
{"code": " mockCollector)\n            registrar.add(listOf(srcFile.toFile()), outputFile.toFile())\n            Files.write(outputFile, \"blah-blah\".toByteArray())\n        }\n        assertIterableEquals(\n            setOf(listOf(srcFile.toFile()) to outputFile.toFile()),\n            mockCollector.addedOutputItems,\n            \"TransactionOutputsRegistrar should call the origin\"\n        )\n        assertFalse(Files.exists(outputFile), \"Output file wasn't reverted\")\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.backend.jvm\n\nimport org.jetbrains.kotlin.backend.jvm.JvmBackendContext\nimport org.jetbrains.kotlin.backend.jvm.JvmBackendExtension\nimport org.jetbrains.kotlin.backend.jvm.ModuleMetadataSerializer\nimport org.jetbrains.kotlin.backend.jvm.metadata.MetadataSerializer\nimport org.jetbrains.kotlin.codegen.serialization.JvmSerializationBindings\nimport org.jetbrains.kotlin.fir.backend.Fir2IrComponents\nimport org.jetbrains.kotlin.fir.backend.FirMetadataSource\nimport org.jetbrains.kotlin.fir.declarations.FirClass\nimport org.jetbrains.kotlin.fir.declarations.FirDeclaration\nimport org.jetbrains.kotlin.fir.serialization.FirElementAwareStringTable\nimport org.jetbrains.kotlin.fir.serialization.FirElementSerializer\nimport org.jetbrains.kotlin.fir.serialization.TypeApproximatorForMetadataSerializer\nimport org.jetbrains.kotlin.fir.serialization.serializeAnnotations\nimport org.jetbrains.kotlin.ir.declarations.IrClass\nimport org.jetbrains.kotlin.ir.declarations.MetadataSo"}
{"code": "urce\nimport org.jetbrains.kotlin.metadata.ProtoBuf\nimport org.jetbrains.kotlin.metadata.serialization.MutableVersionRequirementTable\nimport org.jetbrains.kotlin.serialization.StringTableImpl\nimport org.jetbrains.kotlin.serialization.deserialization.builtins.BuiltInSerializerProtocol\nimport org.jetbrains.org.objectweb.asm.Type\n\nclass FirJvmBackendExtension(\n    private val components: Fir2IrComponents,\n    private val actualizedExpectDeclarations: Set<FirDeclaration>?\n) : JvmBackendExtension {\n    override fun createSerializer(\n        context: JvmBackendContext,\n        klass: IrClass,\n        type: Type,\n        bindings: JvmSerializationBindings,\n        parentSerializer: MetadataSerializer?\n    ): MetadataSerializer {\n        return makeFirMetadataSerializerForIrClass(\n            components.session,\n            context,\n            klass,\n            bindings,\n            components,\n            parentSerializer,\n            actualizedExpectDeclarations\n        )\n    }\n\n    overrid"}
{"code": "e fun createModuleMetadataSerializer(context: JvmBackendContext) = object : ModuleMetadataSerializer {\n        override fun serializeOptionalAnnotationClass(metadata: MetadataSource.Class, stringTable: StringTableImpl): ProtoBuf.Class {\n\n            require(metadata is FirMetadataSource.Class) { \"Metadata is expected to be ${FirMetadataSource.Class::class.simpleName}\" }\n\n            val session = components.session\n            val fir = metadata.fir\n\n            val typeApproximator = TypeApproximatorForMetadataSerializer(session)\n            // Get rid of special serializer extension after KT-57919, i.e. when we serialize all the annotations by default\n            val firSerializerExtension = object : FirJvmSerializerExtension(\n                session,\n                JvmSerializationBindings(),\n                context.state,\n                // annotation can't have local delegated properties, it is safe to pass empty list\n                localDelegatedProperties = emptyList(),\n      "}
{"code": "          typeApproximator,\n                components,\n                object : FirElementAwareStringTable {\n                    override fun getQualifiedClassNameIndex(className: String, isLocal: Boolean): Int =\n                        stringTable.getQualifiedClassNameIndex(className, isLocal)\n\n                    override fun getStringIndex(string: String): Int = stringTable.getStringIndex(string)\n                }\n            ) {\n                override fun serializeClass(\n                    klass: FirClass,\n                    proto: ProtoBuf.Class.Builder,\n                    versionRequirementTable: MutableVersionRequirementTable,\n                    childSerializer: FirElementSerializer,\n                ) {\n                    klass.serializeAnnotations(\n                        session,\n                        additionalMetadataProvider,\n                        annotationSerializer,\n                        proto,\n                        BuiltInSerializerProtocol.classAnnotati"}
{"code": "on\n                    )\n                    super.serializeClass(klass, proto, versionRequirementTable, childSerializer)\n                }\n            }\n            val serializer = FirElementSerializer.create(\n                session,\n                components.scopeSession,\n                fir,\n                firSerializerExtension,\n                parentSerializer = null,\n                typeApproximator,\n                context.config.languageVersionSettings\n            )\n            return serializer.classProto(fir).build()\n        }\n    }\n}\n"}
{"code": "// ISSUE: KTIJ-26465\n// TODO: arrayOf() should be resolved because it's from builtins that are always presented\n\n<caret>annotation class Ann(vararg val a: String = [\"/\"])"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.checkers\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.builtins.StandardNames\nimport org.jetbrains.kotlin.config.ApiVersion\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.diagnostics.reportDiagnosticOnce\nimport org.jetbrains.kotlin.name.isSubpackageOf\nimport org.jetbrains.kotlin.psi.KtAnnotationEntry\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.resolve.RequireKotlinConstants\nimport org.jetbrains.kotlin.resolve.annotations.argumentValue\nimport org.jetbrains.kotlin.resolve.constants.StringValue\nimport org.jetbrains.kotlin.resolve.deprecation.getSinceVersion\nimport org.jetbrains.kotlin.resolve.descriptorUtil.fqNameOrNull\nimport org.jetbrains.kotlin.resolve.source.getPsi\n\nobject DeprecatedSinceKotlinAnnotationChecker : DeclarationChecker {\n    o"}
{"code": "verride fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n        val deprecatedSinceAnnotation = descriptor.annotations.findAnnotation(StandardNames.FqNames.deprecatedSinceKotlin) ?: return\n        val deprecatedSinceAnnotationPsi = deprecatedSinceAnnotation.source.getPsi() as? KtAnnotationEntry ?: return\n\n        val deprecatedAnnotation = descriptor.annotations.findAnnotation(StandardNames.FqNames.deprecated)\n\n        val deprecatedSinceAnnotationName = deprecatedSinceAnnotationPsi.typeReference ?: return\n\n        if (descriptor.fqNameOrNull()?.isSubpackageOf(StandardNames.BUILT_INS_PACKAGE_FQ_NAME) == false) {\n            context.trace.report(\n                Errors.DEPRECATED_SINCE_KOTLIN_OUTSIDE_KOTLIN_SUBPACKAGE.on(\n                    deprecatedSinceAnnotationName\n                )\n            )\n            return\n        }\n\n        if (deprecatedAnnotation == null) {\n            context.trace.report(\n                "}
{"code": "Errors.DEPRECATED_SINCE_KOTLIN_WITHOUT_DEPRECATED.on(\n                    deprecatedSinceAnnotationName\n                )\n            )\n            return\n        }\n\n        if (deprecatedAnnotation.argumentValue(Deprecated::level.name) != null) {\n            context.trace.report(\n                Errors.DEPRECATED_SINCE_KOTLIN_WITH_DEPRECATED_LEVEL.on(\n                    deprecatedSinceAnnotationName\n                )\n            )\n            return\n        }\n\n        if (deprecatedSinceAnnotation.allValueArguments.isEmpty()) {\n            context.trace.report(\n                Errors.DEPRECATED_SINCE_KOTLIN_WITHOUT_ARGUMENTS.on(\n                    deprecatedSinceAnnotationName\n                )\n            )\n            return\n        }\n\n        fun AnnotationDescriptor.getCheckedSinceVersion(name: String) =\n            getSinceVersion(name).also { checkVersion(it, name, context, deprecatedSinceAnnotationName) }\n\n        val warningSince = deprecatedSinceAnnotation.getCheckedSinceVe"}
{"code": "rsion(\"warningSince\")\n        val errorSince = deprecatedSinceAnnotation.getCheckedSinceVersion(\"errorSince\")\n        val hiddenSince = deprecatedSinceAnnotation.getCheckedSinceVersion(\"hiddenSince\")\n\n        if (!lessOrNull(warningSince, errorSince) || !lessOrNull(errorSince, hiddenSince) || !lessOrNull(warningSince, hiddenSince)) {\n            context.trace.report(\n                Errors.DEPRECATED_SINCE_KOTLIN_WITH_UNORDERED_VERSIONS.on(\n                    deprecatedSinceAnnotationName\n                )\n            )\n            return\n        }\n    }\n\n    private fun AnnotationDescriptor.checkVersion(\n        parsedVersion: ApiVersion?,\n        name: String,\n        context: DeclarationCheckerContext,\n        reportOn: PsiElement\n    ) {\n        val argumentValue = (argumentValue(name) as? StringValue)?.value\n        if (argumentValue != null && (parsedVersion == null || !argumentValue.matches(RequireKotlinConstants.VERSION_REGEX))) {\n            context.trace.reportDiagnosticOnce"}
{"code": "(\n                Errors.ILLEGAL_KOTLIN_VERSION_STRING_VALUE.on(\n                    reportOn, fqName ?: return\n                )\n            )\n        }\n    }\n\n    private fun lessOrNull(a: ApiVersion?, b: ApiVersion?): Boolean =\n        if (a == null || b == null) true else a <= b\n}\n"}
{"code": "interface Foo {}\n\nfun test(obj: Any) {\n    <expr>obj.hashCode()</expr>\n    if (obj is Foo) {\n        consume(obj)\n    }\n}\n\nfun consume(obj: Foo) {}"}
{"code": "// FILE: MyAnno.kt\n@Target(AnnotationTarget.TYPE)\nannotation class MyAnno(val s: String)\n\n// FILE: JavaClass.java\nclass JavaClass {\n    void materialize(@MyAnno(\"type\") String @MyAnno(\"vararg\") ...va<caret>lues) {}\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen\n\nimport org.jetbrains.org.objectweb.asm.MethodVisitor\n\nfun visitAnnotableParameterCount(mv: MethodVisitor, paramCount: Int) {\n    mv.visitAnnotableParameterCount(paramCount, true)\n    mv.visitAnnotableParameterCount(paramCount, false)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api\n\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeOwner\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken\nimport org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion\nimport org.jetbrains.kotlin.analysis.api.types.KtType\nimport org.jetbrains.kotlin.types.Variance\n\npublic sealed class KtTypeProjection : KtLifetimeOwner {\n    public abstract val type: KtType?\n}\n\npublic class KtStarTypeProjection(override val token: KtLifetimeToken) : KtTypeProjection() {\n    override val type: KtType? get() = withValidityAssertion { null }\n}\n\npublic class KtTypeArgumentWithVariance(\n    private val _type: KtType,\n    public val variance: Variance,\n    override val token: KtLifetimeToken,\n) : KtTypeProjection() {\n    override val type: KtType get() = withValidityAssertion { _type }\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.lazy\n\nimport org.jetbrains.kotlin.container.PlatformSpecificExtension\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.utils.KotlinExceptionWithAttachments\n\ninterface AbsentDescriptorHandler : PlatformSpecificExtension<AbsentDescriptorHandler> {\n    fun diagnoseDescriptorNotFound(declaration: KtDeclaration): DeclarationDescriptor\n}\n\nclass BasicAbsentDescriptorHandler : AbsentDescriptorHandler {\n    override fun diagnoseDescriptorNotFound(declaration: KtDeclaration) = throw NoDescriptorForDeclarationException(declaration)\n}\n\nclass NoDescriptorForDeclarationException @JvmOverloads constructor(declaration: KtDeclaration, additionalDetails: String? = null) :\n    KotlinExceptionWithAttachments(\n        \"Descriptor wasn't found for declaration $declaration\"\n                + (additionalDetails?.let { \"\\n---------------------------------------------------\\n$it\" } ?: \"\""}
{"code": ")\n    ) {\n    init {\n        withPsiAttachment(\"declaration.kt\", declaration)\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.calls.util\n\nimport org.jetbrains.kotlin.psi.*\n\nfun KtElement?.getCalleeExpressionIfAny(): KtExpression? =\n    when (val element = if (this is KtExpression) KtPsiUtil.deparenthesize(this) else this) {\n        is KtSimpleNameExpression -> element\n        is KtCallElement -> element.calleeExpression\n        is KtQualifiedExpression -> element.selectorExpression.getCalleeExpressionIfAny()\n        is KtOperationExpression -> element.operationReference\n        else -> null\n    }\n"}
{"code": "class MyProducer {\n    fun produce(): Int = 4\n}\n\nfun MyProducer.testFun(param1: Int = produce()) {\n    <expr>42</expr>\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.test.framework.services.libraries\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.PsiFile\nimport org.jetbrains.kotlin.analysis.api.impl.base.util.LibraryUtils\nimport org.jetbrains.kotlin.test.services.TestService\nimport org.jetbrains.kotlin.test.services.TestServices\nimport java.nio.file.Path\n\ninterface TestModuleDecompiler : TestService {\n    fun getAllPsiFilesFromLibrary(artifact: Path, project: Project): List<PsiFile>\n}\n\nval TestServices.testModuleDecompiler: TestModuleDecompiler by TestServices.testServiceAccessor()\n\nclass TestModuleDecompilerJar : TestModuleDecompiler {\n    override fun getAllPsiFilesFromLibrary(artifact: Path, project: Project): List<PsiFile> =\n        LibraryUtils.getAllPsiFilesFromJar(artifact, project)\n}\n"}
{"code": "// COMPILATION_ERRORS\nfun f() {\n    class C {\n        class X {\n            class YY {\n                fun aa() {}\n            }\n        }\n\n        \n        fun g() {\n\n        }\n    }\n}"}
{"code": "interface A<T> {\n   fun <R> foo(r: R)\n}\n\nfun call(a: A<String>) {\n   a.<expr>foo(1)</expr>\n}\n"}
{"code": "fun test() {\n    val x = try {\n        <expr>4</expr>\n    } catch (e: Exception) {\n        5\n    } finally {\n        9\n    }\n}"}
{"code": "// FULL_JDK\n// !DIAGNOSTICS: -UNUSED_VARIABLE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNUSED_PARAMETER -UNUSED_EXPRESSION\n// SKIP_TXT\n\n\n\n// FILE: TestCase1.kt\n// TESTCASE NUMBER: 1\npackage testsCase1\n\nclass Case() {\n    fun case(v: V) {\n        // InitializerTypeMismatchChecker bug\n        val va: () -> String = (V)::a\n\n        val vb: () -> String = (V)::b\n\n        val va1: () -> String = v::a\n        val vb1: () -> String = (V)::b\n\n    }\n\n    val V.Companion.b: String // (3)\n        get() = \"1\"\n\n}\n\nval V.a: String\n    get() = \"1\"\n\nval V.Companion.a: String\n    get() = \"1\"\n\n\nclass V {\n    companion object {\n        const val b: String = \"1\"\n    }\n}\n"}
{"code": "class DropDownComponent<T : Any>(val initialValues: List<T>)\n\nfun test(strings: List<String>) {\n    val dropDown = DropDownComponent(\n        initialValues = buildList {\n            addAll(strings)\n        }\n    )\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.visitors\n\nimport org.jetbrains.kotlin.fir.*\nimport org.jetbrains.kotlin.fir.contracts.*\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.diagnostics.FirDiagnosticHolder\nimport org.jetbrains.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.references.*\nimport org.jetbrains.kotlin.fir.types.*\n\n\nabstract class FirVisitor<out R, in D> {\n\n    abstract fun visitElement(element: FirElement, data: D): R\n\n    open fun visitAnnotationContainer(annotationContainer: FirAnnotationContainer, data: D): R =\n        visitElement(annotationContainer, data)\n\n    open fun visitTypeRef(typeRef: FirTypeRef, data: D): R =\n        visitElement(typeRef, data)\n\n    open fun visitReference(reference: FirReference, data: D): R =\n        visitElement(reference, data)\n\n    open fun visitLabel(label: FirLabel, data: D): R =\n "}
{"code": "       visitElement(label, data)\n\n    open fun visitResolvable(resolvable: FirResolvable, data: D): R =\n        visitElement(resolvable, data)\n\n    open fun visitTargetElement(targetElement: FirTargetElement, data: D): R =\n        visitElement(targetElement, data)\n\n    open fun visitDeclarationStatus(declarationStatus: FirDeclarationStatus, data: D): R =\n        visitElement(declarationStatus, data)\n\n    open fun visitResolvedDeclarationStatus(resolvedDeclarationStatus: FirResolvedDeclarationStatus, data: D): R =\n        visitElement(resolvedDeclarationStatus, data)\n\n    open fun visitControlFlowGraphOwner(controlFlowGraphOwner: FirControlFlowGraphOwner, data: D): R =\n        visitElement(controlFlowGraphOwner, data)\n\n    open fun visitStatement(statement: FirStatement, data: D): R =\n        visitElement(statement, data)\n\n    open fun visitExpression(expression: FirExpression, data: D): R =\n        visitElement(expression, data)\n\n    open fun visitLazyExpression(lazyExpression: FirLazy"}
{"code": "Expression, data: D): R =\n        visitElement(lazyExpression, data)\n\n    open fun visitContextReceiver(contextReceiver: FirContextReceiver, data: D): R =\n        visitElement(contextReceiver, data)\n\n    open fun visitElementWithResolveState(elementWithResolveState: FirElementWithResolveState, data: D): R =\n        visitElement(elementWithResolveState, data)\n\n    open fun visitDeclaration(declaration: FirDeclaration, data: D): R =\n        visitElement(declaration, data)\n\n    open fun visitTypeParameterRefsOwner(typeParameterRefsOwner: FirTypeParameterRefsOwner, data: D): R =\n        visitElement(typeParameterRefsOwner, data)\n\n    open fun visitTypeParametersOwner(typeParametersOwner: FirTypeParametersOwner, data: D): R =\n        visitElement(typeParametersOwner, data)\n\n    open fun visitMemberDeclaration(memberDeclaration: FirMemberDeclaration, data: D): R =\n        visitElement(memberDeclaration, data)\n\n    open fun visitAnonymousInitializer(anonymousInitializer: FirAnonymousInitializ"}
{"code": "er, data: D): R =\n        visitElement(anonymousInitializer, data)\n\n    open fun visitCallableDeclaration(callableDeclaration: FirCallableDeclaration, data: D): R =\n        visitElement(callableDeclaration, data)\n\n    open fun visitTypeParameterRef(typeParameterRef: FirTypeParameterRef, data: D): R =\n        visitElement(typeParameterRef, data)\n\n    open fun visitTypeParameter(typeParameter: FirTypeParameter, data: D): R =\n        visitElement(typeParameter, data)\n\n    open fun visitConstructedClassTypeParameterRef(constructedClassTypeParameterRef: FirConstructedClassTypeParameterRef, data: D): R =\n        visitElement(constructedClassTypeParameterRef, data)\n\n    open fun visitOuterClassTypeParameterRef(outerClassTypeParameterRef: FirOuterClassTypeParameterRef, data: D): R =\n        visitElement(outerClassTypeParameterRef, data)\n\n    open fun visitVariable(variable: FirVariable, data: D): R =\n        visitElement(variable, data)\n\n    open fun visitValueParameter(valueParameter: FirValu"}
{"code": "eParameter, data: D): R =\n        visitElement(valueParameter, data)\n\n    open fun visitReceiverParameter(receiverParameter: FirReceiverParameter, data: D): R =\n        visitElement(receiverParameter, data)\n\n    open fun visitProperty(property: FirProperty, data: D): R =\n        visitElement(property, data)\n\n    open fun visitField(field: FirField, data: D): R =\n        visitElement(field, data)\n\n    open fun visitEnumEntry(enumEntry: FirEnumEntry, data: D): R =\n        visitElement(enumEntry, data)\n\n    open fun visitFunctionTypeParameter(functionTypeParameter: FirFunctionTypeParameter, data: D): R =\n        visitElement(functionTypeParameter, data)\n\n    open fun visitClassLikeDeclaration(classLikeDeclaration: FirClassLikeDeclaration, data: D): R =\n        visitElement(classLikeDeclaration, data)\n\n    open fun visitClass(klass: FirClass, data: D): R =\n        visitElement(klass, data)\n\n    open fun visitRegularClass(regularClass: FirRegularClass, data: D): R =\n        visitElement(reg"}
{"code": "ularClass, data)\n\n    open fun visitTypeAlias(typeAlias: FirTypeAlias, data: D): R =\n        visitElement(typeAlias, data)\n\n    open fun visitFunction(function: FirFunction, data: D): R =\n        visitElement(function, data)\n\n    open fun visitContractDescriptionOwner(contractDescriptionOwner: FirContractDescriptionOwner, data: D): R =\n        visitElement(contractDescriptionOwner, data)\n\n    open fun visitSimpleFunction(simpleFunction: FirSimpleFunction, data: D): R =\n        visitElement(simpleFunction, data)\n\n    open fun visitPropertyAccessor(propertyAccessor: FirPropertyAccessor, data: D): R =\n        visitElement(propertyAccessor, data)\n\n    open fun visitBackingField(backingField: FirBackingField, data: D): R =\n        visitElement(backingField, data)\n\n    open fun visitConstructor(constructor: FirConstructor, data: D): R =\n        visitElement(constructor, data)\n\n    open fun visitFile(file: FirFile, data: D): R =\n        visitElement(file, data)\n\n    open fun visitScript(scrip"}
{"code": "t: FirScript, data: D): R =\n        visitElement(script, data)\n\n    open fun visitCodeFragment(codeFragment: FirCodeFragment, data: D): R =\n        visitElement(codeFragment, data)\n\n    open fun visitPackageDirective(packageDirective: FirPackageDirective, data: D): R =\n        visitElement(packageDirective, data)\n\n    open fun visitAnonymousFunction(anonymousFunction: FirAnonymousFunction, data: D): R =\n        visitElement(anonymousFunction, data)\n\n    open fun visitAnonymousFunctionExpression(anonymousFunctionExpression: FirAnonymousFunctionExpression, data: D): R =\n        visitElement(anonymousFunctionExpression, data)\n\n    open fun visitAnonymousObject(anonymousObject: FirAnonymousObject, data: D): R =\n        visitElement(anonymousObject, data)\n\n    open fun visitAnonymousObjectExpression(anonymousObjectExpression: FirAnonymousObjectExpression, data: D): R =\n        visitElement(anonymousObjectExpression, data)\n\n    open fun visitDiagnosticHolder(diagnosticHolder: FirDiagnosticHo"}
{"code": "lder, data: D): R =\n        visitElement(diagnosticHolder, data)\n\n    open fun visitImport(import: FirImport, data: D): R =\n        visitElement(import, data)\n\n    open fun visitResolvedImport(resolvedImport: FirResolvedImport, data: D): R =\n        visitElement(resolvedImport, data)\n\n    open fun visitLoop(loop: FirLoop, data: D): R =\n        visitElement(loop, data)\n\n    open fun visitErrorLoop(errorLoop: FirErrorLoop, data: D): R =\n        visitElement(errorLoop, data)\n\n    open fun visitDoWhileLoop(doWhileLoop: FirDoWhileLoop, data: D): R =\n        visitElement(doWhileLoop, data)\n\n    open fun visitWhileLoop(whileLoop: FirWhileLoop, data: D): R =\n        visitElement(whileLoop, data)\n\n    open fun visitBlock(block: FirBlock, data: D): R =\n        visitElement(block, data)\n\n    open fun visitLazyBlock(lazyBlock: FirLazyBlock, data: D): R =\n        visitElement(lazyBlock, data)\n\n    open fun visitBinaryLogicExpression(binaryLogicExpression: FirBinaryLogicExpression, data: D): R =\n   "}
{"code": "     visitElement(binaryLogicExpression, data)\n\n    open fun <E : FirTargetElement> visitJump(jump: FirJump<E>, data: D): R =\n        visitElement(jump, data)\n\n    open fun visitLoopJump(loopJump: FirLoopJump, data: D): R =\n        visitElement(loopJump, data)\n\n    open fun visitBreakExpression(breakExpression: FirBreakExpression, data: D): R =\n        visitElement(breakExpression, data)\n\n    open fun visitContinueExpression(continueExpression: FirContinueExpression, data: D): R =\n        visitElement(continueExpression, data)\n\n    open fun visitCatch(catch: FirCatch, data: D): R =\n        visitElement(catch, data)\n\n    open fun visitTryExpression(tryExpression: FirTryExpression, data: D): R =\n        visitElement(tryExpression, data)\n\n    open fun <T> visitLiteralExpression(literalExpression: FirLiteralExpression<T>, data: D): R =\n        visitElement(literalExpression, data)\n\n    open fun visitTypeProjection(typeProjection: FirTypeProjection, data: D): R =\n        visitElement(typePr"}
{"code": "ojection, data)\n\n    open fun visitStarProjection(starProjection: FirStarProjection, data: D): R =\n        visitElement(starProjection, data)\n\n    open fun visitPlaceholderProjection(placeholderProjection: FirPlaceholderProjection, data: D): R =\n        visitElement(placeholderProjection, data)\n\n    open fun visitTypeProjectionWithVariance(typeProjectionWithVariance: FirTypeProjectionWithVariance, data: D): R =\n        visitElement(typeProjectionWithVariance, data)\n\n    open fun visitArgumentList(argumentList: FirArgumentList, data: D): R =\n        visitElement(argumentList, data)\n\n    open fun visitCall(call: FirCall, data: D): R =\n        visitElement(call, data)\n\n    open fun visitAnnotation(annotation: FirAnnotation, data: D): R =\n        visitElement(annotation, data)\n\n    open fun visitAnnotationCall(annotationCall: FirAnnotationCall, data: D): R =\n        visitElement(annotationCall, data)\n\n    open fun visitAnnotationArgumentMapping(annotationArgumentMapping: FirAnnotationArgum"}
{"code": "entMapping, data: D): R =\n        visitElement(annotationArgumentMapping, data)\n\n    open fun visitErrorAnnotationCall(errorAnnotationCall: FirErrorAnnotationCall, data: D): R =\n        visitElement(errorAnnotationCall, data)\n\n    open fun visitComparisonExpression(comparisonExpression: FirComparisonExpression, data: D): R =\n        visitElement(comparisonExpression, data)\n\n    open fun visitTypeOperatorCall(typeOperatorCall: FirTypeOperatorCall, data: D): R =\n        visitElement(typeOperatorCall, data)\n\n    open fun visitAssignmentOperatorStatement(assignmentOperatorStatement: FirAssignmentOperatorStatement, data: D): R =\n        visitElement(assignmentOperatorStatement, data)\n\n    open fun visitIncrementDecrementExpression(incrementDecrementExpression: FirIncrementDecrementExpression, data: D): R =\n        visitElement(incrementDecrementExpression, data)\n\n    open fun visitEqualityOperatorCall(equalityOperatorCall: FirEqualityOperatorCall, data: D): R =\n        visitElement(equality"}
{"code": "OperatorCall, data)\n\n    open fun visitWhenExpression(whenExpression: FirWhenExpression, data: D): R =\n        visitElement(whenExpression, data)\n\n    open fun visitWhenBranch(whenBranch: FirWhenBranch, data: D): R =\n        visitElement(whenBranch, data)\n\n    open fun visitContextReceiverArgumentListOwner(contextReceiverArgumentListOwner: FirContextReceiverArgumentListOwner, data: D): R =\n        visitElement(contextReceiverArgumentListOwner, data)\n\n    open fun visitCheckNotNullCall(checkNotNullCall: FirCheckNotNullCall, data: D): R =\n        visitElement(checkNotNullCall, data)\n\n    open fun visitElvisExpression(elvisExpression: FirElvisExpression, data: D): R =\n        visitElement(elvisExpression, data)\n\n    open fun visitArrayLiteral(arrayLiteral: FirArrayLiteral, data: D): R =\n        visitElement(arrayLiteral, data)\n\n    open fun visitAugmentedArraySetCall(augmentedArraySetCall: FirAugmentedArraySetCall, data: D): R =\n        visitElement(augmentedArraySetCall, data)\n\n    open "}
{"code": "fun visitClassReferenceExpression(classReferenceExpression: FirClassReferenceExpression, data: D): R =\n        visitElement(classReferenceExpression, data)\n\n    open fun visitErrorExpression(errorExpression: FirErrorExpression, data: D): R =\n        visitElement(errorExpression, data)\n\n    open fun visitErrorFunction(errorFunction: FirErrorFunction, data: D): R =\n        visitElement(errorFunction, data)\n\n    open fun visitErrorProperty(errorProperty: FirErrorProperty, data: D): R =\n        visitElement(errorProperty, data)\n\n    open fun visitErrorPrimaryConstructor(errorPrimaryConstructor: FirErrorPrimaryConstructor, data: D): R =\n        visitElement(errorPrimaryConstructor, data)\n\n    open fun visitDanglingModifierList(danglingModifierList: FirDanglingModifierList, data: D): R =\n        visitElement(danglingModifierList, data)\n\n    open fun visitQualifiedAccessExpression(qualifiedAccessExpression: FirQualifiedAccessExpression, data: D): R =\n        visitElement(qualifiedAccessExpres"}
{"code": "sion, data)\n\n    open fun visitQualifiedErrorAccessExpression(qualifiedErrorAccessExpression: FirQualifiedErrorAccessExpression, data: D): R =\n        visitElement(qualifiedErrorAccessExpression, data)\n\n    open fun visitPropertyAccessExpression(propertyAccessExpression: FirPropertyAccessExpression, data: D): R =\n        visitElement(propertyAccessExpression, data)\n\n    open fun visitFunctionCall(functionCall: FirFunctionCall, data: D): R =\n        visitElement(functionCall, data)\n\n    open fun visitIntegerLiteralOperatorCall(integerLiteralOperatorCall: FirIntegerLiteralOperatorCall, data: D): R =\n        visitElement(integerLiteralOperatorCall, data)\n\n    open fun visitImplicitInvokeCall(implicitInvokeCall: FirImplicitInvokeCall, data: D): R =\n        visitElement(implicitInvokeCall, data)\n\n    open fun visitDelegatedConstructorCall(delegatedConstructorCall: FirDelegatedConstructorCall, data: D): R =\n        visitElement(delegatedConstructorCall, data)\n\n    open fun visitMultiDelegate"}
{"code": "dConstructorCall(multiDelegatedConstructorCall: FirMultiDelegatedConstructorCall, data: D): R =\n        visitElement(multiDelegatedConstructorCall, data)\n\n    open fun visitComponentCall(componentCall: FirComponentCall, data: D): R =\n        visitElement(componentCall, data)\n\n    open fun visitCallableReferenceAccess(callableReferenceAccess: FirCallableReferenceAccess, data: D): R =\n        visitElement(callableReferenceAccess, data)\n\n    open fun visitThisReceiverExpression(thisReceiverExpression: FirThisReceiverExpression, data: D): R =\n        visitElement(thisReceiverExpression, data)\n\n    open fun visitInaccessibleReceiverExpression(inaccessibleReceiverExpression: FirInaccessibleReceiverExpression, data: D): R =\n        visitElement(inaccessibleReceiverExpression, data)\n\n    open fun visitSmartCastExpression(smartCastExpression: FirSmartCastExpression, data: D): R =\n        visitElement(smartCastExpression, data)\n\n    open fun visitSafeCallExpression(safeCallExpression: FirSafeCal"}
{"code": "lExpression, data: D): R =\n        visitElement(safeCallExpression, data)\n\n    open fun visitCheckedSafeCallSubject(checkedSafeCallSubject: FirCheckedSafeCallSubject, data: D): R =\n        visitElement(checkedSafeCallSubject, data)\n\n    open fun visitGetClassCall(getClassCall: FirGetClassCall, data: D): R =\n        visitElement(getClassCall, data)\n\n    open fun visitWrappedExpression(wrappedExpression: FirWrappedExpression, data: D): R =\n        visitElement(wrappedExpression, data)\n\n    open fun visitWrappedArgumentExpression(wrappedArgumentExpression: FirWrappedArgumentExpression, data: D): R =\n        visitElement(wrappedArgumentExpression, data)\n\n    open fun visitSpreadArgumentExpression(spreadArgumentExpression: FirSpreadArgumentExpression, data: D): R =\n        visitElement(spreadArgumentExpression, data)\n\n    open fun visitNamedArgumentExpression(namedArgumentExpression: FirNamedArgumentExpression, data: D): R =\n        visitElement(namedArgumentExpression, data)\n\n    open fun "}
{"code": "visitVarargArgumentsExpression(varargArgumentsExpression: FirVarargArgumentsExpression, data: D): R =\n        visitElement(varargArgumentsExpression, data)\n\n    open fun visitSamConversionExpression(samConversionExpression: FirSamConversionExpression, data: D): R =\n        visitElement(samConversionExpression, data)\n\n    open fun visitResolvedQualifier(resolvedQualifier: FirResolvedQualifier, data: D): R =\n        visitElement(resolvedQualifier, data)\n\n    open fun visitErrorResolvedQualifier(errorResolvedQualifier: FirErrorResolvedQualifier, data: D): R =\n        visitElement(errorResolvedQualifier, data)\n\n    open fun visitResolvedReifiedParameterReference(resolvedReifiedParameterReference: FirResolvedReifiedParameterReference, data: D): R =\n        visitElement(resolvedReifiedParameterReference, data)\n\n    open fun visitReturnExpression(returnExpression: FirReturnExpression, data: D): R =\n        visitElement(returnExpression, data)\n\n    open fun visitStringConcatenationCall(stringC"}
{"code": "oncatenationCall: FirStringConcatenationCall, data: D): R =\n        visitElement(stringConcatenationCall, data)\n\n    open fun visitThrowExpression(throwExpression: FirThrowExpression, data: D): R =\n        visitElement(throwExpression, data)\n\n    open fun visitVariableAssignment(variableAssignment: FirVariableAssignment, data: D): R =\n        visitElement(variableAssignment, data)\n\n    open fun visitWhenSubjectExpression(whenSubjectExpression: FirWhenSubjectExpression, data: D): R =\n        visitElement(whenSubjectExpression, data)\n\n    open fun visitDesugaredAssignmentValueReferenceExpression(desugaredAssignmentValueReferenceExpression: FirDesugaredAssignmentValueReferenceExpression, data: D): R =\n        visitElement(desugaredAssignmentValueReferenceExpression, data)\n\n    open fun visitWrappedDelegateExpression(wrappedDelegateExpression: FirWrappedDelegateExpression, data: D): R =\n        visitElement(wrappedDelegateExpression, data)\n\n    open fun visitEnumEntryDeserializedAccessExpr"}
{"code": "ession(enumEntryDeserializedAccessExpression: FirEnumEntryDeserializedAccessExpression, data: D): R =\n        visitElement(enumEntryDeserializedAccessExpression, data)\n\n    open fun visitNamedReference(namedReference: FirNamedReference, data: D): R =\n        visitElement(namedReference, data)\n\n    open fun visitNamedReferenceWithCandidateBase(namedReferenceWithCandidateBase: FirNamedReferenceWithCandidateBase, data: D): R =\n        visitElement(namedReferenceWithCandidateBase, data)\n\n    open fun visitErrorNamedReference(errorNamedReference: FirErrorNamedReference, data: D): R =\n        visitElement(errorNamedReference, data)\n\n    open fun visitSuperReference(superReference: FirSuperReference, data: D): R =\n        visitElement(superReference, data)\n\n    open fun visitThisReference(thisReference: FirThisReference, data: D): R =\n        visitElement(thisReference, data)\n\n    open fun visitControlFlowGraphReference(controlFlowGraphReference: FirControlFlowGraphReference, data: D): R =\n  "}
{"code": "      visitElement(controlFlowGraphReference, data)\n\n    open fun visitResolvedNamedReference(resolvedNamedReference: FirResolvedNamedReference, data: D): R =\n        visitElement(resolvedNamedReference, data)\n\n    open fun visitResolvedErrorReference(resolvedErrorReference: FirResolvedErrorReference, data: D): R =\n        visitElement(resolvedErrorReference, data)\n\n    open fun visitDelegateFieldReference(delegateFieldReference: FirDelegateFieldReference, data: D): R =\n        visitElement(delegateFieldReference, data)\n\n    open fun visitBackingFieldReference(backingFieldReference: FirBackingFieldReference, data: D): R =\n        visitElement(backingFieldReference, data)\n\n    open fun visitResolvedCallableReference(resolvedCallableReference: FirResolvedCallableReference, data: D): R =\n        visitElement(resolvedCallableReference, data)\n\n    open fun visitResolvedTypeRef(resolvedTypeRef: FirResolvedTypeRef, data: D): R =\n        visitElement(resolvedTypeRef, data)\n\n    open fun visitE"}
{"code": "rrorTypeRef(errorTypeRef: FirErrorTypeRef, data: D): R =\n        visitElement(errorTypeRef, data)\n\n    open fun visitTypeRefWithNullability(typeRefWithNullability: FirTypeRefWithNullability, data: D): R =\n        visitElement(typeRefWithNullability, data)\n\n    open fun visitUserTypeRef(userTypeRef: FirUserTypeRef, data: D): R =\n        visitElement(userTypeRef, data)\n\n    open fun visitDynamicTypeRef(dynamicTypeRef: FirDynamicTypeRef, data: D): R =\n        visitElement(dynamicTypeRef, data)\n\n    open fun visitFunctionTypeRef(functionTypeRef: FirFunctionTypeRef, data: D): R =\n        visitElement(functionTypeRef, data)\n\n    open fun visitIntersectionTypeRef(intersectionTypeRef: FirIntersectionTypeRef, data: D): R =\n        visitElement(intersectionTypeRef, data)\n\n    open fun visitImplicitTypeRef(implicitTypeRef: FirImplicitTypeRef, data: D): R =\n        visitElement(implicitTypeRef, data)\n\n    open fun visitContractElementDeclaration(contractElementDeclaration: FirContractElementDeclar"}
{"code": "ation, data: D): R =\n        visitElement(contractElementDeclaration, data)\n\n    open fun visitEffectDeclaration(effectDeclaration: FirEffectDeclaration, data: D): R =\n        visitElement(effectDeclaration, data)\n\n    open fun visitContractDescription(contractDescription: FirContractDescription, data: D): R =\n        visitElement(contractDescription, data)\n\n    open fun visitLegacyRawContractDescription(legacyRawContractDescription: FirLegacyRawContractDescription, data: D): R =\n        visitElement(legacyRawContractDescription, data)\n\n    open fun visitRawContractDescription(rawContractDescription: FirRawContractDescription, data: D): R =\n        visitElement(rawContractDescription, data)\n\n    open fun visitResolvedContractDescription(resolvedContractDescription: FirResolvedContractDescription, data: D): R =\n        visitElement(resolvedContractDescription, data)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cli.common.modules\n\nimport org.jetbrains.kotlin.modules.JavaRootPath\nimport org.jetbrains.kotlin.modules.Module\nimport java.util.*\n\nclass ModuleBuilder(\n    private val name: String,\n    private val outputDir: String,\n    private val type: String\n) : Module {\n    private val sourceFiles = ArrayList<String>()\n    private val commonSourceFiles = ArrayList<String>()\n    private val classpathRoots = ArrayList<String>()\n    private val javaSourceRoots = ArrayList<JavaRootPath>()\n    private val friendDirs = ArrayList<String>()\n    override var modularJdkRoot: String? = null\n\n    fun addSourceFiles(path: String) {\n        sourceFiles.add(path)\n    }\n\n    fun addCommonSourceFiles(path: String) {\n        commonSourceFiles.add(path)\n    }\n\n    fun addClasspathEntry(path: String) {\n        classpathRoots.add(path)\n    }\n\n    fun addJavaSourceRoot(rootPath: JavaRootPath) {\n        javaSourceRoots.add(rootPath)\n    }\n\n    fun addFriendDir(friendDir: String) {\n       "}
{"code": " friendDirs.add(friendDir)\n    }\n\n    override fun getOutputDirectory(): String = outputDir\n    override fun getFriendPaths(): List<String> = friendDirs\n    override fun getJavaSourceRoots(): List<JavaRootPath> = javaSourceRoots\n    override fun getSourceFiles(): List<String> = sourceFiles\n    override fun getCommonSourceFiles(): List<String> = commonSourceFiles\n    override fun getClasspathRoots(): List<String> = classpathRoots\n    override fun getModuleName(): String = name\n    override fun getModuleType(): String = type\n\n    override fun toString() = \"$name ($type)\"\n}\n"}
{"code": "// FILE: Base.java\n\npublic class Base {\n    protected String foo() { return \"\"; }\n}\n\n// FILE: O.kt\n\nopen class Wrapper(val b: Boolean)\n\nobject O {\n    private class Derived(private val bar: Int) : Base() {\n        private inner class Some(val z: Boolean) {\n            fun test() {\n                val x = bar\n                val o = object : Wrapper(z) {\n                    fun local() {\n                        val y = foo()\n                    }\n                    val oo = object {\n                        val zz = z\n                    }\n                }\n            }\n        }\n        fun test() {\n            val x = bar\n            val o = object {\n                fun local() {\n                    val y = foo()\n                }\n            }\n        }\n    }\n}\n\nclass Generator(val codegen: Any) {\n    private fun gen(): Any =\n        object : Wrapper(true) {\n            private fun invokeFunction() {\n                val c = codegen\n                val cc = codegen.hashCode()\n       "}
{"code": "     }\n        }\n}\n"}
{"code": "fun foo() {}\n\nclass C {\n    fun bar() {}\n    fun err() {}\n\n    class Nested {\n        fun test() {\n            <!UNRESOLVED_REFERENCE!>err<!>()\n        }\n    }\n}\n\nfun test() {\n    val c = C()\n    foo()\n    c.bar()\n\n    val err = C()\n    err.<!UNRESOLVED_REFERENCE!>foo<!>()\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.impl.base.test.cases.annotations\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.annotations.KtAnnotationsList\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtAnnotatedSymbol\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.test.framework.services.expressionMarkerProvider\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.assertions\n\nabstract class AbstractAnalysisApiAnnotationsOnDeclarationsTest : AbstractAnalysisApiBasedTest() {\n\n    context(KtAnalysisSession)\n    open fun renderAnnotations(annotations: KtAnnotationsList): String = TestAnnotationRenderer.renderAnnotations(annotations)\n\n    overr"}
{"code": "ide fun doTestByMainFile(mainFile: KtFile, mainModule: KtTestModule, testServices: TestServices) {\n        val ktDeclaration = testServices.expressionMarkerProvider.getElementOfTypeAtCaret<KtDeclaration>(mainFile)\n        val actual = analyseForTest(ktDeclaration) {\n            val declarationSymbol = ktDeclaration.getSymbol() as KtAnnotatedSymbol\n            buildString {\n                appendLine(\"KtDeclaration: ${ktDeclaration::class.simpleName} ${ktDeclaration.name}\")\n                append(renderAnnotations(declarationSymbol.annotationsList))\n            }\n        }\n\n        testServices.assertions.assertEqualsToTestDataFileSibling(actual)\n    }\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cfg.pseudocode.instructions.special\n\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.*\nimport org.jetbrains.kotlin.psi.KtElement\nimport java.util.*\n\nclass SubroutineExitInstruction(\n    val subroutine: KtElement,\n    blockScope: BlockScope,\n    val isError: Boolean\n) : InstructionImpl(blockScope) {\n    private var _sink: SubroutineSinkInstruction? = null\n\n    var sink: SubroutineSinkInstruction\n        get() = _sink!!\n        set(value: SubroutineSinkInstruction) {\n            _sink = outgoingEdgeTo(value) as SubroutineSinkInstruction\n        }\n\n    override val nextInstructions: Collection<Instruction>\n        get() = Collections.singleton(sink)\n\n    override fun accept(visitor: InstructionVisitor) {\n        visitor.visitSubroutineExit(this)\n    }\n\n    override fun <R> accept(visitor: InstructionVisitorWithResult<R>): R = visitor.visitSubroutineExit(this)\n\n    override fun toString(): String = if (isError) \"<ERROR>\" else \"<END>\"\n\n    override fun"}
{"code": " createCopy(): InstructionImpl =\n        SubroutineExitInstruction(subroutine, blockScope, isError)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.utils.errors\n\nimport org.jetbrains.kotlin.utils.exceptions.errorWithAttachment\n\npublic fun unexpectedElementError(elementName: String, element: Any?): Nothing {\n    errorWithAttachment(\"Unexpected $elementName ${element?.let { it::class.simpleName }}\") {\n        withEntry(elementName, element) { element.toString() }\n    }\n}\n\npublic inline fun <reified ELEMENT> unexpectedElementError(element: Any?): Nothing {\n    unexpectedElementError(ELEMENT::class.simpleName ?: ELEMENT::class.java.name, element)\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.wasm.checkers\n\nimport org.jetbrains.kotlin.fir.analysis.checkers.type.FirDynamicUnsupportedChecker\nimport org.jetbrains.kotlin.fir.analysis.checkers.type.FirTypeRefChecker\nimport org.jetbrains.kotlin.fir.analysis.checkers.type.TypeCheckers\n\nobject WasmBaseTypeCheckers : TypeCheckers() {\n    override val typeRefCheckers: Set<FirTypeRefChecker>\n        get() = setOf(\n            FirDynamicUnsupportedChecker,\n        )\n}\n"}
{"code": "fun test() {\n    class Local\n\n    val l = Local()\n}\n"}
{"code": "// FILE: A.java\n\npublic class A {\n    public int x;\n\n    public String getX() {\n        return \"\"\n    }\n}\n\n// FILE: main.kt\n\nfun test(a: A) {\n    val int = a.x // <- should be int\n    val string = a.getX()\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.daemon.common\n\nimport java.io.File\nimport java.io.Serializable\n\nclass CompileIterationResult(\n    @Suppress(\"unused\") // used in Gradle\n        val sourceFiles: Iterable<File>,\n    @Suppress(\"unused\") // used in Gradle\n        val exitCode: String\n) : Serializable {\n    companion object {\n        const val serialVersionUID: Long = 0\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.calls.checkers\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.descriptors.ModuleDescriptor\nimport org.jetbrains.kotlin.descriptors.SimpleFunctionDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.psi.KtConstantExpression\nimport org.jetbrains.kotlin.psi.KtExpression\nimport org.jetbrains.kotlin.psi.KtPsiUtil\nimport org.jetbrains.kotlin.psi.KtUnaryExpression\nimport org.jetbrains.kotlin.resolve.BindingContext\nimport org.jetbrains.kotlin.resolve.BindingTrace\nimport org.jetbrains.kotlin.resolve.calls.components.isVararg\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\nimport org.jetbrains.kotlin.resolve.calls.util.getResolvedCall\nimport org.jetbrains.kotlin.resolve.constants.ErrorValue\nimport org.jetbrains.kotlin.resolve.constants.IntegerLiteralTypeConstructor\nimport org.jetbrains.kotlin.resolve.constants.Int"}
{"code": "egerValueTypeConstant\nimport org.jetbrains.kotlin.resolve.constants.TypedCompileTimeConstant\nimport org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe\nimport org.jetbrains.kotlin.types.*\nimport org.jetbrains.kotlin.types.typeUtil.*\n\nobject NewSchemeOfIntegerOperatorResolutionChecker : CallChecker {\n    override fun check(resolvedCall: ResolvedCall<*>, reportOn: PsiElement, context: CallCheckerContext) {\n        for ((valueParameter, arguments) in resolvedCall.valueArguments) {\n            val expectedType = if (valueParameter.isVararg) {\n                valueParameter.varargElementType ?: continue\n            } else {\n                valueParameter.type\n            }.unwrap().lowerIfFlexible()\n            if (!needToCheck(expectedType)) {\n                continue\n            }\n            for (argument in arguments.arguments) {\n                val expression = KtPsiUtil.deparenthesize(argument.getArgumentExpression()) ?: continue\n                checkArgumentImpl(expectedType, expr"}
{"code": "ession, context.trace, context.moduleDescriptor)\n            }\n        }\n    }\n\n    @JvmStatic\n    fun checkArgument(\n        expectedType: KotlinType,\n        argument: KtExpression,\n        trace: BindingTrace,\n        moduleDescriptor: ModuleDescriptor\n    ) {\n        if (needToCheck(expectedType)) {\n            checkArgumentImpl(expectedType.lowerIfFlexible(), KtPsiUtil.deparenthesize(argument)!!, trace, moduleDescriptor)\n        }\n    }\n\n    fun needToCheck(expectedType: KotlinType): Boolean {\n        if (TypeUtils.noExpectedType(expectedType)) return false\n        return expectedType.lowerIfFlexible().isPrimitiveNumberOrNullableType()\n    }\n\n    private fun checkArgumentImpl(\n        expectedType: SimpleType,\n        argumentExpression: KtExpression,\n        trace: BindingTrace,\n        moduleDescriptor: ModuleDescriptor\n    ) {\n        val bindingContext = trace.bindingContext\n        val callForArgument = argumentExpression.getResolvedCall(bindingContext) ?: return\n        if ("}
{"code": "!callForArgument.isIntOperator()) return\n        val callElement = callForArgument.call.callElement as? KtExpression ?: return\n        val deparenthesizedElement = KtPsiUtil.deparenthesize(callElement)!!\n        if (deparenthesizedElement is KtConstantExpression) return\n        if (deparenthesizedElement is KtUnaryExpression) {\n            val token = deparenthesizedElement.operationToken\n            if (token == KtTokens.PLUS || token == KtTokens.MINUS) return\n        }\n\n        val compileTimeValue = bindingContext[BindingContext.COMPILE_TIME_VALUE, argumentExpression] ?: return\n\n        val newExpressionType = when (compileTimeValue) {\n            is IntegerValueTypeConstant -> {\n                val currentExpressionType = compileTimeValue.unknownIntegerType\n                val valueTypeConstructor = currentExpressionType.constructor as? IntegerLiteralTypeConstructor ?: return\n                valueTypeConstructor.getApproximatedType()\n            }\n            is TypedCompileTimeCon"}
{"code": "stant -> {\n                val typeFromCall = callForArgument.resultingDescriptor.returnType?.lowerIfFlexible()\n                if (typeFromCall != null) {\n                    typeFromCall\n                } else {\n                    val constantValue = compileTimeValue.constantValue\n                    if (constantValue is ErrorValue) return\n                    // Values of all numeric constants are held in Long value\n                    val value = constantValue.value as? Long ?: return\n                    IntegerLiteralTypeConstructor(value, moduleDescriptor, compileTimeValue.parameters).getApproximatedType()\n                }\n            }\n            else -> return\n        }\n        if (newExpressionType.constructor != expectedType.constructor) {\n            val willBeConversion = newExpressionType.isInt() && expectedType.makeNotNullable().isLong()\n            if (!willBeConversion) {\n                trace.report(Errors.INTEGER_OPERATOR_RESOLVE_WILL_CHANGE.on(argumentExpression, n"}
{"code": "ewExpressionType))\n            }\n        }\n    }\n\n    private fun ResolvedCall<*>.isIntOperator(): Boolean {\n        val descriptor = resultingDescriptor as? SimpleFunctionDescriptor ?: return false\n        return descriptor.fqNameSafe in literalOperatorsFqNames\n    }\n\n    private val literalOperatorsFqNames: Set<FqName> = listOf(\n        \"plus\", \"minus\", \"times\", \"div\", \"rem\", \"plus\", \"minus\",\n        \"times\", \"div\", \"rem\", \"shl\", \"shr\", \"ushr\", \"and\", \"or\",\n        \"xor\", \"unaryPlus\", \"unaryMinus\", \"inv\",\n    ).mapTo(mutableSetOf()) { FqName.fromSegments(listOf(\"kotlin\", \"Int\", it)) }\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.calls.checkers\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.builtins.KotlinBuiltIns\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.psi.KtBinaryExpression\nimport org.jetbrains.kotlin.resolve.BindingContext\nimport org.jetbrains.kotlin.resolve.calls.context.ResolutionContext\nimport org.jetbrains.kotlin.resolve.calls.inference.BuilderInferenceSession\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\nimport org.jetbrains.kotlin.resolve.isInlineClassType\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.kotlin.types.TypeIntersector\nimport org.jetbrains.kotlin.types.checkEnumsForCompatibility\nimport org.jetbrains.kotlin.types.checker.KotlinTypeChecker\nimport org.jetbrains.kotlin.types.expressions.OperatorConventions\nimport org.jetbrains.kotlin.types.expressions.SenselessComparisonChecker.checkSenselessComparisonWithNull\nimport org."}
{"code": "jetbrains.kotlin.types.typeUtil.builtIns\nimport org.jetbrains.kotlin.util.OperatorNameConventions\n\nobject EqualityCallChecker : CallChecker {\n    override fun check(resolvedCall: ResolvedCall<*>, reportOn: PsiElement, context: CallCheckerContext) {\n        val callExpression = resolvedCall.call.callElement as? KtBinaryExpression ?: return\n        val operationType = callExpression.operationReference.getReferencedNameElementType()\n\n        if (operationType in OperatorConventions.EQUALS_OPERATIONS) {\n            checkEquality(resolvedCall, callExpression, context.resolutionContext)\n        }\n    }\n\n    private fun checkEquality(resolvedCall: ResolvedCall<*>, expression: KtBinaryExpression, context: ResolutionContext<*>) {\n        val returnType = resolvedCall.resultingDescriptor.returnType ?: return\n        val builtIns = returnType.builtIns\n\n        if (!builtIns.isBooleanOrSubtype(returnType)) {\n            context.trace.report(\n                Errors.RESULT_TYPE_MISMATCH.on(\n        "}
{"code": "            expression.operationReference,\n                    \"'${OperatorNameConventions.EQUALS}'\",\n                    builtIns.booleanType,\n                    returnType\n                )\n            )\n            return\n        }\n\n        ensureNonemptyIntersectionOfOperandTypes(expression, context)\n    }\n\n    // We check identity equality separately because we don't have a call for it\n    fun checkIdentityEquality(expression: KtBinaryExpression, context: ResolutionContext<*>) {\n        ensureNonemptyIntersectionOfOperandTypes(expression, context)\n        checkIdentityOnPrimitiveOrInlineClassTypes(expression, context)\n    }\n\n    private fun checkIdentityOnPrimitiveOrInlineClassTypes(expression: KtBinaryExpression, context: ResolutionContext<*>) {\n        val left = expression.left ?: return\n        val right = expression.right ?: return\n\n        val leftType = context.trace.getType(left) ?: return\n        val rightType = context.trace.getType(right) ?: return\n\n        if (KotlinT"}
{"code": "ypeChecker.DEFAULT.equalTypes(leftType, rightType)) {\n            if (KotlinBuiltIns.isPrimitiveType(leftType)) {\n                context.trace.report(Errors.DEPRECATED_IDENTITY_EQUALS.on(expression, leftType, rightType))\n            }\n        } else if (isIdentityComparedWithImplicitBoxing(leftType, rightType) || isIdentityComparedWithImplicitBoxing(rightType, leftType)) {\n            context.trace.report(Errors.IMPLICIT_BOXING_IN_IDENTITY_EQUALS.on(expression, leftType, rightType))\n        }\n        if (leftType.isInlineClassType() || rightType.isInlineClassType()) {\n            context.trace.report(Errors.FORBIDDEN_IDENTITY_EQUALS.on(expression, leftType, rightType))\n        }\n    }\n\n    private fun isIdentityComparedWithImplicitBoxing(leftType: KotlinType, rightType: KotlinType) =\n        KotlinBuiltIns.isPrimitiveType(leftType)\n                && !KotlinBuiltIns.isPrimitiveType(rightType)\n                && KotlinTypeChecker.DEFAULT.isSubtypeOf(leftType, rightType)\n\n    private fu"}
{"code": "n ensureNonemptyIntersectionOfOperandTypes(expression: KtBinaryExpression, context: ResolutionContext<*>) {\n        val left = expression.left ?: return\n        val right = expression.right ?: return\n\n        val leftType = context.trace.getType(left) ?: return\n        val rightType = context.trace.getType(right) ?: return\n\n        if (TypeIntersector.isIntersectionEmpty(leftType, rightType)) {\n            val isProperEqualityChecksEnabled =\n                context.languageVersionSettings.supportsFeature(LanguageFeature.ProperEqualityChecksInBuilderInferenceCalls)\n            val shouldReportWarnings = !isProperEqualityChecksEnabled\n                    && context.inferenceSession is BuilderInferenceSession\n                    && context.trace.get(BindingContext.MARKED_EQUALIY_CALL_PROPER_IN_BUILDER_INFERENCE, expression) != null\n            val diagnostic = if (shouldReportWarnings) Errors.EQUALITY_NOT_APPLICABLE_WARNING else Errors.EQUALITY_NOT_APPLICABLE\n\n            context.trace.re"}
{"code": "port(diagnostic.on(expression, expression.operationReference, leftType, rightType))\n        } else {\n            checkEnumsForCompatibility(context, expression, leftType, rightType)\n        }\n\n        checkSenselessComparisonWithNull(\n            expression, left, right, context, context.trace::getType, context.dataFlowInfo::getStableNullability\n        )\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.util\n\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.PackageFragmentDescriptor\nimport org.jetbrains.kotlin.descriptors.containingPackage\nimport org.jetbrains.kotlin.incremental.KotlinLookupLocation\nimport org.jetbrains.kotlin.incremental.components.EnumWhenTracker\nimport org.jetbrains.kotlin.incremental.components.LookupTracker\nimport org.jetbrains.kotlin.incremental.record\nimport org.jetbrains.kotlin.psi.KtExpression\nimport org.jetbrains.kotlin.psi.KtNameReferenceExpression\nimport org.jetbrains.kotlin.psi.KtWhenEntry\nimport org.jetbrains.kotlin.resolve.DescriptorUtils\nimport org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.kotlin.types.isError\nimport org.jetbrains.kotlin.types.typeUtil.isUnit\n\nfun LookupTracker.record(expression: KtExpression, type: KotlinType) {\n    if (type.isError || type.isUnit()) return\n\n    val typeDescriptor = t"}
{"code": "ype.constructor.declarationDescriptor ?: return\n    val scopeDescriptor = typeDescriptor.containingDeclaration\n\n    // Scope descriptor is function descriptor only when type is local\n    // Lookups for local types are not needed since all usages are compiled with the type\n    when {\n        scopeDescriptor is PackageFragmentDescriptor && !DescriptorUtils.isLocal(typeDescriptor) -> {\n            record(KotlinLookupLocation(expression), scopeDescriptor, typeDescriptor.name)\n        }\n        scopeDescriptor is ClassDescriptor && !DescriptorUtils.isLocal(typeDescriptor) -> {\n            record(KotlinLookupLocation(expression), scopeDescriptor, typeDescriptor.name)\n        }\n    }\n\n    for (typeArgument in type.arguments) {\n        if (!typeArgument.isStarProjection) {\n            record(expression, typeArgument.type)\n        }\n    }\n}\n\nfun EnumWhenTracker.record(subjectType: KotlinType?, subjectExpression: KtExpression, elseEntry: KtWhenEntry?) {\n    if (elseEntry != null) return\n    if ("}
{"code": "subjectExpression !is KtNameReferenceExpression) return\n\n    val declarationDescriptor = subjectType?.constructor?.declarationDescriptor ?: return\n    val containingPackage = declarationDescriptor.containingPackage()?.toString() ?: return\n    val fqName = declarationDescriptor.fqNameSafe.asString()\n    val filePath = subjectExpression.containingFile.virtualFile?.path ?: return\n    val owner = if (fqName.startsWith(\"$containingPackage.\")) {\n        containingPackage + \".\" + fqName.substring(containingPackage.length + 1).replace(\".\", \"$\")\n    } else {\n        fqName.replace(\".\", \"$\")\n    }\n\n    this.report(filePath, owner)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.load.java\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.PsiPackage\nimport com.intellij.psi.search.GlobalSearchScope\nimport org.jetbrains.kotlin.load.java.structure.JavaClass\nimport org.jetbrains.kotlin.load.java.structure.JavaPackage\nimport org.jetbrains.kotlin.load.java.structure.impl.JavaPackageImpl\nimport org.jetbrains.kotlin.load.java.structure.impl.source.JavaElementSourceFactory\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.resolve.jvm.KotlinJavaPsiFacade\nimport javax.inject.Inject\n\nfun Project.createJavaClassFinder(scope: GlobalSearchScope): JavaClassFinder =\n    JavaClassFinderImpl().apply {\n        setProjectInstance(this@createJavaClassFinder)\n        setScope(scope)\n    }\n\nclass JavaClassFinderImpl : AbstractJavaClassFinder() {\n    private lateinit var javaFacade: KotlinJavaPsiFacade\n\n    @Inject\n    override fun setProjectInstance(project: Project) {\n        super.setProjectInstance(project)\n       "}
{"code": " javaFacade = KotlinJavaPsiFacade.getInstance(project)\n    }\n\n    override fun findClass(request: JavaClassFinder.Request): JavaClass? {\n        return javaFacade.findClass(request, javaSearchScope)\n    }\n\n    override fun findClasses(request: JavaClassFinder.Request): List<JavaClass> {\n        return javaFacade.findClasses(request, javaSearchScope)\n    }\n\n    override fun findPackage(fqName: FqName, mayHaveAnnotations: Boolean): JavaPackage? {\n        return javaFacade.findPackage(fqName.asString(), javaSearchScope)\n            ?.let { createJavaPackage(it, mayHaveAnnotations) }\n    }\n\n    private fun createJavaPackage(\n        psiPackage: PsiPackage,\n        mayHaveAnnotations: Boolean,\n    ): JavaPackageImpl {\n        val project = javaFacade.project\n        val sourceFactory = JavaElementSourceFactory.getInstance(project)\n        return JavaPackageImpl(sourceFactory.createPsiSource(psiPackage), javaSearchScope, mayHaveAnnotations)\n    }\n\n    override fun knownClassNamesInPackage(pa"}
{"code": "ckageFqName: FqName): Set<String>? {\n        return javaFacade.knownClassNamesInPackage(packageFqName, javaSearchScope)\n    }\n\n    override fun canComputeKnownClassNamesInPackage(): Boolean {\n        return javaFacade.canComputeKnownClassNamesInPackage()\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.descriptors.components\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.analysis.api.components.KtExpressionTypeProvider\nimport org.jetbrains.kotlin.analysis.api.descriptors.Fe10AnalysisContext\nimport org.jetbrains.kotlin.analysis.api.descriptors.Fe10AnalysisFacade.AnalysisMode\nimport org.jetbrains.kotlin.analysis.api.descriptors.KtFe10AnalysisSession\nimport org.jetbrains.kotlin.analysis.api.descriptors.components.base.Fe10KtAnalysisSessionComponent\nimport org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.toKtType\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken\nimport org.jetbrains.kotlin.analysis.api.types.KtErrorType\nimport org.jetbrains.kotlin.analysis.api.types.KtFunctionalType\nimport org.jetbrains.kotlin.analysis.api.types.KtType\nimport org.jetbrains.kotlin.descriptors.CallableDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.lexer.KtTokens\nimpo"}
{"code": "rt org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.psi.psiUtil.*\nimport org.jetbrains.kotlin.resolve.BindingContext\nimport org.jetbrains.kotlin.resolve.calls.components.isVararg\nimport org.jetbrains.kotlin.resolve.calls.inference.returnTypeOrNothing\nimport org.jetbrains.kotlin.resolve.calls.smartcasts.MultipleSmartCasts\nimport org.jetbrains.kotlin.resolve.calls.smartcasts.SingleSmartCast\nimport org.jetbrains.kotlin.resolve.calls.util.getParameterForArgument\nimport org.jetbrains.kotlin.resolve.calls.util.getResolvedCall\nimport org.jetbrains.kotlin.resolve.calls.util.getType\nimport org.jetbrains.kotlin.resolve.sam.SamConstructorDescriptor\nimport org.jetbrains.kotlin.resolve.sam.getFunctionTypeForAbstractMethod\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.kotlin.types.TypeUtils\nimport org.jetbrains.kotlin.types.checker.intersectWrappedTypes\nimport org.jetbrains.kotlin.types.error.ErrorTypeKind\nimport org.jetbrains.kotlin.types.error.ErrorUtils\nimport org.jetbra"}
{"code": "ins.kotlin.types.typeUtil.makeNullable\n\nclass KtFe10ExpressionTypeProvider(\n    override val analysisSession: KtFe10AnalysisSession\n) : KtExpressionTypeProvider(), Fe10KtAnalysisSessionComponent {\n    private companion object {\n        val NON_EXPRESSION_CONTAINERS = arrayOf(\n            KtImportDirective::class.java,\n            KtTypeReference::class.java,\n            KtPackageDirective::class.java,\n            KtLabelReferenceExpression::class.java\n        )\n    }\n\n    override val token: KtLifetimeToken\n        get() = analysisSession.token\n\n    override fun getKtExpressionType(expression: KtExpression): KtType? {\n        // Not sure if it's safe enough. In theory, some annotations on expressions might change its type\n        val unwrapped = expression.unwrapParenthesesLabelsAndAnnotations() as? KtExpression ?: return null\n        if (unwrapped.getParentOfTypes(false, *NON_EXPRESSION_CONTAINERS) != null) {\n            return null\n        }\n\n        val bindingContext = analysisCont"}
{"code": "ext.analyze(unwrapped, AnalysisMode.PARTIAL)\n        val smartCastType = when (val smartCastType = bindingContext[BindingContext.SMARTCAST, expression]) {\n            is SingleSmartCast -> smartCastType.type\n            is MultipleSmartCasts -> intersectWrappedTypes(smartCastType.map.values)\n            else -> null\n        }\n        val kotlinType = smartCastType ?: expression.getType(bindingContext) ?: analysisContext.builtIns.unitType\n        return kotlinType.toKtType(analysisContext)\n    }\n\n    override fun getReturnTypeForKtDeclaration(declaration: KtDeclaration): KtType {\n        // Handle callable declarations with explicit return type first\n        if (declaration is KtCallableDeclaration) {\n            val typeReference = declaration.typeReference\n\n            if (typeReference != null) {\n                val bindingContext = analysisContext.analyze(typeReference, AnalysisMode.PARTIAL)\n                val kotlinType =\n                    if (declaration is KtParameter && decla"}
{"code": "ration.isVarArg) {\n                        // we want full Array<out T> type for parity with FIR implementation\n                        bindingContext[BindingContext.VALUE_PARAMETER, declaration]?.returnType\n                    } else {\n                        bindingContext[BindingContext.TYPE, typeReference]\n                    } ?: ErrorUtils.createErrorType(ErrorTypeKind.RETURN_TYPE, typeReference.text)\n\n                return kotlinType.toKtType(analysisContext)\n            }\n        }\n\n        if (declaration is KtFunction && declaration !is KtConstructor<*> && declaration.equalsToken != null) {\n            val bindingContext = analysisContext.analyze(declaration)\n            val kotlinType = bindingContext[BindingContext.FUNCTION, declaration]?.returnType\n                ?: ErrorUtils.createErrorType(ErrorTypeKind.IMPLICIT_RETURN_TYPE_FOR_FUNCTION, declaration.name ?: \"<unknown>\")\n\n            return kotlinType.toKtType(analysisContext)\n        }\n\n        if (declaration is KtPr"}
{"code": "operty) {\n            val bindingContext = analysisContext.analyze(declaration)\n            val kotlinType = bindingContext[BindingContext.VARIABLE, declaration]?.returnType\n                ?: ErrorUtils.createErrorType(ErrorTypeKind.IMPLICIT_RETURN_TYPE_FOR_PROPERTY, declaration.name ?: \"<unknown>\")\n\n            return kotlinType.toKtType(analysisContext)\n        }\n\n        if (declaration is KtPropertyAccessor) {\n            val bindingContext = analysisContext.analyze(declaration)\n            val kotlinType = bindingContext[BindingContext.PROPERTY_ACCESSOR, declaration]?.returnType\n                ?: ErrorUtils.createErrorType(\n                    ErrorTypeKind.IMPLICIT_RETURN_TYPE_FOR_PROPERTY_ACCESSOR, declaration.property.name ?: \"<unknown>\"\n                )\n\n            return kotlinType.toKtType(analysisContext)\n        }\n\n        // Manually handle custom setter parameter\n        if (declaration is KtParameter) {\n            val parameterList = declaration.parent as? KtParame"}
{"code": "terList\n            if (parameterList?.parameters?.singleOrNull() == declaration) {\n                val propertyAccessor = parameterList.parent as? KtPropertyAccessor\n                val property = propertyAccessor?.parent as? KtProperty\n                if (property != null && property.setter == propertyAccessor) {\n                    val bindingContext = analysisContext.analyze(property)\n                    val kotlinType = bindingContext[BindingContext.VARIABLE, property]?.returnType\n                        ?: ErrorUtils.createErrorType(ErrorTypeKind.RETURN_TYPE_FOR_PROPERTY, declaration.name ?: \"<unknown>\")\n\n                    return kotlinType.toKtType(analysisContext)\n                }\n            }\n        }\n\n        if (declaration is KtConstructor<*>) {\n            val bindingContext = analysisContext.analyze(declaration)\n            val kotlinType = bindingContext[BindingContext.CONSTRUCTOR, declaration]?.returnType\n                ?: ErrorUtils.createErrorType(\n             "}
{"code": "       ErrorTypeKind.RETURN_TYPE_FOR_CONSTRUCTOR, declaration.containingClass()?.name ?: \"<unknown>\"\n                )\n            return kotlinType.toKtType(analysisContext)\n        }\n\n        return analysisContext.builtIns.unitType.toKtType(analysisContext)\n    }\n\n    override fun getFunctionalTypeForKtFunction(declaration: KtFunction): KtType {\n        val analysisMode = if (declaration.hasDeclaredReturnType()) AnalysisMode.PARTIAL else AnalysisMode.FULL\n        val bindingContext = analysisContext.analyze(declaration, analysisMode)\n        val functionDescriptor = bindingContext[BindingContext.FUNCTION, declaration]\n\n        if (functionDescriptor != null) {\n            return getFunctionTypeForAbstractMethod(functionDescriptor, false).toKtType(analysisContext)\n        }\n\n        val parameterCount = declaration.valueParameters.size + (if (declaration.isExtensionDeclaration()) 1 else 0)\n\n        val function = when {\n            declaration.hasModifier(KtTokens.SUSPEND_KEYWORD) ->"}
{"code": " analysisContext.builtIns.getSuspendFunction(parameterCount)\n            else -> analysisContext.builtIns.getFunction(parameterCount)\n        }\n\n        val errorMessage = \"Descriptor not found for function \\\"${declaration.name}\\\"\"\n        return ErrorUtils.createErrorType(ErrorTypeKind.NOT_FOUND_DESCRIPTOR_FOR_FUNCTION, function.typeConstructor, errorMessage)\n            .toKtType(analysisContext)\n    }\n\n    override fun getExpectedType(expression: PsiElement): KtType? {\n        val ktExpression = expression.getParentOfType<KtExpression>(false) ?: return null\n        val parentExpression = if (ktExpression.parent is KtLabeledExpression) {\n            // lambda -> labeled expression -> lambda argument (value argument)\n            ktExpression.parent.parent\n        } else {\n            ktExpression.parent\n        }\n\n        // Unwrap specific expressions\n        when (ktExpression) {\n            is KtNameReferenceExpression -> {\n                if (parentExpression is KtDotQualifiedExpr"}
{"code": "ession && parentExpression.selectorExpression == ktExpression) {\n                    return getExpectedType(parentExpression)\n                }\n            }\n            is KtFunctionLiteral -> {\n                return getExpectedType(ktExpression.parent)\n            }\n        }\n\n        when (parentExpression) {\n            is KtCallableDeclaration -> {\n                if (expression is KtBlockExpression) {\n                    return null\n                }\n\n                if (parentExpression.typeReference == null) return null\n\n                val bindingContext = analysisContext.analyze(parentExpression)\n                val descriptor = bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, parentExpression]\n                if (descriptor is CallableDescriptor) {\n                    return descriptor.returnType?.toKtNonErrorType(analysisContext)\n                }\n            }\n\n            is KtBinaryExpressionWithTypeRHS -> {\n                val typeReference = parentExpression.r"}
{"code": "ight\n                if (KtPsiUtil.isCast(parentExpression) && typeReference != null) {\n                    val bindingContext = analysisContext.analyze(typeReference)\n                    var kotlinType = bindingContext[BindingContext.TYPE, typeReference]\n                    if (kotlinType != null && KtPsiUtil.isSafeCast(parentExpression)) {\n                        kotlinType = kotlinType.makeNullable()\n                    }\n                    return kotlinType?.toKtNonErrorType(analysisContext)\n                }\n            }\n\n            is KtValueArgument -> {\n                val callExpression = getContainingCallExpression(parentExpression)\n                if (callExpression != null) {\n                    val bindingContext = analysisContext.analyze(callExpression)\n                    val resolvedCall = callExpression.getResolvedCall(bindingContext)\n                    if (resolvedCall != null) {\n                        val parameterDescriptor = resolvedCall.getParameterForArgumen"}
{"code": "t(parentExpression)?.original\n                        if (parameterDescriptor != null) {\n                            val kotlinType = when (val originalCallableDescriptor = parameterDescriptor.containingDeclaration) {\n                                is SamConstructorDescriptor -> originalCallableDescriptor.returnTypeOrNothing\n                                else -> {\n                                    if (parameterDescriptor.isVararg)\n                                        parameterDescriptor.varargElementType\n                                    else\n                                        parameterDescriptor.type\n                                }\n                            }\n                            return kotlinType?.toKtNonErrorType(analysisContext)\n                        }\n                    }\n                }\n            }\n\n            is KtWhenConditionWithExpression -> {\n                val whenExpression = (parentExpression.parent as? KtWhenEntry)?.parent as? KtWhenExp"}
{"code": "ression\n                if (whenExpression != null) {\n                    val subject = whenExpression.subjectExpression ?: return with(analysisSession) { builtinTypes.BOOLEAN }\n                    val kotlinType = analysisContext.analyze(subject).getType(subject)\n                    return kotlinType?.toKtNonErrorType(analysisContext)\n                }\n            }\n\n            is KtBlockExpression -> {\n                if (expression == parentExpression.statements.lastOrNull()) {\n                    val functionLiteral = parentExpression.parent as? KtFunctionLiteral\n                    if (functionLiteral != null) {\n                        val functionalType = getExpectedType(functionLiteral) as? KtFunctionalType\n                        functionalType?.returnType?.let { return it }\n                    }\n                }\n            }\n\n            is KtWhenEntry -> {\n                if (expression == parentExpression.expression) {\n                    val whenExpression = parentExpres"}
{"code": "sion.parent as? KtWhenExpression\n                    if (whenExpression != null) {\n                        getExpectedType(whenExpression)?.let { return it }\n\n                        val entries = whenExpression.entries\n                        val entryExpressions = entries.mapNotNull { entry -> entry.expression?.takeUnless { expression == it } }\n                        val kotlinTypes = entryExpressions.mapNotNull { analysisContext.analyze(it).getType(it) }\n                        return intersectWrappedTypes(kotlinTypes).toKtNonErrorType(analysisContext)\n                    }\n                }\n            }\n        }\n\n        val bindingContext = analysisContext.analyze(ktExpression)\n        val kotlinType = bindingContext[BindingContext.EXPECTED_EXPRESSION_TYPE, ktExpression]\n        return kotlinType?.toKtNonErrorType(analysisContext)\n    }\n\n    private fun getContainingCallExpression(argument: KtValueArgument): KtCallExpression? {\n        return when (val parent = argument.parent)"}
{"code": " {\n            is KtCallExpression -> parent\n            is KtValueArgumentList -> parent.parent as? KtCallExpression\n            else -> null\n        }\n    }\n\n    override fun isDefinitelyNull(expression: KtExpression): Boolean {\n        val unwrapped = expression.unwrapParenthesesLabelsAndAnnotations() as? KtElement ?: return false\n        val bindingContext = analysisContext.analyze(expression, AnalysisMode.PARTIAL)\n\n        if (bindingContext[BindingContext.SMARTCAST_NULL, expression] == true) {\n            return true\n        }\n\n        for (diagnostic in bindingContext.diagnostics.forElement(unwrapped)) {\n            if (diagnostic.factory == Errors.ALWAYS_NULL) {\n                return true\n            }\n        }\n\n        return false\n    }\n\n    override fun isDefinitelyNotNull(expression: KtExpression): Boolean {\n        val bindingContext = analysisContext.analyze(expression)\n\n        val smartCasts = bindingContext[BindingContext.SMARTCAST, expression]\n\n        if (smartCast"}
{"code": "s is MultipleSmartCasts) {\n            if (smartCasts.map.values.all { !it.isMarkedNullable }) {\n                return true\n            }\n        }\n\n        val smartCastType = smartCasts?.defaultType\n        if (smartCastType != null && !smartCastType.isMarkedNullable) {\n            return true\n        }\n\n        val expressionType = expression.getType(bindingContext) ?: return false\n        return !TypeUtils.isNullableType(expressionType)\n    }\n\n    private fun KotlinType.toKtNonErrorType(analysisContext: Fe10AnalysisContext): KtType? =\n        this.toKtType(analysisContext).takeUnless { it is KtErrorType }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.transformers.body.resolve\n\nimport org.jetbrains.kotlin.*\nimport org.jetbrains.kotlin.descriptors.ClassKind\nimport org.jetbrains.kotlin.fir.*\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.declarations.utils.isExternal\nimport org.jetbrains.kotlin.fir.declarations.utils.isLocal\nimport org.jetbrains.kotlin.fir.diagnostics.*\nimport org.jetbrains.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.expressions.FirOperation.*\nimport org.jetbrains.kotlin.fir.expressions.builder.*\nimport org.jetbrains.kotlin.fir.expressions.impl.FirResolvedArgumentList\nimport org.jetbrains.kotlin.fir.expressions.impl.toAnnotationArgumentMapping\nimport org.jetbrains.kotlin.fir.extensions.*\nimport org.jetbrains.kotlin.fir.references.*\nimport org.jetbrains.kotlin.fir.references.builder.buildErrorNamedReference\nimport org.jetbrains.kotlin.fir.references.builder.buildExplicitSuperReference\nimport org.jetbrains.kotlin.fir.references.build"}
{"code": "er.buildResolvedNamedReference\nimport org.jetbrains.kotlin.fir.references.builder.buildSimpleNamedReference\nimport org.jetbrains.kotlin.fir.references.impl.FirSimpleNamedReference\nimport org.jetbrains.kotlin.fir.resolve.*\nimport org.jetbrains.kotlin.fir.resolve.calls.*\nimport org.jetbrains.kotlin.fir.resolve.diagnostics.*\nimport org.jetbrains.kotlin.fir.resolve.substitution.ConeSubstitutor\nimport org.jetbrains.kotlin.fir.resolve.transformers.replaceLambdaArgumentInvocationKinds\nimport org.jetbrains.kotlin.fir.scopes.impl.isWrappedIntegerOperator\nimport org.jetbrains.kotlin.fir.scopes.impl.isWrappedIntegerOperatorForUnsignedType\nimport org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.fir.types.builder.buildErrorTypeRef\nimport org.jetbrains.kotlin.fir.visitors.FirDefaultTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.TransformData\nimport org.jetbrains.ko"}
{"code": "tlin.fir.visitors.transformSingle\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.name.SpecialNames\nimport org.jetbrains.kotlin.name.StandardClassIds\nimport org.jetbrains.kotlin.resolve.calls.inference.buildAbstractResultingSubstitutor\nimport org.jetbrains.kotlin.types.AbstractTypeChecker\nimport org.jetbrains.kotlin.types.ConstantValueKind\nimport org.jetbrains.kotlin.types.TypeApproximatorConfiguration\nimport org.jetbrains.kotlin.util.OperatorNameConventions\nimport org.jetbrains.kotlin.util.PrivateForInline\n\nopen class FirExpressionsResolveTransformer(transformer: FirAbstractBodyResolveTransformerDispatcher) :\n    FirPartialBodyResolveTransformer(transformer) {\n    private inline val builtinTypes: BuiltinTypes get() = session.builtinTypes\n    private val arrayOfCallTransformer = FirArrayOfCallTransformer()\n    var enableArrayOfCallTransformation = false\n    var containingSafeCallExpression: FirSafeCallExpression? = null\n\n    private val expressionResolutionExtensions "}
{"code": "= session.extensionService.expressionResolutionExtensions.takeIf { it.isNotEmpty() }\n    private val assignAltererExtensions = session.extensionService.assignAltererExtensions.takeIf { it.isNotEmpty() }\n    @OptIn(FirExtensionApiInternals::class)\n    private val callRefinementExtensions = session.extensionService.callRefinementExtensions.takeIf { it.isNotEmpty() }\n\n    init {\n        @Suppress(\"LeakingThis\")\n        components.callResolver.initTransformer(this)\n    }\n\n    override fun transformExpression(expression: FirExpression, data: ResolutionMode): FirStatement {\n        if (!expression.isResolved && expression !is FirWrappedExpression) {\n            expression.resultType = ConeErrorType(\n                ConeSimpleDiagnostic(\n                    \"Type calculating for ${expression::class} is not supported\",\n                    DiagnosticKind.InferenceError\n                )\n            )\n        }\n        return (expression.transformChildren(transformer, data) as FirStatement)\n    "}
{"code": "}\n\n    override fun transformSmartCastExpression(smartCastExpression: FirSmartCastExpression, data: ResolutionMode): FirStatement {\n        return smartCastExpression\n    }\n\n    override fun transformQualifiedAccessExpression(\n        qualifiedAccessExpression: FirQualifiedAccessExpression,\n        data: ResolutionMode,\n    ): FirStatement = whileAnalysing(session, qualifiedAccessExpression) {\n        transformQualifiedAccessExpression(qualifiedAccessExpression, data, isUsedAsReceiver = false, isUsedAsGetClassReceiver = false)\n    }\n\n    private fun transformQualifiedAccessExpression(\n        qualifiedAccessExpression: FirQualifiedAccessExpression,\n        data: ResolutionMode,\n        isUsedAsReceiver: Boolean,\n        isUsedAsGetClassReceiver: Boolean,\n    ): FirExpression {\n        if (qualifiedAccessExpression.isResolved && qualifiedAccessExpression.calleeReference !is FirSimpleNamedReference) {\n            return qualifiedAccessExpression\n        }\n\n        qualifiedAccessExpressi"}
{"code": "on.transformAnnotations(this, data)\n        qualifiedAccessExpression.transformTypeArguments(transformer, ResolutionMode.ContextIndependent)\n\n        var result = when (val callee = qualifiedAccessExpression.calleeReference) {\n            is FirThisReference -> {\n                val labelName = callee.labelName\n                val implicitReceiver = implicitReceiverStack[labelName]\n                implicitReceiver?.let {\n                    callee.replaceBoundSymbol(it.boundSymbol)\n                    if (it is ContextReceiverValue) {\n                        callee.replaceContextReceiverNumber(it.contextReceiverNumber)\n                    }\n                }\n                val implicitType = implicitReceiver?.originalType\n                val resultType: ConeKotlinType = when {\n                    implicitReceiver is InaccessibleImplicitReceiverValue -> ConeErrorType(ConeInstanceAccessBeforeSuperCall(\"<this>\"))\n                    implicitType != null -> implicitType\n                  "}
{"code": "  labelName != null -> ConeErrorType(ConeSimpleDiagnostic(\"Unresolved this@$labelName\", DiagnosticKind.UnresolvedLabel))\n                    else -> ConeErrorType(ConeSimpleDiagnostic(\"'this' is not defined in this context\", DiagnosticKind.NoThis))\n                }\n                (resultType as? ConeErrorType)?.diagnostic?.let {\n                    callee.replaceDiagnostic(it)\n                }\n\n                // For situations like:\n                // buildList {\n                //    val myList: MutableList<String> = this\n                // }\n                // We need to add a constraint `MutableList<Ev> <: MutableList<String>`\n                data.expectedType?.coneTypeOrNull?.let { expectedType ->\n                    context.inferenceSession.addSubtypeConstraintIfCompatible(\n                        lowerType = resultType,\n                        upperType = expectedType,\n                        qualifiedAccessExpression,\n                    )\n                }\n\n                "}
{"code": "qualifiedAccessExpression.resultType = resultType\n                qualifiedAccessExpression\n            }\n            is FirSuperReference -> {\n                transformSuperReceiver(\n                    callee,\n                    qualifiedAccessExpression,\n                    containingSafeCallExpression?.takeIf { qualifiedAccessExpression == it.receiver }?.selector as? FirQualifiedAccessExpression\n                )\n            }\n            is FirDelegateFieldReference -> {\n                val delegateFieldSymbol = callee.resolvedSymbol\n                qualifiedAccessExpression.resultType = delegateFieldSymbol.fir.delegate!!.resolvedType\n                qualifiedAccessExpression\n            }\n            is FirResolvedNamedReference,\n            is FirErrorNamedReference -> {\n                if (!qualifiedAccessExpression.isResolved) {\n                    storeTypeFromCallee(qualifiedAccessExpression, isLhsOfAssignment = false)\n                }\n                qualifiedAccessExpres"}
{"code": "sion\n            }\n            else -> {\n                val transformedCallee = resolveQualifiedAccessAndSelectCandidate(\n                    qualifiedAccessExpression,\n                    isUsedAsReceiver,\n                    isUsedAsGetClassReceiver,\n                    // Set the correct call site. For assignment LHSs, it's the assignment, otherwise it's the qualified access itself.\n                    callSite = when (data) {\n                        is ResolutionMode.AssignmentLValue -> data.variableAssignment\n                        else -> qualifiedAccessExpression\n                    },\n                    data,\n                )\n\n                fun FirExpression.alsoRecordLookup() = also {\n                    if (transformedCallee.isResolved) {\n                        session.lookupTracker?.recordTypeResolveAsLookup(\n                            transformedCallee.resolvedType, callee.source, components.file.source\n                        )\n                    }\n               "}
{"code": " }\n\n                // NB: here we can get raw expression because of dropped qualifiers (see transform callee),\n                // so candidate existence must be checked before calling completion\n                if (transformedCallee is FirQualifiedAccessExpression && transformedCallee.candidate() != null) {\n                    if (!transformedCallee.isAcceptableResolvedQualifiedAccess()) {\n                        return qualifiedAccessExpression.alsoRecordLookup()\n                    }\n                    callCompleter.completeCall(transformedCallee, data)\n                } else {\n                    transformedCallee\n                }.alsoRecordLookup()\n            }\n        }\n\n        // If we're resolving the LHS of an assignment, skip DFA to prevent the access being treated as a variable read and\n        // smart-casts being applied.\n        if (data !is ResolutionMode.AssignmentLValue) {\n            when (result) {\n                is FirQualifiedAccessExpression -> {\n            "}
{"code": "        dataFlowAnalyzer.exitQualifiedAccessExpression(result)\n                    result = components.transformQualifiedAccessUsingSmartcastInfo(result)\n                    if (result is FirSmartCastExpression) {\n                        dataFlowAnalyzer.exitSmartCastExpression(result)\n                    }\n                }\n                is FirResolvedQualifier -> {\n                    dataFlowAnalyzer.exitResolvedQualifierNode(result)\n                }\n            }\n        }\n        return result\n    }\n\n    fun <Q : FirQualifiedAccessExpression> transformExplicitReceiverOf(qualifiedAccessExpression: Q): Q {\n        val explicitReceiver = qualifiedAccessExpression.explicitReceiver\n        if (explicitReceiver is FirQualifiedAccessExpression) {\n            val superReference = explicitReceiver.calleeReference as? FirSuperReference\n            if (superReference != null) {\n                transformSuperReceiver(superReference, explicitReceiver, qualifiedAccessExpression)\n            "}
{"code": "    return qualifiedAccessExpression\n            }\n        }\n\n        if (explicitReceiver != null) {\n            qualifiedAccessExpression.replaceExplicitReceiver(\n                explicitReceiver.transformAsExplicitReceiver(ResolutionMode.ReceiverResolution, isUsedAsGetClassReceiver = false)\n            )\n        }\n\n        return qualifiedAccessExpression\n    }\n\n    private fun FirExpression.transformAsExplicitReceiver(\n        resolutionMode: ResolutionMode,\n        isUsedAsGetClassReceiver: Boolean,\n    ): FirExpression {\n        return when (this) {\n            is FirPropertyAccessExpression -> transformQualifiedAccessExpression(\n                this, resolutionMode, isUsedAsReceiver = true, isUsedAsGetClassReceiver = isUsedAsGetClassReceiver\n            )\n            else -> transformSingle(this@FirExpressionsResolveTransformer, resolutionMode)\n        }\n    }\n\n    override fun transformPropertyAccessExpression(\n        propertyAccessExpression: FirPropertyAccessExpression,\n    "}
{"code": "    data: ResolutionMode\n    ): FirStatement {\n        return transformQualifiedAccessExpression(propertyAccessExpression, data)\n    }\n\n    protected open fun resolveQualifiedAccessAndSelectCandidate(\n        qualifiedAccessExpression: FirQualifiedAccessExpression,\n        isUsedAsReceiver: Boolean,\n        isUsedAsGetClassReceiver: Boolean,\n        callSite: FirElement,\n        data: ResolutionMode,\n    ): FirExpression {\n        return callResolver.resolveVariableAccessAndSelectCandidate(\n            qualifiedAccessExpression, isUsedAsReceiver, isUsedAsGetClassReceiver, callSite, data\n        )\n    }\n\n    fun transformSuperReceiver(\n        superReference: FirSuperReference,\n        superReferenceContainer: FirQualifiedAccessExpression,\n        containingCall: FirQualifiedAccessExpression?\n    ): FirQualifiedAccessExpression {\n        val labelName = superReference.labelName\n        val lastDispatchReceiver = implicitReceiverStack.lastDispatchReceiver()\n        val implicitReceiver ="}
{"code": "\n            // Only report label issues if the label is set and the receiver stack is not empty\n            if (labelName != null && lastDispatchReceiver != null) {\n                val labeledReceiver = implicitReceiverStack[labelName] as? ImplicitDispatchReceiverValue\n                if (labeledReceiver == null) {\n                    return markSuperReferenceError(\n                        ConeSimpleDiagnostic(\"Unresolved label\", DiagnosticKind.UnresolvedLabel),\n                        superReferenceContainer,\n                        superReference\n                    )\n                }\n                labeledReceiver\n            } else {\n                lastDispatchReceiver\n            }\n        implicitReceiver?.receiverExpression?.let {\n            superReferenceContainer.replaceDispatchReceiver(it)\n        }\n        val superTypeRefs = implicitReceiver?.boundSymbol?.fir?.superTypeRefs\n        val superTypeRef = superReference.superTypeRef\n        when {\n            containingCall"}
{"code": " == null -> {\n                val superNotAllowedDiagnostic = ConeSimpleDiagnostic(\"Super not allowed\", DiagnosticKind.SuperNotAllowed)\n                return markSuperReferenceError(superNotAllowedDiagnostic, superReferenceContainer, superReference)\n            }\n            implicitReceiver == null || superTypeRefs == null || superTypeRefs.isEmpty() -> {\n                val diagnostic =\n                    if (implicitReceiverStack.lastOrNull() is InaccessibleImplicitReceiverValue) {\n                        ConeInstanceAccessBeforeSuperCall(\"<super>\")\n                    } else {\n                        ConeSimpleDiagnostic(\"Super not available\", DiagnosticKind.SuperNotAvailable)\n                    }\n                return markSuperReferenceError(diagnostic, superReferenceContainer, superReference)\n            }\n            superTypeRef is FirResolvedTypeRef -> {\n                superReferenceContainer.resultType = superTypeRef.type\n            }\n            superTypeRef !is FirImpl"}
{"code": "icitTypeRef -> {\n                components.typeResolverTransformer.withBareTypes {\n                    superReference.transformChildren(transformer, ResolutionMode.ContextIndependent)\n                }\n\n                val actualSuperType = (superReference.superTypeRef.coneType as? ConeClassLikeType)\n                    ?.fullyExpandedType(session)?.let { superType ->\n                        val classId = superType.lookupTag.classId\n                        val correspondingDeclaredSuperType = superTypeRefs.firstOrNull {\n                            it.coneType.fullyExpandedType(session).classId == classId\n                        }?.coneTypeSafe<ConeClassLikeType>()?.fullyExpandedType(session) ?: return@let null\n\n                        if (superType.typeArguments.isEmpty() && correspondingDeclaredSuperType.typeArguments.isNotEmpty() ||\n                            superType == correspondingDeclaredSuperType\n                        ) {\n                            correspondingDeclaredSup"}
{"code": "erType\n                        } else {\n                            null\n                        }\n                    }\n                \n                val actualSuperTypeRef = actualSuperType?.toFirResolvedTypeRef(superTypeRef.source, superTypeRef) ?: buildErrorTypeRef {\n                    source = superTypeRef.source\n                    diagnostic = ConeSimpleDiagnostic(\"Not a super type\", DiagnosticKind.NotASupertype)\n                    annotations = superTypeRef.annotations.toMutableList()\n                }\n                superReferenceContainer.resultType = actualSuperTypeRef.type\n                superReference.replaceSuperTypeRef(actualSuperTypeRef)\n            }\n            else -> {\n                val types = components.findTypesForSuperCandidates(superTypeRefs, containingCall)\n                val resultType = when (types.size) {\n                    0 -> buildErrorTypeRef {\n                        source = superReferenceContainer.source\n                        // Errors o"}
{"code": "n the callee will be reported, no reason to also report on the error type ref.\n                        diagnostic =\n                            ConeUnreportedDuplicateDiagnostic(ConeSimpleDiagnostic(\"Unresolved super method\", DiagnosticKind.Other))\n                    }\n                    1 -> types.single().toFirResolvedTypeRef(superReferenceContainer.source?.fakeElement(KtFakeSourceElementKind.SuperCallImplicitType))\n                    else -> buildErrorTypeRef {\n                        source = superReferenceContainer.source\n                        diagnostic = ConeAmbiguousSuper(types)\n                    }\n                }\n                superReferenceContainer.resultType = resultType.type\n                superReference.replaceSuperTypeRef(resultType)\n            }\n        }\n        return superReferenceContainer\n    }\n\n    private fun markSuperReferenceError(\n        superNotAvailableDiagnostic: ConeDiagnostic,\n        superReferenceContainer: FirQualifiedAccessExpression,\n  "}
{"code": "      superReference: FirSuperReference\n    ): FirQualifiedAccessExpression {\n        val resultType = buildErrorTypeRef {\n            diagnostic = superNotAvailableDiagnostic\n        }\n        superReferenceContainer.resultType = resultType.type\n        superReference.replaceSuperTypeRef(resultType)\n        superReferenceContainer.replaceCalleeReference(buildErrorNamedReference {\n            source = superReferenceContainer.source?.fakeElement(KtFakeSourceElementKind.ReferenceInAtomicQualifiedAccess)\n            diagnostic = superNotAvailableDiagnostic\n        })\n        return superReferenceContainer\n    }\n\n    protected open fun FirQualifiedAccessExpression.isAcceptableResolvedQualifiedAccess(): Boolean {\n        return true\n    }\n\n    override fun transformSafeCallExpression(\n        safeCallExpression: FirSafeCallExpression,\n        data: ResolutionMode\n    ): FirStatement {\n        whileAnalysing(session, safeCallExpression) {\n            withContainingSafeCallExpression(safeCall"}
{"code": "Expression) {\n                safeCallExpression.transformAnnotations(this, ResolutionMode.ContextIndependent)\n                safeCallExpression.transformReceiver(this, ResolutionMode.ContextIndependent)\n\n                val receiver = safeCallExpression.receiver\n\n                dataFlowAnalyzer.enterSafeCallAfterNullCheck(safeCallExpression)\n\n                safeCallExpression.apply {\n                    checkedSubjectRef.value.propagateTypeFromOriginalReceiver(receiver, components.session, components.file)\n                    transformSelector(this@FirExpressionsResolveTransformer, data)\n                    propagateTypeFromQualifiedAccessAfterNullCheck(session, context.file)\n                }\n\n                dataFlowAnalyzer.exitSafeCall(safeCallExpression)\n\n                return safeCallExpression\n            }\n        }\n    }\n\n    private inline fun <T> withContainingSafeCallExpression(safeCallExpression: FirSafeCallExpression, block: () -> T): T {\n        val old = containing"}
{"code": "SafeCallExpression\n        try {\n            containingSafeCallExpression = safeCallExpression\n            return block()\n        } finally {\n            containingSafeCallExpression = old\n        }\n    }\n\n    override fun transformCheckedSafeCallSubject(\n        checkedSafeCallSubject: FirCheckedSafeCallSubject,\n        data: ResolutionMode\n    ): FirStatement {\n        return checkedSafeCallSubject\n    }\n\n    override fun transformFunctionCall(functionCall: FirFunctionCall, data: ResolutionMode): FirStatement =\n        transformFunctionCallInternal(functionCall, data, CallResolutionMode.REGULAR)\n\n    internal enum class CallResolutionMode {\n        REGULAR,\n\n        \n        PROVIDE_DELEGATE,\n\n        \n        OPTION_FOR_AUGMENTED_ASSIGNMENT,\n    }\n\n    internal fun transformFunctionCallInternal(\n        functionCall: FirFunctionCall,\n        data: ResolutionMode,\n        callResolutionMode: CallResolutionMode,\n    ): FirStatement =\n        whileAnalysing(session, functionCall) {\n   "}
{"code": "         val calleeReference = functionCall.calleeReference\n            if (\n                (calleeReference is FirResolvedNamedReference || calleeReference is FirErrorNamedReference) &&\n                !functionCall.isResolved\n            ) {\n                storeTypeFromCallee(functionCall, isLhsOfAssignment = false)\n            }\n            if (calleeReference is FirNamedReferenceWithCandidate) return functionCall\n            if (calleeReference !is FirSimpleNamedReference) {\n                // The callee reference can be resolved as an error very early, e.g., `super` as a callee during raw FIR creation.\n                // We still need to visit/transform other parts, e.g., call arguments, to check if any other errors are there.\n                if (calleeReference !is FirResolvedNamedReference) {\n                    functionCall.transformChildren(transformer, ResolutionMode.ContextIndependent)\n                }\n                return functionCall\n            }\n            function"}
{"code": "Call.transformAnnotations(transformer, data)\n            functionCall.replaceLambdaArgumentInvocationKinds(session)\n            functionCall.transformTypeArguments(transformer, ResolutionMode.ContextIndependent)\n            val choosingOptionForAugmentedAssignment = callResolutionMode == CallResolutionMode.OPTION_FOR_AUGMENTED_ASSIGNMENT\n            val withTransformedArguments = if (!choosingOptionForAugmentedAssignment) {\n                dataFlowAnalyzer.enterCallArguments(functionCall, functionCall.arguments)\n                // In provideDelegate mode the explicitReceiver is already resolved\n                // E.g. we have val some by someDelegate\n                // At 1st stage of delegate inference we resolve someDelegate itself,\n                // at 2nd stage in provideDelegate mode we are trying to resolve someDelegate.provideDelegate(),\n                // and 'someDelegate' explicit receiver is resolved at 1st stage\n                // See also FirDeclarationsResolveTransformer"}
{"code": ".transformWrappedDelegateExpression\n                val withResolvedExplicitReceiver =\n                    if (callResolutionMode == CallResolutionMode.PROVIDE_DELEGATE) functionCall else transformExplicitReceiverOf(functionCall)\n                withResolvedExplicitReceiver.also {\n                    dataFlowAnalyzer.exitCallExplicitReceiver()\n                    it.replaceArgumentList(it.argumentList.transform(this, ResolutionMode.ContextDependent))\n                    dataFlowAnalyzer.exitCallArguments()\n                }\n            } else {\n                functionCall\n            }\n\n            val resultExpression = callResolver.resolveCallAndSelectCandidate(withTransformedArguments, data)\n\n            val completeInference = callCompleter.completeCall(\n                resultExpression, data,\n                skipEvenPartialCompletion = choosingOptionForAugmentedAssignment,\n            )\n            var result = completeInference.transformToIntegerOperatorCallOrApproximateItIfNeed"}
{"code": "ed(data)\n            if (!choosingOptionForAugmentedAssignment) {\n                dataFlowAnalyzer.exitFunctionCall(result, data.forceFullCompletion)\n            }\n            @OptIn(FirExtensionApiInternals::class)\n            if (callRefinementExtensions != null) {\n                val reference = result.calleeReference\n                if (reference is FirResolvedNamedReference) {\n                    val callData = reference.resolvedSymbol.fir.originalCallDataForPluginRefinedCall\n                    if (callData != null) {\n                        result = callData.extension.transform(result, callData.originalSymbol)\n                    }\n                }\n            }\n\n            addReceiversFromExtensions(result)\n\n            if (enableArrayOfCallTransformation) {\n                return arrayOfCallTransformer.transformFunctionCall(result, session)\n            }\n            return result\n        }\n\n    @OptIn(PrivateForInline::class)\n    private fun addReceiversFromExtensions(functi"}
{"code": "onCall: FirFunctionCall) {\n        val extensions = expressionResolutionExtensions ?: return\n        val boundSymbol = context.containerIfAny?.symbol as? FirCallableSymbol<*> ?: return\n        for (extension in extensions) {\n            for (receiverType in extension.addNewImplicitReceivers(functionCall)) {\n                val receiverValue = ImplicitExtensionReceiverValue(\n                    boundSymbol,\n                    receiverType,\n                    session,\n                    scopeSession\n                )\n                context.addReceiver(name = null, receiverValue)\n            }\n        }\n    }\n\n    private fun FirFunctionCall.transformToIntegerOperatorCallOrApproximateItIfNeeded(resolutionMode: ResolutionMode): FirFunctionCall {\n        if (!explicitReceiver.isIntegerLiteralOrOperatorCall()) return this\n        val resolvedSymbol = calleeReference.toResolvedNamedFunctionSymbol() ?: return this\n        if (!resolvedSymbol.isWrappedIntegerOperator()) return this\n\n       "}
{"code": " val arguments = this.argumentList.arguments\n        val argument = when (arguments.size) {\n            0 -> null\n            1 -> arguments.first()\n            else -> return this\n        }\n        assert(argument?.isIntegerLiteralOrOperatorCall() != false)\n\n        val originalCall = this\n\n        val integerOperatorType = ConeIntegerConstantOperatorTypeImpl(\n            isUnsigned = resolvedSymbol.isWrappedIntegerOperatorForUnsignedType(),\n            ConeNullability.NOT_NULL\n        )\n\n        val approximationIsNeeded =\n            resolutionMode !is ResolutionMode.ReceiverResolution && resolutionMode !is ResolutionMode.ContextDependent\n\n        val integerOperatorCall = buildIntegerLiteralOperatorCall {\n            source = originalCall.source\n            coneTypeOrNull = integerOperatorType\n            annotations.addAll(originalCall.annotations)\n            typeArguments.addAll(originalCall.typeArguments)\n            calleeReference = originalCall.calleeReference\n            or"}
{"code": "igin = originalCall.origin\n            argumentList = originalCall.argumentList\n            explicitReceiver = originalCall.explicitReceiver\n            dispatchReceiver = originalCall.dispatchReceiver\n            extensionReceiver = originalCall.extensionReceiver\n        }\n\n        return if (approximationIsNeeded) {\n            integerOperatorCall.transformSingle<FirFunctionCall, ConeKotlinType?>(\n                components.integerLiteralAndOperatorApproximationTransformer,\n                resolutionMode.expectedType?.coneTypeSafe()\n            )\n        } else {\n            integerOperatorCall\n        }\n    }\n\n    override fun transformBlock(block: FirBlock, data: ResolutionMode): FirStatement {\n        context.forBlock(session) {\n            transformBlockInCurrentScope(block, data)\n        }\n        return block\n    }\n\n    internal fun transformBlockInCurrentScope(block: FirBlock, data: ResolutionMode) {\n        dataFlowAnalyzer.enterBlock(block)\n        val numberOfStatements = b"}
{"code": "lock.statements.size\n\n        block.transformStatementsIndexed(transformer) { index ->\n            val value =\n                if (index == numberOfStatements - 1)\n                    if (data is ResolutionMode.WithExpectedType)\n                        data.copy(mayBeCoercionToUnitApplied = true)\n                    else\n                        data\n                else\n                    ResolutionMode.ContextIndependent\n\n            TransformData.Data(value)\n        }\n        block.transformOtherChildren(transformer, data)\n        if (data is ResolutionMode.WithExpectedType && data.expectedTypeRef.coneTypeSafe<ConeKotlinType>()?.isUnitOrFlexibleUnit == true) {\n            // Unit-coercion\n            block.resultType = data.expectedTypeRef.type\n        } else {\n            // Bottom-up propagation: from the return type of the last expression in the block to the block type\n            block.writeResultType(session)\n        }\n\n        dataFlowAnalyzer.exitBlock(block)\n    }\n\n    overr"}
{"code": "ide fun transformThisReceiverExpression(\n        thisReceiverExpression: FirThisReceiverExpression,\n        data: ResolutionMode,\n    ): FirStatement {\n        return transformQualifiedAccessExpression(thisReceiverExpression, data)\n    }\n\n    override fun transformComparisonExpression(\n        comparisonExpression: FirComparisonExpression,\n        data: ResolutionMode\n    ): FirStatement = whileAnalysing(session, comparisonExpression) {\n        return (comparisonExpression.transformChildren(transformer, ResolutionMode.ContextIndependent) as FirComparisonExpression).also {\n            it.resultType = builtinTypes.booleanType.type\n            dataFlowAnalyzer.exitComparisonExpressionCall(it)\n        }\n    }\n\n    @OptIn(FirContractViolation::class)\n    override fun transformAssignmentOperatorStatement(\n        assignmentOperatorStatement: FirAssignmentOperatorStatement,\n        data: ResolutionMode\n    ): FirStatement = whileAnalysing(session, assignmentOperatorStatement) {\n        val op"}
{"code": "eration = assignmentOperatorStatement.operation\n        val fakeSourceKind = operation.toAugmentedAssignSourceKind()\n        require(operation != FirOperation.ASSIGN)\n\n        assignmentOperatorStatement.transformAnnotations(transformer, ResolutionMode.ContextIndependent)\n        dataFlowAnalyzer.enterCallArguments(assignmentOperatorStatement, listOf(assignmentOperatorStatement.rightArgument))\n        val leftArgument = assignmentOperatorStatement.leftArgument\n            .transformAsExplicitReceiver(ResolutionMode.ReceiverResolution, isUsedAsGetClassReceiver = false)\n        val rightArgument = assignmentOperatorStatement.rightArgument.transformSingle(transformer, ResolutionMode.ContextDependent)\n        dataFlowAnalyzer.exitCallArguments()\n\n        val generator = GeneratorOfPlusAssignCalls(\n            assignmentOperatorStatement,\n            assignmentOperatorStatement.toReference(session)?.source,\n            operation,\n            leftArgument,\n            rightArgument\n        )"}
{"code": "\n\n        // x.plusAssign(y)\n        val assignOperatorCall = generator.createAssignOperatorCall(fakeSourceKind)\n        val resolvedAssignCall = assignOperatorCall.resolveCandidateForAssignmentOperatorCall()\n        val assignCallReference = resolvedAssignCall.calleeReference as? FirNamedReferenceWithCandidate\n        val assignIsSuccessful = assignCallReference?.isError == false\n\n        // x = x + y\n        val simpleOperatorCall = generator.createSimpleOperatorCall(fakeSourceKind)\n        val resolvedOperatorCall = simpleOperatorCall.resolveCandidateForAssignmentOperatorCall()\n        val operatorCallReference = resolvedOperatorCall.calleeReference as? FirNamedReferenceWithCandidate\n        val operatorIsSuccessful = operatorCallReference?.isError == false\n\n        fun operatorReturnTypeMatches(candidate: Candidate): Boolean {\n            // After KT-45503, non-assign flavor of operator is checked more strictly: the return type must be assignable to the variable.\n            val op"}
{"code": "eratorCallReturnType = resolvedOperatorCall.resolvedType\n            val substitutor = candidate.system.currentStorage()\n                .buildAbstractResultingSubstitutor(candidate.system.typeSystemContext) as ConeSubstitutor\n            return AbstractTypeChecker.isSubtypeOf(\n                session.typeContext,\n                substitutor.substituteOrSelf(operatorCallReturnType),\n                leftArgument.resolvedType\n            )\n        }\n        // following `!!` is safe since `operatorIsSuccessful = true` implies `operatorCallReference != null`\n        val operatorReturnTypeMatches = operatorIsSuccessful && operatorReturnTypeMatches(operatorCallReference!!.candidate)\n\n        val lhsReference = leftArgument.toReference(session)\n        val lhsSymbol = lhsReference?.toResolvedVariableSymbol()\n        val lhsVariable = lhsSymbol?.fir\n        val lhsIsVar = lhsVariable?.isVar == true\n\n        fun chooseAssign(): FirStatement {\n            callCompleter.completeCall(resolvedAssi"}
{"code": "gnCall, ResolutionMode.ContextIndependent)\n            dataFlowAnalyzer.exitFunctionCall(resolvedAssignCall, callCompleted = true)\n            return resolvedAssignCall\n        }\n\n        fun chooseOperator(): FirStatement {\n            callCompleter.completeCall(\n                resolvedOperatorCall,\n                (lhsVariable?.returnTypeRef as? FirResolvedTypeRef)?.let {\n                    ResolutionMode.WithExpectedType(it, expectedTypeMismatchIsReportedInChecker = true)\n                } ?: ResolutionMode.ContextIndependent,\n            )\n            dataFlowAnalyzer.exitFunctionCall(resolvedOperatorCall, callCompleted = true)\n\n            val leftArgumentDesugaredSource = leftArgument.source?.fakeElement(fakeSourceKind)\n            val unwrappedLeftArgument = leftArgument.unwrapSmartcastExpression()\n            val assignmentLeftArgument = buildDesugaredAssignmentValueReferenceExpression {\n                expressionRef = FirExpressionRef<FirExpression>().apply { bind(unwrappedL"}
{"code": "eftArgument) }\n                source = leftArgumentDesugaredSource\n            }\n\n            val assignment =\n                buildVariableAssignment {\n                    source = assignmentOperatorStatement.source?.fakeElement(fakeSourceKind)\n                    lValue = assignmentLeftArgument\n                    rValue = resolvedOperatorCall\n                    annotations += assignmentOperatorStatement.annotations\n                }\n\n            val receiverTemporaryVariable =\n                generateExplicitReceiverTemporaryVariable(session, unwrappedLeftArgument, leftArgumentDesugaredSource)\n            return if (receiverTemporaryVariable != null) {\n                buildBlock {\n                    source = assignmentOperatorStatement.source?.fakeElement(fakeSourceKind)\n                    annotations += assignmentOperatorStatement.annotations\n\n                    statements += receiverTemporaryVariable\n                    statements += assignment\n                }\n            }"}
{"code": " else {\n                assignment\n            }.transform(transformer, ResolutionMode.ContextIndependent)\n        }\n\n        fun chooseResolved(): FirStatement {\n            // If neither candidate is successful, choose whichever is resolved, prioritizing assign\n            val isAssignResolved = (assignCallReference as? FirErrorReferenceWithCandidate)?.diagnostic !is ConeUnresolvedNameError\n            val isOperatorResolved = (operatorCallReference as? FirErrorReferenceWithCandidate)?.diagnostic !is ConeUnresolvedNameError\n            return when {\n                isAssignResolved -> chooseAssign()\n                isOperatorResolved -> chooseOperator()\n                else -> chooseAssign()\n            }\n        }\n\n        fun reportAmbiguity(): FirStatement {\n            val operatorCallCandidate = requireNotNull(operatorCallReference?.candidate)\n            val assignmentCallCandidate = requireNotNull(assignCallReference?.candidate)\n            return buildErrorExpression {\n      "}
{"code": "          source = assignmentOperatorStatement.source\n                diagnostic = ConeOperatorAmbiguityError(listOf(operatorCallCandidate, assignmentCallCandidate))\n            }\n        }\n\n        return when {\n            assignIsSuccessful && !lhsIsVar -> chooseAssign()\n            !assignIsSuccessful && !operatorIsSuccessful -> chooseResolved()\n            !assignIsSuccessful && operatorIsSuccessful -> chooseOperator()\n            assignIsSuccessful && !operatorIsSuccessful -> chooseAssign()\n            leftArgument.resolvedType is ConeDynamicType -> chooseAssign()\n            !operatorReturnTypeMatches -> chooseAssign()\n            else -> reportAmbiguity()\n        }\n    }\n\n    @OptIn(FirContractViolation::class)\n    override fun transformIncrementDecrementExpression(\n        incrementDecrementExpression: FirIncrementDecrementExpression,\n        data: ResolutionMode\n    ): FirStatement {\n        val fakeSourceKind = sourceKindForIncOrDec(incrementDecrementExpression.operationName"}
{"code": ", incrementDecrementExpression.isPrefix)\n        incrementDecrementExpression.transformAnnotations(transformer, ResolutionMode.ContextIndependent)\n\n        val originalExpression = incrementDecrementExpression.expression.transformSingle(transformer, ResolutionMode.ContextIndependent)\n        val expression = when (originalExpression) {\n            is FirSafeCallExpression -> originalExpression.selector as? FirExpression ?: buildErrorExpression {\n                source = originalExpression.source\n                diagnostic = ConeSyntaxDiagnostic(\"Safe call selector expected to be an expression here\")\n            }\n            else -> originalExpression\n        }\n\n        @OptIn(FirImplementationDetail::class)\n        if (expression is FirQualifiedAccessExpression) expression.replaceSource(expression.source?.fakeElement(fakeSourceKind))\n\n        val desugaredSource = incrementDecrementExpression.source?.fakeElement(fakeSourceKind)\n\n        fun generateTemporaryVariable(name: Name, initia"}
{"code": "lizer: FirExpression): FirProperty = generateTemporaryVariable(\n            moduleData = session.moduleData,\n            source = desugaredSource,\n            name = name,\n            initializer = initializer,\n            typeRef = initializer.resolvedType.toFirResolvedTypeRef(desugaredSource),\n        )\n\n        fun buildAndResolveOperatorCall(\n            receiver: FirExpression,\n            fakeSourceKind: KtFakeSourceElementKind.DesugaredIncrementOrDecrement,\n        ): FirFunctionCall = buildFunctionCall {\n            source = incrementDecrementExpression.operationSource\n            explicitReceiver = receiver\n            calleeReference = buildSimpleNamedReference {\n                source = incrementDecrementExpression.operationSource?.fakeElement(fakeSourceKind)\n                name = incrementDecrementExpression.operationName\n            }\n            origin = FirFunctionCallOrigin.Operator\n        }.transformSingle(transformer, ResolutionMode.ContextIndependent)\n\n        fun "}
{"code": "buildAndResolveVariableAssignment(rValue: FirExpression): FirVariableAssignment = buildVariableAssignment {\n            source = desugaredSource\n            lValue = buildDesugaredAssignmentValueReferenceExpression {\n                source = ((expression as? FirErrorExpression)?.expression ?: expression).source\n                    ?.fakeElement(fakeSourceKind)\n                expressionRef = FirExpressionRef<FirExpression>().apply { bind(expression.unwrapSmartcastExpression()) }\n            }\n            this.rValue = rValue\n        }.transformSingle(transformer, ResolutionMode.ContextIndependent)\n\n        val block = buildBlock {\n            source = desugaredSource\n            annotations += incrementDecrementExpression.annotations\n\n            generateExplicitReceiverTemporaryVariable(session, expression, desugaredSource)\n                ?.let { statements += it }\n\n            if (incrementDecrementExpression.isPrefix) {\n                // a = a.inc()\n                statements += b"}
{"code": "uildAndResolveVariableAssignment(buildAndResolveOperatorCall(expression, fakeSourceKind))\n                // ^a\n                statements += buildDesugaredAssignmentValueReferenceExpression {\n                    source = ((expression as? FirErrorExpression)?.expression ?: expression).source\n                        ?.fakeElement(fakeSourceKind)\n                    expressionRef = FirExpressionRef<FirExpression>().apply { bind(expression.unwrapSmartcastExpression()) }\n                }.let {\n                    it.transform<FirStatement, ResolutionMode>(transformer, ResolutionMode.ContextIndependent)\n                    components.transformDesugaredAssignmentValueUsingSmartcastInfo(it)\n                }\n            } else {\n                val unaryVariable = generateTemporaryVariable(SpecialNames.UNARY, expression)\n\n                // val <unary> = a\n                statements += unaryVariable\n                // a = <unary>.inc()\n                statements += buildAndResolveVariableAss"}
{"code": "ignment(\n                    buildAndResolveOperatorCall(\n                        unaryVariable.toQualifiedAccess(),\n                        fakeSourceKind\n                    )\n                )\n                // ^<unary>\n                statements += unaryVariable.toQualifiedAccess()\n            }\n        }.apply {\n            replaceConeTypeOrNull((statements.last() as FirExpression).resolvedType)\n        }\n\n        return if (originalExpression is FirSafeCallExpression) {\n            originalExpression.replaceSelector(block)\n            originalExpression\n        } else {\n            block\n        }\n    }\n\n    override fun transformEqualityOperatorCall(\n        equalityOperatorCall: FirEqualityOperatorCall,\n        data: ResolutionMode\n    ): FirStatement = whileAnalysing(session, equalityOperatorCall) {\n        val arguments = equalityOperatorCall.argumentList.arguments\n        require(arguments.size == 2) {\n            \"Unexpected number of arguments in equality call: ${argument"}
{"code": "s.size}\"\n        }\n        // In cases like materialize1() == materialize2() we add expected type just for the right argument.\n        // One of the reasons is just consistency with K1 and with the desugared form `a.equals(b)`. See KT-47409 for clarifications.\n        val leftArgumentTransformed: FirExpression = arguments[0].transform(transformer, ResolutionMode.ContextIndependent)\n        dataFlowAnalyzer.exitEqualityOperatorLhs()\n        val rightArgumentTransformed: FirExpression = arguments[1].transform(transformer, withExpectedType(builtinTypes.nullableAnyType))\n\n        equalityOperatorCall\n            .transformAnnotations(transformer, ResolutionMode.ContextIndependent)\n            .replaceArgumentList(buildBinaryArgumentList(leftArgumentTransformed, rightArgumentTransformed))\n        equalityOperatorCall.resultType = builtinTypes.booleanType.type\n\n        dataFlowAnalyzer.exitEqualityOperatorCall(equalityOperatorCall)\n        return equalityOperatorCall\n    }\n\n    private fun F"}
{"code": "irFunctionCall.resolveCandidateForAssignmentOperatorCall(): FirFunctionCall {\n        return transformFunctionCallInternal(\n            this,\n            ResolutionMode.ContextDependent,\n            CallResolutionMode.OPTION_FOR_AUGMENTED_ASSIGNMENT\n        ) as FirFunctionCall\n    }\n\n    private fun FirTypeRef.withTypeArgumentsForBareType(argument: FirExpression, operation: FirOperation): FirTypeRef {\n        val type = coneTypeSafe<ConeClassLikeType>() ?: return this\n        if (type.typeArguments.isNotEmpty()) return this // TODO: Incorrect for local classes, KT-59686\n        // TODO: Check equality of size of arguments and parameters?\n\n        val firClass = type.lookupTag.toSymbol(session)?.fir ?: return this\n        if (firClass.typeParameters.isEmpty()) return this\n\n        val originalType = argument.unwrapExpression().resolvedType.let {\n            components.context.inferenceSession.getAndSemiFixCurrentResultIfTypeVariable(it) ?: it\n        }\n\n        val outerClasses by lazy"}
{"code": "(LazyThreadSafetyMode.NONE) { firClass.symbol.getClassAndItsOuterClassesWhenLocal(session) }\n        val newType = components.computeRepresentativeTypeForBareType(type, originalType)\n            ?: if (\n                firClass.isLocal && firClass.typeParameters.none { it.symbol.containingDeclarationSymbol in outerClasses } &&\n                (operation == NOT_IS || operation == IS || operation == AS || operation == SAFE_AS)\n            ) {\n                (firClass as FirClass).defaultType()\n            } else return buildErrorTypeRef {\n                source = this@withTypeArgumentsForBareType.source\n                diagnostic = ConeNoTypeArgumentsOnRhsError(firClass.typeParameters.size, firClass.symbol)\n            }\n        return if (newType.typeArguments.isEmpty()) this else withReplacedConeType(newType)\n    }\n\n    override fun transformTypeOperatorCall(\n        typeOperatorCall: FirTypeOperatorCall,\n        data: ResolutionMode,\n    ): FirStatement {\n        val resolved = compo"}
{"code": "nents.typeResolverTransformer.withBareTypes {\n            if (typeOperatorCall.operation == IS || typeOperatorCall.operation == NOT_IS) {\n                components.typeResolverTransformer.withIsOperandOfIsOperator {\n                    typeOperatorCall.transformConversionTypeRef(transformer, ResolutionMode.ContextIndependent)\n                }\n            } else {\n                typeOperatorCall.transformConversionTypeRef(transformer, ResolutionMode.ContextIndependent)\n            }\n        }.transformTypeOperatorCallChildren()\n\n        val conversionTypeRef = resolved.conversionTypeRef.withTypeArgumentsForBareType(resolved.argument, typeOperatorCall.operation)\n        resolved.transformChildren(object : FirDefaultTransformer<Any?>() {\n            override fun <E : FirElement> transformElement(element: E, data: Any?): E {\n                return element\n            }\n\n            override fun transformTypeRef(typeRef: FirTypeRef, data: Any?): FirTypeRef {\n                return if (ty"}
{"code": "peRef === resolved.conversionTypeRef) {\n                    conversionTypeRef\n                } else {\n                    typeRef\n                }\n            }\n        }, null)\n\n        when (resolved.operation) {\n            IS, NOT_IS -> {\n                resolved.resultType = session.builtinTypes.booleanType.type\n            }\n            AS -> {\n                resolved.resultType = conversionTypeRef.coneType\n            }\n            SAFE_AS -> {\n                resolved.resultType = conversionTypeRef.coneType.withNullability(\n                    ConeNullability.NULLABLE, session.typeContext,\n                )\n            }\n            else -> error(\"Unknown type operator: ${resolved.operation}\")\n        }\n        dataFlowAnalyzer.exitTypeOperatorCall(resolved)\n        return resolved\n    }\n\n    private fun FirTypeOperatorCall.transformTypeOperatorCallChildren(): FirTypeOperatorCall {\n        if (operation == AS || operation == SAFE_AS) {\n            val argument = argumentList"}
{"code": ".arguments.singleOrNull() ?: error(\"Not a single argument: ${this.render()}\")\n\n            // For calls in the form of (materialize() as MyClass) we've got a special rule that adds expect type to the `materialize()` call\n            // AS operator doesn't add expected type to any other expressions\n            // See https://kotlinlang.org/docs/whatsnew12.html#support-for-foo-as-a-shorthand-for-this-foo\n            // And limitations at org.jetbrains.kotlin.fir.resolve.inference.FirCallCompleterKt.isFunctionForExpectTypeFromCastFeature(org.jetbrains.kotlin.fir.declarations.FirFunction<?>)\n            if (argument is FirFunctionCall || (argument is FirSafeCallExpression && argument.selector is FirFunctionCall)) {\n                val expectedType = conversionTypeRef.coneTypeSafe<ConeKotlinType>()?.takeIf {\n                    // is not bare type\n                    it !is ConeClassLikeType ||\n                            it.typeArguments.isNotEmpty() ||\n                            (it.look"}
{"code": "upTag.toSymbol(session)?.fir as? FirTypeParameterRefsOwner)?.typeParameters?.isEmpty() == true\n                }?.let {\n                    if (operation == SAFE_AS)\n                        it.withNullability(ConeNullability.NULLABLE, session.typeContext)\n                    else\n                        it\n                }\n\n                if (expectedType != null) {\n                    val newMode = ResolutionMode.WithExpectedType(conversionTypeRef.withReplacedConeType(expectedType), fromCast = true)\n                    return transformOtherChildren(transformer, newMode)\n                }\n            }\n        }\n\n        return transformOtherChildren(transformer, ResolutionMode.ContextIndependent)\n    }\n\n    @OptIn(UnresolvedExpressionTypeAccess::class)\n    override fun transformCheckNotNullCall(\n        checkNotNullCall: FirCheckNotNullCall,\n        data: ResolutionMode,\n    ): FirStatement {\n        // Resolve the return type of a call to the synthetic function with signature:\n    "}
{"code": "    //   fun <K> checkNotNull(arg: K?): K\n        // ...in order to get the not-nullable type of the argument.\n\n        if (checkNotNullCall.calleeReference is FirResolvedNamedReference && checkNotNullCall.isResolved) {\n            return checkNotNullCall\n        }\n\n        if (checkNotNullCall.arguments.firstOrNull()?.coneTypeOrNull !is ConeDynamicType) {\n            dataFlowAnalyzer.enterCheckNotNullCall()\n        }\n\n        checkNotNullCall\n            .transformAnnotations(transformer, ResolutionMode.ContextIndependent)\n            .replaceArgumentList(checkNotNullCall.argumentList.transform(transformer, ResolutionMode.ContextDependent))\n\n        val result = callCompleter.completeCall(\n            components.syntheticCallGenerator.generateCalleeForCheckNotNullCall(checkNotNullCall, resolutionContext, data), data\n        )\n\n        if (checkNotNullCall.arguments.firstOrNull()?.coneTypeOrNull !is ConeDynamicType) {\n            dataFlowAnalyzer.exitCheckNotNullCall(result, data.force"}
{"code": "FullCompletion)\n        }\n\n        return result\n    }\n\n    override fun transformBinaryLogicExpression(\n        binaryLogicExpression: FirBinaryLogicExpression,\n        data: ResolutionMode,\n    ): FirStatement = whileAnalysing(session, binaryLogicExpression) {\n        val booleanType = builtinTypes.booleanType.type.toFirResolvedTypeRef()\n        return binaryLogicExpression.also(dataFlowAnalyzer::enterBinaryLogicExpression)\n            .transformLeftOperand(this, ResolutionMode.WithExpectedType(booleanType))\n            .also(dataFlowAnalyzer::exitLeftBinaryLogicExpressionArgument)\n            .transformRightOperand(this, ResolutionMode.WithExpectedType(booleanType))\n            .also(dataFlowAnalyzer::exitBinaryLogicExpression)\n            .transformOtherChildren(transformer, ResolutionMode.WithExpectedType(booleanType))\n            .also { it.resultType = booleanType.type }\n    }\n\n    override fun transformDesugaredAssignmentValueReferenceExpression(\n        desugaredAssignmentValu"}
{"code": "eReferenceExpression: FirDesugaredAssignmentValueReferenceExpression,\n        data: ResolutionMode,\n    ): FirStatement {\n        val referencedExpression = desugaredAssignmentValueReferenceExpression.expressionRef.value\n        if (referencedExpression is FirQualifiedAccessExpression) {\n            val typeFromCallee = components.typeFromCallee(referencedExpression)\n            desugaredAssignmentValueReferenceExpression.resultType = session.typeApproximator.approximateToSubType(\n                typeFromCallee.type,\n                TypeApproximatorConfiguration.FinalApproximationAfterResolutionAndInference\n            ) ?: typeFromCallee.type\n        } else {\n            desugaredAssignmentValueReferenceExpression.resultType = referencedExpression.resolvedType\n        }\n        return desugaredAssignmentValueReferenceExpression\n    }\n\n    override fun transformVariableAssignment(\n        variableAssignment: FirVariableAssignment,\n        data: ResolutionMode,\n    ): FirStatement = whi"}
{"code": "leAnalysing(session, variableAssignment) {\n        variableAssignment.transformAnnotations(transformer, ResolutionMode.ContextIndependent)\n\n        variableAssignment.transformLValue(transformer, ResolutionMode.AssignmentLValue(variableAssignment))\n\n        val resolvedReference = variableAssignment.calleeReference\n\n        if (assignAltererExtensions != null && resolvedReference is FirResolvedNamedReference) {\n            val alteredAssignments = assignAltererExtensions.mapNotNull { alterer ->\n                alterer.transformVariableAssignment(variableAssignment)?.let { it to alterer }\n            }\n            when (alteredAssignments.size) {\n                0 -> {}\n                1 -> {\n                    val transformedAssignment = alteredAssignments.first().first\n                    return transformedAssignment.transform(transformer, ResolutionMode.ContextIndependent)\n                }\n\n                else -> {\n                    val extensionNames = alteredAssignments.map { "}
{"code": "it.second::class.qualifiedName }\n                    val errorLValue = buildErrorExpression {\n                        expression = variableAssignment.lValue\n                        source = variableAssignment.lValue.source?.fakeElement(KtFakeSourceElementKind.AssignmentLValueError)\n                        diagnostic = ConeAmbiguousAlteredAssign(extensionNames)\n                    }\n                    variableAssignment.replaceLValue(errorLValue)\n                }\n            }\n        }\n\n        val result = context.withAssignmentRhs {\n            variableAssignment.transformRValue(\n                transformer,\n                withExpectedType(\n                    variableAssignment.lValue.resolvedType.toFirResolvedTypeRef(),\n                    expectedTypeMismatchIsReportedInChecker = true,\n                ),\n            )\n        }\n\n        // for cases like\n        // buildSomething { tVar = \"\" // Should infer TV from String assignment }\n        context.inferenceSession.addSubtype"}
{"code": "ConstraintIfCompatible(\n            lowerType = variableAssignment.rValue.resolvedType,\n            upperType = variableAssignment.lValue.resolvedType,\n            variableAssignment,\n        )\n\n        dataFlowAnalyzer.exitVariableAssignment(result)\n\n        return result\n    }\n\n    override fun transformCallableReferenceAccess(\n        callableReferenceAccess: FirCallableReferenceAccess,\n        data: ResolutionMode,\n    ): FirStatement = whileAnalysing(session, callableReferenceAccess) {\n        if (callableReferenceAccess.calleeReference is FirResolvedNamedReference) {\n            return callableReferenceAccess\n        }\n\n        callableReferenceAccess.transformAnnotations(transformer, data)\n        val explicitReceiver = callableReferenceAccess.explicitReceiver\n        val transformedLHS = explicitReceiver\n            ?.transformAsExplicitReceiver(ResolutionMode.ReceiverResolution.ForCallableReference, false)\n            .apply {\n                if (this is FirResolvedQualifier &"}
{"code": "& callableReferenceAccess.hasQuestionMarkAtLHS) {\n                    replaceIsNullableLHSForCallableReference(true)\n                }\n            }\n\n        transformedLHS?.let { callableReferenceAccess.replaceExplicitReceiver(transformedLHS) }\n\n        return if (data is ResolutionMode.ContextDependent) {\n            context.storeCallableReferenceContext(callableReferenceAccess)\n            callableReferenceAccess\n        } else {\n            components.syntheticCallGenerator.resolveCallableReferenceWithSyntheticOuterCall(\n                callableReferenceAccess, data.expectedType, resolutionContext, data\n            )\n        }.also {\n            dataFlowAnalyzer.exitCallableReference(it)\n        }\n    }\n\n    override fun transformGetClassCall(\n        getClassCall: FirGetClassCall,\n        data: ResolutionMode\n    ): FirStatement = whileAnalysing(session, getClassCall) {\n        getClassCall.transformAnnotations(transformer, ResolutionMode.ContextIndependent)\n        val arg = getC"}
{"code": "lassCall.argument\n        val dataForLhs = if (arg is FirLiteralExpression<*>) {\n            withExpectedType(arg.kind.expectedConeType(session).toFirResolvedTypeRef())\n        } else {\n            ResolutionMode.ContextIndependent\n        }\n\n        val transformedGetClassCall = run {\n            val argument = getClassCall.argument\n            val replacedArgument: FirExpression = argument.transformAsExplicitReceiver(dataForLhs, isUsedAsGetClassReceiver = true)\n\n            getClassCall.argumentList.transformArguments(object : FirTransformer<Nothing?>() {\n                @Suppress(\"UNCHECKED_CAST\")\n                override fun <E : FirElement> transformElement(element: E, data: Nothing?): E = replacedArgument as E\n            }, null)\n\n            getClassCall\n        }\n\n        val typeOfExpression = when (val lhs = transformedGetClassCall.argument) {\n            is FirResolvedQualifier -> {\n                lhs.replaceResolvedToCompanionObject(newResolvedToCompanionObject = false)\n "}
{"code": "               val symbol = lhs.symbol\n                val typeArguments: Array<ConeTypeProjection> =\n                    if (lhs.typeArguments.isNotEmpty()) {\n                        // If type arguments exist, use them to construct the type of the expression.\n                        lhs.typeArguments.map { it.toConeTypeProjection() }.toTypedArray()\n                    } else {\n                        // Otherwise, prepare the star projections as many as the size of type parameters.\n                        Array((symbol?.fir as? FirTypeParameterRefsOwner)?.typeParameters?.size ?: 0) {\n                            ConeStarProjection\n                        }\n                    }\n                val type = symbol?.constructType(typeArguments, isNullable = false)\n                if (type != null) {\n                    lhs.replaceConeTypeOrNull(\n                        type.also {\n                            session.lookupTracker?.recordTypeResolveAsLookup(it, getClassCall.source, compone"}
{"code": "nts.file.source)\n                        }\n                    )\n                    type\n                } else {\n                    lhs.resolvedType\n                }\n            }\n            is FirResolvedReifiedParameterReference -> {\n                val symbol = lhs.symbol\n                symbol.constructType(emptyArray(), isNullable = false)\n            }\n            else -> {\n                if (!shouldComputeTypeOfGetClassCallWithNotQualifierInLhs(getClassCall)) return transformedGetClassCall\n                val resultType = lhs.resolvedType\n                if (resultType is ConeErrorType) {\n                    resultType\n                } else {\n                    ConeKotlinTypeProjectionOut(resultType)\n                }\n            }\n        }\n\n        transformedGetClassCall.resultType = StandardClassIds.KClass.constructClassLikeType(arrayOf(typeOfExpression), false)\n        dataFlowAnalyzer.exitGetClassCall(transformedGetClassCall)\n        return transformedGetClassCall\n"}
{"code": "    }\n\n    protected open fun shouldComputeTypeOfGetClassCallWithNotQualifierInLhs(getClassCall: FirGetClassCall): Boolean {\n        return true\n    }\n\n    override fun <T> transformLiteralExpression(\n        literalExpression: FirLiteralExpression<T>,\n        data: ResolutionMode,\n    ): FirStatement {\n        literalExpression.transformAnnotations(transformer, ResolutionMode.ContextIndependent)\n\n        val type = when (val kind = literalExpression.kind) {\n            ConstantValueKind.IntegerLiteral, ConstantValueKind.UnsignedIntegerLiteral -> {\n                val expressionType = ConeIntegerLiteralConstantTypeImpl.create(\n                    literalExpression.value as Long,\n                    isTypePresent = { it.lookupTag.toSymbol(session) != null },\n                    isUnsigned = kind == ConstantValueKind.UnsignedIntegerLiteral\n                )\n                val expectedTypeRef = data.expectedType\n                @Suppress(\"UNCHECKED_CAST\")\n                when {\n         "}
{"code": "           expressionType is ConeErrorType -> {\n                        expressionType\n                    }\n                    expressionType is ConeClassLikeType -> {\n                        literalExpression.replaceKind(expressionType.toConstKind() as ConstantValueKind<T>)\n                        expressionType\n                    }\n                    data is ResolutionMode.ReceiverResolution && !data.forCallableReference -> {\n                        require(expressionType is ConeIntegerLiteralConstantTypeImpl)\n                        ConeIntegerConstantOperatorTypeImpl(expressionType.isUnsigned, ConeNullability.NOT_NULL)\n                    }\n                    expectedTypeRef != null -> {\n                        require(expressionType is ConeIntegerLiteralConstantTypeImpl)\n                        val coneType = expectedTypeRef.coneTypeSafe<ConeKotlinType>()?.fullyExpandedType(session)\n                        val approximatedType = expressionType.getApproximatedType(coneType)\n  "}
{"code": "                      literalExpression.replaceKind(approximatedType.toConstKind() as ConstantValueKind<T>)\n                        approximatedType\n                    }\n                    else -> {\n                        expressionType\n                    }\n                }\n            }\n            else -> kind.expectedConeType(session)\n        }\n\n        dataFlowAnalyzer.exitLiteralExpression(literalExpression as FirLiteralExpression<*>)\n        literalExpression.resultType = type\n\n        return when (val resolvedType = literalExpression.resolvedType) {\n            is ConeErrorType -> buildErrorExpression {\n                expression = literalExpression\n                diagnostic = resolvedType.diagnostic\n                source = literalExpression.source\n            }\n\n            else -> literalExpression\n        }\n    }\n\n    override fun transformAnnotation(annotation: FirAnnotation, data: ResolutionMode): FirStatement {\n        if (annotation.resolved) return annotation\n    "}
{"code": "    annotation.transformAnnotationTypeRef(transformer, ResolutionMode.ContextIndependent)\n        return annotation\n    }\n\n    override fun transformAnnotationCall(\n        annotationCall: FirAnnotationCall,\n        data: ResolutionMode\n    ): FirStatement = whileAnalysing(session, annotationCall) {\n        if (annotationCall.resolved) return annotationCall\n        annotationCall.transformAnnotationTypeRef(transformer, ResolutionMode.ContextIndependent)\n        annotationCall.replaceAnnotationResolvePhase(FirAnnotationResolvePhase.Types)\n        return context.forAnnotation {\n            withFirArrayOfCallTransformer {\n                dataFlowAnalyzer.enterAnnotation()\n                val result = callResolver.resolveAnnotationCall(annotationCall)\n                dataFlowAnalyzer.exitAnnotation()\n                if (result == null) return annotationCall\n                callCompleter.completeCall(result, ResolutionMode.ContextIndependent)\n                (result.argumentList as FirResol"}
{"code": "vedArgumentList).let { annotationCall.replaceArgumentMapping((it).toAnnotationArgumentMapping()) }\n                annotationCall\n            }\n        }\n    }\n\n    override fun transformErrorAnnotationCall(errorAnnotationCall: FirErrorAnnotationCall, data: ResolutionMode): FirStatement {\n        return transformAnnotationCall(errorAnnotationCall, data)\n    }\n\n    protected inline fun <T> withFirArrayOfCallTransformer(block: () -> T): T {\n        enableArrayOfCallTransformation = true\n        return try {\n            block()\n        } finally {\n            enableArrayOfCallTransformation = false\n        }\n    }\n\n    override fun transformDelegatedConstructorCall(\n        delegatedConstructorCall: FirDelegatedConstructorCall,\n        data: ResolutionMode,\n    ): FirStatement = whileAnalysing(session, delegatedConstructorCall) {\n        if (transformer.implicitTypeOnly) return delegatedConstructorCall\n        when (delegatedConstructorCall.calleeReference) {\n            is FirResolvedNam"}
{"code": "edReference, is FirErrorNamedReference -> return delegatedConstructorCall\n        }\n        val containers = components.context.containers\n        val containingClass = containers[containers.lastIndex - 1] as FirClass\n        val containingConstructor = containers.last() as FirConstructor\n        if (delegatedConstructorCall.isSuper && delegatedConstructorCall.constructedTypeRef is FirImplicitTypeRef) {\n            val superClass = containingClass.superTypeRefs.firstOrNull {\n                if (it !is FirResolvedTypeRef) return@firstOrNull false\n                val declaration = extractSuperTypeDeclaration(it) ?: return@firstOrNull false\n                val isExternalConstructorWithoutArguments = declaration.isExternal\n                        && delegatedConstructorCall.isCallToDelegatedConstructorWithoutArguments\n                declaration.classKind == ClassKind.CLASS && !isExternalConstructorWithoutArguments\n\n            } as FirResolvedTypeRef? ?: session.builtinTypes.anyType\n     "}
{"code": "       delegatedConstructorCall.replaceConstructedTypeRef(superClass)\n            delegatedConstructorCall.replaceCalleeReference(buildExplicitSuperReference {\n                source = delegatedConstructorCall.calleeReference.source\n                superTypeRef = superClass\n            })\n        }\n\n        dataFlowAnalyzer.enterCallArguments(delegatedConstructorCall, delegatedConstructorCall.arguments)\n        val lastDispatchReceiver = implicitReceiverStack.lastDispatchReceiver()\n        context.forDelegatedConstructorCall(containingConstructor, containingClass as? FirRegularClass, components) {\n            delegatedConstructorCall.transformChildren(transformer, ResolutionMode.ContextDependent)\n        }\n        dataFlowAnalyzer.exitCallArguments()\n\n        val reference = delegatedConstructorCall.calleeReference\n        val constructorType: ConeClassLikeType? = when (reference) {\n            is FirThisReference -> lastDispatchReceiver?.type as? ConeClassLikeType\n            is FirSu"}
{"code": "perReference -> reference.superTypeRef\n                .coneTypeSafe<ConeClassLikeType>()\n                ?.takeIf { it !is ConeErrorType }\n                ?.fullyExpandedType(session)\n            else -> null\n        }\n\n        val resolvedCall = callResolver\n            .resolveDelegatingConstructorCall(delegatedConstructorCall, constructorType, containingClass.symbol.toLookupTag())\n\n        if (reference is FirThisReference && reference.boundSymbol == null) {\n            (resolvedCall.dispatchReceiver?.resolvedType as? ConeClassLikeType)?.lookupTag?.toSymbol(session)?.let {\n                reference.replaceBoundSymbol(it)\n            }\n        }\n\n        // it seems that we may leave this code as is\n        // without adding `context.withTowerDataContext(context.getTowerDataContextForConstructorResolution())`\n        val result = callCompleter.completeCall(resolvedCall, ResolutionMode.ContextIndependent)\n        dataFlowAnalyzer.exitDelegatedConstructorCall(result, data.forceFullCom"}
{"code": "pletion)\n\n        // Update source of delegated constructor call when supertype isn't initialized\n        val sourceKind = result.source?.kind\n        if (containingConstructor.isPrimary &&\n            sourceKind is KtFakeSourceElementKind &&\n            // Delegated constructor calls of primary constructors with uninitialized supertypes have the whole class as source\n            result.source == containingClass.source?.fakeElement(sourceKind)\n        ) {\n            val superTypeRef = containingClass.superTypeRefs.firstOrNull {\n                it.coneType == result.toResolvedCallableSymbol()?.resolvedReturnType\n            }\n            @OptIn(FirImplementationDetail::class)\n            if (superTypeRef?.source?.kind is KtRealSourceElementKind) {\n                result.replaceSource(superTypeRef.source?.fakeElement(KtFakeSourceElementKind.DelegatingConstructorCall))\n            }\n        }\n\n        return result\n    }\n\n    private val FirDelegatedConstructorCall.isCallToDelegatedConst"}
{"code": "ructorWithoutArguments\n        get() = source?.kind == KtFakeSourceElementKind.DelegatingConstructorCall\n\n    private fun extractSuperTypeDeclaration(typeRef: FirTypeRef): FirRegularClass? {\n        if (typeRef !is FirResolvedTypeRef) return null\n        return when (val declaration = typeRef.firClassLike(session)) {\n            is FirRegularClass -> declaration\n            is FirTypeAlias -> extractSuperTypeDeclaration(declaration.expandedTypeRef)\n            else -> null\n        }\n    }\n\n    private class GeneratorOfPlusAssignCalls(\n        val baseElement: FirStatement,\n        val referenceSource: KtSourceElement?,\n        val operation: FirOperation,\n        val lhs: FirExpression,\n        val rhs: FirExpression\n    ) {\n        companion object {\n            fun createFunctionCall(\n                name: Name,\n                source: KtSourceElement?,\n                referenceSource: KtSourceElement?,\n                annotations: List<FirAnnotation>,\n                receiver: FirEx"}
{"code": "pression,\n                vararg arguments: FirExpression\n            ): FirFunctionCall = buildFunctionCall {\n                this.source = source\n                explicitReceiver = receiver\n                argumentList = when (arguments.size) {\n                    0 -> FirEmptyArgumentList\n                    1 -> buildUnaryArgumentList(arguments.first())\n                    else -> buildArgumentList {\n                        this.arguments.addAll(arguments)\n                    }\n                }\n                calleeReference = buildSimpleNamedReference {\n                    this.source = referenceSource ?: source\n                    this.name = name\n                }\n                origin = FirFunctionCallOrigin.Operator\n                this.annotations.addAll(annotations)\n            }\n        }\n\n        private fun createFunctionCall(name: Name, fakeSourceElementKind: KtFakeSourceElementKind): FirFunctionCall {\n            return createFunctionCall(\n                name,\n     "}
{"code": "           baseElement.source?.fakeElement(fakeSourceElementKind),\n                referenceSource,\n                baseElement.annotations,\n                lhs,\n                rhs,\n            )\n        }\n\n        fun createAssignOperatorCall(fakeSourceElementKind: KtFakeSourceElementKind): FirFunctionCall {\n            return createFunctionCall(FirOperationNameConventions.ASSIGNMENTS.getValue(operation), fakeSourceElementKind)\n        }\n\n        fun createSimpleOperatorCall(fakeSourceElementKind: KtFakeSourceElementKind): FirFunctionCall {\n            return createFunctionCall(FirOperationNameConventions.ASSIGNMENTS_TO_SIMPLE_OPERATOR.getValue(operation), fakeSourceElementKind)\n        }\n    }\n\n    override fun transformAugmentedArraySetCall(\n        augmentedArraySetCall: FirAugmentedArraySetCall,\n        data: ResolutionMode\n    ): FirStatement = whileAnalysing(session, augmentedArraySetCall) {\n        \n\n        val operation = augmentedArraySetCall.operation\n        assert(operat"}
{"code": "ion in FirOperation.ASSIGNMENTS)\n        assert(operation != FirOperation.ASSIGN)\n\n        val fakeSourceElementKind = operation.toAugmentedAssignSourceKind()\n\n        augmentedArraySetCall.transformAnnotations(transformer, data)\n\n        dataFlowAnalyzer.enterCallArguments(augmentedArraySetCall, listOf(augmentedArraySetCall.rhs))\n        // transformedLhsCall: a.get(index)\n        val transformedLhsCall = augmentedArraySetCall.lhsGetCall.transformSingle(transformer, ResolutionMode.ContextIndependent)\n            .also { it.setArrayAugmentedAssignSource(fakeSourceElementKind) }\n        val transformedRhs = augmentedArraySetCall.rhs.transformSingle(transformer, ResolutionMode.ContextDependent)\n        dataFlowAnalyzer.exitCallArguments()\n\n        val generator = GeneratorOfPlusAssignCalls(\n            augmentedArraySetCall,\n            augmentedArraySetCall.calleeReference.source,\n            operation,\n            transformedLhsCall,\n            transformedRhs\n        )\n\n        // a.g"}
{"code": "et(b).plusAssign(c)\n        val assignOperatorCall = generator.createAssignOperatorCall(operation.toAugmentedAssignSourceKind())\n        val resolvedAssignCall = assignOperatorCall.resolveCandidateForAssignmentOperatorCall()\n        val assignCallReference = resolvedAssignCall.calleeReference as? FirNamedReferenceWithCandidate\n        val assignIsSuccessful = assignCallReference?.isError == false\n\n        fun chooseAssign(): FirFunctionCall {\n            callCompleter.completeCall(resolvedAssignCall, ResolutionMode.ContextIndependent)\n            dataFlowAnalyzer.exitFunctionCall(resolvedAssignCall, callCompleted = true)\n            return resolvedAssignCall\n        }\n\n        // prefer a \"simpler\" variant for dynamics\n        if (transformedLhsCall.calleeReference.toResolvedBaseSymbol()?.origin == FirDeclarationOrigin.DynamicScope) {\n            return chooseAssign()\n        }\n\n        // <array>.set(<index_i>, <array>.get(<index_i>).plus(c))\n        val info =\n            tryResolveA"}
{"code": "ugmentedArraySetCallAsSetGetBlock(augmentedArraySetCall, transformedLhsCall, transformedRhs, fakeSourceElementKind)\n\n        val resolvedOperatorCall = info.operatorCall\n        val operatorCallReference = resolvedOperatorCall.calleeReference as? FirNamedReferenceWithCandidate\n        val operatorIsSuccessful = operatorCallReference?.isError == false\n\n        // if `plus` call already inapplicable then there is no need to try to resolve `set` call\n        if (assignIsSuccessful && !operatorIsSuccessful) {\n            return chooseAssign()\n        }\n\n        // a.set(b, a.get(b).plus(c))\n        val resolvedSetCall = info.setCall\n        val setCallReference = resolvedSetCall.calleeReference as? FirNamedReferenceWithCandidate\n        val setIsSuccessful = setCallReference?.isError == false\n\n        fun chooseSetOperator(): FirStatement {\n            callCompleter.completeCall(resolvedSetCall, ResolutionMode.ContextIndependent)\n            dataFlowAnalyzer.exitFunctionCall(resolvedSetCal"}
{"code": "l, callCompleted = true)\n            return info.toBlock()\n        }\n\n        fun reportError(diagnostic: ConeDiagnostic): FirStatement {\n            return chooseAssign().also {\n                val errorReference = buildErrorNamedReference {\n                    source = augmentedArraySetCall.source\n                    this.diagnostic = diagnostic\n                }\n                it.replaceCalleeReference(errorReference)\n            }\n        }\n\n        fun reportAmbiguity(\n            firstReference: FirNamedReferenceWithCandidate?,\n            secondReference: FirNamedReferenceWithCandidate?\n        ): FirStatement {\n            val firstCandidate = firstReference?.candidate\n            val secondCandidate = secondReference?.candidate\n            requireNotNull(firstCandidate)\n            requireNotNull(secondCandidate)\n            return reportError(ConeOperatorAmbiguityError(listOf(firstCandidate, secondCandidate)))\n        }\n\n        fun reportUnresolvedReference(): FirStatement "}
{"code": "{\n            return reportError(ConeUnresolvedNameError(Name.identifier(operation.operator)))\n        }\n\n        return when {\n            assignIsSuccessful && setIsSuccessful -> reportAmbiguity(assignCallReference, setCallReference)\n            assignIsSuccessful -> chooseAssign()\n            setIsSuccessful -> chooseSetOperator()\n            else -> reportUnresolvedReference()\n        }\n    }\n\n    \n    private inner class AugmentedArraySetAsGetSetCallDesugaringInfo(\n        val augmentedArraySetCall: FirAugmentedArraySetCall,\n        val arrayVariable: FirProperty,\n        val indexVariables: List<FirProperty>,\n        val operatorCall: FirFunctionCall,\n        val setCall: FirFunctionCall\n    ) {\n        fun toBlock(): FirBlock {\n            return buildBlock {\n                annotations += augmentedArraySetCall.annotations\n                statements += arrayVariable\n                statements += indexVariables\n                statements += setCall\n                source = augmen"}
{"code": "tedArraySetCall.source?.fakeElement(augmentedArraySetCall.operation.toAugmentedAssignSourceKind())\n            }.also {\n                it.replaceConeTypeOrNull(session.builtinTypes.unitType.type)\n            }\n        }\n    }\n\n    private fun tryResolveAugmentedArraySetCallAsSetGetBlock(\n        augmentedArraySetCall: FirAugmentedArraySetCall,\n        lhsGetCall: FirFunctionCall,\n        transformedRhs: FirExpression,\n        fakeSourceElementKind: KtFakeSourceElementKind,\n    ): AugmentedArraySetAsGetSetCallDesugaringInfo {\n        val initializer = lhsGetCall.explicitReceiver ?: buildErrorExpression {\n            source = augmentedArraySetCall.source\n                ?.fakeElement(fakeSourceElementKind)\n            diagnostic = ConeSyntaxDiagnostic(\"No receiver for array access\")\n        }\n        val arrayVariable = generateTemporaryVariable(\n            session.moduleData,\n            source = lhsGetCall.explicitReceiver?.source?.fakeElement(fakeSourceElementKind),\n            name"}
{"code": " = SpecialNames.ARRAY,\n            initializer = initializer,\n            typeRef = initializer.resolvedType.toFirResolvedTypeRef(initializer.source?.fakeElement(fakeSourceElementKind)),\n        )\n\n        val flattenedGetCallArguments = buildList {\n            for (argument in lhsGetCall.arguments) {\n                if (argument is FirVarargArgumentsExpression) {\n                    addAll(argument.arguments)\n                } else {\n                    add(argument)\n                }\n            }\n        }\n        val indexVariables = flattenedGetCallArguments.mapIndexed { i, index ->\n            // If the get call arguments are SAM converted, unwrap the SAM conversion.\n            // Otherwise, we might fail resolution if the get and set operator parameter types are different\n            // (different SAM types or one is a SAM type and the other isn't).\n            val unwrappedSamIndex = (index as? FirSamConversionExpression)?.expression ?: index\n            generateTemporaryVaria"}
{"code": "ble(\n                session.moduleData,\n                source = unwrappedSamIndex.source?.fakeElement(fakeSourceElementKind),\n                name = SpecialNames.subscribeOperatorIndex(i),\n                initializer = unwrappedSamIndex,\n                typeRef = unwrappedSamIndex.resolvedType.toFirResolvedTypeRef(),\n            )\n        }\n\n        arrayVariable.transformSingle(transformer, ResolutionMode.ContextIndependent)\n        indexVariables.forEach { it.transformSingle(transformer, ResolutionMode.ContextIndependent) }\n\n        val arrayAccess = arrayVariable.toQualifiedAccess()\n        val indicesQualifiedAccess = indexVariables.map { it.toQualifiedAccess() }\n\n        // If the get call arguments were SAM conversions, they were unwrapped for the variable initializers.\n        // We need to reapply the SAM conversions here because the get call won't be completed again (where the SAM conversions could be\n        // applied automatically).\n        // SAM conversions will be appl"}
{"code": "ied automatically for the set call during completion.\n        val indicesQualifiedAccessForGet = indicesQualifiedAccess.mapIndexed { index, qualifiedAccess ->\n            val samConversion = flattenedGetCallArguments[index] as? FirSamConversionExpression ?: return@mapIndexed qualifiedAccess\n            buildSamConversionExpressionCopy(samConversion) {\n                expression = qualifiedAccess\n            }\n        }\n\n        val getCall = buildFunctionCall {\n            source = augmentedArraySetCall.arrayAccessSource?.fakeElement(fakeSourceElementKind)\n            explicitReceiver = arrayAccess\n            if (lhsGetCall.explicitReceiver == lhsGetCall.dispatchReceiver) {\n                dispatchReceiver = arrayAccess\n                extensionReceiver = lhsGetCall.extensionReceiver\n            } else {\n                extensionReceiver = arrayAccess\n                dispatchReceiver = lhsGetCall.dispatchReceiver\n            }\n            calleeReference = lhsGetCall.calleeReference\n "}
{"code": "           var i = 0\n            val newMapping = (lhsGetCall.argumentList as FirResolvedArgumentList).mapping.mapKeysTo(LinkedHashMap()) { (argument) ->\n                if (argument is FirVarargArgumentsExpression) {\n                    buildVarargArgumentsExpression {\n                        val varargSize = argument.arguments.size\n                        arguments += indicesQualifiedAccessForGet.subList(i, i + varargSize)\n                        i += varargSize\n                        source = argument.source\n                        coneTypeOrNull = argument.resolvedType\n                        coneElementTypeOrNull = argument.coneElementTypeOrNull\n                    }\n                } else {\n                    indicesQualifiedAccessForGet[i++]\n                }\n            }\n            argumentList = buildResolvedArgumentList(\n                lhsGetCall.argumentList,\n                newMapping,\n            )\n            origin = FirFunctionCallOrigin.Operator\n            coneTy"}
{"code": "peOrNull = lhsGetCall.resolvedType\n        }\n\n        val generator = GeneratorOfPlusAssignCalls(\n            augmentedArraySetCall,\n            augmentedArraySetCall.calleeReference.source,\n            augmentedArraySetCall.operation,\n            getCall,\n            transformedRhs\n        )\n\n        val operatorCall = generator.createSimpleOperatorCall(augmentedArraySetCall.operation.toAugmentedAssignSourceKind())\n        val resolvedOperatorCall = operatorCall.resolveCandidateForAssignmentOperatorCall()\n\n        val setCall = GeneratorOfPlusAssignCalls.createFunctionCall(\n            OperatorNameConventions.SET,\n            augmentedArraySetCall.source?.fakeElement(augmentedArraySetCall.operation.toAugmentedAssignSourceKind()),\n            augmentedArraySetCall.calleeReference.source,\n            annotations = augmentedArraySetCall.annotations,\n            receiver = arrayAccess, // a\n            *indicesQualifiedAccess.toTypedArray(), // indices\n            resolvedOperatorCall // "}
{"code": "a.get(b).plus(c)\n        )\n        val resolvedSetCall = setCall.resolveCandidateForAssignmentOperatorCall()\n\n        return AugmentedArraySetAsGetSetCallDesugaringInfo(\n            augmentedArraySetCall,\n            arrayVariable,\n            indexVariables,\n            resolvedOperatorCall,\n            resolvedSetCall\n        )\n    }\n\n    override fun transformArrayLiteral(arrayLiteral: FirArrayLiteral, data: ResolutionMode): FirStatement =\n        whileAnalysing(session, arrayLiteral) {\n            when (data) {\n                is ResolutionMode.ContextDependent -> {\n                    // Argument in non-annotation call (unsupported) or if type of array parameter is unresolved.\n                    arrayLiteral.transformChildren(transformer, data)\n                    arrayLiteral\n                }\n                is ResolutionMode.WithExpectedType -> {\n                    // Default value of array parameter (Array<T> or primitive array such as IntArray, FloatArray, ...)\n            "}
{"code": "        // or argument for array parameter in annotation call.\n                    arrayLiteral.transformChildren(transformer, ResolutionMode.ContextDependent)\n                    val call = components.syntheticCallGenerator.generateSyntheticArrayOfCall(\n                        arrayLiteral,\n                        data.expectedTypeRef,\n                        resolutionContext,\n                        data,\n                    )\n                    callCompleter.completeCall(call, data)\n                    arrayOfCallTransformer.transformFunctionCall(call, session)\n                }\n                else -> {\n                    // Other unsupported usage.\n                    val syntheticIdCall = components.syntheticCallGenerator.generateSyntheticIdCall(\n                        arrayLiteral,\n                        resolutionContext,\n                        data,\n                    )\n                    arrayLiteral.transformChildren(transformer, ResolutionMode.ContextDependent)\n    "}
{"code": "                callCompleter.completeCall(syntheticIdCall, ResolutionMode.ContextIndependent)\n                    arrayLiteral\n                }\n            }\n        }\n\n    override fun transformStringConcatenationCall(\n        stringConcatenationCall: FirStringConcatenationCall,\n        data: ResolutionMode\n    ): FirStatement = whileAnalysing(session, stringConcatenationCall) {\n        dataFlowAnalyzer.enterStringConcatenationCall()\n        stringConcatenationCall.transformChildren(transformer, ResolutionMode.ContextIndependent)\n        dataFlowAnalyzer.exitStringConcatenationCall(stringConcatenationCall)\n        return stringConcatenationCall\n    }\n\n    override fun transformAnonymousObjectExpression(\n        anonymousObjectExpression: FirAnonymousObjectExpression,\n        data: ResolutionMode,\n    ): FirStatement {\n        anonymousObjectExpression.transformAnonymousObject(transformer, data)\n        if (!anonymousObjectExpression.isResolved) {\n            anonymousObjectExpressio"}
{"code": "n.resultType = anonymousObjectExpression.anonymousObject.defaultType()\n        }\n        dataFlowAnalyzer.exitAnonymousObjectExpression(anonymousObjectExpression)\n        return anonymousObjectExpression\n    }\n\n    override fun transformAnonymousFunctionExpression(\n        anonymousFunctionExpression: FirAnonymousFunctionExpression,\n        data: ResolutionMode\n    ): FirStatement {\n        dataFlowAnalyzer.enterAnonymousFunctionExpression(anonymousFunctionExpression)\n        return anonymousFunctionExpression.transformAnonymousFunction(transformer, data)\n    }\n\n    // ------------------------------------------------------------------------------------------------\n\n    internal fun storeTypeFromCallee(access: FirQualifiedAccessExpression, isLhsOfAssignment: Boolean) {\n        val typeFromCallee = components.typeFromCallee(access)\n        access.resultType = if (isLhsOfAssignment) {\n            session.typeApproximator.approximateToSubType(\n                typeFromCallee.type, TypeAppro"}
{"code": "ximatorConfiguration.FinalApproximationAfterResolutionAndInference\n            )\n        } else {\n            session.typeApproximator.approximateToSuperType(\n                typeFromCallee.type, TypeApproximatorConfiguration.IntermediateApproximationToSupertypeAfterCompletionInK2\n            )\n        } ?: typeFromCallee.type\n    }\n\n}\n\nprivate fun FirFunctionCall.setArrayAugmentedAssignSource(fakeSourceElementKind: KtFakeSourceElementKind) {\n    if (calleeReference.isError()) return\n    val newSource = source?.fakeElement(fakeSourceElementKind)\n    @OptIn(FirImplementationDetail::class)\n    replaceSource(newSource)\n    val oldCalleeReference = calleeReference as? FirResolvedNamedReference\n        ?: error(\"${FirResolvedNamedReference::class.simpleName}} expected, got ${calleeReference.render()}\")\n    replaceCalleeReference(buildResolvedNamedReference {\n        this.name = oldCalleeReference.name\n        this.source = newSource\n        this.resolvedSymbol = oldCalleeReference.resolvedS"}
{"code": "ymbol\n    })\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\", \"unused\")\n\npackage org.jetbrains.kotlin.fir.expressions.builder\n\nimport kotlin.contracts.*\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.builder.FirAnnotationContainerBuilder\nimport org.jetbrains.kotlin.fir.builder.FirBuilderDsl\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirAssignmentOperatorStatement\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.expressions.FirOperation\nimport org.jetbrains.kotlin.fir.expressions.impl.FirAssignmentOperatorStatementImpl\n\n@FirBuilderDsl\nclass FirAssignmentOperatorStatementBuilder : FirAnnotationContainerBuilder {\n    override var source: KtSourceElement? = null\n    override val annotations: MutableList<FirAnnotati"}
{"code": "on> = mutableListOf()\n    lateinit var operation: FirOperation\n    lateinit var leftArgument: FirExpression\n    lateinit var rightArgument: FirExpression\n\n    override fun build(): FirAssignmentOperatorStatement {\n        return FirAssignmentOperatorStatementImpl(\n            source,\n            annotations.toMutableOrEmpty(),\n            operation,\n            leftArgument,\n            rightArgument,\n        )\n    }\n\n}\n\n@OptIn(ExperimentalContracts::class)\ninline fun buildAssignmentOperatorStatement(init: FirAssignmentOperatorStatementBuilder.() -> Unit): FirAssignmentOperatorStatement {\n    contract {\n        callsInPlace(init, InvocationKind.EXACTLY_ONCE)\n    }\n    return FirAssignmentOperatorStatementBuilder().apply(init).build()\n}\n"}
{"code": "// example from https://kotlinlang.org/docs/generics.html#underscore-operator-for-type-arguments\n// modified to avoid using reflection (::class.java)\n\nabstract class SomeClass<T> {\n    abstract fun execute() : T\n}\n\nclass SomeImplementation : SomeClass<String>() {\n    override fun execute(): String = \"Test\"\n}\n\nclass OtherImplementation : SomeClass<Int>() {\n    override fun execute(): Int = 42\n}\n\nobject Runner {\n    inline fun <reified S: SomeClass<T>, T> run(instance: S) : T {\n        return instance.execute()\n    }\n}\n\nfun test() {\n    val i = SomeImplementation()\n    // T is inferred as String because SomeImplementation derives from SomeClass<String>\n    val s = Runner.run<_, _>(i)\n    assert(s == \"Test\")\n\n    val j = OtherImplementation()\n    // T is inferred as Int because OtherImplementation derives from SomeClass<Int>\n    val n = Runner.run<<caret>_, _>(j)\n    assert(n == 42)\n}\n"}
{"code": "// FILE: usage.kt\nfun usa<caret>ge(j: JavaDeclaration) = j.foo()\n\n@Target(AnnotationTarget.TYPE)\nannotation class MyAnno(val s: String)\n\n// FILE: JavaDeclaration.java\npublic interface JavaDeclaration {\n    @MyAnno(\"array value annotation\") Integer @MyAnno(\"array annotation\") [] foo();\n}"}
{"code": "package a\n\nclass A {\n    companion object Named {\n        val i: Int = 1\n    }\n}\n\nfun main(args: Array<String>) {\n    A.Na<caret>med.i\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.scopes.receivers\n\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.incremental.components.LookupLocation\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtExpression\nimport org.jetbrains.kotlin.psi.KtSimpleNameExpression\nimport org.jetbrains.kotlin.psi.psiUtil.getTopmostParentQualifiedExpressionForSelector\nimport org.jetbrains.kotlin.resolve.DescriptorUtils\nimport org.jetbrains.kotlin.resolve.descriptorUtil.classValueType\nimport org.jetbrains.kotlin.resolve.scopes.ChainedMemberScope\nimport org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter\nimport org.jetbrains.kotlin.resolve.scopes.MemberScope\nimport org.jetbrains.kotlin.resolve.scopes.MemberScopeImpl\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.kotlin.utils.Printer\n\ninterface Qualifier : QualifierReceiver {\n    val referenceExpression: KtSimpleNameExpression\n}\n\nval Qualifier.expression: KtExpression\n    get() = referenceExpress"}
{"code": "ion.getTopmostParentQualifiedExpressionForSelector() ?: referenceExpression\n\nclass PackageQualifier(\n    override val referenceExpression: KtSimpleNameExpression,\n    override val descriptor: PackageViewDescriptor\n) : Qualifier {\n    override val classValueReceiver: ReceiverValue? get() = null\n    override val staticScope: MemberScope get() = descriptor.memberScope\n\n    override fun toString() = \"Package{$descriptor}\"\n}\n\nclass TypeParameterQualifier(\n    override val referenceExpression: KtSimpleNameExpression,\n    override val descriptor: TypeParameterDescriptor\n) : Qualifier {\n    override val classValueReceiver: ReceiverValue? get() = null\n    override val staticScope: MemberScope get() = MemberScope.Empty\n\n    override fun toString() = \"TypeParameter{$descriptor}\"\n}\n\ninterface ClassifierQualifier : Qualifier {\n    override val descriptor: ClassifierDescriptorWithTypeParameters\n}\n\nclass ClassQualifier(\n    override val referenceExpression: KtSimpleNameExpression,\n    override val de"}
{"code": "scriptor: ClassDescriptor\n) : ClassifierQualifier {\n    override val classValueReceiver: ClassValueReceiver? = descriptor.classValueType?.let {\n        ClassValueReceiver(this, it)\n    }\n\n    override val staticScope: MemberScope\n        get() =\n            if (descriptor.kind == ClassKind.ENUM_ENTRY) descriptor.staticScope\n            else ChainedMemberScope.create(\n                \"Static scope for ${descriptor.name} as class or object\",\n                descriptor.staticScope,\n                descriptor.unsubstitutedInnerClassesScope\n            )\n\n    override fun toString() = \"Class{$descriptor}\"\n}\n\nclass TypeAliasQualifier(\n    override val referenceExpression: KtSimpleNameExpression,\n    override val descriptor: TypeAliasDescriptor,\n    val classDescriptor: ClassDescriptor\n) : ClassifierQualifier {\n    override val classValueReceiver: ClassValueReceiver?\n        get() = classDescriptor.classValueType?.let {\n            ClassValueReceiver(this, it)\n        }\n\n    override val stat"}
{"code": "icScope: MemberScope\n        get() = when {\n            DescriptorUtils.isEnumClass(classDescriptor) ->\n                ChainedMemberScope.create(\n                    \"Static scope for typealias ${descriptor.name}\",\n                    classDescriptor.staticScope,\n                    EnumEntriesScope()\n                )\n            else ->\n                classDescriptor.staticScope\n        }\n\n    \n    private inner class EnumEntriesScope : MemberScopeImpl() {\n        override fun getContributedDescriptors(\n            kindFilter: DescriptorKindFilter,\n            nameFilter: (Name) -> Boolean\n        ): Collection<DeclarationDescriptor> =\n            classDescriptor.unsubstitutedInnerClassesScope\n                .getContributedDescriptors(kindFilter, nameFilter)\n                .filter { DescriptorUtils.isEnumEntry(it) }\n\n        override fun getContributedClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? =\n            classDescriptor.unsubstitutedInnerClassesSco"}
{"code": "pe\n                .getContributedClassifier(name, location)\n                ?.takeIf { DescriptorUtils.isEnumEntry(it) }\n\n        override fun printScopeStructure(p: Printer) {\n            p.println(this::class.java.simpleName, \" {\")\n            p.pushIndent()\n            p.println(\"descriptor = \", descriptor)\n            p.popIndent()\n            p.println(\"}\")\n        }\n    }\n}\n\nclass ClassValueReceiver @JvmOverloads constructor(\n    val classQualifier: ClassifierQualifier,\n    private val type: KotlinType,\n    original: ClassValueReceiver? = null\n) : ExpressionReceiver {\n    private val original = original ?: this\n\n    override fun getType() = type\n\n    override val expression: KtExpression\n        get() = classQualifier.expression\n\n    override fun replaceType(newType: KotlinType) = ClassValueReceiver(classQualifier, newType, original)\n\n    override fun getOriginal() = original\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.calls.tower\n\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.config.LanguageVersionSettings\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.descriptors.synthetic.SyntheticMemberDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.extensions.internal.CandidateInterceptor\nimport org.jetbrains.kotlin.incremental.components.LookupLocation\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.Call\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.psi.KtReferenceExpression\nimport org.jetbrains.kotlin.resolve.BindingContext\nimport org.jetbrains.kotlin.resolve.BindingTrace\nimport org.jetbrains.kotlin.resolve.TemporaryBindingTrace\nimport org.jetbrains.kotlin.resolve.calls.CallResolver\nimport org.jetbrains.kotlin.resolve.calls.CallTransformer\nimport org.jetbrains.kotlin.resolve.calls.CandidateResolver\nimport org.jetbrains.kotlin.resolve.cal"}
{"code": "ls.context.*\nimport org.jetbrains.kotlin.resolve.calls.inference.BuilderInferenceSupport\nimport org.jetbrains.kotlin.resolve.calls.model.*\nimport org.jetbrains.kotlin.resolve.calls.results.OverloadResolutionResultsImpl\nimport org.jetbrains.kotlin.resolve.calls.results.ResolutionResultsHandler\nimport org.jetbrains.kotlin.resolve.calls.results.ResolutionStatus\nimport org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo\nimport org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory\nimport org.jetbrains.kotlin.resolve.calls.tasks.*\nimport org.jetbrains.kotlin.resolve.calls.util.*\nimport org.jetbrains.kotlin.resolve.deprecation.DeprecationResolver\nimport org.jetbrains.kotlin.resolve.descriptorUtil.hasDynamicExtensionAnnotation\nimport org.jetbrains.kotlin.resolve.scopes.*\nimport org.jetbrains.kotlin.resolve.scopes.receivers.*\nimport org.jetbrains.kotlin.resolve.scopes.utils.canBeResolvedWithoutDeprecation\nimport org.jetbrains.kotlin.types.DeferredType\nimport org.jetbrains.ko"}
{"code": "tlin.types.error.ErrorUtils\nimport org.jetbrains.kotlin.types.TypeApproximator\nimport org.jetbrains.kotlin.types.expressions.OperatorConventions\nimport org.jetbrains.kotlin.types.isDynamic\nimport org.jetbrains.kotlin.util.OperatorNameConventions\nimport org.jetbrains.kotlin.utils.addIfNotNull\nimport org.jetbrains.kotlin.utils.addToStdlib.compactIfPossible\nimport org.jetbrains.kotlin.utils.sure\n\nclass NewResolutionOldInference(\n    private val candidateResolver: CandidateResolver,\n    private val towerResolver: TowerResolver,\n    private val resolutionResultsHandler: ResolutionResultsHandler,\n    private val dynamicCallableDescriptors: DynamicCallableDescriptors,\n    private val syntheticScopes: SyntheticScopes,\n    private val languageVersionSettings: LanguageVersionSettings,\n    private val builderInferenceSupport: BuilderInferenceSupport,\n    private val deprecationResolver: DeprecationResolver,\n    private val typeApproximator: TypeApproximator,\n    private val implicitsResolutionFil"}
{"code": "ter: ImplicitsExtensionsResolutionFilter,\n    private val callResolver: CallResolver,\n    private val candidateInterceptor: CandidateInterceptor\n) {\n    sealed class ResolutionKind {\n        abstract internal fun createTowerProcessor(\n            outer: NewResolutionOldInference,\n            name: Name,\n            tracing: TracingStrategy,\n            scopeTower: ImplicitScopeTower,\n            explicitReceiver: DetailedReceiver?,\n            context: BasicCallResolutionContext\n        ): ScopeTowerProcessor<MyCandidate>\n\n        object Function : ResolutionKind() {\n            override fun createTowerProcessor(\n                outer: NewResolutionOldInference, name: Name, tracing: TracingStrategy,\n                scopeTower: ImplicitScopeTower, explicitReceiver: DetailedReceiver?, context: BasicCallResolutionContext\n            ): ScopeTowerProcessor<MyCandidate> {\n                val functionFactory = outer.CandidateFactoryImpl(name, context, tracing)\n                return createFu"}
{"code": "nctionProcessor(\n                    scopeTower,\n                    name,\n                    functionFactory,\n                    outer.CandidateFactoryProviderForInvokeImpl(functionFactory),\n                    explicitReceiver\n                )\n            }\n        }\n\n        object Variable : ResolutionKind() {\n            override fun createTowerProcessor(\n                outer: NewResolutionOldInference, name: Name, tracing: TracingStrategy,\n                scopeTower: ImplicitScopeTower, explicitReceiver: DetailedReceiver?, context: BasicCallResolutionContext\n            ): ScopeTowerProcessor<MyCandidate> {\n                val variableFactory = outer.CandidateFactoryImpl(name, context, tracing)\n                return createVariableAndObjectProcessor(scopeTower, name, variableFactory, explicitReceiver)\n            }\n        }\n\n        object CallableReference : ResolutionKind() {\n            override fun createTowerProcessor(\n                outer: NewResolutionOldInference, n"}
{"code": "ame: Name, tracing: TracingStrategy,\n                scopeTower: ImplicitScopeTower, explicitReceiver: DetailedReceiver?, context: BasicCallResolutionContext\n            ): ScopeTowerProcessor<MyCandidate> {\n                val functionFactory = outer.CandidateFactoryImpl(name, context, tracing)\n                val variableFactory = outer.CandidateFactoryImpl(name, context, tracing)\n                return PrioritizedCompositeScopeTowerProcessor(\n                    createSimpleFunctionProcessor(scopeTower, name, functionFactory, explicitReceiver, classValueReceiver = false),\n                    createVariableProcessor(scopeTower, name, variableFactory, explicitReceiver, classValueReceiver = false)\n                )\n            }\n        }\n\n        object Invoke : ResolutionKind() {\n            override fun createTowerProcessor(\n                outer: NewResolutionOldInference, name: Name, tracing: TracingStrategy,\n                scopeTower: ImplicitScopeTower, explicitReceiver: Detail"}
{"code": "edReceiver?, context: BasicCallResolutionContext\n            ): ScopeTowerProcessor<MyCandidate> {\n                val functionFactory = outer.CandidateFactoryImpl(name, context, tracing)\n                // todo\n                val call = (context.call as? CallTransformer.CallForImplicitInvoke).sure {\n                    \"Call should be CallForImplicitInvoke, but it is: ${context.call}\"\n                }\n                return createProcessorWithReceiverValueOrEmpty(explicitReceiver) {\n                    createCallTowerProcessorForExplicitInvoke(\n                        scopeTower,\n                        functionFactory,\n                        context.transformToReceiverWithSmartCastInfo(call.dispatchReceiver),\n                        it\n                    )\n                }\n            }\n\n        }\n\n        class GivenCandidates : ResolutionKind() {\n            override fun createTowerProcessor(\n                outer: NewResolutionOldInference, name: Name, tracing: TracingStrateg"}
{"code": "y,\n                scopeTower: ImplicitScopeTower, explicitReceiver: DetailedReceiver?, context: BasicCallResolutionContext\n            ): ScopeTowerProcessor<MyCandidate> {\n                throw IllegalStateException(\"Should be not called\")\n            }\n        }\n    }\n\n    fun <D : CallableDescriptor> runResolution(\n        context: BasicCallResolutionContext,\n        name: Name,\n        kind: ResolutionKind,\n        tracing: TracingStrategy\n    ): OverloadResolutionResultsImpl<D> {\n        val explicitReceiver = context.call.explicitReceiver\n        val detailedReceiver = if (explicitReceiver is QualifierReceiver?) {\n            explicitReceiver\n        } else {\n            context.transformToReceiverWithSmartCastInfo(explicitReceiver as ReceiverValue)\n        }\n\n        val dynamicScope = dynamicCallableDescriptors.createDynamicDescriptorScope(context.call, context.scope.ownerDescriptor)\n        val scopeTower = ImplicitScopeTowerImpl(\n            context, dynamicScope, syntheticS"}
{"code": "copes, context.call.createLookupLocation(), typeApproximator, implicitsResolutionFilter, callResolver, candidateInterceptor\n        )\n\n        val shouldUseOperatorRem = languageVersionSettings.supportsFeature(LanguageFeature.OperatorRem)\n        val isBinaryRemOperator = isBinaryRemOperator(context.call)\n        val nameToResolve = if (isBinaryRemOperator && !shouldUseOperatorRem)\n            OperatorConventions.REM_TO_MOD_OPERATION_NAMES[name]!!\n        else\n            name\n\n        val processor = kind.createTowerProcessor(this, nameToResolve, tracing, scopeTower, detailedReceiver, context)\n\n        if (context.collectAllCandidates) {\n            return allCandidatesResult(towerResolver.collectAllCandidates(scopeTower, processor, nameToResolve))\n        }\n\n        var candidates =\n            towerResolver.runResolve(scopeTower, processor, useOrder = kind != ResolutionKind.CallableReference, name = nameToResolve)\n\n        // Temporary hack to resolve 'rem' as 'mod' if the first is "}
{"code": "do not present\n        val emptyOrInapplicableCandidates = candidates.isEmpty() ||\n                candidates.all { it.resultingApplicability.isInapplicable }\n        if (isBinaryRemOperator && shouldUseOperatorRem && emptyOrInapplicableCandidates) {\n            val deprecatedName = OperatorConventions.REM_TO_MOD_OPERATION_NAMES[name]\n            val processorForDeprecatedName =\n                kind.createTowerProcessor(this, deprecatedName!!, tracing, scopeTower, detailedReceiver, context)\n            candidates = towerResolver.runResolve(\n                scopeTower,\n                processorForDeprecatedName,\n                useOrder = kind != ResolutionKind.CallableReference,\n                name = deprecatedName\n            )\n        }\n\n        candidates = candidateInterceptor.interceptResolvedCandidates(candidates, context, candidateResolver, callResolver, name, kind, tracing)\n\n        if (candidates.isEmpty()) {\n            if (reportAdditionalDiagnosticIfNoCandidates(context, n"}
{"code": "ameToResolve, kind, scopeTower, detailedReceiver)) {\n                return OverloadResolutionResultsImpl.nameNotFound()\n            }\n        }\n\n        val overloadResults = convertToOverloadResults<D>(candidates, tracing, context)\n        builderInferenceSupport.checkBuilderInferenceCalls(context, tracing, overloadResults)\n        return overloadResults\n    }\n\n    fun <D : CallableDescriptor> runResolutionForGivenCandidates(\n        basicCallContext: BasicCallResolutionContext,\n        tracing: TracingStrategy,\n        candidates: Collection<OldResolutionCandidate<D>>\n    ): OverloadResolutionResultsImpl<D> {\n        val resolvedCandidates = candidates.map { candidate ->\n            val candidateTrace = TemporaryBindingTrace.create(basicCallContext.trace, \"Context for resolve candidate\")\n            val resolvedCall = ResolvedCallImpl.create(candidate, candidateTrace, tracing, basicCallContext.dataFlowInfoForArguments)\n\n            if (deprecationResolver.isHiddenInResolution(\n     "}
{"code": "               candidate.descriptor, basicCallContext.call, basicCallContext.trace.bindingContext, basicCallContext.isSuperCall\n                )\n            ) {\n                return@map MyCandidate(listOf(HiddenDescriptor), resolvedCall)\n            }\n\n            val callCandidateResolutionContext = CallCandidateResolutionContext.create(\n                resolvedCall, basicCallContext, candidateTrace, tracing, basicCallContext.call,\n                CandidateResolveMode.EXIT_ON_FIRST_ERROR\n            )\n            candidateResolver.performResolutionForCandidateCall(callCandidateResolutionContext, basicCallContext.checkArguments) // todo\n\n            val diagnostics = listOfNotNull(createPreviousResolveError(resolvedCall.status))\n            MyCandidate(diagnostics, resolvedCall) {\n                resolvedCall.performRemainingTasks()\n                listOfNotNull(createPreviousResolveError(resolvedCall.status))\n            }\n        }\n        if (basicCallContext.collectAllCandidates"}
{"code": ") {\n            val allCandidates = towerResolver.runWithEmptyTowerData(\n                KnownResultProcessor(resolvedCandidates),\n                TowerResolver.AllCandidatesCollector(), useOrder = false\n            )\n            return allCandidatesResult(allCandidates)\n        }\n\n        val processedCandidates = towerResolver.runWithEmptyTowerData(\n            KnownResultProcessor(resolvedCandidates),\n            TowerResolver.SuccessfulResultCollector(), useOrder = true\n        )\n\n        return convertToOverloadResults(processedCandidates, tracing, basicCallContext)\n    }\n\n    private fun <D : CallableDescriptor> allCandidatesResult(allCandidates: Collection<MyCandidate>) =\n        OverloadResolutionResultsImpl.nameNotFound<D>().apply {\n            this.allCandidates = allCandidates.map {\n                @Suppress(\"UNCHECKED_CAST\")\n                it.resolvedCall as MutableResolvedCall<D>\n            }\n        }\n\n    private fun <D : CallableDescriptor> convertToOverloadResults(\n "}
{"code": "       candidates: Collection<MyCandidate>,\n        tracing: TracingStrategy,\n        basicCallContext: BasicCallResolutionContext\n    ): OverloadResolutionResultsImpl<D> {\n        val resolvedCalls = candidates.map {\n            val (diagnostics, resolvedCall) = it\n            if (resolvedCall is VariableAsFunctionResolvedCallImpl) {\n                // todo hacks\n                tracing.bindReference(resolvedCall.variableCall.trace, resolvedCall.variableCall)\n                tracing.bindResolvedCall(resolvedCall.variableCall.trace, resolvedCall)\n\n                resolvedCall.variableCall.trace.addOwnDataTo(resolvedCall.functionCall.trace)\n\n                resolvedCall.functionCall.tracingStrategy.bindReference(resolvedCall.functionCall.trace, resolvedCall.functionCall)\n                //                resolvedCall.hackInvokeTracing.bindResolvedCall(resolvedCall.functionCall.trace, resolvedCall)\n            } else {\n                tracing.bindReference(resolvedCall.trace, resolvedCal"}
{"code": "l)\n                tracing.bindResolvedCall(resolvedCall.trace, resolvedCall)\n            }\n\n            if (resolvedCall.status.possibleTransformToSuccess()) {\n                for (error in diagnostics) {\n                    when (error) {\n                        is UnsupportedInnerClassCall -> resolvedCall.trace.report(\n                            Errors.UNSUPPORTED.on(\n                                resolvedCall.call.callElement,\n                                error.message\n                            )\n                        )\n\n                        is NestedClassViaInstanceReference -> tracing.nestedClassAccessViaInstanceReference(\n                            resolvedCall.trace,\n                            error.classDescriptor,\n                            resolvedCall.explicitReceiverKind\n                        )\n\n                        is ErrorDescriptorDiagnostic -> {\n                            // todo\n                            //  return@map null\n                    "}
{"code": "    }\n\n                        is ResolvedUsingDeprecatedVisibility -> {\n                            reportResolvedUsingDeprecatedVisibility(\n                                resolvedCall.call, resolvedCall.candidateDescriptor,\n                                resolvedCall.resultingDescriptor, error, resolvedCall.trace\n                            )\n                        }\n                    }\n                }\n            }\n\n            @Suppress(\"UNCHECKED_CAST\")\n            resolvedCall as MutableResolvedCall<D>\n        }\n\n        return resolutionResultsHandler.computeResultAndReportErrors(basicCallContext, tracing, resolvedCalls, languageVersionSettings)\n    }\n\n    // true if we found something\n    private fun reportAdditionalDiagnosticIfNoCandidates(\n        context: BasicCallResolutionContext,\n        name: Name,\n        kind: ResolutionKind,\n        scopeTower: ImplicitScopeTower,\n        detailedReceiver: DetailedReceiver?\n    ): Boolean {\n        val reference = context.call."}
{"code": "calleeExpression as? KtReferenceExpression ?: return false\n\n        val errorCandidates = when (kind) {\n            ResolutionKind.Function -> collectErrorCandidatesForFunction(scopeTower, name, detailedReceiver)\n            ResolutionKind.Variable -> collectErrorCandidatesForVariable(scopeTower, name, detailedReceiver)\n            else -> emptyList()\n        }\n\n        val candidate = errorCandidates.firstOrNull() as? ErrorCandidate.Classifier ?: return false\n\n        context.trace.record(BindingContext.REFERENCE_TARGET, reference, candidate.descriptor)\n        context.trace.report(Errors.RESOLUTION_TO_CLASSIFIER.on(reference, candidate.descriptor, candidate.kind, candidate.errorMessage))\n\n        return true\n    }\n\n    public class ImplicitScopeTowerImpl(\n        val resolutionContext: BasicCallResolutionContext,\n        override val dynamicScope: MemberScope,\n        override val syntheticScopes: SyntheticScopes,\n        override val location: LookupLocation,\n        override val ty"}
{"code": "peApproximator: TypeApproximator,\n        override val implicitsResolutionFilter: ImplicitsExtensionsResolutionFilter,\n        val callResolver: CallResolver,\n        val candidateInterceptor: CandidateInterceptor\n    ) : ImplicitScopeTower {\n        private val cache = HashMap<ReceiverValue, ReceiverValueWithSmartCastInfo>()\n\n        override fun getImplicitReceiver(scope: LexicalScope): ReceiverValueWithSmartCastInfo? =\n            scope.implicitReceiver?.value?.let {\n                cache.getOrPut(it) { resolutionContext.transformToReceiverWithSmartCastInfo(it) }\n            }\n\n        override fun getContextReceivers(scope: LexicalScope): List<ReceiverValueWithSmartCastInfo> =\n            scope.contextReceiversGroup.map { cache.getOrPut(it.value) { resolutionContext.transformToReceiverWithSmartCastInfo(it.value) } }\n\n        override fun getNameForGivenImportAlias(name: Name): Name? =\n            (resolutionContext.call.callElement.containingFile as? KtFile)?.getNameForGivenImportA"}
{"code": "lias(name)\n\n        override val lexicalScope: LexicalScope get() = resolutionContext.scope\n\n        override val isDebuggerContext: Boolean get() = resolutionContext.isDebuggerContext\n\n        override val isNewInferenceEnabled: Boolean\n            get() = resolutionContext.languageVersionSettings.supportsFeature(LanguageFeature.NewInference)\n\n        override val areContextReceiversEnabled: Boolean\n            get() = resolutionContext.languageVersionSettings.supportsFeature(LanguageFeature.ContextReceivers)\n\n        override val languageVersionSettings: LanguageVersionSettings\n            get() = resolutionContext.languageVersionSettings\n\n        override fun interceptFunctionCandidates(\n            resolutionScope: ResolutionScope,\n            name: Name,\n            initialResults: Collection<FunctionDescriptor>,\n            location: LookupLocation,\n            dispatchReceiver: ReceiverValueWithSmartCastInfo?,\n            extensionReceiver: ReceiverValueWithSmartCastInfo?\n      "}
{"code": "  ): Collection<FunctionDescriptor> {\n            return candidateInterceptor.interceptFunctionCandidates(initialResults, this, resolutionContext, resolutionScope, callResolver, name, location)\n        }\n\n        override fun interceptVariableCandidates(\n            resolutionScope: ResolutionScope,\n            name: Name,\n            initialResults: Collection<VariableDescriptor>,\n            location: LookupLocation,\n            dispatchReceiver: ReceiverValueWithSmartCastInfo?,\n            extensionReceiver: ReceiverValueWithSmartCastInfo?\n        ): Collection<VariableDescriptor> {\n            return candidateInterceptor.interceptVariableCandidates(initialResults, this, resolutionContext, resolutionScope, callResolver, name, location)\n        }\n    }\n\n    class MyCandidate(\n        // Diagnostics that are already computed\n        // if resultingApplicability is successful they must be the same as `diagnostics`,\n        // otherwise they might be a bit different but result remains u"}
{"code": "nsuccessful\n        val eagerDiagnostics: List<KotlinCallDiagnostic>,\n        val resolvedCall: MutableResolvedCall<*>,\n        finalDiagnosticsComputation: (() -> List<KotlinCallDiagnostic>)? = null\n    ) : Candidate {\n        val diagnostics: List<KotlinCallDiagnostic> by lazy(LazyThreadSafetyMode.NONE) {\n            finalDiagnosticsComputation?.invoke() ?: eagerDiagnostics\n        }\n\n        operator fun component1() = diagnostics\n        operator fun component2() = resolvedCall\n\n        override val resultingApplicability: CandidateApplicability by lazy(LazyThreadSafetyMode.NONE) {\n            getResultApplicability(diagnostics)\n        }\n\n        override fun addCompatibilityWarning(other: Candidate) {\n            // Only applicable for new inference\n        }\n\n        @OptIn(ApplicabilityDetail::class)\n        override val isSuccessful = getResultApplicability(eagerDiagnostics).isSuccess\n    }\n\n    private inner class CandidateFactoryImpl(\n        val name: Name,\n        val basi"}
{"code": "cCallContext: BasicCallResolutionContext,\n        val tracing: TracingStrategy\n    ) : CandidateFactory<MyCandidate> {\n        override fun createCandidate(\n            towerCandidate: CandidateWithBoundDispatchReceiver,\n            explicitReceiverKind: ExplicitReceiverKind,\n            extensionReceiver: ReceiverValueWithSmartCastInfo?\n        ): MyCandidate {\n\n            val candidateTrace = TemporaryBindingTrace.create(basicCallContext.trace, \"Context for resolve candidate\")\n            val candidateCall = ResolvedCallImpl(\n                basicCallContext.call, towerCandidate.descriptor,\n                towerCandidate.dispatchReceiver?.receiverValue, extensionReceiver?.receiverValue,\n                explicitReceiverKind, null, candidateTrace, tracing,\n                basicCallContext.dataFlowInfoForArguments // todo may be we should create new mutable info for arguments\n            )\n\n            \n            if (extensionReceiver != null) {\n                val parameterIsDynamic"}
{"code": " = towerCandidate.descriptor.extensionReceiverParameter!!.value.type.isDynamic()\n                val argumentIsDynamic = extensionReceiver.receiverValue.type.isDynamic()\n\n                if (parameterIsDynamic != argumentIsDynamic ||\n                    (parameterIsDynamic && !towerCandidate.descriptor.hasDynamicExtensionAnnotation())\n                ) {\n                    return MyCandidate(listOf(HiddenExtensionRelatedToDynamicTypes), candidateCall)\n                }\n            }\n\n            if (deprecationResolver.isHiddenInResolution(\n                    towerCandidate.descriptor, basicCallContext.call, basicCallContext.trace.bindingContext, basicCallContext.isSuperCall\n                )\n            ) {\n                return MyCandidate(listOf(HiddenDescriptor), candidateCall)\n            }\n\n            val callCandidateResolutionContext = CallCandidateResolutionContext.create(\n                candidateCall, basicCallContext, candidateTrace, tracing, basicCallContext.call,\n    "}
{"code": "            CandidateResolveMode.EXIT_ON_FIRST_ERROR\n            )\n            candidateResolver.performResolutionForCandidateCall(callCandidateResolutionContext, basicCallContext.checkArguments) // todo\n\n            val diagnostics = createDiagnosticsForCandidate(towerCandidate, candidateCall)\n            return MyCandidate(diagnostics, candidateCall) {\n                candidateCall.performRemainingTasks()\n                createDiagnosticsForCandidate(towerCandidate, candidateCall)\n            }\n        }\n\n        \n        override fun createCandidate(\n            towerCandidate: CandidateWithBoundDispatchReceiver,\n            explicitReceiverKind: ExplicitReceiverKind,\n            extensionReceiverCandidates: List<ReceiverValueWithSmartCastInfo>\n        ): MyCandidate = error(\"${this::class.simpleName} doesn't support candidates with multiple extension receiver candidates\")\n\n        override fun createErrorCandidate(): MyCandidate {\n            throw IllegalStateException(\"Not suppor"}
{"code": "ted creating error candidate for the old type inference candidate factory\")\n        }\n\n        private fun createDiagnosticsForCandidate(\n            towerCandidate: CandidateWithBoundDispatchReceiver,\n            candidateCall: ResolvedCallImpl<CallableDescriptor>\n        ): List<ResolutionDiagnostic> =\n            mutableListOf<ResolutionDiagnostic>().apply {\n                addAll(towerCandidate.diagnostics)\n                addAll(checkInfixAndOperator(basicCallContext.call, towerCandidate.descriptor))\n                addIfNotNull(createPreviousResolveError(candidateCall.status))\n            }\n\n        private fun checkInfixAndOperator(call: Call, descriptor: CallableDescriptor): List<ResolutionDiagnostic> {\n            if (descriptor !is FunctionDescriptor || ErrorUtils.isError(descriptor)) return emptyList()\n            if (descriptor.name != name && (name == OperatorNameConventions.UNARY_PLUS || name == OperatorNameConventions.UNARY_MINUS)) {\n                return listOf(Depreca"}
{"code": "tedUnaryPlusAsPlus)\n            }\n\n            val conventionError = if (isConventionCall(call) && !descriptor.isOperator) InvokeConventionCallNoOperatorModifier else null\n            val infixError = if (isInfixCall(call) && !descriptor.isInfix) InfixCallNoInfixModifier else null\n            return listOfNotNull(conventionError, infixError)\n        }\n\n    }\n\n    private inner class CandidateFactoryProviderForInvokeImpl(\n        val functionContext: CandidateFactoryImpl\n    ) : CandidateFactoryProviderForInvoke<MyCandidate> {\n\n        override fun transformCandidate(\n            variable: MyCandidate,\n            invoke: MyCandidate\n        ): MyCandidate {\n            @Suppress(\"UNCHECKED_CAST\") val resolvedCallImpl = VariableAsFunctionResolvedCallImpl(\n                invoke.resolvedCall as MutableResolvedCall<FunctionDescriptor>,\n                variable.resolvedCall as MutableResolvedCall<VariableDescriptor>\n            )\n            @OptIn(ApplicabilityDetail::class)\n            a"}
{"code": "ssert(variable.resultingApplicability.isSuccess) {\n                \"Variable call must be success: $variable\"\n            }\n\n            return MyCandidate(variable.eagerDiagnostics + invoke.eagerDiagnostics, resolvedCallImpl) {\n                variable.diagnostics + invoke.diagnostics\n            }\n        }\n\n        override fun factoryForVariable(stripExplicitReceiver: Boolean): CandidateFactory<MyCandidate> {\n            val newCall = CallTransformer.stripCallArguments(functionContext.basicCallContext.call).let {\n                if (stripExplicitReceiver) CallTransformer.stripReceiver(it) else it\n            }\n            return CandidateFactoryImpl(\n                functionContext.name,\n                functionContext.basicCallContext.replaceCall(newCall),\n                functionContext.tracing\n            )\n        }\n\n        override fun factoryForInvoke(\n            variable: MyCandidate,\n            useExplicitReceiver: Boolean\n        ): Pair<ReceiverValueWithSmartCastInfo, "}
{"code": "CandidateFactory<MyCandidate>>? {\n            assert(variable.resolvedCall.status.possibleTransformToSuccess()) {\n                \"Incorrect status: ${variable.resolvedCall.status} for variable call: ${variable.resolvedCall} \" +\n                        \"and descriptor: ${variable.resolvedCall.candidateDescriptor}\"\n            }\n            val calleeExpression = variable.resolvedCall.call.calleeExpression\n            val variableDescriptor = variable.resolvedCall.resultingDescriptor as VariableDescriptor\n            assert(variable.resolvedCall.status.possibleTransformToSuccess() && calleeExpression != null) {\n                \"Unexpected variable candidate: $variable\"\n            }\n            val variableType = variableDescriptor.type\n\n            if (variableType is DeferredType && variableType.isComputing) {\n                return null // todo: create special check that there is no invoke on variable\n            }\n            val basicCallContext = functionContext.basicCallContext\n "}
{"code": "           val variableReceiver = ExpressionReceiver.create(\n                calleeExpression!!,\n                variableType,\n                basicCallContext.trace.bindingContext\n            )\n            // used for smartCasts, see: DataFlowValueFactory.getIdForSimpleNameExpression\n            functionContext.tracing.bindReference(variable.resolvedCall.trace, variable.resolvedCall)\n            // todo hacks\n            val functionCall = CallTransformer.CallForImplicitInvoke(\n                basicCallContext.call.explicitReceiver?.takeIf { useExplicitReceiver },\n                variableReceiver, basicCallContext.call, true\n            )\n            val tracingForInvoke = TracingStrategyForInvoke(calleeExpression, functionCall, variableReceiver.type)\n            val basicCallResolutionContext = basicCallContext.replaceBindingTrace(variable.resolvedCall.trace)\n                .replaceCall(functionCall)\n                .replaceContextDependency(ContextDependency.DEPENDENT) // todo\n\n   "}
{"code": "         val newContext = CandidateFactoryImpl(OperatorNameConventions.INVOKE, basicCallResolutionContext, tracingForInvoke)\n\n            return basicCallResolutionContext.transformToReceiverWithSmartCastInfo(variableReceiver) to newContext\n        }\n\n    }\n\n}\n\nfun ResolutionContext<*>.transformToReceiverWithSmartCastInfo(receiver: ReceiverValue) =\n    transformToReceiverWithSmartCastInfo(scope.ownerDescriptor, trace.bindingContext, dataFlowInfo, receiver, languageVersionSettings, dataFlowValueFactory)\n\nfun transformToReceiverWithSmartCastInfo(\n    containingDescriptor: DeclarationDescriptor,\n    bindingContext: BindingContext,\n    dataFlowInfo: DataFlowInfo,\n    receiver: ReceiverValue,\n    languageVersionSettings: LanguageVersionSettings,\n    dataFlowValueFactory: DataFlowValueFactory\n): ReceiverValueWithSmartCastInfo {\n    val dataFlowValue = dataFlowValueFactory.createDataFlowValue(receiver, bindingContext, containingDescriptor)\n    return ReceiverValueWithSmartCastInfo(\n        re"}
{"code": "ceiver,\n        dataFlowInfo.getCollectedTypes(dataFlowValue, languageVersionSettings).compactIfPossible(),\n        dataFlowValue.isStable\n    )\n}\n\ninternal class PreviousResolutionError(candidateLevel: CandidateApplicability) : ResolutionDiagnostic(candidateLevel)\n\ninternal fun createPreviousResolveError(status: ResolutionStatus): PreviousResolutionError? {\n    val level = when (status) {\n        ResolutionStatus.SUCCESS, ResolutionStatus.INCOMPLETE_TYPE_INFERENCE -> return null\n        ResolutionStatus.UNSAFE_CALL_ERROR -> CandidateApplicability.UNSAFE_CALL\n        ResolutionStatus.ARGUMENTS_MAPPING_ERROR -> CandidateApplicability.INAPPLICABLE_ARGUMENTS_MAPPING_ERROR\n        ResolutionStatus.RECEIVER_TYPE_ERROR -> CandidateApplicability.INAPPLICABLE_WRONG_RECEIVER\n        else -> CandidateApplicability.INAPPLICABLE\n    }\n    return PreviousResolutionError(level)\n}\n\ninternal fun Call.isCallWithSuperReceiver(): Boolean = explicitReceiver is SuperCallReceiverValue \nprivate val BasicCall"}
{"code": "ResolutionContext.isSuperCall: Boolean get() = call.isCallWithSuperReceiver()\n\ninternal fun reportResolvedUsingDeprecatedVisibility(\n    call: Call,\n    candidateDescriptor: CallableDescriptor,\n    resultingDescriptor : CallableDescriptor,\n    diagnostic: ResolvedUsingDeprecatedVisibility,\n    trace: BindingTrace\n) {\n    trace.record(\n        BindingContext.DEPRECATED_SHORT_NAME_ACCESS,\n        call.calleeExpression\n    )\n\n    val descriptorToLookup: DeclarationDescriptor = when (candidateDescriptor) {\n        is ClassConstructorDescriptor -> candidateDescriptor.containingDeclaration\n        is FakeCallableDescriptorForObject -> candidateDescriptor.classDescriptor\n        is SyntheticMemberDescriptor<*> -> candidateDescriptor.baseDescriptorForSynthetic\n        is PropertyDescriptor, is FunctionDescriptor -> candidateDescriptor\n        else -> error(\n            \"Unexpected candidate descriptor of resolved call with \" +\n                    \"ResolvedUsingDeprecatedVisibility-diagnostic: "}
{"code": "$candidateDescriptor\\n\" +\n                    \"Call context: ${call.callElement.parent?.text}\"\n        )\n    }\n\n    // If this descriptor was resolved from HierarchicalScope, then there can be another, non-deprecated path\n    // in parents of base scope\n    val sourceScope = diagnostic.baseSourceScope\n    val canBeResolvedWithoutDeprecation = if (sourceScope is HierarchicalScope) {\n        descriptorToLookup.canBeResolvedWithoutDeprecation(\n            sourceScope,\n            diagnostic.lookupLocation\n        )\n    } else {\n        // Normally, that should be unreachable, but instead of asserting that, we will report diagnostic\n        false\n    }\n\n    if (!canBeResolvedWithoutDeprecation) {\n        trace.report(\n            Errors.DEPRECATED_ACCESS_BY_SHORT_NAME.on(call.callElement, resultingDescriptor)\n        )\n    }\n\n}\n"}
{"code": "// SKIP_WHEN_OUT_OF_CONTENT_ROOT\n// MEMBER_NAME_FILTER: something\n// FILE: Derived.kt\nclass Der<caret>ived : Base() {\n    @Anno(\"getSomething: ${getterProperty}\")\n    override fun getSomething(): String {\n        \"body: ${propertyFromBody}\"\n    }\n\n    @Anno(\"setSomething: ${setterProperty}\")\n    override fun setSomething(s: @Anno(\"setter type ${propertyFromSetter}\") String) {\n        println(s)\n    }\n}\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)\nannotation class Anno(val s: String)\n\nval getterProperty = 2.let { it + 1 }\nval setterProperty = 2.let { it + 1 }\nval propertyFromBody = \"str\" + 1.toString()\nval propertyFromSetter = 1.toString() + \"2\"\n\n// FILE: Base.java\npublic class Base {\n    public String getSomething() {\n        return \"\";\n    }\n\n    public void setSomething(String s) {\n\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.cli.jvm.compiler\n\nimport com.intellij.openapi.extensions.ExtensionPoint\nimport com.intellij.openapi.project.Project\nimport com.intellij.openapi.util.Disposer\nimport com.intellij.openapi.vfs.StandardFileSystems\nimport com.intellij.openapi.vfs.VirtualFile\nimport com.intellij.openapi.vfs.VirtualFileManager\nimport com.intellij.openapi.vfs.VirtualFileSystem\nimport com.intellij.psi.PsiElementFinder\nimport com.intellij.psi.PsiFile\nimport com.intellij.psi.search.GlobalSearchScope\nimport com.intellij.psi.search.ProjectScope\nimport org.jetbrains.kotlin.KtIoFileSourceFile\nimport org.jetbrains.kotlin.KtPsiSourceFile\nimport org.jetbrains.kotlin.KtSourceFile\nimport org.jetbrains.kotlin.KtVirtualFileSourceFile\nimport org.jetbrains.kotlin.asJava.finder.JavaElementFinder\nimport org.jetbrains.kotlin.fir.FirModuleData\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.SessionConfiguration\nimport org.jetbrains.kotlin.fir.java.FirJavaElementFinder\nimpo"}
{"code": "rt org.jetbrains.kotlin.fir.java.FirJavaFacadeForSource\nimport org.jetbrains.kotlin.fir.session.environment.AbstractProjectEnvironment\nimport org.jetbrains.kotlin.fir.session.environment.AbstractProjectFileSearchScope\nimport org.jetbrains.kotlin.load.java.createJavaClassFinder\nimport org.jetbrains.kotlin.load.kotlin.KotlinClassFinder\nimport org.jetbrains.kotlin.load.kotlin.PackagePartProvider\nimport org.jetbrains.kotlin.load.kotlin.VirtualFileFinderFactory\nimport org.jetbrains.kotlin.resolve.jvm.modules.JavaModuleResolver\nimport java.io.File\n\nclass PsiBasedProjectFileSearchScope(val psiSearchScope: GlobalSearchScope) : AbstractProjectFileSearchScope {\n\n    override val isEmpty: Boolean\n        get() = psiSearchScope == GlobalSearchScope.EMPTY_SCOPE\n\n    override operator fun minus(other: AbstractProjectFileSearchScope): AbstractProjectFileSearchScope =\n        PsiBasedProjectFileSearchScope(psiSearchScope.intersectWith(GlobalSearchScope.notScope(other.asPsiSearchScope())))\n\n    overrid"}
{"code": "e operator fun plus(other: AbstractProjectFileSearchScope): AbstractProjectFileSearchScope =\n        PsiBasedProjectFileSearchScope(psiSearchScope.uniteWith(other.asPsiSearchScope()))\n\n    override operator fun not(): AbstractProjectFileSearchScope =\n        PsiBasedProjectFileSearchScope(GlobalSearchScope.notScope(psiSearchScope))\n}\n\nopen class VfsBasedProjectEnvironment(\n    val project: Project,\n    val localFileSystem: VirtualFileSystem,\n    private val getPackagePartProviderFn: (GlobalSearchScope) -> PackagePartProvider\n) : AbstractProjectEnvironment {\n\n    override fun getKotlinClassFinder(fileSearchScope: AbstractProjectFileSearchScope): KotlinClassFinder =\n        VirtualFileFinderFactory.getInstance(project).create(fileSearchScope.asPsiSearchScope())\n\n    override fun getJavaModuleResolver(): JavaModuleResolver =\n        JavaModuleResolver.getInstance(project)\n\n    override fun getPackagePartProvider(fileSearchScope: AbstractProjectFileSearchScope): PackagePartProvider =\n     "}
{"code": "   getPackagePartProviderFn(fileSearchScope.asPsiSearchScope())\n\n    @OptIn(SessionConfiguration::class)\n    override fun registerAsJavaElementFinder(firSession: FirSession) {\n        val psiFinderExtensionPoint = PsiElementFinder.EP.getPoint(project)\n        psiFinderExtensionPoint.unregisterFinders<JavaElementFinder>()\n        psiFinderExtensionPoint.unregisterFinders<FirJavaElementFinder>()\n\n        val firJavaElementFinder = FirJavaElementFinder(firSession, project)\n        firSession.register(FirJavaElementFinder::class, firJavaElementFinder)\n        // see comment and TODO in KotlinCoreEnvironment.registerKotlinLightClassSupport (KT-64296)\n        @Suppress(\"DEPRECATION\")\n        PsiElementFinder.EP.getPoint(project).registerExtension(firJavaElementFinder)\n        Disposer.register(project) {\n            psiFinderExtensionPoint.unregisterFinders<FirJavaElementFinder>()\n        }\n    }\n\n    private fun List<VirtualFile>.toSearchScope(allowOutOfProjectRoots: Boolean) =\n        take"}
{"code": "If { it.isNotEmpty() }\n            ?.let {\n                if (allowOutOfProjectRoots) GlobalSearchScope.filesWithLibrariesScope(project, it)\n                else GlobalSearchScope.filesWithoutLibrariesScope(project, it)\n            }\n            ?: GlobalSearchScope.EMPTY_SCOPE\n\n    override fun getSearchScopeByIoFiles(files: Iterable<File>, allowOutOfProjectRoots: Boolean): AbstractProjectFileSearchScope =\n        PsiBasedProjectFileSearchScope(\n            files\n                .mapNotNull { localFileSystem.findFileByPath(it.absolutePath) }\n                .toSearchScope(allowOutOfProjectRoots)\n        )\n\n    override fun getSearchScopeBySourceFiles(files: Iterable<KtSourceFile>, allowOutOfProjectRoots: Boolean): AbstractProjectFileSearchScope =\n        PsiBasedProjectFileSearchScope(\n            files\n                .mapNotNull {\n                    when (it) {\n                        is KtPsiSourceFile -> it.psiFile.virtualFile\n                        is KtVirtualFileSourceFile -"}
{"code": "> it.virtualFile\n                        is KtIoFileSourceFile -> localFileSystem.findFileByPath(it.file.absolutePath)\n                        else -> null // TODO: find out whether other use cases should be supported\n                    }\n                }\n                .toSearchScope(allowOutOfProjectRoots)\n        )\n\n    override fun getSearchScopeByDirectories(directories: Iterable<File>): AbstractProjectFileSearchScope =\n        PsiBasedProjectFileSearchScope(\n            directories\n                .mapNotNull { localFileSystem.findFileByPath(it.absolutePath) }\n                .toSet()\n                .takeIf { it.isNotEmpty() }\n                ?.let {\n                    KotlinToJVMBytecodeCompiler.DirectoriesScope(project, it)\n                } ?: GlobalSearchScope.EMPTY_SCOPE\n        )\n\n    fun getSearchScopeByPsiFiles(files: Iterable<PsiFile>, allowOutOfProjectRoots: Boolean= false): AbstractProjectFileSearchScope =\n        PsiBasedProjectFileSearchScope(\n            files."}
{"code": "map { it.virtualFile }.let {\n                if (allowOutOfProjectRoots) GlobalSearchScope.filesWithLibrariesScope(project, it)\n                else GlobalSearchScope.filesWithoutLibrariesScope(project, it)\n            }\n        )\n\n    override fun getSearchScopeForProjectLibraries(): AbstractProjectFileSearchScope =\n        PsiBasedProjectFileSearchScope(ProjectScope.getLibrariesScope(project))\n\n    override fun getSearchScopeForProjectJavaSources(): AbstractProjectFileSearchScope =\n        PsiBasedProjectFileSearchScope(TopDownAnalyzerFacadeForJVM.AllJavaSourcesInProjectScope(project))\n\n    override fun getFirJavaFacade(\n        firSession: FirSession,\n        baseModuleData: FirModuleData,\n        fileSearchScope: AbstractProjectFileSearchScope\n    ) = FirJavaFacadeForSource(firSession, baseModuleData, project.createJavaClassFinder(fileSearchScope.asPsiSearchScope()))\n\n}\n\nprivate fun AbstractProjectFileSearchScope.asPsiSearchScope() =\n    when {\n        this === AbstractProjectFileS"}
{"code": "earchScope.EMPTY -> GlobalSearchScope.EMPTY_SCOPE\n        this === AbstractProjectFileSearchScope.ANY -> GlobalSearchScope.notScope(GlobalSearchScope.EMPTY_SCOPE)\n        else -> (this as PsiBasedProjectFileSearchScope).psiSearchScope\n    }\n\nfun KotlinCoreEnvironment.toAbstractProjectEnvironment(): AbstractProjectEnvironment =\n    VfsBasedProjectEnvironment(\n        project, VirtualFileManager.getInstance().getFileSystem(StandardFileSystems.FILE_PROTOCOL),\n        { createPackagePartProvider(it) }\n    )\n\nfun GlobalSearchScope.toAbstractProjectFileSearchScope(): AbstractProjectFileSearchScope =\n    PsiBasedProjectFileSearchScope(this)\n\ninline fun <reified T : PsiElementFinder> ExtensionPoint<PsiElementFinder>.unregisterFinders() {\n    if (extensionList.any { it is T }) {\n        unregisterExtension(T::class.java)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.inference\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.builtins.StandardNames\nimport org.jetbrains.kotlin.fakeElement\nimport org.jetbrains.kotlin.fir.*\nimport org.jetbrains.kotlin.fir.declarations.FirAnonymousFunction\nimport org.jetbrains.kotlin.fir.declarations.FirDeclarationOrigin\nimport org.jetbrains.kotlin.fir.declarations.FirFunction\nimport org.jetbrains.kotlin.fir.declarations.FirResolvePhase\nimport org.jetbrains.kotlin.fir.declarations.builder.buildContextReceiver\nimport org.jetbrains.kotlin.fir.declarations.builder.buildValueParameter\nimport org.jetbrains.kotlin.fir.diagnostics.ConeCannotInferReceiverParameterType\nimport org.jetbrains.kotlin.fir.diagnostics.ConeCannotInferValueParameterType\nimport org.jetbrains.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.resolve.ResolutionMode\nimport org.jetbrains.kotlin.fir.resolve.calls.*\nimport org.jetbrains.kotlin.fir.resolve.fullyExpandedType\nimport"}
{"code": " org.jetbrains.kotlin.fir.resolve.inference.model.ConeArgumentConstraintPosition\nimport org.jetbrains.kotlin.fir.resolve.inference.model.ConeExpectedTypeConstraintPosition\nimport org.jetbrains.kotlin.fir.resolve.initialTypeOfCandidate\nimport org.jetbrains.kotlin.fir.resolve.substitution.ConeSubstitutor\nimport org.jetbrains.kotlin.fir.resolve.transformers.FirCallCompletionResultsWriterTransformer\nimport org.jetbrains.kotlin.fir.resolve.transformers.body.resolve.FirAbstractBodyResolveTransformer\nimport org.jetbrains.kotlin.fir.resolve.transformers.body.resolve.FirAbstractBodyResolveTransformerDispatcher\nimport org.jetbrains.kotlin.fir.resolve.transformers.body.resolve.resultType\nimport org.jetbrains.kotlin.fir.resolve.transformers.replaceLambdaArgumentInvocationKinds\nimport org.jetbrains.kotlin.fir.resolve.typeFromCallee\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\nimport org.jetbrains.kotlin.fir.symbols.SyntheticCallableId\nimport org.jetbrains.kotlin.fir.symbols.impl.FirCallab"}
{"code": "leSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirValueParameterSymbol\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.fir.types.builder.buildErrorTypeRef\nimport org.jetbrains.kotlin.fir.types.builder.buildResolvedTypeRef\nimport org.jetbrains.kotlin.fir.types.impl.ConeClassLikeTypeImpl\nimport org.jetbrains.kotlin.fir.visitors.transformSingle\nimport org.jetbrains.kotlin.resolve.calls.inference.addEqualityConstraintIfCompatible\nimport org.jetbrains.kotlin.resolve.calls.inference.addSubtypeConstraintIfCompatible\nimport org.jetbrains.kotlin.resolve.calls.inference.buildAbstractResultingSubstitutor\nimport org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintSystemCompletionMode\nimport org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintStorage\nimport org.jetbrains.kotlin.types.TypeApproximatorConfiguration\nimport org.jetbrains.kotlin.types.model.safeSubstitute\nimport org.jetbrains.kotlin.utils.addToStdlib.runIf\n\nclass FirCallCompleter(\n    pr"}
{"code": "ivate val transformer: FirAbstractBodyResolveTransformerDispatcher,\n    private val components: FirAbstractBodyResolveTransformer.BodyResolveTransformerComponents,\n) {\n    private val session = components.session\n    private val inferenceSession\n        get() = transformer.context.inferenceSession\n\n    val completer = ConstraintSystemCompleter(components)\n\n    fun <T> completeCall(\n        call: T,\n        resolutionMode: ResolutionMode,\n        // Only expected to be true for resolving different versions of augmented assignments\n        skipEvenPartialCompletion: Boolean = false,\n    ): T where T : FirResolvable, T : FirStatement {\n        val typeRef = components.typeFromCallee(call)\n\n        val reference = call.calleeReference as? FirNamedReferenceWithCandidate ?: return call\n\n        val candidate = reference.candidate\n        val initialType = typeRef.initialTypeOfCandidate(candidate)\n\n        if (call is FirExpression) {\n            call.resultType = initialType\n            sess"}
{"code": "ion.lookupTracker?.recordTypeResolveAsLookup(initialType, call.source, components.context.file.source)\n        }\n\n        addConstraintFromExpectedType(\n            candidate,\n            initialType,\n            resolutionMode,\n        )\n\n        if (skipEvenPartialCompletion) return call\n\n        val completionMode = candidate.computeCompletionMode(\n            session.inferenceComponents, resolutionMode, initialType\n        ).let {\n            when {\n                it == ConstraintSystemCompletionMode.FULL ->\n                    inferenceSession.customCompletionModeInsteadOfFull(call) ?: ConstraintSystemCompletionMode.FULL\n                else -> it\n            }\n        }\n\n        val analyzer = createPostponedArgumentsAnalyzer(transformer.resolutionContext)\n        if (call is FirFunctionCall) {\n            call.replaceLambdaArgumentInvocationKinds(session)\n        }\n\n        return when (completionMode) {\n            ConstraintSystemCompletionMode.FULL -> {\n                runCo"}
{"code": "mpletionForCall(candidate, completionMode, call, initialType, analyzer)\n\n                val readOnlyConstraintStorage = candidate.system.asReadOnlyStorage()\n                checkStorageConstraintsAfterFullCompletion(readOnlyConstraintStorage)\n\n                val finalSubstitutor = readOnlyConstraintStorage\n                    .buildAbstractResultingSubstitutor(session.typeContext) as ConeSubstitutor\n                call.transformSingle(\n                    FirCallCompletionResultsWriterTransformer(\n                        session, components.scopeSession, finalSubstitutor,\n                        components.returnTypeCalculator,\n                        session.typeApproximator,\n                        components.dataFlowAnalyzer,\n                        components.integerLiteralAndOperatorApproximationTransformer,\n                        components.samResolver,\n                        components.context,\n                    ),\n                    null\n                )\n            }\n"}
{"code": "\n            ConstraintSystemCompletionMode.PARTIAL, ConstraintSystemCompletionMode.PCLA_POSTPONED_CALL -> {\n                runCompletionForCall(candidate, completionMode, call, initialType, analyzer)\n\n                inferenceSession.processPartiallyResolvedCall(call, resolutionMode, completionMode)\n\n                call\n            }\n\n            ConstraintSystemCompletionMode.UNTIL_FIRST_LAMBDA -> throw IllegalStateException()\n        }\n    }\n\n    private fun checkStorageConstraintsAfterFullCompletion(storage: ConstraintStorage) {\n        // Fast path for sake of optimization\n        if (storage.notFixedTypeVariables.isEmpty()) return\n\n        val notFixedTypeVariablesBasedOnTypeParameters = storage.notFixedTypeVariables.filter {\n            it.value.typeVariable is ConeTypeParameterBasedTypeVariable\n        }\n\n        // TODO: Turn it into `require(storage.notFixedTypeVariables.isEmpty())` (KT-66759)\n        require(notFixedTypeVariablesBasedOnTypeParameters.isEmpty()) {\n         "}
{"code": "   \"All variables should be fixed to something, \" +\n                    \"but {${notFixedTypeVariablesBasedOnTypeParameters.keys.joinToString(\", \")}} are found\"\n        }\n    }\n\n    private fun addConstraintFromExpectedType(\n        candidate: Candidate,\n        initialType: ConeKotlinType,\n        resolutionMode: ResolutionMode,\n    ) {\n        if (resolutionMode !is ResolutionMode.WithExpectedType) return\n        val expectedType = resolutionMode.expectedTypeRef.type.fullyExpandedType(session)\n\n        val system = candidate.system\n        when {\n            // Only add equality constraint in independent contexts (resolutionMode.forceFullCompletion) for K1 compatibility.\n            // Otherwise,\n            // we miss some constraints from incorporation which leads to NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER in cases like\n            // compiler/testData/diagnostics/tests/inference/nestedIfWithExpectedType.kt.\n            resolutionMode.forceFullCompletion && candidate.isSyntheticF"}
{"code": "unctionCallThatShouldUseEqualityConstraint(expectedType) ->\n                system.addEqualityConstraintIfCompatible(initialType, expectedType, ConeExpectedTypeConstraintPosition)\n\n            // If type mismatch is assumed to be reported in the checker, we should not add a subtyping constraint that leads to error.\n            // Because it might make resulting type correct while, it's hopefully would be more clear if we let the call be inferred without\n            // the expected type, and then would report diagnostic in the checker.\n            // It's assumed to be safe & sound, because if constraint system has contradictions when expected type is added,\n            // the resulting expression type cannot be inferred to something that is a subtype of `expectedType`,\n            // thus the diagnostic should be reported.\n            !resolutionMode.shouldBeStrictlyEnforced || resolutionMode.expectedTypeMismatchIsReportedInChecker -> {\n                system.addSubtypeConstraintIfComp"}
{"code": "atible(initialType, expectedType, ConeExpectedTypeConstraintPosition)\n            }\n            resolutionMode.fromCast -> {\n                if (candidate.isFunctionForExpectTypeFromCastFeature()) {\n                    system.addSubtypeConstraint(\n                        initialType, expectedType,\n                        ConeExpectedTypeConstraintPosition,\n                    )\n                }\n            }\n            !expectedType.isUnitOrFlexibleUnit || !resolutionMode.mayBeCoercionToUnitApplied -> {\n                system.addSubtypeConstraint(initialType, expectedType, ConeExpectedTypeConstraintPosition)\n            }\n            system.notFixedTypeVariables.isEmpty() -> return\n            expectedType.isUnit -> {\n                system.addEqualityConstraintIfCompatible(initialType, expectedType, ConeExpectedTypeConstraintPosition)\n            }\n            else -> {\n                system.addSubtypeConstraintIfCompatible(initialType, expectedType, ConeExpectedTypeConstraintPosit"}
{"code": "ion)\n            }\n        }\n    }\n\n    \n    private fun Candidate.isSyntheticFunctionCallThatShouldUseEqualityConstraint(expectedType: ConeKotlinType): Boolean {\n        // If we're inside an assignment's RHS, we mustn't add an equality constraint because it might prevent smartcasts.\n        // Example: val x: String? = null; x = if (foo) \"\" else throw Exception()\n        if (components.context.isInsideAssignmentRhs) return false\n\n        val symbol = symbol as? FirCallableSymbol ?: return false\n        if (symbol.origin != FirDeclarationOrigin.Synthetic.FakeFunction ||\n            expectedType.isUnitOrNullableUnit ||\n            expectedType.isAnyOrNullableAny ||\n            // We don't want to add an equality constraint to a nullable type to a !! call.\n            // See compiler/testData/diagnostics/tests/inference/checkNotNullWithNullableExpectedType.kt\n            (symbol.callableId == SyntheticCallableId.CHECK_NOT_NULL && expectedType.canBeNull(session))\n        ) {\n            "}
{"code": "return false\n        }\n\n        // If our expression contains any elvis, even nested, we mustn't add an equality constraint because it might influence the\n        // inferred type of the elvis RHS.\n        if (system.allTypeVariables.values.any {\n                it is ConeTypeParameterBasedTypeVariable && it.typeParameterSymbol.containingDeclarationSymbol.isSyntheticElvisFunction()\n            }\n        ) {\n            return false\n        }\n\n        return true\n    }\n\n    private fun FirBasedSymbol<*>.isSyntheticElvisFunction(): Boolean {\n        return origin == FirDeclarationOrigin.Synthetic.FakeFunction && (this as? FirCallableSymbol)?.callableId == SyntheticCallableId.ELVIS_NOT_NULL\n    }\n\n    fun <T> runCompletionForCall(\n        candidate: Candidate,\n        completionMode: ConstraintSystemCompletionMode,\n        call: T,\n        initialType: ConeKotlinType,\n        analyzer: PostponedArgumentsAnalyzer? = null,\n    ) where T : FirStatement {\n        @Suppress(\"NAME_SHADOWING\")\n "}
{"code": "       val analyzer = analyzer ?: createPostponedArgumentsAnalyzer(transformer.resolutionContext)\n        completer.complete(\n            candidate.system.asConstraintSystemCompleterContext(),\n            completionMode,\n            listOf(call),\n            initialType,\n            transformer.resolutionContext\n        ) { atom, withPCLASession ->\n            analyzer.analyze(candidate.system, atom, candidate, withPCLASession)\n        }\n    }\n\n    fun prepareLambdaAtomForFactoryPattern(\n        atom: ResolvedLambdaAtom,\n        candidate: Candidate,\n    ) {\n        val returnVariable = ConeTypeVariableForLambdaReturnType(atom.atom, \"_R\")\n        val csBuilder = candidate.system.getBuilder()\n        csBuilder.registerVariable(returnVariable)\n        val functionalType = csBuilder.buildCurrentSubstitutor()\n            .safeSubstitute(csBuilder, atom.expectedType!!) as ConeClassLikeType\n        val size = functionalType.typeArguments.size\n        val expectedType = ConeClassLikeTypeImpl("}
{"code": "\n            functionalType.lookupTag,\n            Array(size) { index -> if (index != size - 1) functionalType.typeArguments[index] else returnVariable.defaultType },\n            isNullable = functionalType.isNullable,\n            functionalType.attributes\n        )\n        csBuilder.addSubtypeConstraint(expectedType, functionalType, ConeArgumentConstraintPosition(atom.atom))\n        atom.replaceExpectedType(expectedType, returnVariable.defaultType)\n        atom.replaceTypeVariableForLambdaReturnType(returnVariable)\n    }\n\n    fun createCompletionResultsWriter(\n        substitutor: ConeSubstitutor,\n        mode: FirCallCompletionResultsWriterTransformer.Mode = FirCallCompletionResultsWriterTransformer.Mode.Normal,\n    ): FirCallCompletionResultsWriterTransformer {\n        return FirCallCompletionResultsWriterTransformer(\n            session, components.scopeSession, substitutor, components.returnTypeCalculator,\n            session.typeApproximator,\n            components.dataFlowAnaly"}
{"code": "zer,\n            components.integerLiteralAndOperatorApproximationTransformer,\n            components.samResolver,\n            components.context,\n            mode,\n        )\n    }\n\n    fun createPostponedArgumentsAnalyzer(context: ResolutionContext): PostponedArgumentsAnalyzer {\n        val lambdaAnalyzer = LambdaAnalyzerImpl()\n        return PostponedArgumentsAnalyzer(\n            context,\n            lambdaAnalyzer,\n            session.inferenceComponents,\n            transformer.components.callResolver\n        )\n    }\n\n    private inner class LambdaAnalyzerImpl : LambdaAnalyzer {\n        override fun analyzeAndGetLambdaReturnArguments(\n            lambdaAtom: ResolvedLambdaAtom,\n            receiverType: ConeKotlinType?,\n            contextReceivers: List<ConeKotlinType>,\n            parameters: List<ConeKotlinType>,\n            expectedReturnType: ConeKotlinType?,\n            candidate: Candidate,\n            withPCLASession: Boolean,\n            forOverloadByLambdaReturnType: Boo"}
{"code": "lean,\n        ): ReturnArgumentsAnalysisResult {\n            val lambdaArgument: FirAnonymousFunction = lambdaAtom.atom\n            val needItParam = lambdaArgument.valueParameters.isEmpty() && parameters.size == 1\n\n            val matchedParameter = candidate.argumentMapping?.firstNotNullOfOrNull { (currentArgument, currentValueParameter) ->\n                val currentLambdaArgument =\n                    (currentArgument as? FirAnonymousFunctionExpression)?.anonymousFunction\n                if (currentLambdaArgument === lambdaArgument) {\n                    currentValueParameter\n                } else {\n                    null\n                }\n            }\n\n            lambdaArgument.matchingParameterFunctionType = matchedParameter?.returnTypeRef?.coneType\n\n            val itParam = when {\n                needItParam -> {\n                    val name = StandardNames.IMPLICIT_LAMBDA_PARAMETER_NAME\n                    val itType = parameters.single()\n                    buildValuePar"}
{"code": "ameter {\n                        resolvePhase = FirResolvePhase.BODY_RESOLVE\n                        source = lambdaAtom.atom.source?.fakeElement(KtFakeSourceElementKind.ItLambdaParameter)\n                        containingFunctionSymbol = lambdaArgument.symbol\n                        moduleData = session.moduleData\n                        origin = FirDeclarationOrigin.Source\n                        this.name = name\n                        symbol = FirValueParameterSymbol(name)\n                        returnTypeRef =\n                            itType.approximateLambdaInputType(symbol, withPCLASession).toFirResolvedTypeRef(\n                                lambdaAtom.atom.source?.fakeElement(KtFakeSourceElementKind.ItLambdaParameter)\n                            )\n                        defaultValue = null\n                        isCrossinline = false\n                        isNoinline = false\n                        isVararg = false\n                    }\n                }\n             "}
{"code": "   else -> null\n            }\n\n            val expectedReturnTypeRef = expectedReturnType?.let { lambdaArgument.returnTypeRef.resolvedTypeFromPrototype(it) }\n\n            when {\n                receiverType == null -> lambdaArgument.replaceReceiverParameter(null)\n                !lambdaAtom.coerceFirstParameterToExtensionReceiver -> {\n                    lambdaArgument.receiverParameter?.apply {\n                        val type = receiverType.approximateLambdaInputType(valueParameter = null, withPCLASession)\n                        val source =\n                            source?.fakeElement(KtFakeSourceElementKind.LambdaReceiver)\n                                ?: lambdaArgument.source?.fakeElement(KtFakeSourceElementKind.LambdaReceiver)\n                        replaceTypeRef(typeRef.resolvedTypeFromPrototype(type, source))\n                    }\n                }\n                else -> lambdaArgument.replaceReceiverParameter(null)\n            }\n\n            if (contextReceivers.isNot"}
{"code": "Empty()) {\n                lambdaArgument.replaceContextReceivers(\n                    contextReceivers.map { contextReceiverType ->\n                        buildContextReceiver {\n                            typeRef = buildResolvedTypeRef {\n                                type = contextReceiverType\n                            }\n                        }\n                    }\n                )\n            }\n\n            val lookupTracker = session.lookupTracker\n            val fileSource = components.file.source\n            val theParameters = when {\n                lambdaAtom.coerceFirstParameterToExtensionReceiver -> when (receiverType) {\n                    null -> error(\"Coercion to extension receiver while no receiver present\")\n                    else -> listOf(receiverType) + parameters\n                }\n                else -> parameters\n            }\n            lambdaArgument.valueParameters.forEachIndexed { index, parameter ->\n                if (index >= theParameters.size) "}
{"code": "{\n                    // May happen in erroneous code, see KT-60450\n                    // In test forEachOnZip.kt we have two declared parameters, but in fact forEach expects only one\n                    parameter.replaceReturnTypeRef(\n                        buildErrorTypeRef {\n                            diagnostic = ConeCannotInferValueParameterType(\n                                parameter.symbol, \"Lambda or anonymous function has more parameters than expected\"\n                            )\n                            source = parameter.source\n                        }\n                    )\n                    return@forEachIndexed\n                }\n                val newReturnType = theParameters[index].approximateLambdaInputType(parameter.symbol, withPCLASession)\n                val newReturnTypeRef = if (parameter.returnTypeRef is FirImplicitTypeRef) {\n                    newReturnType.toFirResolvedTypeRef(parameter.source?.fakeElement(KtFakeSourceElementKind.ImplicitReturnTy"}
{"code": "peOfLambdaValueParameter))\n                } else parameter.returnTypeRef.resolvedTypeFromPrototype(newReturnType)\n                parameter.replaceReturnTypeRef(newReturnTypeRef)\n                lookupTracker?.recordTypeResolveAsLookup(newReturnTypeRef, parameter.source, fileSource)\n            }\n\n            lambdaArgument.replaceValueParameters(lambdaArgument.valueParameters + listOfNotNull(itParam))\n            lambdaArgument.replaceReturnTypeRef(\n                expectedReturnTypeRef?.also {\n                    lookupTracker?.recordTypeResolveAsLookup(it, lambdaArgument.source, fileSource)\n                } ?: components.noExpectedType\n            )\n\n            var additionalConstraints: ConstraintStorage? = null\n\n            transformer.context.withAnonymousFunctionTowerDataContext(lambdaArgument.symbol) {\n                val pclaInferenceSession =\n                    runIf(withPCLASession) {\n                        candidate.lambdasAnalyzedWithPCLA += lambdaArgument\n\n          "}
{"code": "              FirPCLAInferenceSession(candidate, session.inferenceComponents, transformer.context.returnTypeCalculator)\n                    }\n\n                if (pclaInferenceSession != null) {\n                    transformer.context.withInferenceSession(pclaInferenceSession) {\n                        lambdaArgument.transformSingle(transformer, ResolutionMode.LambdaResolution(expectedReturnTypeRef))\n\n                        applyResultsToMainCandidate()\n                    }\n                } else {\n                    additionalConstraints =\n                        transformer.context.inferenceSession.runLambdaCompletion(candidate, forOverloadByLambdaReturnType) {\n                            lambdaArgument.transformSingle(transformer, ResolutionMode.LambdaResolution(expectedReturnTypeRef))\n                        }\n                }\n            }\n            transformer.context.dropContextForAnonymousFunction(lambdaArgument)\n\n            val returnArguments = components.dataFlowAnaly"}
{"code": "zer.returnExpressionsOfAnonymousFunction(lambdaArgument).map { it.expression }\n\n            return ReturnArgumentsAnalysisResult(returnArguments, additionalConstraints)\n        }\n    }\n\n    private fun ConeKotlinType.approximateLambdaInputType(\n        valueParameter: FirValueParameterSymbol?,\n        isRootLambdaForPCLASession: Boolean,\n    ): ConeKotlinType {\n        // We only run lambda completion from ConstraintSystemCompletionContext.analyzeRemainingNotAnalyzedPostponedArgument when they are\n        // left uninferred.\n        // Currently, we use stub types for builder inference, so CANNOT_INFER_PARAMETER_TYPE is the only possible result here.\n        if (useErrorTypeInsteadOfTypeVariableForParameterType(isReceiver = valueParameter == null, isRootLambdaForPCLASession)) {\n            val diagnostic = valueParameter?.let(::ConeCannotInferValueParameterType) ?: ConeCannotInferReceiverParameterType()\n            return ConeErrorType(diagnostic)\n        }\n\n        return session.type"}
{"code": "Approximator.approximateToSuperType(\n            this, TypeApproximatorConfiguration.IntermediateApproximationToSupertypeAfterCompletionInK2\n        ) ?: this\n    }\n\n    private fun ConeKotlinType.useErrorTypeInsteadOfTypeVariableForParameterType(\n        isReceiver: Boolean,\n        isRootLambdaForPCLASession: Boolean,\n    ): Boolean {\n        if (this !is ConeTypeVariableType) return false\n\n        // Receivers are expected to be fixed both for PCLA/nonPCLA lambdas, so just build error type\n        if (isReceiver) return true\n\n        // Besides PCLA, all type variables for parameter types should be fixed before lambda analysis\n        // Inside PCLA (or when we start it), we force fixing receivers before lambda analysis, but allow value parameters\n        // to remain unfixed TVs.\n        if (isRootLambdaForPCLASession || inferenceSession is FirPCLAInferenceSession) {\n            // For type variables not based on type parameters (created for lambda parameters with no expected type)"}
{"code": "\n            // we force them to be fixed before lambda analysis.\n            //\n            // Otherwise, it's a type variable based on a type parameter which resulting type might be inferred from the lambda body,\n            // so in that case leave type variable type\n            return typeConstructor.originalTypeParameter == null\n        }\n\n        return true\n    }\n}\n\nprivate fun Candidate.isFunctionForExpectTypeFromCastFeature(): Boolean {\n    if (typeArgumentMapping != TypeArgumentMapping.NoExplicitArguments) return false\n    val fir = symbol.fir as? FirFunction ?: return false\n\n    return fir.isFunctionForExpectTypeFromCastFeature()\n}\n\n// Expect type is only being added to calls in a position of cast argument: foo() as R\n// And that call should be resolved to something materialize()-like: it returns its single generic parameter and doesn't have value parameters\n// fun <T> materialize(): T\ninternal fun FirFunction.isFunctionForExpectTypeFromCastFeature(): Boolean {\n    val typeP"}
{"code": "arameter = typeParameters.singleOrNull() ?: return false\n\n    val returnType = returnTypeRef.coneTypeSafe<ConeKotlinType>() ?: return false\n\n    if ((returnType.unwrap() as? ConeTypeParameterType)?.lookupTag != typeParameter.symbol.toLookupTag()) return false\n\n    fun FirTypeRef.isBadType() =\n        coneTypeSafe<ConeKotlinType>()\n            ?.contains { (it.unwrap() as? ConeTypeParameterType)?.lookupTag == typeParameter.symbol.toLookupTag() } != false\n\n    if (valueParameters.any { it.returnTypeRef.isBadType() } || receiverParameter?.typeRef?.isBadType() == true) return false\n\n    return true\n}\n\nprivate fun ConeKotlinType.unwrap(): ConeSimpleKotlinType = lowerBoundIfFlexible().let {\n    if (it is ConeDefinitelyNotNullType) it.original.unwrap() else it\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental.classpathDiff\n\n// TODO: Write this test\nabstract class ClasspathSnapshotShrinkerTest\n"}
{"code": "\nclass Bar {\n    operator fun invoke(): Foo { return <!RETURN_TYPE_MISMATCH!>this<!> } // (1)\n\n}\n\nfun x() {\n\n}\n\nclass Foo {\n\n\n    operator fun Bar.invoke(): Foo { return <!RETURN_TYPE_MISMATCH!>this<!> } // (2)\n\n    val x: Bar = Bar()\n\n    fun bar() = x() // Should resolve to invoke (1)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental.classpathDiff\n\nimport org.jetbrains.kotlin.incremental.classpathDiff.ClasspathSnapshotTestCommon.SourceFile.JavaSourceFile\nimport org.jetbrains.kotlin.incremental.classpathDiff.ClasspathSnapshotTestCommon.SourceFile.KotlinSourceFile\nimport org.jetbrains.kotlin.incremental.storage.fromByteArray\nimport org.jetbrains.kotlin.incremental.storage.toByteArray\nimport org.junit.Assert.assertEquals\nimport org.junit.Test\nimport java.io.File\n\nabstract class ClasspathSnapshotSerializerTest : ClasspathSnapshotTestCommon() {\n\n    companion object {\n        val testDataDir =\n            File(\"compiler/incremental-compilation-impl/testData/org/jetbrains/kotlin/incremental/classpathDiff/ClasspathSnapshotterTest\")\n    }\n\n    protected abstract val sourceFile: TestSourceFile\n\n    @Test\n    open fun `test ClassSnapshotExternalizer`() {\n        val originalSnapshot = sourceFile.compileAndSnapshot()\n        val serializedSnapshot = ClassSnapshotExternalizer.toByteAr"}
{"code": "ray(originalSnapshot)\n        val deserializedSnapshot = ClassSnapshotExternalizer.fromByteArray(serializedSnapshot)\n\n        assertEquals(originalSnapshot.toGson(), deserializedSnapshot.toGson())\n    }\n}\n\nclass KotlinClassesClasspathSnapshotSerializerTest : ClasspathSnapshotSerializerTest() {\n\n    override val sourceFile = TestSourceFile(\n        KotlinSourceFile(\n            baseDir = File(testDataDir, \"kotlin/testSimpleClass/src\"), relativePath = \"com/example/SimpleClass.kt\",\n            preCompiledClassFile = ClassFile(File(testDataDir, \"kotlin/testSimpleClass/classes\"), \"com/example/SimpleClass.class\")\n        ), tmpDir\n    )\n}\n\nclass JavaClassesClasspathSnapshotSerializerTest : ClasspathSnapshotSerializerTest() {\n\n    override val sourceFile = TestSourceFile(\n        JavaSourceFile(\n            baseDir = File(testDataDir, \"java/testSimpleClass/src\"), relativePath = \"com/example/SimpleClass.java\",\n        ), tmpDir\n    )\n}\n"}
{"code": "fun x() {\n    <expr>foo(1)</expr>\n}\n\nfun foo(){}\n"}
{"code": "// FILE: main.kt\n\nabstract class Outer {\n    annotation class Ann\n}\n\nclass Foo <expr>@Outer.Ann</expr> constructor() : Outer()\n"}
{"code": "// MODULE: context\n\n// FILE: context.kt\nclass Foo {\n    private val a: String = \"foo\"\n\n    inner class Bar {\n        private val b: String = \"bar\"\n\n        fun test() {\n            <caret_context>val x = 0\n        }\n    }\n}\n\nfun callFoo(foo: Foo): Int {\n    return 0\n}\n\nfun callString(string: String): Int {\n    return 1\n}\n\n\n// MODULE: main\n// MODULE_KIND: CodeFragment\n// CONTEXT_MODULE: context\n\n// FILE: fragment.kt\n// CODE_FRAGMENT_KIND: EXPRESSION\ncallFoo(this@Foo) + callString(a) + callString(b)"}
{"code": "// FIR_IDENTICAL\npackage test\n\nannotation class AnnoA\nannotation class AnnoB\n\nenum class AnnotatedParameterInEnumConstructor(@AnnoA a: String, @AnnoB b: String) {\n    A(\"1\", \"b\")\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir\n\nimport com.intellij.psi.PsiComment\nimport com.intellij.psi.PsiElement\nimport com.intellij.psi.PsiElementVisitor\nimport com.intellij.psi.impl.source.tree.LeafPsiElement\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators.AnalysisApiFirScriptTestConfigurator\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators.AnalysisApiFirSourceTestConfigurator\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.test.framework.test.configurators.AnalysisApiTestConfigurator\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.psi.KtClassLikeDeclaration\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.assertions\n\nabstract class AbstractClassIdTest : "}
{"code": "AbstractAnalysisApiBasedTest() {\n    override fun doTestByMainFile(mainFile: KtFile, mainModule: KtTestModule, testServices: TestServices) {\n        val text = buildString {\n            mainFile.accept(object : PsiElementVisitor() {\n                override fun visitElement(element: PsiElement) {\n                    if (element is KtClassLikeDeclaration) {\n                        append(\"\")\n                    }\n\n                    if (element is LeafPsiElement) {\n                        append(element.text)\n                    }\n\n                    element.acceptChildren(this)\n                }\n\n                override fun visitComment(comment: PsiComment) {\n                    if (comment.tokenType == KtTokens.BLOCK_COMMENT) {\n                        return\n                    }\n\n                    super.visitComment(comment)\n                }\n            })\n        }\n\n        testServices.assertions.assertEqualsToTestDataFileSibling(text, mainFile.name.substringAfterLast('.'))\n "}
{"code": "   }\n}\n\nabstract class AbstractSourceClassIdTest : AbstractClassIdTest() {\n    override val configurator: AnalysisApiTestConfigurator = AnalysisApiFirSourceTestConfigurator(analyseInDependentSession = false)\n}\n\nabstract class AbstractScriptClassIdTest : AbstractClassIdTest() {\n    override val configurator: AnalysisApiTestConfigurator = AnalysisApiFirScriptTestConfigurator(analyseInDependentSession = false)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.providers.topics\n\nimport org.jetbrains.kotlin.analysis.project.structure.KtModule\n\npublic fun interface KotlinModuleStateModificationListener {\n    \n    public fun onModification(module: KtModule, modificationKind: KotlinModuleStateModificationKind)\n}\n\npublic enum class KotlinModuleStateModificationKind {\n    \n    UPDATE,\n\n    \n    REMOVAL,\n}\n"}
{"code": "package test\nfun f() {\n    fun <A, B: A> f1() {}\n}"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.declarations\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.FirModuleData\nimport org.jetbrains.kotlin.fir.contracts.FirContractDescription\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirBlock\nimport org.jetbrains.kotlin.fir.references.FirControlFlowGraphReference\nimport org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol\nimport org.jetbrains.kotlin.fir.types.ConeSimpleKotlinType\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedContainerSource\n\n\nabstract class FirSimpleFun"}
{"code": "ction : FirFunction(), FirContractDescriptionOwner, FirTypeParametersOwner {\n    abstract override val source: KtSourceElement?\n    abstract override val moduleData: FirModuleData\n    abstract override val origin: FirDeclarationOrigin\n    abstract override val attributes: FirDeclarationAttributes\n    abstract override val status: FirDeclarationStatus\n    abstract override val returnTypeRef: FirTypeRef\n    abstract override val receiverParameter: FirReceiverParameter?\n    abstract override val deprecationsProvider: DeprecationsProvider\n    abstract override val containerSource: DeserializedContainerSource?\n    abstract override val dispatchReceiverType: ConeSimpleKotlinType?\n    abstract override val contextReceivers: List<FirContextReceiver>\n    abstract override val controlFlowGraphReference: FirControlFlowGraphReference?\n    abstract override val valueParameters: List<FirValueParameter>\n    abstract override val body: FirBlock?\n    abstract override val contractDescription: FirContra"}
{"code": "ctDescription?\n    abstract val name: Name\n    abstract override val symbol: FirNamedFunctionSymbol\n    abstract override val annotations: List<FirAnnotation>\n    abstract override val typeParameters: List<FirTypeParameter>\n\n    override fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitSimpleFunction(this, data)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transformer.transformSimpleFunction(this, data) as E\n\n    abstract override fun replaceStatus(newStatus: FirDeclarationStatus)\n\n    abstract override fun replaceReturnTypeRef(newReturnTypeRef: FirTypeRef)\n\n    abstract override fun replaceReceiverParameter(newReceiverParameter: FirReceiverParameter?)\n\n    abstract override fun replaceDeprecationsProvider(newDeprecationsProvider: DeprecationsProvider)\n\n    abstract override fun replaceContextReceivers(newContextReceivers: List<FirContextReceiver>)\n\n    abstract overr"}
{"code": "ide fun replaceControlFlowGraphReference(newControlFlowGraphReference: FirControlFlowGraphReference?)\n\n    abstract override fun replaceValueParameters(newValueParameters: List<FirValueParameter>)\n\n    abstract override fun replaceBody(newBody: FirBlock?)\n\n    abstract override fun replaceContractDescription(newContractDescription: FirContractDescription?)\n\n    abstract override fun replaceAnnotations(newAnnotations: List<FirAnnotation>)\n\n    abstract override fun <D> transformStatus(transformer: FirTransformer<D>, data: D): FirSimpleFunction\n\n    abstract override fun <D> transformReturnTypeRef(transformer: FirTransformer<D>, data: D): FirSimpleFunction\n\n    abstract override fun <D> transformReceiverParameter(transformer: FirTransformer<D>, data: D): FirSimpleFunction\n\n    abstract override fun <D> transformValueParameters(transformer: FirTransformer<D>, data: D): FirSimpleFunction\n\n    abstract override fun <D> transformBody(transformer: FirTransformer<D>, data: D): FirSimpleFunctio"}
{"code": "n\n\n    abstract override fun <D> transformContractDescription(transformer: FirTransformer<D>, data: D): FirSimpleFunction\n\n    abstract override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirSimpleFunction\n\n    abstract override fun <D> transformTypeParameters(transformer: FirTransformer<D>, data: D): FirSimpleFunction\n}\n"}
{"code": "// ISSUE: KT-40131\n\nimport kotlin.reflect.KClass\n\nval <U> KClass<<!UPPER_BOUND_VIOLATED!>U<!>>.javaImpl: Class<U>\n    get() = null!!\n\nval <T : KClass<*>> T.myJava1: Class<*>\n    get() = <!DEBUG_INFO_EXPRESSION_TYPE(\"java.lang.Class<CapturedType(*)>\")!>javaImpl<!>\n\nval <E : Any, T : KClass<E>> T.myJava2: Class<E>\n    get() = <!DEBUG_INFO_EXPRESSION_TYPE(\"java.lang.Class<E>\")!>javaImpl<!>\n"}
{"code": "// EXPECTED: org.jetbrains.kotlin.light.classes.symbol.methods.SymbolLightAccessorMethod\n// EXPECTED: org.jetbrains.kotlin.light.classes.symbol.fields.SymbolLightFieldForProperty\nclass Foo {\n    internal val <caret> p: Int = 42\n}"}
{"code": "fun test(b: Boolean): Int {\n    val n: Int = <expr>(b)</expr>.hashCode()\n    return n * 2\n}"}
{"code": "// IGNORE_FE10\n\n// MODULE: lib\n// MODULE_KIND: LibraryBinary\n// FILE: MySealedInterface.kt\nsealed interface MySealedInterface\n\nclass OneSealedChild : MySealedInterface\nclass TwoSealedChild : MySealedInterface\n\n// MODULE: main(lib)\n// FILE: main.kt\nfun testSealed(m: MySealedInterface): String {\n    return when (m) {\n        is OneSealedChild -> \"1\"\n    }\n}\n"}
{"code": "// COMPILATION_ERRORS\nfun foo() {\n    true<<caret>String>\n}\n"}
{"code": "class Foo {\n  operator fun invoke(a: Any) {}\n}\n\nfun test(f: Foo) {\n  f f@ <caret>{}\n}\n"}
{"code": "@Retention(AnnotationRetention.<expr>SOURCE</expr>)\nannotation class Anno\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen\n\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes\nimport org.jetbrains.org.objectweb.asm.Type\nimport java.util.*\n\nclass DefaultCallArgs(val size: Int) {\n\n    private val bits: BitSet = BitSet(size)\n\n    fun mark(index: Int) {\n        assert (index < size) {\n            \"Mask index should be less then size, but $index >= $size\"\n        }\n        bits.set(index)\n    }\n\n    fun toInts(): List<Int> {\n        if (bits.isEmpty || size == 0) {\n            return emptyList()\n        }\n\n        val masks = ArrayList<Int>(1)\n\n        var mask = 0\n        for (i in 0 until size) {\n            if (i != 0 && i % Integer.SIZE == 0) {\n                masks.add(mask)\n                mask = 0\n            }\n            mask = mask or if (bits.get(i)) 1 shl (i % Integer.SIZE) else 0\n        }\n        masks.add(mask)\n\n        return masks\n    }\n\n    fun generateOnStackIfNeeded(callGenerator: CallGenerator, isConstructor: Boolean): Boolean {\n        val toInts = toInt"}
{"code": "s()\n        if (!toInts.isEmpty()) {\n            for (mask in toInts) {\n                callGenerator.putValueIfNeeded(\n                    JvmKotlinType(Type.INT_TYPE), StackValue.constant(mask, Type.INT_TYPE), ValueKind.DEFAULT_MASK\n                )\n            }\n\n            val parameterType = if (isConstructor) AsmTypes.DEFAULT_CONSTRUCTOR_MARKER else AsmTypes.OBJECT_TYPE\n            callGenerator.putValueIfNeeded(\n                JvmKotlinType(parameterType), StackValue.constant(null, parameterType), ValueKind.METHOD_HANDLE_IN_DEFAULT\n            )\n        }\n        return toInts.isNotEmpty()\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.substitution\n\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.types.ConeTypeProjection\nimport org.jetbrains.kotlin.types.model.TypeSubstitutorMarker\n\nabstract class ConeSubstitutor : TypeSubstitutorMarker {\n    open fun substituteOrSelf(type: ConeKotlinType): ConeKotlinType = substituteOrNull(type) ?: type\n    abstract fun substituteOrNull(type: ConeKotlinType): ConeKotlinType?\n    abstract fun substituteArgument(projection: ConeTypeProjection, index: Int): ConeTypeProjection?\n\n    object Empty : ConeSubstitutor() {\n        override fun substituteOrSelf(type: ConeKotlinType): ConeKotlinType {\n            return type\n        }\n\n        override fun substituteOrNull(type: ConeKotlinType): ConeKotlinType? {\n            return null\n        }\n\n        override fun substituteArgument(projection: ConeTypeProjection, index: Int): ConeTypeProjection? {\n            return null\n        }\n\n        override fun toString"}
{"code": "(): String = \"Empty\"\n    }\n}\n\nfun ConeSubstitutor.substituteOrNull(type: ConeKotlinType?): ConeKotlinType? {\n    return type?.let { substituteOrNull(it) }\n}\n\nobject NoSubstitutor : TypeSubstitutorMarker\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.util\n\nimport org.jetbrains.kotlin.fir.FirElementWithResolveState\nimport org.jetbrains.kotlin.fir.declarations.FirResolvePhase\nimport org.jetbrains.kotlin.fir.declarations.ResolveStateAccess\nimport org.jetbrains.kotlin.fir.utils.exceptions.withFirEntry\nimport org.jetbrains.kotlin.utils.exceptions.checkWithAttachment\n\ninternal fun FirElementWithResolveState.checkPhase(requiredResolvePhase: FirResolvePhase) {\n    @OptIn(ResolveStateAccess::class)\n    val declarationResolveState = resolveState\n    checkWithAttachment(\n        declarationResolveState.resolvePhase >= requiredResolvePhase,\n        { \"At least $requiredResolvePhase expected but $declarationResolveState found for ${this::class.simpleName}\" },\n    ) {\n        withFirEntry(\"firDeclaration\", this@checkPhase)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.types\n\nimport org.jetbrains.kotlin.analysis.api.KtTypeProjection\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeOwner\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken\nimport org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion\nimport org.jetbrains.kotlin.analysis.api.symbols.KtClassifierSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.nameOrAnonymous\nimport org.jetbrains.kotlin.name.Name\n\npublic sealed interface KtClassTypeQualifier : KtLifetimeOwner {\n    public val name: Name\n    public val typeArguments: List<KtTypeProjection>\n\n    public class KtResolvedClassTypeQualifier(\n        private val _symbol: KtClassifierSymbol,\n        private val _typeArguments: List<KtTypeProjection>,\n        override val token: KtLifetimeToken\n    ) : KtClassTypeQualifier {\n        override val name: Name get() = withValidityAssertion { _symbol.nameOrAnonymous }\n        public val symbol: KtClassifierSymbol get"}
{"code": "() = withValidityAssertion { _symbol }\n        override val typeArguments: List<KtTypeProjection> get() = withValidityAssertion { _typeArguments }\n    }\n\n    public class KtUnresolvedClassTypeQualifier(\n        private val _name: Name,\n        private val _typeArguments: List<KtTypeProjection>,\n        override val token: KtLifetimeToken\n    ) : KtClassTypeQualifier {\n        override val name: Name get() = withValidityAssertion { _name }\n        override val typeArguments: List<KtTypeProjection> get() = withValidityAssertion { _typeArguments }\n    }\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.asJava.elements\n\nimport com.intellij.lang.Language\nimport com.intellij.psi.*\n\n// Based on com.intellij.psi.impl.light.LightParameter\nopen class LightParameter @JvmOverloads constructor(\n    private val myName: String,\n    type: PsiType,\n    val method: KtLightMethod,\n    language: Language?,\n    private val myVarArgs: Boolean = type is PsiEllipsisType\n) : LightVariableBuilder(method.manager, myName, type, language),\n    PsiParameter {\n    override fun getDeclarationScope(): KtLightMethod = method\n\n    override fun accept(visitor: PsiElementVisitor) {\n        if (visitor is JavaElementVisitor) {\n            visitor.visitParameter(this)\n        }\n    }\n\n    override fun toString(): String = \"Light Parameter\"\n\n    override fun isVarArgs(): Boolean = myVarArgs\n\n    override fun getName(): String = myName\n\n    companion object {\n        val EMPTY_ARRAY = arrayOfNulls<LightParameter>(0)\n    }\n\n}"}
{"code": "class A {\n  var : Int = 1\n    set(value) {\n      <expr>doSmth</expr>(value)\n    }\n}\n\nfun doSmth(i: String) = 4"}
{"code": "\n\npackage org.jetbrains.kotlin.diagnostics.rendering\n\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.name.FqNameUnsafe\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.renderer.ClassifierNamePolicy\nimport org.jetbrains.kotlin.renderer.DescriptorRenderer\nimport org.jetbrains.kotlin.resolve.descriptorUtil.fqNameUnsafe\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.kotlin.types.getAbbreviation\nimport org.jetbrains.kotlin.types.typeUtil.contains\nimport java.util.*\n\nval RenderingContext.adaptiveClassifierPolicy: ClassifierNamePolicy\n    get() = this[ADAPTIVE_CLASSIFIER_POLICY_KEY]\n\nprivate class AdaptiveClassifierNamePolicy(private val ambiguousNames: List<Name>) : ClassifierNamePolicy {\n    private val renderedParameters = mutableMapOf<Name, LinkedHashSet<TypeParameterDescriptor>>()\n\n    override fun renderClassifier(classifier: ClassifierDescriptor, renderer: DescriptorRenderer): String {\n        return when {\n            hasUniqu"}
{"code": "eName(classifier) -> ClassifierNamePolicy.SHORT.renderClassifier(classifier, renderer)\n            classifier is ClassDescriptor ||\n                    classifier is TypeAliasDescriptor ->\n                ClassifierNamePolicy.FULLY_QUALIFIED.renderClassifier(classifier, renderer)\n            classifier is TypeParameterDescriptor -> {\n                val name = classifier.name\n                val typeParametersWithSameName = renderedParameters.getOrPut(name) { LinkedHashSet() }\n                val isFirstOccurence = typeParametersWithSameName.add(classifier)\n                val index = typeParametersWithSameName.indexOf(classifier)\n                renderer.renderAmbiguousTypeParameter(classifier, index + 1, isFirstOccurence)\n            }\n            else -> error(\"Unexpected classifier: ${classifier::class.java}\")\n        }\n    }\n\n    private fun hasUniqueName(classifier: ClassifierDescriptor): Boolean {\n        return classifier.name !in ambiguousNames\n    }\n\n    private fun Descripto"}
{"code": "rRenderer.renderAmbiguousTypeParameter(\n        typeParameter: TypeParameterDescriptor, index: Int, firstOccurence: Boolean\n    ) = buildString {\n        append(typeParameter.name)\n        append(\"#$index\")\n        if (firstOccurence) {\n            append(renderMessage(\" (type parameter of ${renderFqName(typeParameter.containingDeclaration.fqNameUnsafe)})\"))\n        }\n    }\n}\n\nprivate val ADAPTIVE_CLASSIFIER_POLICY_KEY = object : RenderingContext.Key<ClassifierNamePolicy>(\"ADAPTIVE_CLASSIFIER_POLICY\") {\n    override fun compute(objectsToRender: Collection<Any?>): ClassifierNamePolicy {\n        val ambiguousNames =\n            collectClassifiersFqNames(objectsToRender).groupBy { it.shortNameOrSpecial() }.filter { it.value.size > 1 }.map { it.key }\n        return AdaptiveClassifierNamePolicy(ambiguousNames)\n    }\n}\n\nprivate fun collectClassifiersFqNames(objectsToRender: Collection<Any?>): Set<FqNameUnsafe> = LinkedHashSet<FqNameUnsafe>().apply {\n    collectMentionedClassifiersFqNames(obj"}
{"code": "ectsToRender, this)\n}\n\nprivate fun collectMentionedClassifiersFqNames(contextObjects: Iterable<Any?>, result: MutableSet<FqNameUnsafe>) {\n    fun KotlinType.addMentionedTypeConstructor() {\n        constructor.declarationDescriptor?.let { result.add(it.fqNameUnsafe) }\n    }\n\n    contextObjects.filterIsInstance<KotlinType>().forEach { diagnosticType ->\n        diagnosticType.contains { innerType ->\n            innerType.addMentionedTypeConstructor()\n            innerType.getAbbreviation()?.addMentionedTypeConstructor()\n            false\n        }\n    }\n\n    contextObjects.filterIsInstance<Iterable<*>>().forEach {\n        collectMentionedClassifiersFqNames(it, result)\n    }\n    contextObjects.filterIsInstance<ClassifierDescriptor>().forEach {\n        result.add(it.fqNameUnsafe)\n    }\n    contextObjects.filterIsInstance<TypeParameterDescriptor>().forEach {\n        collectMentionedClassifiersFqNames(it.upperBounds, result)\n    }\n    contextObjects.filterIsInstance<CallableDescriptor>().forE"}
{"code": "ach {\n        collectMentionedClassifiersFqNames(\n            listOf(\n                it.typeParameters,\n                it.returnType,\n                it.valueParameters,\n                it.dispatchReceiverParameter?.type,\n                it.extensionReceiverParameter?.type\n            ), result\n        )\n    }\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.declarations\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\n\n\nabstract class FirResolvedImport : FirImport() {\n    abstract override val source: KtSourceElement?\n    abstract override val importedFqName: FqName?\n    abstract override val isAllUnder: Boolean\n    abstract override val aliasName: Name?\n    abstract override val aliasSource: KtSourceElement?\n    abstract val delegate: FirImport\n    abstract val packageFqName: FqName\n    abstract val relativeParentClassName: FqName?\n    abstract val resolvedParentClassId: ClassId?\n    abstract val importedName: Name?\n\n    ov"}
{"code": "erride fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitResolvedImport(this, data)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transformer.transformResolvedImport(this, data) as E\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve\n\nimport org.jetbrains.kotlin.cfg.ControlFlowInformationProviderImpl\nimport org.jetbrains.kotlin.container.StorageComponentContainer\nimport org.jetbrains.kotlin.container.useInstance\n\nobject CompilerEnvironment : TargetEnvironment(\"Compiler\") {\n    override fun configure(container: StorageComponentContainer) {\n        configureCompilerEnvironment(container)\n        container.useInstance(ControlFlowInformationProviderImpl.Factory)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.test.framework.test.configurators\n\nimport com.intellij.mock.MockApplication\nimport com.intellij.mock.MockProject\nimport org.jetbrains.kotlin.test.services.TestServices\n\nabstract class AnalysisApiTestServiceRegistrar {\n    open fun registerApplicationServices(application: MockApplication, testServices: TestServices) {}\n\n    open fun registerProjectExtensionPoints(project: MockProject, testServices: TestServices) {}\n\n    open fun registerProjectServices(project: MockProject, testServices: TestServices) {}\n\n    open fun registerProjectModelServices(project: MockProject, testServices: TestServices) {}\n}\n"}
{"code": "package test\n\nclass Receiver {\n    fun fromReceiver() {}\n}\n\nopen class Base(val value: Receiver.() -> Unit) {\n    fun baseMember(): Int = 10\n    val baseProp: Int = 10\n}\n\nclass Child : Base({ <expr>this</expr> }) {\n    fun childMember(): Int = 10\n    val childProp: Int = 10\n}"}
{"code": "  val x: Int\n    get() {\n      fun doSmth(i: String) = 4\n      return <expr>doSmth</expr>(\"str\")\n    }\n"}
{"code": "// WITH_STDLIB\n\ninterface NavGraphBuilder\n\ninterface AnimatedContentTransitionScope<S>\n\ninterface NavBackStackEntry\n\ninterface EnterTransition\n\nfun NavGraphBuilder.compose(\n  enter<caret>Transition: (@JvmSuppressWildcards(suppress = true)\n    AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition?)? = null,\n) = TODO()"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\")\n\npackage org.jetbrains.kotlin.fir.references.impl\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.diagnostics.ConeDiagnostic\nimport org.jetbrains.kotlin.fir.references.FirThisReference\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\ninternal class FirExplicitThisReference(\n    override val source: KtSourceElement?,\n    override val labelName: String?,\n    override var contextReceiverNumber: Int,\n    override var diagnostic: ConeDiagnostic?,\n) : FirThisReference() {\n    override var boundSymbol: FirBasedSymbol<*>? = null\n    override val isImplicit: Boolean = false\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {}\n\n    override fun <D> transformChildren(transform"}
{"code": "er: FirTransformer<D>, data: D): FirExplicitThisReference {\n        return this\n    }\n\n    override fun replaceBoundSymbol(newBoundSymbol: FirBasedSymbol<*>?) {\n        boundSymbol = newBoundSymbol\n    }\n\n    override fun replaceContextReceiverNumber(newContextReceiverNumber: Int) {\n        contextReceiverNumber = newContextReceiverNumber\n    }\n\n    override fun replaceDiagnostic(newDiagnostic: ConeDiagnostic?) {\n        diagnostic = newDiagnostic\n    }\n}\n"}
{"code": "// WITH_STDLIB\n// LOOK_UP_FOR_ELEMENT_OF_TYPE: org.jetbrains.kotlin.psi.KtCallExpression\n\nfun foo(x: MutableMap<Int, MutableList<String>>) {\n    x.getOrPut(1) { <expr>mutableListOf<String>()</expr> } += \"str\"\n}"}
{"code": "fun x() {\n    1 toCall a<caret>v\n}\n\ninfix fun <T> T.toCall(y: T) {}"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.expressions\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.symbols.impl.FirTypeParameterSymbol\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\n\nabstract class FirResolvedReifiedParameterReference : FirExpression() {\n    abstract override val source: KtSourceElement?\n    @UnresolvedExpressionTypeAccess\n    abstract override val coneTypeOrNull: ConeKotlinType?\n    abstract override val annotations: List<FirAnnotation>\n    abstract val symbol: FirTypeParameterSymbol\n\n    override fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitResolvedReifiedParameterReference(this, data)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun"}
{"code": " <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transformer.transformResolvedReifiedParameterReference(this, data) as E\n\n    abstract override fun replaceConeTypeOrNull(newConeTypeOrNull: ConeKotlinType?)\n\n    abstract override fun replaceAnnotations(newAnnotations: List<FirAnnotation>)\n\n    abstract override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirResolvedReifiedParameterReference\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.declarations\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\n\nsealed interface FirTypeParametersOwner : FirTypeParameterRefsOwner {\n    override val source: KtSourceElement?\n    override val typeParameters: List<FirTypeParameter>\n\n    override fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitTypeParametersOwner(this, data)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transformer.transformTypeParametersOwner(this, data) as E\n\n    override fun <D> transformTypeParameters(transformer: FirTransformer<D>, data: D): FirTypeParametersOwner\n}\n"}
{"code": "fun test(b: Any?): Int {\n    if (b is <expr>Number</expr>) {\n        return 54\n    } else if (b is Int) {\n        return 87\n    } else {\n        return 0\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.scopes.impl\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.intrinsics\n\nimport org.jetbrains.kotlin.codegen.Callable\nimport org.jetbrains.kotlin.codegen.CallableMethod\nimport org.jetbrains.kotlin.codegen.ExpressionCodegen\nimport org.jetbrains.kotlin.codegen.StackValue\nimport org.jetbrains.kotlin.psi.KtPrefixExpression\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\n\nclass Not : IntrinsicMethod() {\n    override fun toCallable(method: CallableMethod): Callable =\n            object : IntrinsicCallable(method) {\n                override fun invokeMethodWithArguments(\n                        resolvedCall: ResolvedCall<*>,\n                        receiver: StackValue,\n                        codegen: ExpressionCodegen\n                ): StackValue {\n                    val element = resolvedCall.call.callElement\n                    val stackValue =\n                            if (element is KtPrefixExpression) {\n                                codegen.gen(element.baseExpression)\n                    "}
{"code": "        }\n                            else {\n                                StackValue.receiver(resolvedCall, receiver, codegen, this)\n                            }\n                    return StackValue.not(stackValue)\n                }\n            }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.buildtools.api\n\nimport java.io.File\n\n\n@ExperimentalBuildToolsApi\npublic interface CompilerExecutionStrategyConfiguration {\n    \n    public fun useInProcessStrategy(): CompilerExecutionStrategyConfiguration\n\n    \n    public fun useDaemonStrategy(\n        jvmArguments: List<String>,\n    ): CompilerExecutionStrategyConfiguration\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.checkers.diagnostics.factories\n\nimport org.jetbrains.kotlin.config.LanguageVersionSettings\nimport org.jetbrains.kotlin.descriptors.impl.ModuleDescriptorImpl\nimport org.jetbrains.kotlin.diagnostics.Diagnostic\nimport org.jetbrains.kotlin.psi.KtElement\nimport org.jetbrains.kotlin.resolve.BindingContext\nimport org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory\n\ninterface DebugInfoDiagnosticFactory {\n    val withExplicitDefinitionOnly: Boolean\n\n    fun createDiagnostic(\n        element: KtElement,\n        bindingContext: BindingContext,\n        dataFlowValueFactory: DataFlowValueFactory?,\n        languageVersionSettings: LanguageVersionSettings?,\n        moduleDescriptor: ModuleDescriptorImpl?\n    ): Diagnostic\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.references\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.symbols.impl.FirDelegateFieldSymbol\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.name.Name\n\n\nabstract class FirDelegateFieldReference : FirResolvedNamedReference() {\n    abstract override val source: KtSourceElement?\n    abstract override val name: Name\n    abstract override val resolvedSymbol: FirDelegateFieldSymbol\n\n    override fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitDelegateFieldReference(this, data)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transformer.transformDelegateFieldRefere"}
{"code": "nce(this, data) as E\n}\n"}
{"code": "class A {\n  var x\n    get() = 1\n    set(value) = <expr>doSmth</expr>(value)\n}\n\nfun doSmth(i: String) = 4\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.lazy.declarations\n\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtFile\n\ninterface PackageMemberDeclarationProvider : DeclarationProvider {\n    fun getAllDeclaredSubPackages(nameFilter: (Name) -> Boolean): Collection<FqName>\n\n    fun getPackageFiles(): Collection<KtFile>\n\n    fun containsFile(file: KtFile): Boolean\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.transformers\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.FirResolvePhase\nimport org.jetbrains.kotlin.fir.resolve.fullyExpandedType\nimport org.jetbrains.kotlin.fir.resolve.toSymbol\nimport org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase\nimport org.jetbrains.kotlin.fir.types.ConeClassLikeType\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.types.coneTypeSafe\n\nfun ConeKotlinType?.ensureResolvedTypeDeclaration(\n    useSiteSession: FirSession,\n    requiredPhase: FirResolvePhase = FirResolvePhase.DECLARATIONS,\n) {\n    if (this !is ConeClassLikeType) return\n\n    lookupTag.toSymbol(useSiteSession)?.lazyResolveToPhase(requiredPhase)\n    fullyExpandedType(useSiteSession).lookupTag.toSymbol(useSiteSession)?.lazyResolveToPhase(requiredPhase)\n}\n\nfun FirTypeRef.ensureResolvedTypeDeclaration(\n    useSiteSession: FirSession,\n  "}
{"code": "  requiredPhase: FirResolvePhase = FirResolvePhase.DECLARATIONS,\n) {\n    coneTypeSafe<ConeKotlinType>().ensureResolvedTypeDeclaration(useSiteSession, requiredPhase)\n}\n"}
{"code": "// FILE: Test.java\npublic class Test {\n\n    public interface I1 {}\n    public interface I2 {}\n    public interface I3 {}\n\n    public interface I123 extends I1, I2, I3 {}\n\n    public static class Base {\n        public <P extends I1 & I2 & I3> void foo(P p) {}\n    }\n\n    public static class Derived extends Base {\n        @Override\n        public <P extends I1 & I3 & I2> void foo(P p) {}\n    }\n\n    public static class DerivedRaw extends Base {\n        public void foo(I1 p) {}\n    }\n}\n\n// FILE: main.kt\ninterface KI1\ninterface KI2\ninterface KI12 : KI1, KI2\n\nopen class KBase {\n    open fun <P> foo()\n    where P : KI1, P : KI2 {}\n}\n\nclass KDerived : KBase() {\n    override fun <P> foo()\n    where P : KI2, P : KI1 {}\n}\n\n\nfun callJava(derived: Test.Derived, derivedRaw: Test.DerivedRaw, v: Test.I123) {\n    derived.foo(v)\n    derivedRaw.foo(v)\n}\n\nfun callKotlin(derived: KDerived) {\n    derived.foo<KI12>()\n}\n"}
{"code": "val String.foo: String get() = \"\"\n\nfun take(s: String?) {\n    s?.<expr>foo</expr>\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.impl.base.test.cases.components.typeProvider\n\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.test.framework.services.expressionMarkerProvider\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.psi.KtTypeReference\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.assertions\nimport org.jetbrains.kotlin.types.Variance\n\nabstract class AbstractTypeReferenceTest : AbstractAnalysisApiBasedTest() {\n    override fun doTestByMainFile(mainFile: KtFile, mainModule: KtTestModule, testServices: TestServices) {\n        val expressionAtCaret = testServices.expressionMarkerProvider.getElementOfTypeAtCaret(mainFile) as KtTypeReference\n\n        val actual = analyseForTest(expressionAtCaret) {\n            val ktType = expressionAtCaret.getKtTyp"}
{"code": "e()\n            buildString {\n                appendLine(\"expression: ${expressionAtCaret.text}\")\n                appendLine(\"ktType: ${ktType.render(position = Variance.INVARIANT)}\")\n            }\n        }\n\n        testServices.assertions.assertEqualsToTestDataFileSibling(actual)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.buildtools.api\n\nimport org.jetbrains.kotlin.buildtools.api.jvm.ClassSnapshotGranularity\nimport org.jetbrains.kotlin.buildtools.api.jvm.ClasspathEntrySnapshot\nimport org.jetbrains.kotlin.buildtools.api.jvm.JvmCompilationConfiguration\nimport java.io.File\n\n\n@ExperimentalBuildToolsApi\npublic interface CompilationService {\n    \n    public fun calculateClasspathSnapshot(classpathEntry: File, granularity: ClassSnapshotGranularity): ClasspathEntrySnapshot\n\n    \n    public fun makeCompilerExecutionStrategyConfiguration(): CompilerExecutionStrategyConfiguration\n\n    \n    public fun makeJvmCompilationConfiguration(): JvmCompilationConfiguration\n\n    \n    public fun compileJvm(\n        projectId: ProjectId,\n        strategyConfig: CompilerExecutionStrategyConfiguration,\n        compilationConfig: JvmCompilationConfiguration,\n        sources: List<File>,\n        arguments: List<String>,\n    ): CompilationResult\n\n    \n    public fun finishProjectCompilation(projectId: "}
{"code": "ProjectId)\n\n    \n    public fun getCustomKotlinScriptFilenameExtensions(classpath: List<File>): Collection<String>\n\n    \n    public fun getCompilerVersion(): String\n\n    @ExperimentalBuildToolsApi\n    public companion object {\n        @JvmStatic\n        public fun loadImplementation(classLoader: ClassLoader): CompilationService =\n            loadImplementation(CompilationService::class, classLoader)\n    }\n}"}
{"code": "// FILE: R.kt\npackage test.pkg\n\nclass R {\n    class string {\n        companion object {\n            val hello : Int = 42\n        }\n    }\n}\n\n// FILE: main.kt\n\npackage test.pkg\n\nimport test.pkg.R as coreR\n\nfun box() {\n    val s = core<caret>R.string.hello\n}\n"}
{"code": "fun test() {\n    val f = fun <expr>String</expr>.(): Int {\n        return 56\n    }\n    \"jello\".f()\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators\n\nimport com.intellij.openapi.Disposable\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtScriptTestModuleFactory\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModuleFactory\nimport org.jetbrains.kotlin.test.builders.TestConfigurationBuilder\n\nopen class AnalysisApiFirScriptTestConfigurator(analyseInDependentSession: Boolean) :\n    AnalysisApiFirSourceLikeTestConfigurator(analyseInDependentSession) {\n    override fun configureTest(builder: TestConfigurationBuilder, disposable: Disposable) {\n        super.configureTest(builder, disposable)\n\n        builder.apply {\n            useAdditionalService<KtTestModuleFactory> { KtScriptTestModuleFactory }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirProperty\nimport org.jetbrains.kotlin.fir.declarations.utils.hasBackingField\nimport org.jetbrains.kotlin.fir.declarations.utils.isInline\n\nobject FirInlinePropertyChecker : FirPropertyChecker(MppCheckerKind.Common) {\n    override fun check(declaration: FirProperty, context: CheckerContext, reporter: DiagnosticReporter) {\n        if (declaration.getter?.isInline != true && declaration.setter?.isInline != true) return\n\n        FirInlineDeclarationChecker.checkCallableDeclaration(declaration, context, reporter)\n\n        if ("}
{"code": "declaration.hasBackingField || declaration.delegate != null) {\n            when (declaration.source?.kind) {\n                KtFakeSourceElementKind.PropertyFromParameter -> reporter.reportOn(\n                    declaration.source, FirErrors.INLINE_PROPERTY_WITH_BACKING_FIELD_DEPRECATION, context\n                )\n                else -> reporter.reportOn(\n                    declaration.source, FirErrors.INLINE_PROPERTY_WITH_BACKING_FIELD, context\n                )\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.extended\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.expression.FirQualifiedAccessExpressionChecker\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.expressions.FirLiteralExpression\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.expressions.FirFunctionCall\nimport org.jetbrains.kotlin.fir.expressions.FirQualifiedAccessExpression\nimport org.jetbrains.kotlin.fir.psi\nimport org.jetbrains.kotlin.fir.analysis.checkers.fullyExpandedClassId\nimport org.jetbrains.kotlin.fir.types.ConeFlexibleType\nimport org.jetbrains.kotlin.fir.types.classId\nimport org.jetbrains.kot"}
{"code": "lin.fir.types.isMarkedNullable\nimport org.jetbrains.kotlin.fir.types.resolvedType\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.StandardClassIds\nimport org.jetbrains.kotlin.psi.KtSafeQualifiedExpression\n\nobject RedundantCallOfConversionMethod : FirQualifiedAccessExpressionChecker(MppCheckerKind.Common) {\n    override fun check(expression: FirQualifiedAccessExpression, context: CheckerContext, reporter: DiagnosticReporter) {\n        if (expression !is FirFunctionCall) return\n        val functionName = expression.calleeReference.name.asString()\n        val qualifiedType = targetClassMap[functionName] ?: return\n\n        if (expression.explicitReceiver?.isRedundant(qualifiedType, context.session) == true) {\n            reporter.reportOn(expression.source, FirErrors.REDUNDANT_CALL_OF_CONVERSION_METHOD, context)\n        }\n    }\n\n    private fun FirExpression.isRedundant(qualifiedClassId: ClassId, session: FirSession): Boolean {\n        val thisType = if (this is F"}
{"code": "irLiteralExpression<*>) {\n            this.resolvedType.classId\n        } else {\n            when {\n                resolvedType is ConeFlexibleType -> null\n                psi?.parent !is KtSafeQualifiedExpression\n                        && (psi is KtSafeQualifiedExpression || resolvedType.isMarkedNullable) -> null\n                this.resolvedType.isMarkedNullable -> null\n                else -> this.resolvedType.fullyExpandedClassId(session)\n            }\n        }\n        return thisType == qualifiedClassId\n    }\n\n    private val targetClassMap = hashMapOf(\n        \"toString\" to StandardClassIds.String,\n        \"toDouble\" to StandardClassIds.Double,\n        \"toFloat\" to StandardClassIds.Float,\n        \"toLong\" to StandardClassIds.Long,\n        \"toInt\" to StandardClassIds.Int,\n        \"toChar\" to StandardClassIds.Char,\n        \"toShort\" to StandardClassIds.Short,\n        \"toByte\" to StandardClassIds.Byte,\n        \"toULong\" to StandardClassIds.ULong,\n        \"toUInt\" to StandardClass"}
{"code": "Ids.UInt,\n        \"toUShort\" to StandardClassIds.UShort,\n        \"toUByte\" to StandardClassIds.UByte\n    )\n}\n"}
{"code": "interface MyMap<K1, V1> {\n    operator fun get(k: K1): V1\n}\n\ninterface Foo {\n    operator fun <K2, V2> MyMap<K2, V2>.set(k: K2, v: V2)\n\n    fun test(m: MyMap<String, Int>) {\n        <expr>m[\"a\"]++</expr>\n    }\n}"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\", \"unused\")\n\npackage org.jetbrains.kotlin.fir.expressions.builder\n\nimport kotlin.contracts.*\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.builder.FirAnnotationContainerBuilder\nimport org.jetbrains.kotlin.fir.builder.FirBuilderDsl\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.expressions.FirIncrementDecrementExpression\nimport org.jetbrains.kotlin.fir.expressions.impl.FirIncrementDecrementExpressionImpl\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.name.Name\n\n@FirBuilderDsl\nclass FirIncrementDecrementExpressionBuilder : FirAnnotationContainerBuilder, FirExpressionBuilder {\n    override var source: KtSourceElement? ="}
{"code": " null\n    override var coneTypeOrNull: ConeKotlinType? = null\n    override val annotations: MutableList<FirAnnotation> = mutableListOf()\n    var isPrefix: Boolean by kotlin.properties.Delegates.notNull<Boolean>()\n    lateinit var operationName: Name\n    lateinit var expression: FirExpression\n    var operationSource: KtSourceElement? = null\n\n    override fun build(): FirIncrementDecrementExpression {\n        return FirIncrementDecrementExpressionImpl(\n            source,\n            coneTypeOrNull,\n            annotations.toMutableOrEmpty(),\n            isPrefix,\n            operationName,\n            expression,\n            operationSource,\n        )\n    }\n\n}\n\n@OptIn(ExperimentalContracts::class)\ninline fun buildIncrementDecrementExpression(init: FirIncrementDecrementExpressionBuilder.() -> Unit): FirIncrementDecrementExpression {\n    contract {\n        callsInPlace(init, InvocationKind.EXACTLY_ONCE)\n    }\n    return FirIncrementDecrementExpressionBuilder().apply(init).build()\n}\n"}
{"code": "// ISSUE: KT-30756\n\nfun condition(): Boolean = true\n\nfun test_1(x: String?) {\n    do {\n        x ?: return\n    } while(condition())\n\n    x.length\n}\n\nfun test_2(x: String?) {\n    do {\n        x ?: x!!\n    } while(condition())\n\n    x.length\n}\n\nfun test_3() {\n    var a: String? = null\n\n    while (condition()) {\n        a ?: return\n    }\n\n    a<!UNSAFE_CALL!>.<!>length\n}\n\nfun test_4() {\n    var a: String? = null\n\n    while (true) {\n        a ?: return\n    }\n\n    a<!UNSAFE_CALL!>.<!>length\n}\n\nfun test_5(x: String?) {\n    do {\n        x ?: return\n        Unit\n    } while(condition())\n\n    x.length\n}\n\nfun test_6(x: String?) {\n    do {\n        x ?: x!!\n        Unit\n    } while(condition())\n\n    x.length\n}\n\nfun test_7() {\n    var a: String? = null\n\n    while (condition()) {\n        a ?: return\n        a\n    }\n\n    a<!UNSAFE_CALL!>.<!>length\n}\n\nfun test_8() {\n    var a: String? = null\n\n    while (true) {\n        a ?: return\n        a\n    }\n\n    a<!UNSAFE_CALL!>.<!>length\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen\n\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.descriptors.PropertyDescriptor\nimport org.jetbrains.kotlin.descriptors.ReceiverParameterDescriptor\nimport org.jetbrains.kotlin.types.KotlinType\n\nclass AccessorForPropertyBackingField(\n    property: PropertyDescriptor,\n    containingDeclaration: DeclarationDescriptor,\n    delegateType: KotlinType?,\n    extensionReceiverParameter: ReceiverParameterDescriptor?,\n    dispatchReceiverParameter: ReceiverParameterDescriptor?,\n    nameSuffix: String,\n    fieldAccessorKind: AccessorKind\n) : AccessorForPropertyDescriptor(\n    property,\n    delegateType ?: property.type,\n    extensionReceiverParameter?.type,\n    dispatchReceiverParameter,\n    containingDeclaration,\n    null,\n    nameSuffix,\n    fieldAccessorKind\n)\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.range\n\nimport org.jetbrains.kotlin.builtins.KotlinBuiltIns\nimport org.jetbrains.kotlin.codegen.ExpressionCodegen\nimport org.jetbrains.kotlin.codegen.range.forLoop.CharSequenceWithIndexForLoopGenerator\nimport org.jetbrains.kotlin.codegen.range.forLoop.ForLoopGenerator\nimport org.jetbrains.kotlin.descriptors.CallableDescriptor\nimport org.jetbrains.kotlin.psi.KtDestructuringDeclaration\nimport org.jetbrains.kotlin.psi.KtForExpression\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\n\nclass CharSequenceWithIndexRangeValue(rangeCall: ResolvedCall<out CallableDescriptor>) : AbstractDestructuredPairRangeValue(rangeCall) {\n\n    override fun createDestructuredPairForLoopGenerator(\n        codegen: ExpressionCodegen,\n        forExpression: KtForExpression,\n        loopParameter: KtDestructuringDeclaration,\n        rangeCall: ResolvedCall<out CallableDescriptor>\n    ): ForLoopGenerator =\n        CharSequenceWithIndexForLoopGenerator(\n            co"}
{"code": "degen, forExpression, loopParameter, rangeCall,\n            canCacheLength = canCacheLength(rangeCall)\n        )\n\n    private fun canCacheLength(rangeCall: ResolvedCall<out CallableDescriptor>): Boolean {\n        val receiverType = rangeCall.extensionReceiver?.type ?: return false\n        return KotlinBuiltIns.isString(receiverType)\n    }\n\n}"}
{"code": "annotation class Annotation(vararg val strings: String)\n\nannotation class AnnotationInner(val value: Annotation)\n\n<expr>@AnnotationInner(Annotation(\"v1\", \"v2\"))</expr>\nclass C\n"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.classes\n\nimport com.intellij.psi.PsiElement\nimport com.intellij.psi.PsiManager\nimport com.intellij.psi.PsiModifier\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.symbols.KtFunctionSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtNamedClassOrObjectSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtPropertySymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolKind\nimport org.jetbrains.kotlin.analysis.api.symbols.pointers.KtSymbolPointer\nimport org.jetbrains.kotlin.analysis.project.structure.KtModule\nimport org.jetbrains.kotlin.asJava.classes.getParentForLocalDeclaration\nimport org.jetbrains.kotlin.asJava.classes.lazyPub\nimport org.jetbrains.kotlin.asJava.elements.KtLightField\nimport org.jetbrains.kotlin.asJava.elements.KtLightMethod\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.light.classes.symbol.annotations.hasJvmStaticAnno"}
{"code": "tation\nimport org.jetbrains.kotlin.light.classes.symbol.fields.SymbolLightField\nimport org.jetbrains.kotlin.light.classes.symbol.fields.SymbolLightFieldForObject\nimport org.jetbrains.kotlin.light.classes.symbol.isConstOrJvmField\nimport org.jetbrains.kotlin.light.classes.symbol.modifierLists.GranularModifiersBox\nimport org.jetbrains.kotlin.psi.KtClassOrObject\nimport org.jetbrains.kotlin.utils.addToStdlib.applyIf\n\nabstract class SymbolLightClassForNamedClassLike : SymbolLightClassForClassLike<KtNamedClassOrObjectSymbol> {\n    constructor(\n        ktAnalysisSession: KtAnalysisSession,\n        ktModule: KtModule,\n        classOrObjectSymbol: KtNamedClassOrObjectSymbol,\n        manager: PsiManager\n    ) : super(\n        ktAnalysisSession = ktAnalysisSession,\n        ktModule = ktModule,\n        classOrObjectSymbol = classOrObjectSymbol,\n        manager = manager,\n    )\n\n    protected constructor(\n        classOrObjectDeclaration: KtClassOrObject?,\n        classOrObjectSymbolPointer: KtSymbo"}
{"code": "lPointer<KtNamedClassOrObjectSymbol>,\n        ktModule: KtModule,\n        manager: PsiManager,\n    ) : super(\n        classOrObjectDeclaration = classOrObjectDeclaration,\n        classOrObjectSymbolPointer = classOrObjectSymbolPointer,\n        ktModule = ktModule,\n        manager = manager\n    )\n\n    protected val isLocal: Boolean by lazyPub {\n        classOrObjectDeclaration?.isLocal ?: withClassOrObjectSymbol { it.symbolKind == KtSymbolKind.LOCAL }\n    }\n\n    override fun getParent(): PsiElement? {\n        if (isLocal) {\n            return classOrObjectDeclaration?.let(::getParentForLocalDeclaration)\n        }\n\n        return containingClass ?: containingFile\n    }\n\n    context(KtAnalysisSession)\n    protected fun addMethodsFromCompanionIfNeeded(\n        result: MutableList<KtLightMethod>,\n        classOrObjectSymbol: KtNamedClassOrObjectSymbol,\n    ) {\n        val companionObjectSymbol = classOrObjectSymbol.companionObject ?: return\n        val methods = companionObjectSymbol.getDec"}
{"code": "laredMemberScope()\n            .getCallableSymbols()\n            .filterIsInstance<KtFunctionSymbol>()\n            .filter { it.hasJvmStaticAnnotation() }\n\n        createMethods(methods, result)\n\n        companionObjectSymbol.getDeclaredMemberScope()\n            .getCallableSymbols()\n            .filterIsInstance<KtPropertySymbol>()\n            .forEach { property ->\n                createPropertyAccessors(\n                    result,\n                    property,\n                    isTopLevel = false,\n                    onlyJvmStatic = true,\n                )\n            }\n    }\n\n    private val isInner: Boolean\n        get() = classOrObjectDeclaration?.hasModifier(KtTokens.INNER_KEYWORD) ?: withClassOrObjectSymbol { it.isInner }\n\n    context(KtAnalysisSession)\n    internal fun addFieldsFromCompanionIfNeeded(\n        result: MutableList<KtLightField>,\n        classOrObjectSymbol: KtNamedClassOrObjectSymbol,\n        nameGenerator: SymbolLightField.FieldNameGenerator,\n    ) {\n        "}
{"code": "classOrObjectSymbol.companionObject\n            ?.getDeclaredMemberScope()\n            ?.getCallableSymbols()\n            ?.filterIsInstance<KtPropertySymbol>()\n            ?.applyIf(isInterface) {\n                filter { it.isConstOrJvmField }\n            }\n            ?.forEach {\n                createField(\n                    declaration = it,\n                    nameGenerator = nameGenerator,\n                    isStatic = true,\n                    result = result\n                )\n            }\n    }\n\n    context(KtAnalysisSession)\n    protected fun addCompanionObjectFieldIfNeeded(result: MutableList<KtLightField>, classOrObjectSymbol: KtNamedClassOrObjectSymbol) {\n        val companionObjectSymbols: List<KtNamedClassOrObjectSymbol>? = classOrObjectDeclaration?.companionObjects?.mapNotNull {\n            it.getNamedClassOrObjectSymbol()\n        } ?: classOrObjectSymbol.companionObject?.let(::listOf)\n\n        companionObjectSymbols?.forEach {\n            result.add(\n              "}
{"code": "  SymbolLightFieldForObject(\n                    ktAnalysisSession = this@KtAnalysisSession,\n                    objectSymbol = it,\n                    containingClass = this,\n                    name = it.name.asString(),\n                    lightMemberOrigin = null,\n                    isCompanion = true,\n                )\n            )\n        }\n    }\n\n    internal fun computeModifiers(modifier: String): Map<String, Boolean>? = when (modifier) {\n        in GranularModifiersBox.VISIBILITY_MODIFIERS -> {\n            GranularModifiersBox.computeVisibilityForClass(ktModule, classOrObjectSymbolPointer, isTopLevel)\n        }\n\n        in GranularModifiersBox.MODALITY_MODIFIERS -> {\n            GranularModifiersBox.computeSimpleModality(ktModule, classOrObjectSymbolPointer)\n        }\n\n        PsiModifier.STATIC -> {\n            val isStatic = !isTopLevel && !isInner\n            mapOf(modifier to isStatic)\n        }\n\n        else -> null\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.calls.inference\n\nimport org.jetbrains.kotlin.descriptors.TypeParameterDescriptor\nimport org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPosition\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.kotlin.types.TypeSubstitutor\n\ninterface ConstraintSystem {\n    val status: ConstraintSystemStatus\n\n    \n    val typeVariables: Set<TypeVariable>\n\n    \n    fun getTypeBounds(typeVariable: TypeVariable): TypeBounds\n\n    \n    val resultingSubstitutor: TypeSubstitutor\n\n    \n    val currentSubstitutor: TypeSubstitutor\n\n    fun toBuilder(filterConstraintPosition: (ConstraintPosition) -> Boolean = { true }): Builder\n\n    interface Builder {\n        \n        fun registerTypeVariables(\n            call: CallHandle, typeParameters: Collection<TypeParameterDescriptor>, external: Boolean = false\n        ): TypeSubstitutor\n\n        \n        fun addSubtypeConstraint(constrainingType: KotlinType?, subjectType: KotlinType?, constr"}
{"code": "aintPosition: ConstraintPosition)\n\n        \n        val typeVariableSubstitutors: Map<CallHandle, TypeSubstitutor>\n\n        \n        fun add(other: Builder)\n\n        fun fixVariables()\n\n        fun build(): ConstraintSystem\n    }\n}\n"}
{"code": "fun test(b: String?) {\n    b?.let {\n        return@let <expr>5</expr>\n    }\n}"}
{"code": "interface WithGeneric<S> {\n    fun <T : S> functionWithGeneric(t: T): T\n\n    fun prop(): S\n}\n\nfun take(w: WithGeneric<*>) {\n    // this is an error on purpose!\n    w.<expr>functionWithGeneric</expr>\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.tree.generator\n\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.annotations\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.arguments\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.body\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.calleeReference\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.classKind\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.controlFlowGraphReferenceField\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.declarations\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.effectiveVisibility\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.initializer\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.modality\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.name\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.receivers\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.returnTypeRef\nimport org.jetbrains.kotlin.fir.tree.gene"}
{"code": "rator.FieldSets.scopeProvider\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.smartcastStability\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.status\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.superTypeRefs\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.symbol\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.symbolWithArgument\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.symbolWithPackageWithArgument\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.typeArguments\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.typeParameterRefs\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.typeParameters\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.typeRefField\nimport org.jetbrains.kotlin.fir.tree.generator.FieldSets.visibility\nimport org.jetbrains.kotlin.fir.tree.generator.context.AbstractFieldConfigurator\nimport org.jetbrains.kotlin.fir.tree.generator.context.AbstractFirTreeBuilder.Companion.baseFir"}
{"code": "Element\nimport org.jetbrains.kotlin.fir.tree.generator.context.type\nimport org.jetbrains.kotlin.fir.tree.generator.model.*\nimport org.jetbrains.kotlin.generators.tree.ArbitraryImportable\nimport org.jetbrains.kotlin.generators.tree.AbstractField\nimport org.jetbrains.kotlin.generators.tree.StandardTypes\nimport org.jetbrains.kotlin.generators.tree.TypeRef\nimport org.jetbrains.kotlin.generators.tree.withArgs\nimport org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedContainerSource\n\nobject NodeConfigurator : AbstractFieldConfigurator<FirTreeBuilder>(FirTreeBuilder) {\n    fun configureFields() = configure {\n        baseFirElement.configure {\n            +field(\"source\", sourceElementType, nullable = true)\n        }\n\n        annotationContainer.configure {\n            +annotations\n        }\n\n        typeParameterRef.configure {\n            +symbol(typeParameterSymbolType.typeName)\n        }\n\n        typeParametersOwner.configure {\n            +typeParameters.withTransf"}
{"code": "orm()\n        }\n\n        typeParameterRefsOwner.configure {\n            +typeParameterRefs.withTransform()\n        }\n\n        resolvable.configure {\n            +calleeReference.withTransform()\n        }\n\n        diagnosticHolder.configure {\n            +field(\"diagnostic\", coneDiagnosticType)\n        }\n\n        controlFlowGraphOwner.configure {\n            +controlFlowGraphReferenceField\n        }\n\n        contextReceiver.configure {\n            +field(typeRef, withReplace = true).withTransform()\n            +field(\"customLabelName\", nameType, nullable = true)\n            +field(\"labelNameFromTypeRef\", nameType, nullable = true)\n        }\n\n        elementWithResolveState.configure {\n            +field(\"resolvePhase\", resolvePhaseType).apply { isParameter = true; }\n            +field(\"resolveState\", resolveStateType).apply {\n                isMutable = true; isVolatile = true; isFinal = true;\n                implementationDefaultStrategy = AbstractField.ImplementationDefaultStrategy.La"}
{"code": "teinit\n                customInitializationCall = \"resolvePhase.asResolveState()\"\n                arbitraryImportables += phaseAsResolveStateExtentionImport\n                optInAnnotation = resolveStateAccessAnnotation\n            }\n\n            +field(\"moduleData\", firModuleDataType)\n            shouldBeAbstractClass()\n        }\n\n        declaration.configure {\n            +symbolWithPackageWithArgument(\"fir.symbols\", \"FirBasedSymbol\")\n            +field(\"moduleData\", firModuleDataType)\n            +field(\"origin\", declarationOriginType)\n            +field(\"attributes\", declarationAttributesType)\n            shouldBeAbstractClass()\n        }\n\n        callableDeclaration.configure {\n            +field(\"returnTypeRef\", typeRef, withReplace = true).withTransform()\n            +field(\"receiverParameter\", receiverParameter, nullable = true, withReplace = true).withTransform()\n            +field(\"deprecationsProvider\", deprecationsProviderType).withReplace().apply { isMutable = true }\n    "}
{"code": "        +symbolWithArgument(\"FirCallableSymbol\")\n\n            +field(\"containerSource\", type<DeserializedContainerSource>(), nullable = true)\n            +field(\"dispatchReceiverType\", coneSimpleKotlinTypeType, nullable = true)\n\n            +fieldList(contextReceiver, useMutableOrEmpty = true, withReplace = true)\n        }\n\n        function.configure {\n            +symbolWithArgument(\"FirFunctionSymbol\")\n            +fieldList(valueParameter, withReplace = true).withTransform()\n            +body(nullable = true, withReplace = true).withTransform()\n        }\n\n        errorExpression.configure {\n            +field(\"expression\", expression, nullable = true)\n            +field(\"nonExpressionElement\", baseFirElement, nullable = true)\n        }\n\n        errorFunction.configure {\n            +symbol(\"FirErrorFunctionSymbol\")\n        }\n\n        memberDeclaration.configure {\n            +status.withTransform().withReplace()\n        }\n\n        expression.configure {\n            +field(\"coneTypeO"}
{"code": "rNull\", coneKotlinTypeType, nullable = true, withReplace = true).apply {\n                optInAnnotation = unresolvedExpressionTypeAccessAnnotation\n            }\n            +annotations\n        }\n\n        argumentList.configure {\n            +arguments.withTransform()\n        }\n\n        call.configure {\n            +field(argumentList, withReplace = true)\n        }\n\n        block.configure {\n            +fieldList(statement).withTransform()\n            needTransformOtherChildren()\n        }\n\n        binaryLogicExpression.configure {\n            +field(\"leftOperand\", expression).withTransform()\n            +field(\"rightOperand\", expression).withTransform()\n            +field(\"kind\", operationKindType)\n            needTransformOtherChildren()\n        }\n\n        jump.configure {\n            val e = withArg(\"E\", targetElement)\n            +field(\"target\", jumpTargetType.withArgs(e))\n        }\n\n        loopJump.configure {\n            parentArgs(jump, \"E\" to loop)\n        }\n\n        return"}
{"code": "Expression.configure {\n            parentArgs(jump, \"E\" to function)\n            +field(\"result\", expression).withTransform()\n            needTransformOtherChildren()\n        }\n\n        label.configure {\n            +stringField(\"name\")\n        }\n\n        loop.configure {\n            +field(block).withTransform()\n            +field(\"condition\", expression).withTransform()\n            +field(label, nullable = true)\n            needTransformOtherChildren()\n        }\n\n        whileLoop.configure {\n            +field(\"condition\", expression).withTransform()\n            +field(block).withTransform()\n        }\n\n        catchClause.configure {\n            +field(\"parameter\", property).withTransform()\n            +field(block).withTransform()\n            needTransformOtherChildren()\n        }\n\n        tryExpression.configure {\n            +field(\"tryBlock\", block).withTransform()\n            +fieldList(\"catches\", catchClause).withTransform()\n            +field(\"finallyBlock\", block, nullable ="}
{"code": " true).withTransform()\n            needTransformOtherChildren()\n        }\n\n        elvisExpression.configure {\n            +field(\"lhs\", expression).withTransform()\n            +field(\"rhs\", expression).withTransform()\n        }\n\n        contextReceiverArgumentListOwner.configure {\n            +fieldList(\"contextReceiverArguments\", expression, useMutableOrEmpty = true, withReplace = true)\n        }\n\n        qualifiedAccessExpression.configure {\n            +typeArguments.withTransform()\n            +receivers\n            +field(\"source\", sourceElementType, nullable = true, withReplace = true)\n            +fieldList(\"nonFatalDiagnostics\", coneDiagnosticType, useMutableOrEmpty = true, withReplace = true)\n        }\n\n        qualifiedErrorAccessExpression.configure {\n            +field(\"selector\", errorExpression)\n            +field(\"receiver\", expression)\n        }\n\n        literalExpression.configure {\n            val t = withArg(\"T\")\n            +field(\"kind\", constKindType.withArgs(t),"}
{"code": " withReplace = true)\n            +field(\"value\", t)\n        }\n\n        functionCall.configure {\n            +field(\"calleeReference\", namedReference)\n            +field(\"origin\", functionCallOrigin)\n        }\n\n        integerLiteralOperatorCall.configure {\n            // we need methods for transformation of receivers\n            +field(\"dispatchReceiver\", expression, nullable = true, withReplace = true).withTransform()\n            +field(\"extensionReceiver\", expression, nullable = true, withReplace = true).withTransform()\n        }\n\n        comparisonExpression.configure {\n            +field(\"operation\", operationType)\n            +field(\"compareToCall\", functionCall)\n        }\n\n        typeOperatorCall.configure {\n            +field(\"operation\", operationType)\n            +field(\"conversionTypeRef\", typeRef).withTransform()\n            +booleanField(\"argFromStubType\", withReplace = true)\n            needTransformOtherChildren()\n        }\n\n        assignmentOperatorStatement.configure"}
{"code": " {\n            +field(\"operation\", operationType)\n            +field(\"leftArgument\", expression).withTransform()\n            +field(\"rightArgument\", expression).withTransform()\n        }\n\n        incrementDecrementExpression.configure {\n            +booleanField(\"isPrefix\")\n            +field(\"operationName\", nameType)\n            +field(\"expression\", expression)\n            +field(\"operationSource\", sourceElementType, nullable = true)\n        }\n\n        equalityOperatorCall.configure {\n            +field(\"operation\", operationType)\n        }\n\n        whenBranch.configure {\n            +field(\"condition\", expression).withTransform()\n            +field(\"result\", block).withTransform()\n            needTransformOtherChildren()\n        }\n\n        classLikeDeclaration.configure {\n            +symbolWithArgument(\"FirClassLikeSymbol\")\n            +field(\"deprecationsProvider\", deprecationsProviderType).withReplace().apply { isMutable = true }\n        }\n\n        klass.configure {\n            +"}
{"code": "symbolWithArgument(\"FirClassSymbol\")\n            +classKind\n            +superTypeRefs(withReplace = true).withTransform()\n            +declarations.withTransform()\n            +annotations\n            +scopeProvider\n        }\n\n        regularClass.configure {\n            +name\n            +symbol(\"FirRegularClassSymbol\")\n            +booleanField(\"hasLazyNestedClassifiers\")\n            +field(\"companionObjectSymbol\", regularClassSymbolType, nullable = true, withReplace = true)\n            +superTypeRefs(withReplace = true)\n            +fieldList(contextReceiver, useMutableOrEmpty = true)\n        }\n\n        anonymousObject.configure {\n            +symbol(\"FirAnonymousObjectSymbol\")\n        }\n\n        anonymousObjectExpression.configure {\n            +field(anonymousObject).withTransform()\n        }\n\n        typeAlias.configure {\n            +typeParameters\n            +name\n            +symbol(\"FirTypeAliasSymbol\")\n            +field(\"expandedTypeRef\", typeRef, withReplace = true).with"}
{"code": "Transform()\n            +annotations\n        }\n\n        anonymousFunction.configure {\n            +symbol(\"FirAnonymousFunctionSymbol\")\n            +field(label, nullable = true)\n            +field(\"invocationKind\", eventOccurrencesRangeType, nullable = true, withReplace = true).apply {\n                isMutable = true\n            }\n            +field(\"inlineStatus\", inlineStatusType, withReplace = true).apply {\n                isMutable = true\n            }\n            +booleanField(\"isLambda\")\n            +booleanField(\"hasExplicitParameterList\")\n            +typeParameters\n            +field(typeRef, withReplace = true)\n        }\n\n        anonymousFunctionExpression.configure {\n            +field(anonymousFunction).withTransform()\n            +booleanField(\"isTrailingLambda\", withReplace = true).apply {\n                replaceOptInAnnotation = rawFirApi\n            }\n        }\n\n        typeParameter.configure {\n            +name\n            +symbol(\"FirTypeParameterSymbol\")\n        "}
{"code": "    +field(\"containingDeclarationSymbol\", firBasedSymbolType.withArgs(TypeRef.Star)).apply {\n                withBindThis = false\n            }\n            +field(varianceType)\n            +booleanField(\"isReified\")\n            // TODO: `useMutableOrEmpty = true` is a workaround for KT-60324 until KT-60445 has been fixed.\n            +fieldList(\"bounds\", typeRef, withReplace = true, useMutableOrEmpty = true)\n            +annotations\n        }\n\n        simpleFunction.configure {\n            +name\n            +symbol(\"FirNamedFunctionSymbol\")\n            +annotations\n            +typeParameters\n        }\n\n        contractDescriptionOwner.configure {\n            +field(contractDescription, withReplace = true, nullable = true).withTransform()\n        }\n\n        property.configure {\n            +fieldList(contextReceiver, useMutableOrEmpty = true, withReplace = true).withTransform()\n            +symbol(\"FirPropertySymbol\")\n            +field(\"delegateFieldSymbol\", delegateFieldSymbolType, n"}
{"code": "ullable = true)\n            +booleanField(\"isLocal\")\n            +field(\"bodyResolveState\", propertyBodyResolveStateType, withReplace = true)\n            +typeParameters\n        }\n\n        propertyAccessor.configure {\n            +symbol(\"FirPropertyAccessorSymbol\")\n            +field(\"propertySymbol\", firPropertySymbolType).apply {\n                withBindThis = false\n            }\n            +booleanField(\"isGetter\")\n            +booleanField(\"isSetter\")\n            +annotations\n            +typeParameters\n        }\n\n        backingField.configure {\n            +field(\"symbol\", backingFieldSymbolType)\n            +field(\"propertySymbol\", firPropertySymbolType).apply {\n                withBindThis = false\n            }\n            +initializer.withTransform().withReplace()\n            +annotations\n            +typeParameters\n            +status.withTransform()\n        }\n\n        declarationStatus.configure {\n            +visibility\n            +modality(nullable = true)\n            g"}
{"code": "enerateBooleanFields(\n                \"expect\", \"actual\", \"override\", \"operator\", \"infix\", \"inline\", \"tailRec\",\n                \"external\", \"const\", \"lateInit\", \"inner\", \"companion\", \"data\", \"suspend\", \"static\",\n                \"fromSealedClass\", \"fromEnumClass\", \"fun\", \"hasStableParameterNames\",\n            )\n        }\n\n        resolvedDeclarationStatus.configure {\n            +modality(nullable = false)\n            +effectiveVisibility\n            shouldBeAnInterface()\n        }\n\n        implicitInvokeCall.configure {\n            +booleanField(\"isCallWithExplicitReceiver\")\n        }\n\n        constructor.configure {\n            +annotations\n            +symbol(\"FirConstructorSymbol\")\n            +field(\"delegatedConstructor\", delegatedConstructorCall, nullable = true, withReplace = true).withTransform()\n            +body(nullable = true)\n            +booleanField(\"isPrimary\")\n        }\n\n        delegatedConstructorCall.configure {\n            +field(\"constructedTypeRef\", typeRef, with"}
{"code": "Replace = true)\n            +field(\"dispatchReceiver\", expression, nullable = true, withReplace = true).withTransform()\n            +field(\"calleeReference\", reference, withReplace = true)\n            +field(\"source\", sourceElementType, nullable = true, withReplace = true)\n            generateBooleanFields(\"this\", \"super\")\n        }\n\n        multiDelegatedConstructorCall.configure {\n            +fieldList(\"delegatedConstructorCalls\", delegatedConstructorCall, withReplace = true).withTransform()\n        }\n\n        valueParameter.configure {\n            +symbol(\"FirValueParameterSymbol\")\n            +field(\"defaultValue\", expression, nullable = true, withReplace = true)\n            +field(\"containingFunctionSymbol\", functionSymbolType.withArgs(TypeRef.Star)).apply {\n                withBindThis = false\n            }\n            generateBooleanFields(\"crossinline\", \"noinline\", \"vararg\")\n        }\n\n        receiverParameter.configure {\n            +typeRefField.withTransform()\n            "}
{"code": "+annotations\n        }\n\n        variable.configure {\n            +name\n            +symbolWithArgument(\"FirVariableSymbol\")\n            +initializer.withTransform().withReplace()\n            +field(\"delegate\", expression, nullable = true, withReplace = true).withTransform()\n            generateBooleanFields(\"var\", \"val\")\n            +field(\"getter\", propertyAccessor, nullable = true, withReplace = true).withTransform()\n            +field(\"setter\", propertyAccessor, nullable = true, withReplace = true).withTransform()\n            +field(\"backingField\", backingField, nullable = true).withTransform()\n            +annotations\n            needTransformOtherChildren()\n        }\n\n        functionTypeParameter.configure {\n            +field(\"name\", nameType, nullable = true)\n            +field(\"returnTypeRef\", typeRef)\n        }\n\n        errorProperty.configure {\n            +symbol(\"FirErrorPropertySymbol\")\n        }\n\n        enumEntry.configure {\n            +symbol(\"FirEnumEntrySymbol\")\n   "}
{"code": "     }\n\n        field.configure {\n            +symbol(\"FirFieldSymbol\")\n            generateBooleanFields(\"hasConstantInitializer\")\n        }\n\n        anonymousInitializer.configure {\n            +body(nullable = true, withReplace = true)\n            +symbol(\"FirAnonymousInitializerSymbol\")\n            // the containing declaration is nullable, because it is not immediately clear how to obtain it in all places in the fir builder\n            // TODO: review and consider making not-nullable (KT-64195)\n            +field(\"containingDeclarationSymbol\", firBasedSymbolType.withArgs(TypeRef.Star), nullable = true).apply {\n                withBindThis = false\n            }\n        }\n\n        danglingModifierList.configure {\n            +symbol(\"FirDanglingModifierSymbol\")\n        }\n\n        file.configure {\n            +field(\"packageDirective\", packageDirective)\n            +fieldList(import).withTransform()\n            +declarations.withTransform()\n            +stringField(\"name\")\n          "}
{"code": "  +field(\"sourceFile\", sourceFileType, nullable = true)\n            +field(\"sourceFileLinesMapping\", sourceFileLinesMappingType, nullable = true)\n            +symbol(\"FirFileSymbol\")\n        }\n\n        script.configure {\n            +name\n            +declarations.withTransform().withReplace()\n            +symbol(\"FirScriptSymbol\")\n            +fieldList(\"parameters\", property).withTransform()\n            +fieldList(contextReceiver, useMutableOrEmpty = true).withTransform()\n            +field(\"resultPropertyName\", nameType, nullable = true)\n        }\n\n        codeFragment.configure {\n            +symbol(\"FirCodeFragmentSymbol\")\n            +field(block, withReplace = true).withTransform()\n        }\n\n        packageDirective.configure {\n            +field(\"packageFqName\", fqNameType)\n        }\n\n        import.configure {\n            +field(\"importedFqName\", fqNameType, nullable = true)\n            +booleanField(\"isAllUnder\")\n            +field(\"aliasName\", nameType, nullable = true)\n   "}
{"code": "         +field(\"aliasSource\", sourceElementType, nullable = true)\n            shouldBeAbstractClass()\n        }\n\n        resolvedImport.configure {\n            +field(\"delegate\", import, isChild = false)\n            +field(\"packageFqName\", fqNameType)\n            +field(\"relativeParentClassName\", fqNameType, nullable = true)\n            +field(\"resolvedParentClassId\", classIdType, nullable = true)\n            +field(\n                \"importedName\",\n                nameType,\n                nullable = true\n            )\n        }\n\n        annotation.configure {\n            +field(\"useSiteTarget\", annotationUseSiteTargetType, nullable = true, withReplace = true)\n            +field(\"annotationTypeRef\", typeRef, withReplace = true).withTransform()\n            +field(\"argumentMapping\", annotationArgumentMapping, withReplace = true)\n            +typeArguments.withTransform()\n        }\n\n        annotationCall.configure {\n            +field(\"argumentMapping\", annotationArgumentMapping, withRe"}
{"code": "place = true, isChild = false)\n            +field(\"annotationResolvePhase\", annotationResolvePhaseType, withReplace = true)\n            +field(\"containingDeclarationSymbol\", firBasedSymbolType.withArgs(TypeRef.Star)).apply {\n                withBindThis = false\n            }\n        }\n\n        errorAnnotationCall.configure {\n            +field(\"argumentMapping\", annotationArgumentMapping, withReplace = true, isChild = false)\n        }\n\n        annotationArgumentMapping.configure {\n            +field(\"mapping\", StandardTypes.map.withArgs(nameType, expression))\n        }\n\n        augmentedArraySetCall.configure {\n            +field(\"lhsGetCall\", functionCall)\n            +field(\"rhs\", expression)\n            +field(\"operation\", operationType)\n            // Used for resolution errors reporting in case\n            +field(\"calleeReference\", reference, withReplace = true)\n            +field(\"arrayAccessSource\", sourceElementType, nullable = true)\n        }\n\n        classReferenceExpression."}
{"code": "configure {\n            +field(\"classTypeRef\", typeRef)\n        }\n\n        componentCall.configure {\n            +field(\"explicitReceiver\", expression)\n            +intField(\"componentIndex\")\n        }\n\n        smartCastExpression.configure {\n            +field(\"originalExpression\", expression, withReplace = true).withTransform()\n            +field(\"typesFromSmartCast\", StandardTypes.collection.withArgs(coneKotlinTypeType))\n            +field(\"smartcastType\", typeRef)\n            +field(\"smartcastTypeWithoutNullableNothing\", typeRef, nullable = true)\n            +booleanField(\"isStable\")\n            +smartcastStability\n        }\n\n        safeCallExpression.configure {\n            +field(\"receiver\", expression).withTransform()\n            // Special node that might be used as a reference to receiver of a safe call after null check\n            +field(\"checkedSubjectRef\", safeCallCheckedSubjectReferenceType)\n            // One that uses checkedReceiver as a receiver\n            +field(\"se"}
{"code": "lector\", statement, withReplace = true).withTransform()\n        }\n\n        checkedSafeCallSubject.configure {\n            +field(\"originalReceiverRef\", referenceToSimpleExpressionType)\n        }\n\n        callableReferenceAccess.configure {\n            +field(\"calleeReference\", namedReference, withReplace = true).withTransform()\n            +booleanField(\"hasQuestionMarkAtLHS\", withReplace = true)\n        }\n\n        getClassCall.configure {\n            +field(\"argument\", expression)\n        }\n\n        wrappedArgumentExpression.configure {\n            +booleanField(\"isSpread\")\n        }\n\n        spreadArgumentExpression.configure {\n            +booleanField(\"isNamed\")\n            +booleanField(\"isFakeSpread\")\n\n            element.kDoc = \"\"\"\n                |### Up to and including body resolution phase\n                |\n                |Represents a spread expression `*foo`. If a spread expression is passed as named argument `foo = *bar`, it will be\n                |represented as an [Fi"}
{"code": "rNamedArgumentExpression] with [FirNamedArgumentExpression.isSpread] set to `true`.\n                |  \n                |### After body resolution phase\n                |\n                |Represents spread expressions `*foo` and named argument expressions for vararg parameters `foo = bar` and `foo = *bar`.\n                |\n                |If [isNamed] is `true`, it means the argument was passed in named form. The name is not saved since it's not required.\n                |To retrieve the argument mapping of a call, [FirResolvedArgumentList.mapping] must be used.\n                |\n                |If [isFakeSpread] is `true`, it means this expression is the argument to a `vararg` parameter that was passed in named form\n                |without a spread operator `*`.\n                |\n                |The information carried by [isNamed] and [isFakeSpread] is only relevant for some checkers. Otherwise,\n                |[FirSpreadArgumentExpression]s should be treated uniformly since th"}
{"code": "ey always represent an array that was passed to a\n                |`vararg` parameter and don't influence the resulting platform code.\n            \"\"\".trimMargin()\n            element.additionalImports.add(ArbitraryImportable(\"org.jetbrains.kotlin.fir.expressions.impl\", \"FirResolvedArgumentList\"))\n        }\n\n        namedArgumentExpression.configure {\n            +name\n\n            element.kDoc = \"\"\"\n                |Represents a named argument `foo = bar` before and during body resolution phase.\n                |\n                |After body resolution, all [FirNamedArgumentExpression]s are removed from the FIR tree and the argument mapping must be\n                |retrieved from [FirResolvedArgumentList.mapping].\n                |\n                |For a named argument with spread operator `foo = *bar`, [isSpread] will be set to `true` but no additional\n                |[FirSpreadArgumentExpression] will be created as the [expression].\n                |\n                |**Special case "}
{"code": "vor varargs**: named arguments for `vararg` parameters are replaced with [FirSpreadArgumentExpression] with\n                |[FirSpreadArgumentExpression.isNamed] set to `true`.\n                |\n                |See [FirVarargArgumentsExpression] for the general structure of arguments of `vararg` parameters after resolution.\n            \"\"\".trimMargin()\n            element.additionalImports.add(ArbitraryImportable(\"org.jetbrains.kotlin.fir.expressions.impl\", \"FirResolvedArgumentList\"))\n        }\n\n        varargArgumentsExpression.configure {\n            +fieldList(\"arguments\", expression)\n            +field(\"coneElementTypeOrNull\", coneKotlinTypeType, nullable = true)\n\n            element.kDoc = \"\"\"\n                |[FirVarargArgumentsExpression]s are created during body resolution phase for arguments of `vararg` parameters.\n                |\n                |If one or multiple elements are passed to a `vararg` parameter, the will be wrapped with a [FirVarargArgumentsExpression]\n     "}
{"code": "           |and [arguments] will contain the individual elements.\n                |\n                |If a named argument is passed to a `vararg` parameter, [arguments] will contain a single [FirSpreadArgumentExpression]\n                |with [FirSpreadArgumentExpression.isNamed] set to `true`.\n                |\n                |[FirSpreadArgumentExpression]s are kept as is in [arguments]. \n                |\n                |If no element is passed to a `vararg` parameter, no [FirVarargArgumentsExpression] is created regardless of whether the\n                |parameter has a default value.\n            \"\"\".trimMargin()\n        }\n\n        samConversionExpression.configure {\n            +field(\"expression\", expression)\n        }\n\n        resolvedQualifier.configure {\n            +field(\"packageFqName\", fqNameType)\n            +field(\"relativeClassFqName\", fqNameType, nullable = true)\n            +field(\"classId\", classIdType, nullable = true)\n            +field(\"symbol\", classLikeSymbolTyp"}
{"code": "e, nullable = true)\n            +booleanField(\"isNullableLHSForCallableReference\", withReplace = true)\n            +booleanField(\"resolvedToCompanionObject\", withReplace = true)\n            +booleanField(\"canBeValue\", withReplace = true)\n            +booleanField(\"isFullyQualified\")\n            +fieldList(\"nonFatalDiagnostics\", coneDiagnosticType, useMutableOrEmpty = true)\n            +typeArguments.withTransform()\n        }\n\n        resolvedReifiedParameterReference.configure {\n            +field(\"symbol\", typeParameterSymbolType)\n        }\n\n        stringConcatenationCall.configure {\n        }\n\n        throwExpression.configure {\n            +field(\"exception\", expression).withTransform()\n        }\n\n        variableAssignment.configure {\n            +field(\"lValue\", expression).withTransform().withReplace()\n            +field(\"rValue\", expression).withTransform()\n        }\n\n        whenSubjectExpression.configure {\n            +field(\"whenRef\", whenRefType)\n        }\n\n        desugar"}
{"code": "edAssignmentValueReferenceExpression.configure {\n            +field(\"expressionRef\", referenceToSimpleExpressionType)\n        }\n\n        wrappedExpression.configure {\n            +field(expression)\n        }\n\n        wrappedDelegateExpression.configure {\n            +field(\"provideDelegateCall\", functionCall)\n        }\n\n        enumEntryDeserializedAccessExpression.configure {\n            +field(\"enumClassId\", classIdType)\n            +field(\"enumEntryName\", nameType)\n        }\n\n        namedReference.configure {\n            +name\n        }\n\n        namedReferenceWithCandidateBase.configure {\n            +field(\"candidateSymbol\", firBasedSymbolType.withArgs(TypeRef.Star))\n        }\n\n        resolvedNamedReference.configure {\n            +field(\"resolvedSymbol\", firBasedSymbolType.withArgs(TypeRef.Star))\n        }\n\n        resolvedCallableReference.configure {\n            +fieldList(\"inferredTypeArguments\", coneKotlinTypeType)\n            +field(\"mappedArguments\", callableReferenceMappe"}
{"code": "dArgumentsType)\n        }\n\n        delegateFieldReference.configure {\n            +field(\"resolvedSymbol\", delegateFieldSymbolType)\n        }\n\n        backingFieldReference.configure {\n            +field(\"resolvedSymbol\", backingFieldSymbolType)\n        }\n\n        superReference.configure {\n            +stringField(\"labelName\", nullable = true)\n            +field(\"superTypeRef\", typeRef, withReplace = true)\n        }\n\n        thisReference.configure {\n            +stringField(\"labelName\", nullable = true)\n            +field(\"boundSymbol\", firBasedSymbolType.withArgs(TypeRef.Star), nullable = true, withReplace = true)\n            +intField(\"contextReceiverNumber\", withReplace = true)\n            +booleanField(\"isImplicit\")\n            +field(\"diagnostic\", coneDiagnosticType, nullable = true, withReplace = true)\n        }\n\n        typeRef.configure {\n            +annotations\n        }\n\n        resolvedTypeRef.configure {\n            +field(\"type\", coneKotlinTypeType)\n            +field(\""}
{"code": "delegatedTypeRef\", typeRef, nullable = true, isChild = false)\n            element.otherParents.add(typeRefMarkerType)\n        }\n\n        typeRefWithNullability.configure {\n            +booleanField(\"isMarkedNullable\")\n        }\n\n        userTypeRef.configure {\n            +fieldList(\"qualifier\", firQualifierPartType)\n            +booleanField(\"customRenderer\")\n        }\n\n        functionTypeRef.configure {\n            +field(\"receiverTypeRef\", typeRef, nullable = true)\n            +fieldList(\"parameters\", functionTypeParameter)\n            +returnTypeRef\n            +booleanField(\"isSuspend\")\n\n            +fieldList(\"contextReceiverTypeRefs\", typeRef)\n        }\n\n        errorTypeRef.configure {\n            +field(\"partiallyResolvedTypeRef\", typeRef, nullable = true).withTransform()\n        }\n\n        resolvedErrorReference.configure {\n            element.customParentInVisitor = resolvedNamedReference\n        }\n\n        intersectionTypeRef.configure {\n            +field(\"leftType\", type"}
{"code": "Ref)\n            +field(\"rightType\", typeRef)\n        }\n\n        thisReceiverExpression.configure {\n            +field(\"calleeReference\", thisReference)\n            +booleanField(\"isImplicit\")\n        }\n\n        inaccessibleReceiverExpression.configure {\n            +field(\"calleeReference\", thisReference)\n        }\n\n        whenExpression.configure {\n            +field(\"subject\", expression, nullable = true).withTransform()\n            +field(\"subjectVariable\", variable, nullable = true)\n            +fieldList(\"branches\", whenBranch).withTransform()\n            +field(\"exhaustivenessStatus\", exhaustivenessStatusType, nullable = true, withReplace = true)\n            +booleanField(\"usedAsExpression\")\n            needTransformOtherChildren()\n        }\n\n        typeProjectionWithVariance.configure {\n            +field(typeRef)\n            +field(varianceType)\n        }\n\n        contractElementDeclaration.configure {\n            +field(\"effect\", coneContractElementType)\n        }\n\n        "}
{"code": "effectDeclaration.configure {\n            +field(\"effect\", coneEffectDeclarationType)\n        }\n\n        rawContractDescription.configure {\n            +fieldList(\"rawEffects\", expression)\n        }\n\n        resolvedContractDescription.configure {\n            +fieldList(\"effects\", effectDeclaration)\n            +fieldList(\"unresolvedEffects\", contractElementDeclaration)\n            +field(\"diagnostic\", coneDiagnosticType, nullable = true)\n        }\n\n        legacyRawContractDescription.configure {\n            +field(\"contractCall\", functionCall)\n            +field(\"diagnostic\", coneDiagnosticType, nullable = true)\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirBackingField\nimport org.jetbrains.kotlin.fir.declarations.impl.FirDefaultPropertyBackingField\nimport org.jetbrains.kotlin.fir.languageVersionSettings\n\nobject FirExplicitBackingFieldsUnsupportedChecker : FirBackingFieldChecker(MppCheckerKind.Common) {\n    override fun check(declaration: FirBackingField, context: CheckerContext, reporter: DiagnosticReporter) {\n        if (declaration !is FirDefaultPropertyBackingField &&\n            !context.session.languageVersionSettings.supportsFeature(LanguageFeature.ExplicitBackingFie"}
{"code": "lds)\n        ) {\n            reporter.reportOn(\n                declaration.source,\n                FirErrors.UNSUPPORTED_FEATURE,\n                LanguageFeature.ExplicitBackingFields to context.session.languageVersionSettings,\n                context\n            )\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.range.inExpression\n\nimport org.jetbrains.kotlin.codegen.*\nimport org.jetbrains.kotlin.codegen.range.BoundedValue\nimport org.jetbrains.kotlin.codegen.range.comparison.ComparisonGenerator\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.psi.KtSimpleNameExpression\nimport org.jetbrains.org.objectweb.asm.Label\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\n\nclass InFloatingPointRangeLiteralExpressionGenerator(\n    operatorReference: KtSimpleNameExpression,\n    private val rangeLiteral: BoundedValue,\n    private val comparisonGenerator: ComparisonGenerator,\n    private val frameMap: FrameMap\n) : InExpressionGenerator {\n    init {\n        assert(rangeLiteral.isLowInclusive && rangeLiteral.isHighInclusive) { \"Floating point range literal bounds should be inclusive\" }\n    }\n\n    private val isNotIn = operatorReference.getRefer"}
{"code": "encedNameElementType() == KtTokens.NOT_IN\n\n    override fun generate(argument: StackValue): BranchedValue =\n        gen(argument).let { if (isNotIn) Invert(it) else it }\n\n    private fun gen(argument: StackValue): BranchedValue =\n        object : BranchedValue(argument, null, comparisonGenerator.comparedType, Opcodes.IFEQ) {\n            override fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean) {\n                if (jumpIfFalse) {\n                    genJumpIfFalse(v, jumpLabel)\n                } else {\n                    genJumpIfTrue(v, jumpLabel)\n                }\n            }\n\n            private fun genJumpIfTrue(v: InstructionAdapter, jumpLabel: Label) {\n                //  if (arg is in range) goto jumpLabel\n                // =>\n                //      if (arg is NOT in range) goto exitLabel\n                //      goto jumpLabel\n                //  exitLabel:\n\n                frameMap.useTmpVar(operandType) { _ ->\n                    val exitLabel ="}
{"code": " Label()\n                    genJumpIfFalse(v, exitLabel)\n                    v.goTo(jumpLabel)\n                    v.mark(exitLabel)\n                }\n            }\n\n            private fun genJumpIfFalse(v: InstructionAdapter, jumpLabel: Label) {\n                // if (arg is NOT in range) goto jumpLabel\n\n                frameMap.useTmpVar(operandType) { argVar ->\n                    // Evaluate low and high bounds once (unless they have no side effects)\n                    val (lowValue, lowTmpType) = introduceTemporaryIfRequired(v, rangeLiteral.lowBound, operandType)\n                    val (highValue, highTmpType) = introduceTemporaryIfRequired(v, rangeLiteral.highBound, operandType)\n\n                    val argValue = StackValue.local(argVar, operandType)\n                    argValue.store(arg1, v)\n\n                    // if (low bound is NOT satisfied) goto jumpLabel\n                    // arg < low\n                    argValue.put(operandType, v)\n                    lowValue.pu"}
{"code": "t(operandType, v)\n                    comparisonGenerator.jumpIfLess(v, jumpLabel)\n\n                    // if (high bound is NOT satisfied) goto jumpLabel\n                    // arg > high\n                    argValue.put(operandType, v)\n                    highValue.put(operandType, v)\n                    comparisonGenerator.jumpIfGreater(v, jumpLabel)\n\n                    highTmpType?.let { frameMap.leaveTemp(it) }\n                    lowTmpType?.let { frameMap.leaveTemp(it) }\n                }\n\n            }\n\n            // TODO evaluateOnce\n            private fun introduceTemporaryIfRequired(v: InstructionAdapter, value: StackValue, type: Type): Pair<StackValue, Type?> {\n                val resultValue: StackValue\n                val resultType: Type?\n\n                if (value.canHaveSideEffects()) {\n                    val index = frameMap.enterTemp(type)\n                    resultValue = StackValue.local(index, type)\n                    resultType = type\n                    res"}
{"code": "ultValue.store(value, v)\n                } else {\n                    resultValue = value\n                    resultType = null\n                }\n\n                return Pair(resultValue, resultType)\n            }\n        }\n}"}
{"code": "@file:Suppress(\"1\")\n\n@Suppress(\"2\")\nfun resolve<caret>Me() {\n\n}"}
{"code": "fun <T> simpleRun(f: (T) -> Unit): Unit = f(<!RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY!>return<!>)\n\nfun <T, R> List<T>.simpleMap(f: (T) -> R): R {\n\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun <T> simpleWith(t: T, f: T.() -> Unit): Unit = t.f()\n\ninterface KMutableProperty1<T, R> : KProperty1<T, R>, KMutableProperty<R>\n\ninterface KProperty1<T, out R> : KProperty<R>, (T) -> R\n\ninterface KProperty<out R>\n\ninterface KMutableProperty<R>\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.extensions\n\nimport com.intellij.openapi.project.Project\nimport org.jetbrains.kotlin.config.CompilerConfiguration\nimport org.jetbrains.kotlin.psi.KtFile\n\ninterface CollectAdditionalSourcesExtension {\n    companion object : ProjectExtensionDescriptor<CollectAdditionalSourcesExtension>(\n        \"org.jetbrains.kotlin.collectAdditionalSourcesExtension\",\n        CollectAdditionalSourcesExtension::class.java\n    )\n\n    fun collectAdditionalSourcesAndUpdateConfiguration(\n        knownSources: Collection<KtFile>,\n        configuration: CompilerConfiguration,\n        project: Project\n    ): Collection<KtFile>\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.runner\n\nimport java.io.File\nimport java.io.FileNotFoundException\nimport java.net.URL\nimport java.util.*\nimport kotlin.system.exitProcess\n\nobject Main {\n    private val KOTLIN_HOME: File\n\n    init {\n        val home = System.getProperty(\"kotlin.home\")\n        if (home == null) {\n            System.err.println(\"error: no kotlin.home system property was passed\")\n            exitProcess(1)\n        }\n        KOTLIN_HOME = File(home)\n    }\n\n    enum class HowToRun(val argName: String) {\n        GUESS(\"guess\"),\n        CLASSFILE(\"classfile\"),\n        JAR(\"jar\"),\n        SCRIPT(\"script\");\n        // TODO: consider implementing REPL as well\n\n        companion object {\n            val validValues = \"${GUESS.argName} (default), ${CLASSFILE.argName}, ${JAR.argName}, ${SCRIPT.argName} (or .<script filename extension>)\"\n\n            fun fromArg(name: String): HowToRun? =\n                HowToRun.entries.find { it.argName == name }\n        }\n    }\n\n    private fun run(a"}
{"code": "rgs: Array<String>) {\n        val classpath = arrayListOf<URL>()\n        val compilerClasspath = arrayListOf<URL>()\n        var runner: Runner? = null\n        val arguments = arrayListOf<String>()\n        val compilerArguments = arrayListOf<String>()\n        var noStdLib = false\n        var noReflect = false\n        var howtorun = HowToRun.GUESS\n\n        fun setRunner(newRunner: Runner) {\n            if (runner == null) {\n                runner = newRunner\n            } else {\n                throw AssertionError(\"conflicting runner settings\")\n            }\n        }\n\n        var i = 0\n        while (i < args.size) {\n            val arg = args[i]\n\n            fun next(): String {\n                if (++i == args.size) {\n                    throw RunnerException(\"argument expected to $arg\")\n                }\n                return args[i]\n            }\n\n            fun restAsArguments() {\n                arguments.addAll(args.copyOfRange(i+1, args.size))\n            }\n\n            when {"}
{"code": "\n                \"-help\" == arg || \"-h\" == arg -> {\n                    printUsageAndExit()\n                }\n                \"-version\" == arg -> {\n                    printVersionAndExit()\n                }\n                \"-classpath\" == arg || \"-cp\" == arg -> {\n                    for (path in next().split(File.pathSeparator).filter(String::isNotEmpty)) {\n                        classpath.addPath(path)\n                    }\n                }\n                \"-compiler-path\" == arg -> {\n                    for (path in next().split(File.pathSeparator).filter(String::isNotEmpty)) {\n                        compilerClasspath.addPath(path)\n                    }\n                }\n                \"-howtorun\" == arg -> {\n                    if (howtorun != HowToRun.GUESS) {\n                        throw RunnerException(\"-howtorun is already set to ${howtorun.argName}\")\n                    }\n                    val howToRunArg = next()\n                    if (howToRunArg.startsWith(\".\")) {\n"}
{"code": "                        howtorun = HowToRun.SCRIPT\n                        compilerArguments.add(\"-Xdefault-script-extension=$howToRunArg\")\n                    } else {\n                        howtorun = HowToRun.fromArg(howToRunArg)\n                            ?: throw RunnerException(\"invalid argument to the option -howtorun $howToRunArg, valid arguments are: ${HowToRun.validValues}\")\n                    }\n                }\n                \"-expression\" == arg || \"-e\" == arg -> {\n                    if (howtorun != HowToRun.GUESS && howtorun != HowToRun.SCRIPT) {\n                        throw RunnerException(\"expression evaluation is not compatible with -howtorun argument ${howtorun.argName}\")\n                    }\n                    setRunner(ExpressionRunner(next()))\n                    restAsArguments()\n                    break\n                }\n                \"-no-stdlib\" == arg -> {\n                    noStdLib = true\n                    compilerArguments.add(arg)\n           "}
{"code": "     }\n                \"-no-reflect\" == arg -> {\n                    noReflect = true\n                    compilerArguments.add(arg)\n                }\n                arg.startsWith(\"-X\") -> {\n                    compilerArguments.add(arg)\n                }\n                \"-language-version\" == arg -> {\n                    compilerArguments.add(arg)\n                    compilerArguments.add(next())\n                }\n                arg.startsWith(\"-\") -> {\n                    throw RunnerException(\"unknown option: $arg\")\n                }\n                howtorun == HowToRun.JAR || howtorun == HowToRun.GUESS && arg.endsWith(\".jar\") -> {\n                    setRunner(JarRunner(arg))\n                    restAsArguments()\n                    break\n                }\n                howtorun == HowToRun.SCRIPT || howtorun == HowToRun.GUESS && arg.endsWith(\".kts\") -> {\n                    setRunner(ScriptRunner(arg))\n                    restAsArguments()\n                    break\n          "}
{"code": "      }\n                else -> {\n                    val workingDir = File(\".\")\n                    val classFile = File(arg)\n\n                    // Allow running class files with '.class' extension.\n                    // In order to infer its fully qualified name, it should be located in the current working directory or a subdirectory of it\n                    val className =\n                        if (arg.endsWith(\".class\") && classFile.exists() && classFile.canonicalPath.contains(workingDir.canonicalPath)) {\n                            classFile.canonicalFile.toRelativeString(workingDir.canonicalFile)\n                                .removeSuffix(\".class\")\n                                .replace(File.separatorChar, '.')\n                        } else arg\n\n                    setRunner(MainClassRunner(className))\n                    restAsArguments()\n                    break\n                }\n            }\n            i++\n        }\n\n        if (classpath.isEmpty()) {\n          "}
{"code": "  classpath.addPath(\".\")\n        }\n\n        if (!noStdLib) {\n            classpath.addPath(\"$KOTLIN_HOME/lib/kotlin-stdlib.jar\")\n        }\n\n        if (!noReflect) {\n            classpath.addPath(\"$KOTLIN_HOME/lib/kotlin-reflect.jar\")\n        }\n\n        if (runner == null) {\n            setRunner(ReplRunner())\n        }\n\n        if (runner is RunnerWithCompiler && compilerClasspath.isEmpty()) {\n            findCompilerJar(this::class.java, KOTLIN_HOME.resolve(\"lib\")).forEach {\n                compilerClasspath.add(it.absoluteFile.toURI().toURL())\n            }\n        }\n\n        runner!!.run(classpath, compilerArguments, arguments, compilerClasspath)\n    }\n\n    private fun MutableList<URL>.addPath(path: String) {\n        add(File(path).absoluteFile.toURI().toURL())\n    }\n\n    @JvmStatic\n    fun main(args: Array<String>) {\n        try {\n            run(args)\n        }\n        catch (e: RunnerException) {\n            System.err.println(\"error: \" + e.message)\n            exitProcess(1)\n  "}
{"code": "      }\n    }\n\n    private fun printUsageAndExit() {\n        println(\"\"\"kotlin: run Kotlin programs, scripts or REPL.\n\nUsage: kotlin <options> <command> [<arguments>]\nwhere possible options include:\n  -howtorun <value>          How to run the supplied command with arguments, \n                             valid values: ${HowToRun.validValues}\n  -classpath (-cp) <path>    Paths where to find user class files\n  -Dname=value               Set a system JVM property\n  -J<option>                 Pass an option directly to JVM\n  -no-stdlib                 Don't include Kotlin standard library into classpath\n  -no-reflect                Don't include Kotlin reflection implementation into classpath\n  -compiler-path             Kotlin compiler classpath for compiling script or expression or running REPL \n                             If not specified, try to find the compiler in the environment\n  -X<flag>[=value]           Pass -X argument to the compiler\n  -version                   Display Kotli"}
{"code": "n version\n  -help (-h)                 Print a synopsis of options\nand command is interpreted according to the -howtorun option argument \nor, in case of guess, according to the following rules:\n  foo.Bar                    Runs the 'main' function from the class with the given qualified name\n                             (compiler arguments are ignored) \n  app.jar                    Runs the given JAR file as 'java -jar' would do\n                             (compiler arguments are ignored and no Kotlin stdlib is added to the classpath)\n  script.kts                 Compiles and runs the given script, passing <arguments> to it\n  -expression (-e) '2+2'     Evaluates the expression and prints the result, passing <arguments> to it\n  <no command>               Runs Kotlin REPL\narguments are passed to the main function when running class or jar file, and for standard script definitions\nas the 'args' parameter when running script or expression\n\"\"\")\n        exitProcess(0)\n    }\n\n    private fun"}
{"code": " printVersionAndExit() {\n        val version = try {\n            Scanner(File(KOTLIN_HOME, \"build.txt\")).nextLine()\n        }\n        catch (e: FileNotFoundException) {\n            throw RunnerException(\"no build.txt was found at home=$KOTLIN_HOME\")\n        }\n\n        println(\"Kotlin version \" + version + \" (JRE \" + System.getProperty(\"java.runtime.version\") + \")\")\n        exitProcess(0)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cli.common.repl\n\nimport java.io.Reader\nimport java.util.concurrent.locks.ReentrantReadWriteLock\nimport javax.script.*\n\nconst val KOTLIN_SCRIPT_STATE_BINDINGS_KEY = \"kotlin.script.state\"\nconst val KOTLIN_SCRIPT_ENGINE_BINDINGS_KEY = \"kotlin.script.engine\"\n\nabstract class KotlinJsr223JvmScriptEngineBase(protected val myFactory: ScriptEngineFactory) : AbstractScriptEngine(), ScriptEngine, Compilable {\n\n    protected abstract val replCompiler: ReplCompilerWithoutCheck\n    protected abstract val replEvaluator: ReplFullEvaluator\n\n    override fun eval(script: String, context: ScriptContext): Any? = compileAndEval(script, context)\n\n    override fun eval(script: Reader, context: ScriptContext): Any? = compileAndEval(script.readText(), context)\n\n    override fun compile(script: String): CompiledScript = compile(script, getContext())\n\n    override fun compile(script: Reader): CompiledScript = compile(script.readText(), getContext())\n\n    override fun createBindings"}
{"code": "(): Bindings = SimpleBindings().apply { put(KOTLIN_SCRIPT_ENGINE_BINDINGS_KEY, this) }\n\n    override fun getFactory(): ScriptEngineFactory = myFactory\n\n    // the parameter could be used in the future when we decide to keep state completely in the context and solve appropriate problems (now e.g. replCompiler keeps separate state)\n    fun nextCodeLine(context: ScriptContext, code: String) = getCurrentState(context).let { ReplCodeLine(it.getNextLineNo(), it.currentGeneration, code) }\n\n    protected abstract fun createState(lock: ReentrantReadWriteLock = ReentrantReadWriteLock()): IReplStageState<*>\n\n    protected fun getCurrentState(context: ScriptContext) =\n            context.getBindings(ScriptContext.ENGINE_SCOPE)\n                    .getOrPut(KOTLIN_SCRIPT_STATE_BINDINGS_KEY, {\n                        // TODO: check why createBinding is not called on creating default context, so the engine is not set\n                        context.getBindings(ScriptContext.ENGINE_SCOPE).put(KOTLIN_S"}
{"code": "CRIPT_ENGINE_BINDINGS_KEY, this@KotlinJsr223JvmScriptEngineBase)\n                        createState()\n                    }) as IReplStageState<*>\n\n    open fun getInvokeWrapper(context: ScriptContext): InvokeWrapper? = null\n\n    open fun overrideScriptArgs(context: ScriptContext): ScriptArgsWithTypes? = null\n\n    open fun compileAndEval(script: String, context: ScriptContext): Any? {\n        val codeLine = nextCodeLine(context, script)\n        val state = getCurrentState(context)\n        return asJsr223EvalResult {\n            replEvaluator.compileAndEval(state, codeLine, overrideScriptArgs(context), getInvokeWrapper(context))\n        }\n    }\n\n    open fun compile(script: String, context: ScriptContext): CompiledScript {\n        val codeLine = nextCodeLine(context, script)\n        val state = getCurrentState(context)\n\n        val result = replCompiler.compile(state, codeLine)\n        val compiled = when (result) {\n            is ReplCompileResult.Error -> throw ScriptException(\"Error"}
{"code": "${result.locationString()}: ${result.message}\")\n            is ReplCompileResult.Incomplete -> throw ScriptException(\"Error: incomplete code; ${result.message}\")\n            is ReplCompileResult.CompiledClasses -> result\n        }\n        return CompiledKotlinScript(this, codeLine, compiled)\n    }\n\n    open fun eval(compiledScript: CompiledKotlinScript, context: ScriptContext): Any? {\n        val state = getCurrentState(context)\n        return asJsr223EvalResult {\n            replEvaluator.eval(state, compiledScript.compiledData, overrideScriptArgs(context), getInvokeWrapper(context))\n        }\n    }\n\n    private fun asJsr223EvalResult(body: () -> ReplEvalResult): Any? {\n        val result = try {\n            body()\n        } catch (e: Exception) {\n            throw ScriptException(e)\n        }\n\n        return when (result) {\n            is ReplEvalResult.ValueResult -> result.value\n            is ReplEvalResult.UnitResult -> null\n            is ReplEvalResult.Error ->\n                "}
{"code": "when {\n                    result is ReplEvalResult.Error.Runtime && result.cause != null ->\n                        throw ScriptException((result.cause as? java.lang.Exception) ?: RuntimeException(result.cause))\n                    result is ReplEvalResult.Error.CompileTime && result.location != null ->\n                        throw ScriptException(result.message, result.location.path, result.location.line, result.location.column)\n                    else -> throw ScriptException(result.message)\n                }\n            is ReplEvalResult.Incomplete -> throw ScriptException(\"Error: incomplete code. ${result.message}\")\n            is ReplEvalResult.HistoryMismatch -> throw ScriptException(\"Repl history mismatch at line: ${result.lineNo}\")\n        }\n    }\n\n    class CompiledKotlinScript(val engine: KotlinJsr223JvmScriptEngineBase, val codeLine: ReplCodeLine, val compiledData: ReplCompileResult.CompiledClasses) : CompiledScript() {\n        override fun eval(context: ScriptContext): A"}
{"code": "ny? = engine.eval(this, context)\n        override fun getEngine(): ScriptEngine = engine\n    }\n}\n\nprivate fun ReplCompileResult.Error.locationString() =\n        if (location == null) \"\"\n        else \" at ${location.line}:${location.column}\"\n"}
{"code": "val x = <expr>1 + 2</expr>"}
{"code": "fun f(t: (v: Int) -> Unit) {\n    1.run(t)\n}\n\nfun main() {\n    f { i ->\n\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.builtins.StandardNames.DEFAULT_VALUE_PARAMETER\nimport org.jetbrains.kotlin.builtins.StandardNames.ENUM_ENTRIES\nimport org.jetbrains.kotlin.builtins.StandardNames.ENUM_VALUES\nimport org.jetbrains.kotlin.builtins.StandardNames.ENUM_VALUE_OF\nimport org.jetbrains.kotlin.descriptors.Modality\nimport org.jetbrains.kotlin.descriptors.Visibilities\nimport org.jetbrains.kotlin.fakeElement\nimport org.jetbrains.kotlin.fir.declarations.FirDeclarationOrigin\nimport org.jetbrains.kotlin.fir.declarations.FirDeclarationStatus\nimport org.jetbrains.kotlin.fir.declarations.builder.FirRegularClassBuilder\nimport org.jetbrains.kotlin.fir.declarations.builder.buildProperty\nimport org.jetbrains.kotlin.fir.declarations.builder.buildSimpleFunction\nimport org.jetbrains.kotlin.fir.declarations.builder.buildValueParameter\nimport org.jetbrains.kotlin.fir.declarations.impl.FirDeclarationStatusImpl\nimport "}
{"code": "org.jetbrains.kotlin.fir.declarations.impl.FirDefaultPropertyGetter\nimport org.jetbrains.kotlin.fir.declarations.impl.FirResolvedDeclarationStatusImpl\nimport org.jetbrains.kotlin.fir.expressions.builder.buildEmptyExpressionBlock\nimport org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirValueParameterSymbol\nimport org.jetbrains.kotlin.fir.types.ConeTypeProjection\nimport org.jetbrains.kotlin.fir.types.builder.buildResolvedTypeRef\nimport org.jetbrains.kotlin.fir.types.impl.ConeClassLikeTypeImpl\nimport org.jetbrains.kotlin.fir.types.toLookupTag\nimport org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.StandardClassIds\n\nfun FirRegularClassBuilder.generateValuesFunction(\n    moduleData: FirModuleData,\n    packageFqName: FqName,\n    classFqName: FqName,\n    makeExpect: Boolean = false,\n    origin: FirDeclarationOrig"}
{"code": "in = FirDeclarationOrigin.Source\n) {\n    val sourceElement = source?.fakeElement(KtFakeSourceElementKind.EnumGeneratedDeclaration)\n    declarations += buildSimpleFunction {\n        source = sourceElement\n        this.origin = origin\n        this.moduleData = moduleData\n        val returnTypeRef = buildResolvedTypeRef {\n            source = sourceElement\n            type = ConeClassLikeTypeImpl(\n                StandardClassIds.Array.toLookupTag(),\n                arrayOf(\n                    ConeClassLikeTypeImpl(\n                        this@generateValuesFunction.symbol.toLookupTag(),\n                        ConeTypeProjection.EMPTY_ARRAY,\n                        isNullable = false\n                    )\n                ),\n                isNullable = false\n            )\n        }\n        this.returnTypeRef = returnTypeRef\n        name = ENUM_VALUES\n        this.status = createStatus(this@generateValuesFunction.status).apply {\n            isStatic = true\n            isExpect = makeExp"}
{"code": "ect\n        }\n        symbol = FirNamedFunctionSymbol(CallableId(packageFqName, classFqName, ENUM_VALUES))\n        resolvePhase = this@generateValuesFunction.resolvePhase\n        body = buildEmptyExpressionBlock().also {\n            it.replaceConeTypeOrNull(returnTypeRef.type)\n        }\n    }.apply {\n        containingClassForStaticMemberAttr = this@generateValuesFunction.symbol.toLookupTag()\n    }\n}\n\nfun FirRegularClassBuilder.generateValueOfFunction(\n    moduleData: FirModuleData,\n    packageFqName: FqName,\n    classFqName: FqName,\n    makeExpect: Boolean = false,\n    origin: FirDeclarationOrigin = FirDeclarationOrigin.Source\n) {\n    val sourceElement = source?.fakeElement(KtFakeSourceElementKind.EnumGeneratedDeclaration)\n    declarations += buildSimpleFunction {\n        source = sourceElement\n        this.origin = origin\n        this.moduleData = moduleData\n        val returnTypeRef = buildResolvedTypeRef {\n            source = sourceElement\n            type = ConeClassLikeTypeImpl("}
{"code": "\n                this@generateValueOfFunction.symbol.toLookupTag(),\n                emptyArray(),\n                isNullable = false\n            )\n        }\n        this.returnTypeRef = returnTypeRef\n        name = ENUM_VALUE_OF\n\n        status = createStatus(this@generateValueOfFunction.status).apply {\n            isStatic = true\n            isExpect = makeExpect\n        }\n        symbol = FirNamedFunctionSymbol(CallableId(packageFqName, classFqName, ENUM_VALUE_OF))\n        valueParameters += buildValueParameter vp@{\n            source = sourceElement\n            containingFunctionSymbol = this@buildSimpleFunction.symbol\n            this.origin = origin\n            this.moduleData = moduleData\n            this.returnTypeRef = buildResolvedTypeRef {\n                source = sourceElement\n                type = ConeClassLikeTypeImpl(\n                    StandardClassIds.String.toLookupTag(),\n                    emptyArray(),\n                    isNullable = false\n                )\n     "}
{"code": "       }\n            name = DEFAULT_VALUE_PARAMETER\n            this@vp.symbol = FirValueParameterSymbol(DEFAULT_VALUE_PARAMETER)\n            isCrossinline = false\n            isNoinline = false\n            isVararg = false\n            resolvePhase = this@generateValueOfFunction.resolvePhase\n        }\n        resolvePhase = this@generateValueOfFunction.resolvePhase\n        body = buildEmptyExpressionBlock().also {\n            it.replaceConeTypeOrNull(returnTypeRef.type)\n        }\n    }.apply {\n        containingClassForStaticMemberAttr = this@generateValueOfFunction.symbol.toLookupTag()\n    }\n}\n\nfun FirRegularClassBuilder.generateEntriesGetter(\n    moduleData: FirModuleData,\n    packageFqName: FqName,\n    classFqName: FqName,\n    makeExpect: Boolean = false,\n    origin: FirDeclarationOrigin = FirDeclarationOrigin.Source\n) {\n    val sourceElement = source?.fakeElement(KtFakeSourceElementKind.EnumGeneratedDeclaration)\n    declarations += buildProperty {\n        source = sourceElement\n   "}
{"code": "     isVar = false\n        isLocal = false\n        this.origin = origin\n        this.moduleData = moduleData\n        returnTypeRef = buildResolvedTypeRef {\n            source = sourceElement\n            type = ConeClassLikeTypeImpl(\n                StandardClassIds.EnumEntries.toLookupTag(),\n                arrayOf(\n                    ConeClassLikeTypeImpl(this@generateEntriesGetter.symbol.toLookupTag(), ConeTypeProjection.EMPTY_ARRAY, isNullable = false)\n                ),\n                isNullable = false\n            )\n        }\n        name = ENUM_ENTRIES\n        this.status = createStatus(this@generateEntriesGetter.status).apply {\n            isStatic = true\n            isExpect = makeExpect\n        }\n        symbol = FirPropertySymbol(CallableId(packageFqName, classFqName, ENUM_ENTRIES))\n        resolvePhase = this@generateEntriesGetter.resolvePhase\n        getter = FirDefaultPropertyGetter(\n            sourceElement?.fakeElement(KtFakeSourceElementKind.EnumGeneratedDeclaration)"}
{"code": ",\n            moduleData, origin, returnTypeRef.copyWithNewSourceKind(KtFakeSourceElementKind.EnumGeneratedDeclaration),\n            Visibilities.Public, symbol, resolvePhase = this@generateEntriesGetter.resolvePhase\n        ).apply {\n            this.status = createStatus(this@generateEntriesGetter.status).apply {\n                isStatic = true\n            }\n        }\n    }.apply {\n        containingClassForStaticMemberAttr = this@generateEntriesGetter.symbol.toLookupTag()\n    }\n}\n\nprivate fun createStatus(parentStatus: FirDeclarationStatus): FirDeclarationStatusImpl {\n    val parentEffectiveVisibility = (parentStatus as? FirResolvedDeclarationStatusImpl)?.effectiveVisibility\n    return if (parentEffectiveVisibility != null) {\n        FirResolvedDeclarationStatusImpl(Visibilities.Public, Modality.FINAL, parentEffectiveVisibility)\n    } else {\n        FirDeclarationStatusImpl(Visibilities.Public, Modality.FINAL)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.standalone.konan.fir.test.cases.session.builder\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisApiInternals\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeTokenProvider\nimport org.jetbrains.kotlin.analysis.api.standalone.KtAlwaysAccessibleLifetimeTokenProvider\nimport org.jetbrains.kotlin.analysis.api.standalone.buildStandaloneAnalysisAPISession\nimport org.jetbrains.kotlin.analysis.api.standalone.fir.test.cases.session.builder.assertIsCallOf\nimport org.jetbrains.kotlin.analysis.project.structure.KtSourceModule\nimport org.jetbrains.kotlin.analysis.project.structure.builder.buildKtLibraryModule\nimport org.jetbrains.kotlin.analysis.project.structure.builder.buildKtSourceModule\nimport org.jetbrains.kotlin.konan.target.HostManager\nimport org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.platform.konan.NativePlatforms\nimport org.jetbrains.k"}
{"code": "otlin.psi.KtCallExpression\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.psi.psiUtil.findDescendantOfType\nimport org.junit.jupiter.api.Test\n\n@OptIn(KtAnalysisApiInternals::class)\nclass NativeStandaloneSessionBuilderTest {\n    @Test\n    fun testResolveAgainstCommonKlib() {\n        lateinit var sourceModule: KtSourceModule\n        val currentArchitectureTarget = HostManager.host\n        val nativePlatform = NativePlatforms.nativePlatformByTargets(listOf(currentArchitectureTarget))\n        val session = buildStandaloneAnalysisAPISession {\n            registerProjectService(KtLifetimeTokenProvider::class.java, KtAlwaysAccessibleLifetimeTokenProvider())\n\n            buildKtModuleProvider {\n                platform = nativePlatform\n                val kLib = addModule(\n                    buildKtLibraryModule {\n                        val compiledKLibRoot = compileToNativeKLib(testDataPath(\"resolveAgainstNativeKLib/klibSrc\"))\n                        addBinaryRoot(compile"}
{"code": "dKLibRoot)\n                        platform = nativePlatform\n                        libraryName = \"klib\"\n                    }\n                )\n                sourceModule = addModule(\n                    buildKtSourceModule {\n                        addSourceRoot(testDataPath(\"resolveAgainstNativeKLib/src\"))\n                        addRegularDependency(kLib)\n                        platform = nativePlatform\n                        moduleName = \"source\"\n                    }\n                )\n            }\n        }\n        val ktFile = session.modulesWithFiles.getValue(sourceModule).single() as KtFile\n\n        val ktCallExpression = ktFile.findDescendantOfType<KtCallExpression>()!!\n        ktCallExpression.assertIsCallOf(CallableId(FqName(\"nativeKLib\"), Name.identifier(\"nativeKLibFunction\")))\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.cfg\n\nimport org.jetbrains.kotlin.cfg.pseudocode.PseudoValue\nimport org.jetbrains.kotlin.cfg.pseudocode.Pseudocode\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.eval.*\nimport org.jetbrains.kotlin.contracts.description.EventOccurrencesRange\nimport org.jetbrains.kotlin.descriptors.ValueParameterDescriptor\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\nimport org.jetbrains.kotlin.resolve.constants.CompileTimeConstant\nimport org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValue\n\nabstract class ControlFlowBuilderAdapter : ControlFlowBuilder {\n\n    protected abstract val delegateBuilder: ControlFlowBuilder\n\n    override fun loadUnit(expression: KtExpression) {\n        delegateBuilder.loadUnit(expression)\n    }\n\n    override fun loadConstant(expression: KtExpression, constant: CompileTimeConstant<*>?): InstructionWithValue =\n        delegateBuilder.loadConstant(expression, constant)\n\n    override fun"}
{"code": " createAnonymousObject(expression: KtObjectLiteralExpression): InstructionWithValue =\n        delegateBuilder.createAnonymousObject(expression)\n\n    override fun createLambda(expression: KtFunction): InstructionWithValue = delegateBuilder.createLambda(expression)\n\n    override fun loadStringTemplate(expression: KtStringTemplateExpression, inputValues: List<PseudoValue>): InstructionWithValue =\n        delegateBuilder.loadStringTemplate(expression, inputValues)\n\n    override fun magic(\n        instructionElement: KtElement,\n        valueElement: KtElement?,\n        inputValues: List<PseudoValue>,\n        kind: MagicKind\n    ): MagicInstruction = delegateBuilder.magic(instructionElement, valueElement, inputValues, kind)\n\n    override fun merge(expression: KtExpression, inputValues: List<PseudoValue>): MergeInstruction =\n        delegateBuilder.merge(expression, inputValues)\n\n    override fun readVariable(\n        expression: KtExpression,\n        resolvedCall: ResolvedCall<*>,\n        re"}
{"code": "ceiverValues: Map<PseudoValue, ReceiverValue>\n    ): ReadValueInstruction =\n        delegateBuilder.readVariable(expression, resolvedCall, receiverValues)\n\n    override fun call(\n        valueElement: KtElement,\n        resolvedCall: ResolvedCall<*>,\n        receiverValues: Map<PseudoValue, ReceiverValue>,\n        arguments: Map<PseudoValue, ValueParameterDescriptor>\n    ): CallInstruction =\n        delegateBuilder.call(valueElement, resolvedCall, receiverValues, arguments)\n\n    override fun predefinedOperation(\n        expression: KtExpression,\n        operation: ControlFlowBuilder.PredefinedOperation,\n        inputValues: List<PseudoValue>\n    ): OperationInstruction = delegateBuilder.predefinedOperation(expression, operation, inputValues)\n\n    override fun createUnboundLabel(): Label = delegateBuilder.createUnboundLabel()\n\n    override fun createUnboundLabel(name: String): Label = delegateBuilder.createUnboundLabel(name)\n\n    override fun bindLabel(label: Label) {\n        delegateBu"}
{"code": "ilder.bindLabel(label)\n    }\n\n    override fun jump(label: Label, element: KtElement) {\n        delegateBuilder.jump(label, element)\n    }\n\n    override fun jumpOnFalse(label: Label, element: KtElement, conditionValue: PseudoValue?) {\n        delegateBuilder.jumpOnFalse(label, element, conditionValue)\n    }\n\n    override fun jumpOnTrue(label: Label, element: KtElement, conditionValue: PseudoValue?) {\n        delegateBuilder.jumpOnTrue(label, element, conditionValue)\n    }\n\n    override fun nondeterministicJump(label: Label, element: KtElement, inputValue: PseudoValue?) {\n        delegateBuilder.nondeterministicJump(label, element, inputValue)\n    }\n\n    override fun nondeterministicJump(label: List<Label>, element: KtElement) {\n        delegateBuilder.nondeterministicJump(label, element)\n    }\n\n    override fun jumpToError(element: KtElement) {\n        delegateBuilder.jumpToError(element)\n    }\n\n    override fun throwException(throwExpression: KtThrowExpression, thrownValue: PseudoValu"}
{"code": "e) {\n        delegateBuilder.throwException(throwExpression, thrownValue)\n    }\n\n    override fun getSubroutineExitPoint(labelElement: KtElement): Label? = delegateBuilder.getSubroutineExitPoint(labelElement)\n\n    override fun getLoopConditionEntryPoint(loop: KtLoopExpression): Label? = delegateBuilder.getLoopConditionEntryPoint(loop)\n\n    override fun getLoopExitPoint(loop: KtLoopExpression): Label? = delegateBuilder.getLoopExitPoint(loop)\n\n    override fun enterLoop(expression: KtLoopExpression): LoopInfo = delegateBuilder.enterLoop(expression)\n\n    override fun enterLoopBody(expression: KtLoopExpression) {\n        delegateBuilder.enterLoopBody(expression)\n    }\n\n    override fun exitLoopBody(expression: KtLoopExpression) {\n        delegateBuilder.exitLoopBody(expression)\n    }\n\n    override val currentLoop: KtLoopExpression?\n        get() = delegateBuilder.currentLoop\n\n    override fun enterTryFinally(trigger: GenerationTrigger) {\n        delegateBuilder.enterTryFinally(trigger)\n   "}
{"code": " }\n\n    override fun exitTryFinally() {\n        delegateBuilder.exitTryFinally()\n    }\n\n    override fun enterSubroutine(subroutine: KtElement, eventOccurrencesRange: EventOccurrencesRange?) {\n        delegateBuilder.enterSubroutine(subroutine, eventOccurrencesRange)\n    }\n\n    override fun exitSubroutine(subroutine: KtElement, eventOccurrencesRange: EventOccurrencesRange?): Pseudocode =\n        delegateBuilder.exitSubroutine(subroutine, eventOccurrencesRange)\n\n    override val currentSubroutine: KtElement\n        get() = delegateBuilder.currentSubroutine\n\n    override val returnSubroutine: KtElement\n        get() = delegateBuilder.returnSubroutine\n\n    override fun returnValue(returnExpression: KtExpression, returnValue: PseudoValue, subroutine: KtElement) {\n        delegateBuilder.returnValue(returnExpression, returnValue, subroutine)\n    }\n\n    override fun returnNoValue(returnExpression: KtReturnExpression, subroutine: KtElement) {\n        delegateBuilder.returnNoValue(returnExpres"}
{"code": "sion, subroutine)\n    }\n\n    override fun read(element: KtElement, target: AccessTarget, receiverValues: Map<PseudoValue, ReceiverValue>) =\n        delegateBuilder.read(element, target, receiverValues)\n\n    override fun write(\n        assignment: KtElement,\n        lValue: KtElement,\n        rValue: PseudoValue,\n        target: AccessTarget,\n        receiverValues: Map<PseudoValue, ReceiverValue>\n    ) {\n        delegateBuilder.write(assignment, lValue, rValue, target, receiverValues)\n    }\n\n    override fun declareParameter(parameter: KtParameter) {\n        delegateBuilder.declareParameter(parameter)\n    }\n\n    override fun declareVariable(property: KtVariableDeclaration) {\n        delegateBuilder.declareVariable(property)\n    }\n\n    override fun declareFunction(subroutine: KtElement, pseudocode: Pseudocode) {\n        delegateBuilder.declareFunction(subroutine, pseudocode)\n    }\n\n    override fun declareInlinedFunction(subroutine: KtElement, pseudocode: Pseudocode, eventOccurrencesRan"}
{"code": "ge: EventOccurrencesRange) {\n        delegateBuilder.declareInlinedFunction(subroutine, pseudocode, eventOccurrencesRange)\n    }\n\n    override fun declareEntryOrObject(entryOrObject: KtClassOrObject) {\n        delegateBuilder.declareEntryOrObject(entryOrObject)\n    }\n\n    override fun repeatPseudocode(startLabel: Label, finishLabel: Label) {\n        delegateBuilder.repeatPseudocode(startLabel, finishLabel)\n    }\n\n    override fun mark(element: KtElement) {\n        delegateBuilder.mark(element)\n    }\n\n    override fun getBoundValue(element: KtElement?): PseudoValue? = delegateBuilder.getBoundValue(element)\n\n    override fun bindValue(value: PseudoValue, element: KtElement) {\n        delegateBuilder.bindValue(value, element)\n    }\n\n    override fun newValue(element: KtElement?): PseudoValue = delegateBuilder.newValue(element)\n\n    override fun enterBlockScope(block: KtElement) {\n        delegateBuilder.enterBlockScope(block)\n    }\n\n    override fun exitBlockScope(block: KtElement) {\n    "}
{"code": "    delegateBuilder.exitBlockScope(block)\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.diagnostic.compiler.based\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.compiler.based.AbstractLowLevelCompilerBasedTest\nimport org.jetbrains.kotlin.test.Constructor\nimport org.jetbrains.kotlin.test.InTextDirectivesUtils\nimport org.jetbrains.kotlin.test.TargetBackend\nimport org.jetbrains.kotlin.test.TestConfiguration\nimport org.jetbrains.kotlin.test.backend.BlackBoxCodegenSuppressor\nimport org.jetbrains.kotlin.test.builders.TestConfigurationBuilder\nimport org.jetbrains.kotlin.test.builders.firHandlersStep\nimport org.jetbrains.kotlin.test.frontend.fir.handlers.FirCfgDumpHandler\nimport org.jetbrains.kotlin.test.frontend.fir.handlers.FirDiagnosticsHandler\nimport org.jetbrains.kotlin.test.frontend.fir.handlers.FirDumpHandler\nimport org.jetbrains.kotlin.test.frontend.fir.handlers.FirResolvedTypesVerifier\nimport org.jetbrains.kotlin.test.frontend.fir.handlers.FirScopeDumpHandler\nimport org.jetbrains.kotlin.test.model.AfterAn"}
{"code": "alysisChecker\nimport org.jetbrains.kotlin.test.runners.codegen.baseFirBlackBoxCodegenTestDirectivesConfiguration\nimport org.jetbrains.kotlin.test.runners.codegen.configureModernJavaWhenNeeded\nimport org.jetbrains.kotlin.test.services.configuration.CommonEnvironmentConfigurator\nimport org.jetbrains.kotlin.test.services.configuration.JvmEnvironmentConfigurator\nimport org.jetbrains.kotlin.test.services.sourceProviders.AdditionalDiagnosticsSourceFilesProvider\nimport org.jetbrains.kotlin.test.services.sourceProviders.CodegenHelpersSourceFilesProvider\nimport org.jetbrains.kotlin.test.services.sourceProviders.CoroutineHelpersSourceFilesProvider\nimport java.io.File\n\n\nabstract class AbstractLLFirBlackBoxCodegenBasedTestBase : AbstractLowLevelCompilerBasedTest() {\n    abstract fun facade(): Constructor<LowLevelFirFrontendFacade>\n    abstract fun facadeSpecificSuppressor(): Constructor<AfterAnalysisChecker>\n\n    override fun configureTest(builder: TestConfigurationBuilder) {\n        with(builder)"}
{"code": " {\n            facadeStep(facade())\n            baseFirBlackBoxCodegenTestDirectivesConfiguration()\n            configureModernJavaWhenNeeded()\n            useConfigurators(\n                ::CommonEnvironmentConfigurator,\n                ::JvmEnvironmentConfigurator,\n            )\n\n            useAdditionalSourceProviders(\n                ::AdditionalDiagnosticsSourceFilesProvider,\n                ::CoroutineHelpersSourceFilesProvider,\n                ::CodegenHelpersSourceFilesProvider,\n            )\n\n            firHandlersStep {\n                useHandlers(\n                    ::FirDiagnosticsHandler,\n                    ::FirDumpHandler,\n                    ::FirScopeDumpHandler,\n                    ::FirCfgDumpHandler,\n                    ::FirResolvedTypesVerifier,\n                )\n            }\n\n            useAfterAnalysisCheckers(::BlackBoxCodegenSuppressor, facadeSpecificSuppressor())\n        }\n    }\n\n    override fun shouldSkipTest(filePath: String, configuration: TestConf"}
{"code": "iguration): Boolean {\n        val testDataFile = File(filePath)\n        val targetBackend = TargetBackend.JVM_IR\n        if (!InTextDirectivesUtils.isCompatibleTarget(targetBackend, testDataFile)) return true\n\n        return InTextDirectivesUtils.isIgnoredTarget(\n            targetBackend,\n            testDataFile,\n            true,\n            InTextDirectivesUtils.IGNORE_BACKEND_DIRECTIVE_PREFIX,\n            InTextDirectivesUtils.IGNORE_BACKEND_K2_DIRECTIVE_PREFIX,\n        )\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.base.annotations\n\nimport org.jetbrains.kotlin.analysis.api.renderer.base.annotations.renderers.KtAnnotationArgumentsRenderer\nimport org.jetbrains.kotlin.analysis.api.renderer.base.annotations.renderers.KtAnnotationListRenderer\nimport org.jetbrains.kotlin.analysis.api.renderer.base.annotations.renderers.KtAnnotationQualifierRenderer\nimport org.jetbrains.kotlin.analysis.api.renderer.base.annotations.renderers.KtAnnotationUseSiteTargetRenderer\n\npublic object KtAnnotationRendererForSource {\n    public val WITH_QUALIFIED_NAMES: KtAnnotationRenderer = KtAnnotationRenderer {\n        annotationListRenderer = KtAnnotationListRenderer.FOR_SOURCE\n        annotationFilter = KtRendererAnnotationsFilter.NO_NULLABILITY and KtRendererAnnotationsFilter.NO_PARAMETER_NAME\n        annotationsQualifiedNameRenderer = KtAnnotationQualifierRenderer.WITH_QUALIFIED_NAMES\n        annotationUseSiteTargetRenderer = KtAnnotationUseSiteTargetRenderer.WITH_NON_DEFA"}
{"code": "ULT_USE_SITE\n        annotationArgumentsRenderer = KtAnnotationArgumentsRenderer.IF_ANY\n    }\n\n    public val WITH_SHORT_NAMES: KtAnnotationRenderer = WITH_QUALIFIED_NAMES.with {\n        annotationsQualifiedNameRenderer = KtAnnotationQualifierRenderer.WITH_SHORT_NAMES\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.daemon\n\nimport org.jetbrains.kotlin.daemon.common.DummyProfiler\nimport org.jetbrains.kotlin.daemon.common.Profiler\nimport org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache\nimport org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCompilationComponents\nimport org.jetbrains.kotlin.modules.TargetId\n\nclass RemoteIncrementalCompilationComponentsClient(\n    @Suppress(\"DEPRECATION\") val facade: org.jetbrains.kotlin.daemon.common.CompilerCallbackServicesFacade,\n    val profiler: Profiler = DummyProfiler()\n) : IncrementalCompilationComponents {\n    override fun getIncrementalCache(target: TargetId): IncrementalCache = RemoteIncrementalCacheClient(facade, target, profiler)\n}\n"}
{"code": "class Foo {\n    class Bar\n}\n\nfun foo() {\n    Foo.<expr>Bar</expr>\n}"}
{"code": "abstract class Foo {\n    abstract var id: Int\n        protected set\n}\n\nclass Bar : Foo() {\n    override var id: Int = 1\n    public set\n}\n\nfun test() {\n    val bar = Bar()\n    bar.id = 1\n}\n"}
{"code": "// FILE: Producer.java\n\nimport java.util.*;\nimport org.jetbrains.annotations.*;\n\npublic class Producer {\n    @NotNull\n    public static ArrayList foo() { return null; }\n}\n\n// FILE: test.kt\n\ninterface StringSet : MutableSet<String>\n\nfun foo(arg: Boolean) {\n    val x = Producer.foo()\n    if (x is Set<*>) {\n        val y = <!DEBUG_INFO_EXPRESSION_TYPE(\"java.util.ArrayList<kotlin.Any..kotlin.Any?!>..java.util.ArrayList<*> & kotlin.collections.Set<*> & java.util.ArrayList<kotlin.Any..kotlin.Any?!>..java.util.ArrayList<*>\")!>x<!>\n    }\n    if (x is MutableSet<*>) {\n        val y = <!DEBUG_INFO_EXPRESSION_TYPE(\"java.util.ArrayList<kotlin.Any..kotlin.Any?!>..java.util.ArrayList<*> & kotlin.collections.MutableSet<*> & java.util.ArrayList<kotlin.Any..kotlin.Any?!>..java.util.ArrayList<*>\")!>x<!>\n    }\n    if (x is StringSet) {\n        x.add(\"\")\n        x.add(1)\n        x.add(null)\n        x.iterator().next().length\n    }\n}\n"}
{"code": "package test\n\nopen class Base(i: Int)\n\nval property = 10\n\nclass Child : Base {\n    constructor(): super(<expr>property</expr>)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.java.scopes\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.FirDeclarationOrigin\nimport org.jetbrains.kotlin.fir.dispatchReceiverClassLookupTagOrNull\nimport org.jetbrains.kotlin.fir.java.scopes.ClassicBuiltinSpecialProperties.getBuiltinSpecialPropertyGetterName\nimport org.jetbrains.kotlin.fir.resolve.toSymbol\nimport org.jetbrains.kotlin.fir.scopes.*\nimport org.jetbrains.kotlin.fir.scopes.jvm.computeJvmSignature\nimport org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol\nimport org.jetbrains.kotlin.load.java.BuiltinSpecialProperties\nimport org.jetbrains.kotlin.load.java.SpecialGenericSignatures\nimport org.jetbrains.kotlin.load.java.SpecialGenericSignatures.Companion.ERASED_VALUE_PARAMETERS_SHORT_NAMES\nimport org.jetbrains.kotlin.load.java.SpecialGenericSignatures.Companion.ERASED_"}
{"code": "VALUE_PARAMETERS_SIGNATURES\nimport org.jetbrains.kotlin.load.java.SpecialGenericSignatures.Companion.REMOVE_AT_NAME_AND_SIGNATURE\nimport org.jetbrains.kotlin.load.java.SpecialGenericSignatures.Companion.SIGNATURE_TO_JVM_REPRESENTATION_NAME\nimport org.jetbrains.kotlin.name.Name\n\nfun FirCallableSymbol<*>.doesOverrideBuiltinWithDifferentJvmName(containingScope: FirTypeScope, session: FirSession): Boolean {\n    return getOverriddenBuiltinWithDifferentJvmName(containingScope, session) != null\n}\n\nfun <T : FirCallableSymbol<*>> T.getOverriddenBuiltinWithDifferentJvmName(containingScope: FirTypeScope, session: FirSession): T? {\n    if (\n        name !in SpecialGenericSignatures.ORIGINAL_SHORT_NAMES && name !in BuiltinSpecialProperties.SPECIAL_SHORT_NAMES\n    ) return null\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return when (this) {\n        is FirNamedFunctionSymbol -> firstOverriddenFunction(containingScope) {\n            BuiltinMethodsWithDifferentJvmName.isBuiltinFunctionWithDifferentNameInJvm("}
{"code": "it, session)\n        } as T?\n\n        is FirPropertySymbol -> ClassicBuiltinSpecialProperties.findBuiltinSpecialPropertyFqName(this, containingScope) as T?\n\n        else -> null\n    }\n}\n\nfun FirCallableSymbol<*>.getJvmMethodNameIfSpecial(containingScope: FirTypeScope, session: FirSession): Name? {\n    val overriddenBuiltin = getOverriddenBuiltinWithDifferentJvmName(containingScope, session)\n        ?: return null\n    val name = when (overriddenBuiltin) {\n        is FirPropertySymbol -> overriddenBuiltin.getBuiltinSpecialPropertyGetterName(containingScope)\n        is FirNamedFunctionSymbol -> BuiltinMethodsWithDifferentJvmName.getJvmName(overriddenBuiltin)?.asString()\n        else -> null\n    } ?: return null\n    return Name.identifier(name)\n}\n\n\nobject BuiltinMethodsWithSpecialGenericSignature {\n    private val FirNamedFunctionSymbol.hasErasedValueParametersInJava: Boolean\n        get() = fir.computeJvmSignature() in ERASED_VALUE_PARAMETERS_SIGNATURES\n\n    @JvmStatic\n    fun getOverridd"}
{"code": "enBuiltinFunctionWithErasedValueParametersInJava(\n        functionSymbol: FirNamedFunctionSymbol,\n        containingScope: FirTypeScope\n    ): FirNamedFunctionSymbol? {\n        if (!functionSymbol.name.sameAsBuiltinMethodWithErasedValueParameters) return null\n        return functionSymbol.firstOverriddenFunction(containingScope) { it.hasErasedValueParametersInJava }\n    }\n\n    val Name.sameAsBuiltinMethodWithErasedValueParameters: Boolean\n        get() = this in ERASED_VALUE_PARAMETERS_SHORT_NAMES\n}\n\nobject BuiltinMethodsWithDifferentJvmName {\n    fun getJvmName(functionSymbol: FirNamedFunctionSymbol): Name? {\n        return SIGNATURE_TO_JVM_REPRESENTATION_NAME[functionSymbol.fir.computeJvmSignature() ?: return null]\n    }\n\n    fun isBuiltinFunctionWithDifferentNameInJvm(functionSymbol: FirNamedFunctionSymbol, session: FirSession): Boolean {\n        return functionSymbol.isFromBuiltinClass(session) && SIGNATURE_TO_JVM_REPRESENTATION_NAME.containsKey(functionSymbol.fir.computeJvmSignatu"}
{"code": "re())\n    }\n\n    val FirNamedFunctionSymbol.isRemoveAtByIndex: Boolean\n        get() = name.asString() == \"removeAt\" && fir.computeJvmSignature() == REMOVE_AT_NAME_AND_SIGNATURE.signature\n}\n\nobject ClassicBuiltinSpecialProperties {\n    fun FirCallableSymbol<*>.getBuiltinSpecialPropertyGetterName(containingScope: FirTypeScope): String? {\n        val overridden = findBuiltinSpecialPropertyFqName(this, containingScope) ?: return null\n        return BuiltinSpecialProperties.PROPERTY_FQ_NAME_TO_JVM_GETTER_NAME_MAP[overridden.callableId.asSingleFqName()]?.asString()\n    }\n\n    fun findBuiltinSpecialPropertyFqName(symbol: FirCallableSymbol<*>, containingScope: FirTypeScope): FirCallableSymbol<*>? {\n        if (symbol.name !in BuiltinSpecialProperties.SPECIAL_SHORT_NAMES) return null\n\n        return symbol.hasBuiltinSpecialPropertyFqNameImpl(containingScope)\n    }\n\n    private fun FirCallableSymbol<*>.hasBuiltinSpecialPropertyFqNameImpl(containingScope: FirTypeScope): FirCallableSymbol<*>? {\n "}
{"code": "       if (callableId.asSingleFqName() in BuiltinSpecialProperties.SPECIAL_FQ_NAMES && valueParametersAreEmpty()) return this\n        // if (!KotlinBuiltIns.isBuiltIn(this)) return false\n        var result: FirCallableSymbol<*>? = null\n\n        fun process(overridden: FirCallableSymbol<*>, scope: FirTypeScope): ProcessorAction {\n            val foundSymbol = findBuiltinSpecialPropertyFqName(overridden, scope)\n            return if (foundSymbol != null) {\n                result = foundSymbol\n                ProcessorAction.STOP\n            } else {\n                ProcessorAction.NEXT\n            }\n        }\n\n        when (this) {\n            is FirNamedFunctionSymbol -> containingScope.processDirectOverriddenFunctionsWithBaseScope(this) { overridden, scope ->\n                process(overridden, scope)\n            }\n\n            is FirPropertySymbol -> containingScope.processDirectOverriddenPropertiesWithBaseScope(this) { overridden, scope ->\n                process(overridden, scope)\n "}
{"code": "           }\n        }\n\n        return result\n    }\n\n    private fun FirCallableSymbol<*>.valueParametersAreEmpty(): Boolean {\n        return when (this) {\n            is FirNamedFunctionSymbol -> fir.valueParameters.isEmpty()\n            else -> true\n        }\n    }\n}\n\nprivate fun FirCallableSymbol<*>.isFromBuiltinClass(session: FirSession): Boolean {\n    return dispatchReceiverClassLookupTagOrNull()?.toSymbol(session)?.fir?.origin == FirDeclarationOrigin.BuiltIns\n}\n\nprivate fun FirNamedFunctionSymbol.firstOverriddenFunction(\n    containingScope: FirTypeScope,\n    predicate: (FirNamedFunctionSymbol) -> Boolean\n): FirNamedFunctionSymbol? {\n    return firstOverriddenCallable(containingScope, FirTypeScope::processOverriddenFunctionsAndSelf, predicate)\n}\n\nprivate inline fun <T : FirCallableSymbol<*>> T.firstOverriddenCallable(\n    containingScope: FirTypeScope,\n    processFunction: FirTypeScope.(T, (T) -> ProcessorAction) -> ProcessorAction,\n    noinline predicate: (T) -> Boolean,\n): T? {"}
{"code": "\n    var result: T? = null\n    containingScope.processFunction(this) { symbol ->\n        if (predicate(symbol)) {\n            result = symbol\n            ProcessorAction.STOP\n        } else {\n            ProcessorAction.NEXT\n        }\n    }\n    return result\n}\n"}
{"code": "object Foo {\n    object Helper {\n        operator fun invoke() {}\n    }\n}\n\nfun test() {\n    Fo<caret>o.Helper()\n}\n"}
{"code": "\n\n@file:Suppress(\"SpellCheckingInspection\")\n\npackage org.jetbrains.kotlin.fir.resolve.dfa.cfg\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.declarations.FirFile\nimport org.jetbrains.kotlin.fir.references.FirControlFlowGraphReference\nimport org.jetbrains.kotlin.fir.render\nimport org.jetbrains.kotlin.fir.resolve.dfa.*\nimport org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol\nimport org.jetbrains.kotlin.fir.visitors.FirVisitorVoid\nimport org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.utils.DFS\nimport org.jetbrains.kotlin.utils.Printer\n\nprivate class ControlFlowGraphRenderer(\n    builder: StringBuilder,\n    private val options: ControlFlowGraphRenderOptions,\n) {\n    companion object {\n        private const val EDGE = \" -> \"\n        private const val RED = \"red\"\n        private const val BLUE = \"blue\"\n\n        private val DIGIT_REGEX = \"\"\"\\d\"\"\".toRegex()\n    }\n\n    private val printer = Printer(builder)\n\n    private var nodeCounter = 0\n  "}
{"code": "  private var clusterCounter = 0\n\n    fun renderCompleteGraph(graphName: String, printNodesAndEdges: () -> Unit) {\n        var sanitizedName = graphName.replace(\".\", \"_\")\n        if (sanitizedName.isNotEmpty() && DIGIT_REGEX.matches(sanitizedName.first().toString())) {\n            sanitizedName = \"_$sanitizedName\"\n        }\n        printer\n            .println(\"digraph $sanitizedName {\")\n            .pushIndent()\n            .println(\"graph [nodesep=3]\")\n            .println(\"node [shape=box penwidth=2]\")\n            .println(\"edge [penwidth=2]\")\n            .println()\n        printNodesAndEdges()\n        printer\n            .popIndent()\n            .println(\"}\")\n    }\n\n    fun renderPartialGraph(controlFlowGraph: ControlFlowGraph) {\n        val nodes = DFS.topologicalOrder(listOf(controlFlowGraph.enterNode)) { it.followingNodes }\n            .associateWithTo(linkedMapOf()) { nodeCounter++ }\n        printer.renderNodes(nodes)\n        printer.renderEdges(nodes)\n        printer.println()"}
{"code": "\n    }\n\n    private fun Printer.renderNodes(nodes: Map<CFGNode<*>, Int>) {\n        var color = RED\n        for ((node, index) in nodes) {\n            if (node is EnterNodeMarker) {\n                enterCluster(color)\n                color = BLUE\n            }\n            val attributes = mutableListOf<String>()\n            if (options.renderFlow) {\n                // To maintain compatibility with existing CFG renders, only use HTML-like rendering if flow details are enabled.\n                val label = buildString {\n                    append(\"<TABLE BORDER=\\\"0\\\">\")\n                    append(\"<TR><TD><B>\")\n                    append(node.render().toHtmlLikeString())\n                    if (options.renderLevels) {\n                        append(\" [${node.level}]\")\n                    }\n                    append(\"</B></TD></TR>\")\n                    if (node.flowInitialized) {\n                        append(\"<TR><TD ALIGN=\\\"LEFT\\\" BALIGN=\\\"LEFT\\\">\")\n                        append(node"}
{"code": ".renderFlowHtmlLike())\n                        append(\"</TD></TR>\")\n                    }\n                    append(\"</TABLE>\")\n                }\n                attributes += \"label=< $label >\"\n            } else {\n                val label = buildString {\n                    append(node.render().replace(\"\\\"\", \"\"))\n                    if (options.renderLevels) {\n                        append(\" [${node.level}]\")\n                    }\n                }\n                attributes += \"label=\\\"$label\\\"\"\n            }\n\n            when {\n                node.isDead -> \"gray\"\n                node == node.owner.enterNode || node == node.owner.exitNode -> \"red\"\n                node.isUnion -> \"yellow\"\n                else -> null\n            }?.let {\n                attributes += \"style=\\\"filled\\\"\"\n                attributes += \"fillcolor=$it\"\n            }\n            println(index, attributes.joinToString(separator = \" \", prefix = \" [\", postfix = \"];\"))\n            if (node is ExitNodeMark"}
{"code": "er) {\n                exitCluster()\n            }\n        }\n    }\n\n    private val Edge.style: String?\n        get() = listOfNotNull(\n            when {\n                !kind.usedInDfa && !kind.usedInDeadDfa -> \"color=green\"\n                !kind.usedInCfa -> \"color=red\"\n                else -> null\n            },\n            when {\n                kind.isDead -> \"style=dotted\"\n                kind.isBack -> \"style=dashed\"\n                else -> null\n            },\n            label.label?.let { \"label=\\\"$it\\\"\" }\n        ).ifEmpty { null }?.joinToString(prefix = \"[\", separator = \" \", postfix = \"]\")\n\n    private fun Printer.renderEdges(nodes: Map<CFGNode<*>, Int>) {\n        for ((node, index) in nodes) {\n            for ((style, group) in node.followingNodes.groupBy { node.edgeTo(it).style }.entries.sortedBy { it.key }) {\n                val mappedGroup = group.map { nodes.getValue(it) }.sorted()\n                print(index, EDGE, mappedGroup.joinToString(prefix = \"{\", postfix = \"}\", s"}
{"code": "eparator = \" \"))\n                style?.let { printWithNoIndent(\" $it\") }\n                printlnWithNoIndent(\";\")\n            }\n\n            if (node is CFGNodeWithSubgraphs<*>) {\n                val subNodes = node.subGraphs.mapNotNull { nodes[it.enterNode] }.sorted()\n                if (subNodes.isNotEmpty()) {\n                    print(index, EDGE, subNodes.joinToString(prefix = \"{\", postfix = \"}\", separator = \" \"))\n                    printlnWithNoIndent(\" [style=dashed];\")\n                }\n            }\n        }\n    }\n\n    private fun Printer.enterCluster(color: String) {\n        println(\"subgraph cluster_${clusterCounter++} {\")\n        pushIndent()\n        println(\"color=$color\")\n    }\n\n    private fun Printer.exitCluster() {\n        popIndent()\n        println(\"}\")\n    }\n\n    private fun CFGNode<*>.renderFlowHtmlLike(): String {\n        val flow = flow\n        val variables = flow.knownVariables + flow.implications.keys +\n                flow.implications.flatMap { it.value }"}
{"code": ".map { it.condition.variable } +\n                flow.implications.flatMap { it.value }.map { it.effect.variable }\n        return variables.sorted().joinToString(separator = \"<BR/><BR/>\") { variable ->\n            buildString {\n                append(variable.renderHtmlLike())\n                if (variable is RealVariable) {\n                    flow.getTypeStatement(variable)?.let {\n                        append(\"<BR/><B>types</B> \")\n                        append(it.exactType.toHtmlLikeString())\n                    }\n                    flow.implications[flow.unwrapVariable(variable)]?.let {\n                        for (implication in it) {\n                            append(\"<BR/><B>implication</B> \")\n                            append(implication.toHtmlLikeString())\n                        }\n                    }\n                }\n                flow.implications[variable]?.let {\n                    for (implication in it) {\n                        append(\"<BR/><B>implication</B> \""}
{"code": ")\n                        append(implication.toHtmlLikeString())\n                    }\n                }\n            }\n        }\n    }\n\n    private fun DataFlowVariable.renderHtmlLike(): String {\n        val variable = this\n        return buildString {\n            append(\"<B>\")\n            append(variable)\n            append(\"</B>\")\n\n            val callableId = variable.callableId\n            if (variable is RealVariable && callableId != null) {\n                append(\" = \")\n                val receivers = listOfNotNull(\n                    variable.identifier.dispatchReceiver?.callableId?.toHtmlLikeString(),\n                    variable.identifier.extensionReceiver?.callableId?.toHtmlLikeString(),\n                )\n                when (receivers.size) {\n                    2 -> append(receivers.joinToString(prefix = \"(\", postfix = \").\"))\n                    1 -> append(receivers.joinToString(postfix = \".\"))\n                }\n                append(callableId.toHtmlLikeString())\n    "}
{"code": "        }\n            if (variable is SyntheticVariable) {\n                append(\" = '\")\n                append(variable.fir.render().toHtmlLikeString())\n                append(\"'\")\n            }\n        }\n    }\n\n    private val DataFlowVariable.callableId: CallableId?\n        get() = ((this as? RealVariable)?.identifier?.symbol as? FirCallableSymbol<*>)?.callableId\n\n    \n    private fun Any.toHtmlLikeString(): String = toString()\n        .replace(\"&\", \"&amp;\")\n        .replace(\">\", \"&gt;\")\n        .replace(\"<\", \"&lt;\")\n}\n\ndata class ControlFlowGraphRenderOptions(val renderLevels: Boolean = false, val renderFlow: Boolean = false)\n\nfun ControlFlowGraph.renderTo(builder: StringBuilder, options: ControlFlowGraphRenderOptions = ControlFlowGraphRenderOptions()) {\n    ControlFlowGraphRenderer(builder, options).run {\n        renderCompleteGraph(name) {\n            renderPartialGraph(this@renderTo)\n        }\n    }\n}\n\nfun FirElement.renderControlFlowGraphTo(builder: StringBuilder, options: Con"}
{"code": "trolFlowGraphRenderOptions = ControlFlowGraphRenderOptions()) {\n    val graphName = (this@renderControlFlowGraphTo as? FirFile)?.name ?: \"\"\n    ControlFlowGraphRenderer(builder, options).run {\n        renderCompleteGraph(graphName) {\n            accept(\n                object : FirVisitorVoid() {\n                    override fun visitElement(element: FirElement) {\n                        element.acceptChildren(this)\n                    }\n\n                    override fun visitControlFlowGraphReference(controlFlowGraphReference: FirControlFlowGraphReference) {\n                        val controlFlowGraph =\n                            (controlFlowGraphReference as? FirControlFlowGraphReferenceImpl)?.controlFlowGraph ?: return\n                        if (controlFlowGraph.isSubGraph) return\n                        renderPartialGraph(controlFlowGraph)\n                    }\n                }\n            )\n        }\n    }\n}\n\n@Suppress(\"unused\") // Can be used from the debugger\nfun ControlFlow"}
{"code": "Graph.render(options: ControlFlowGraphRenderOptions = ControlFlowGraphRenderOptions()): String =\n    buildString {\n        renderTo(this, options)\n    }\n\n@Suppress(\"unused\") // Can be used from the debugger\nfun FirElement.renderControlFlowGraph(options: ControlFlowGraphRenderOptions = ControlFlowGraphRenderOptions()): String =\n    buildString {\n        renderControlFlowGraphTo(this, options)\n    }\n"}
{"code": "\n\npackage org.jetbrains.kotlin.util\n\nimport java.io.File\nimport java.io.IOError\nimport java.lang.Character.isJavaIdentifierPart\nimport java.lang.Character.isJavaIdentifierStart\nimport java.net.URLClassLoader\nimport java.nio.file.FileSystemNotFoundException\nimport java.nio.file.Paths\nimport java.util.zip.ZipFile\n\n\nobject ServiceLoaderLite {\n    private const val SERVICE_DIRECTORY_LOCATION = \"META-INF/services/\"\n\n    class ServiceLoadingException(val file: File, cause: Throwable) : RuntimeException(\"Error loading services from $file\", cause)\n\n    \n    fun <Service> loadImplementations(service: Class<out Service>, classLoader: URLClassLoader): List<Service> {\n        val files = classLoader.urLs.map { url ->\n            try {\n                Paths.get(url.toURI()).toFile()\n            } catch (e: FileSystemNotFoundException) {\n                throw IllegalArgumentException(\"Only local URLs are supported, got ${url.protocol}\")\n            } catch (e: UnsupportedOperationException) {\n      "}
{"code": "          throw IllegalArgumentException(\"Only local URLs are supported, got ${url.protocol}\")\n            }\n        }\n\n        return loadImplementations(service, files, classLoader)\n    }\n\n    fun <Service> loadImplementations(service: Class<out Service>, files: List<File>, classLoader: ClassLoader): MutableList<Service> {\n        val implementations = mutableListOf<Service>()\n\n        for (className in findImplementations(service, files)) {\n            val instance = Class.forName(className, false, classLoader).newInstance()\n            implementations += service.cast(instance)\n        }\n\n        return implementations\n    }\n\n    inline fun <reified Service : Any> findImplementations(files: List<File>): Set<String> {\n        return findImplementations(Service::class.java, files)\n    }\n\n    inline fun <reified Service : Any> loadImplementations(classLoader: URLClassLoader): List<Service> {\n        return loadImplementations(Service::class.java, classLoader)\n    }\n\n    inline fun <rei"}
{"code": "fied Service : Any> loadImplementations(files: List<File>, classLoader: ClassLoader): List<Service> {\n        return loadImplementations(Service::class.java, files, classLoader)\n    }\n\n    fun findImplementations(service: Class<*>, files: List<File>): Set<String> {\n        return files.flatMapTo(linkedSetOf()) { findImplementations(service, it) }\n    }\n\n    private fun findImplementations(service: Class<*>, file: File): Set<String> {\n        val classIdentifier = getClassIdentifier(service)\n\n        return when {\n            file.isDirectory -> findImplementationsInDirectory(classIdentifier, file)\n            file.isFile && file.extension.lowercase() == \"jar\" -> findImplementationsInJar(classIdentifier, file)\n            else -> emptySet()\n        }\n    }\n\n    private fun findImplementationsInDirectory(classId: String, file: File): Set<String> {\n        val serviceFile = File(file, SERVICE_DIRECTORY_LOCATION + classId).takeIf { it.isFile } ?: return emptySet()\n\n        try {\n          "}
{"code": "  return serviceFile.useLines { parseLines(file, it) }\n        } catch (e: IOError) {\n            throw ServiceLoadingException(file, e)\n        }\n    }\n\n    private fun findImplementationsInJar(classId: String, file: File): Set<String> {\n        ZipFile(file).use { zipFile ->\n            val entry = zipFile.getEntry(SERVICE_DIRECTORY_LOCATION + classId) ?: return emptySet()\n            zipFile.getInputStream(entry).use { inputStream ->\n                return inputStream.bufferedReader().useLines { parseLines(file, it) }\n            }\n        }\n    }\n\n    private fun parseLines(file: File, lines: Sequence<String>): Set<String> {\n        return lines.mapNotNullTo(linkedSetOf()) { parseLine(file, it) }\n    }\n\n    private fun parseLine(file: File, line: String): String? {\n        val actualLine = line.substringBefore('#').trim().takeIf { it.isNotEmpty() } ?: return null\n\n        actualLine.forEachIndexed { index: Int, c: Char ->\n            val isValid = if (index == 0) isJavaIdentifierSt"}
{"code": "art(c) else isJavaIdentifierPart(c) || c == '.'\n            if (!isValid) {\n                val errorText = \"Invalid Java identifier: $line\"\n                throw ServiceLoadingException(file, RuntimeException(errorText))\n            }\n        }\n\n        return actualLine\n    }\n\n    private fun getClassIdentifier(service: Class<*>): String {\n        return service.name\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.expression\n\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.expressions.FirElvisExpression\nimport org.jetbrains.kotlin.fir.types.ConeErrorType\nimport org.jetbrains.kotlin.fir.types.canBeNull\nimport org.jetbrains.kotlin.fir.types.isNullLiteral\nimport org.jetbrains.kotlin.fir.types.resolvedType\n\nobject FirUselessElvisChecker : FirElvisExpressionChecker(MppCheckerKind.Common) {\n    override fun check(expression: FirElvisExpression, context: CheckerContext, reporter: DiagnosticReporter) {\n        // If the overall expression is not resolved/completed, the corresponding error will be reported separate"}
{"code": "ly.\n        // See [FirControlFlowStatementsResolveTransformer#transformElvisExpression],\n        // where an error type is recorded as the expression's return type.\n        if (expression.resolvedType is ConeErrorType) return\n\n        val lhsType = expression.lhs.resolvedType\n        if (lhsType is ConeErrorType) return\n        if (!lhsType.canBeNull(context.session)) {\n            if (context.languageVersionSettings.supportsFeature(LanguageFeature.EnableDfaWarningsInK2)) {\n                reporter.reportOn(expression.source, FirErrors.USELESS_ELVIS, lhsType, context)\n            }\n            return\n        }\n\n        if (expression.rhs.isNullLiteral) {\n            if (context.languageVersionSettings.supportsFeature(LanguageFeature.EnableDfaWarningsInK2)) {\n                reporter.reportOn(expression.source, FirErrors.USELESS_ELVIS_RIGHT_IS_NULL, context)\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.tree.generator.printer\n\nimport org.jetbrains.kotlin.descriptors.Modality\nimport org.jetbrains.kotlin.fir.tree.generator.*\nimport org.jetbrains.kotlin.fir.tree.generator.model.*\nimport org.jetbrains.kotlin.generators.tree.*\nimport org.jetbrains.kotlin.generators.tree.printer.call\nimport org.jetbrains.kotlin.generators.tree.printer.printAcceptChildrenMethod\nimport org.jetbrains.kotlin.generators.tree.printer.printBlock\nimport org.jetbrains.kotlin.generators.tree.printer.printTransformChildrenMethod\nimport org.jetbrains.kotlin.utils.SmartPrinter\nimport org.jetbrains.kotlin.utils.withIndent\n\nprivate class ImplementationFieldPrinter(printer: SmartPrinter) : AbstractFieldPrinter<FieldWithDefault>(printer) {\n\n    private fun Field.isMutableOrEmptyIfList(): Boolean = when (this) {\n        is FieldList -> isMutableOrEmptyList\n        is FieldWithDefault -> origin.isMutableOrEmptyIfList()\n        else -> true\n    }\n\n    override fun forceMutable(field: FieldWit"}
{"code": "hDefault): Boolean = field.isMutable && field.isMutableOrEmptyIfList()\n\n    override fun actualTypeOfField(field: FieldWithDefault) = field.getMutableType()\n\n    override val wrapOptInAnnotations\n        get() = true\n}\n\ninternal class ImplementationPrinter(\n    printer: SmartPrinter\n) : AbstractImplementationPrinter<Implementation, Element, FieldWithDefault>(printer) {\n\n    override val implementationOptInAnnotation: ClassRef<*>\n        get() = firImplementationDetailType\n\n\n    override val pureAbstractElementType: ClassRef<*>\n        get() = org.jetbrains.kotlin.fir.tree.generator.pureAbstractElementType\n\n    override fun makeFieldPrinter(printer: SmartPrinter): AbstractFieldPrinter<FieldWithDefault> = ImplementationFieldPrinter(printer)\n\n    context(ImportCollector)\n    override fun SmartPrinter.printAdditionalMethods(implementation: Implementation) {\n        fun Field.transform() {\n            when (this) {\n                is FieldWithDefault -> origin.transform()\n\n                i"}
{"code": "s SimpleField ->\n                    println(\"$name = ${name}${call()}transform(transformer, data)\")\n\n                is FieldList -> {\n                    addImport(transformInPlaceImport)\n                    println(\"${name}.transformInplace(transformer, data)\")\n                }\n            }\n        }\n        with(implementation) {\n            val isInterface = kind == ImplementationKind.Interface || kind == ImplementationKind.SealedInterface\n            val isAbstract = kind == ImplementationKind.AbstractClass || kind == ImplementationKind.SealedClass\n            val bindingCalls = element.allFields.filter {\n                it.withBindThis && it.hasSymbolType && it !is FieldList && it.name != \"companionObjectSymbol\"\n            }.takeIf {\n                it.isNotEmpty() && !isInterface && !isAbstract &&\n                        !element.typeName.contains(\"Reference\")\n                        && !element.typeName.contains(\"ResolvedQualifier\")\n                        && !element.typeN"}
{"code": "ame.endsWith(\"Ref\")\n            }.orEmpty()\n\n            val customCalls = fieldsInConstructor.filter { it.customInitializationCall != null }\n            if (bindingCalls.isNotEmpty() || customCalls.isNotEmpty()) {\n                println()\n                println(\"init {\")\n                withIndent {\n                    for (symbolField in bindingCalls) {\n                        println(\"${symbolField.name}${symbolField.call()}bind(this)\")\n                    }\n\n                    for (customCall in customCalls) {\n                        addAllImports(customCall.arbitraryImportables)\n                        println(\"${customCall.name} = ${customCall.customInitializationCall}\")\n                    }\n                }\n                println(\"}\")\n            }\n\n            fun Field.acceptString(): String = \"${name}${call()}accept(visitor, data)\"\n\n            if (hasAcceptChildrenMethod) {\n                printAcceptChildrenMethod(this, firVisitorType, TypeVariable(\"R\"), override = tr"}
{"code": "ue)\n                print(\" {\")\n\n                val walkableFields = walkableChildren\n                if (walkableFields.isNotEmpty()) {\n                    println()\n                    withIndent {\n                        for (field in walkableFields) {\n                            when (field.name) {\n                                \"explicitReceiver\" -> {\n                                    val explicitReceiver = implementation[\"explicitReceiver\"]\n                                    val dispatchReceiver = implementation[\"dispatchReceiver\"]\n                                    val extensionReceiver = implementation[\"extensionReceiver\"]\n                                    println(\n                                        \"\"\"\n                                    |${explicitReceiver.acceptString()}\n                                    |        if (dispatchReceiver !== explicitReceiver) {\n                                    |            ${dispatchReceiver.acceptString()}\n                    "}
{"code": "                |        }\n                                    |        if (extensionReceiver !== explicitReceiver && extensionReceiver !== dispatchReceiver) {\n                                    |            ${extensionReceiver.acceptString()}\n                                    |        }\n                                        \"\"\".trimMargin(),\n                                    )\n                                }\n\n                                \"dispatchReceiver\", \"extensionReceiver\", \"subjectVariable\", \"companionObject\" -> {\n                                }\n\n                                else -> {\n                                    if (this.typeName == \"FirWhenExpressionImpl\" && field.name == \"subject\") {\n                                        println(\n                                            \"\"\"\n                                        |val subjectVariable_ = subjectVariable\n                                        |        if (subjectVariable_ != null) {\n                "}
{"code": "                        |            subjectVariable_.accept(visitor, data)\n                                        |        } else {\n                                        |            subject?.accept(visitor, data)\n                                        |        }\n                                            \"\"\".trimMargin(),\n                                        )\n                                    } else {\n                                        when (field.origin) {\n                                            is SimpleField -> {\n                                                println(field.acceptString())\n                                            }\n\n                                            is FieldList -> {\n                                                println(field.name, field.call(), \"forEach { it.accept(visitor, data) }\")\n                                            }\n\n                                            else -> throw IllegalStateException()\n                  "}
{"code": "                      }\n                                    }\n                                }\n\n                            }\n                        }\n                    }\n                }\n                println(\"}\")\n            }\n\n            if (hasTransformChildrenMethod) {\n                printTransformChildrenMethod(\n                    implementation,\n                    firTransformerType,\n                    implementation,\n                    modality = Modality.ABSTRACT.takeIf { isAbstract },\n                    override = true,\n                )\n                if (!isInterface && !isAbstract) {\n                    printBlock {\n                        for (field in transformableChildren) {\n                            when {\n                                field.name == \"explicitReceiver\" -> {\n                                    val explicitReceiver = implementation[\"explicitReceiver\"]\n                                    val dispatchReceiver = implementation[\"dispatchRec"}
{"code": "eiver\"]\n                                    val extensionReceiver = implementation[\"extensionReceiver\"]\n                                    if (explicitReceiver.isMutable) {\n                                        println(\"explicitReceiver = explicitReceiver${explicitReceiver.call()}transform(transformer, data)\")\n                                    }\n                                    if (dispatchReceiver.isMutable) {\n                                        println(\n                                            \"\"\"\n                                    |if (dispatchReceiver !== explicitReceiver) {\n                                    |            dispatchReceiver = dispatchReceiver?.transform(transformer, data)\n                                    |        }\n                                \"\"\".trimMargin(),\n                                        )\n                                    }\n                                    if (extensionReceiver.isMutable) {\n                                   "}
{"code": "     println(\n                                            \"\"\"\n                                    |if (extensionReceiver !== explicitReceiver && extensionReceiver !== dispatchReceiver) {\n                                    |            extensionReceiver = extensionReceiver?.transform(transformer, data)\n                                    |        }\n                                \"\"\".trimMargin(),\n                                        )\n                                    }\n                                }\n\n                                field.name in setOf(\"dispatchReceiver\", \"extensionReceiver\") -> {}\n\n                                field.needsSeparateTransform -> {\n                                    if (!(element.needTransformOtherChildren && field.needTransformInOtherChildren)) {\n                                        println(\"transform${field.name.replaceFirstChar(Char::uppercaseChar)}(transformer, data)\")\n                                    }\n                              "}
{"code": "  }\n\n                                !element.needTransformOtherChildren -> {\n                                    field.transform()\n                                }\n\n                                else -> {}\n                            }\n                        }\n                        if (element.needTransformOtherChildren) {\n                            println(\"transformOtherChildren(transformer, data)\")\n                        }\n                        println(\"return this\")\n                    }\n                }\n            }\n\n            for (field in allFields) {\n                if (!field.needsSeparateTransform) continue\n                println()\n                transformFunctionDeclaration(field, implementation, override = true, kind!!)\n                if (isInterface || isAbstract) {\n                    println()\n                    continue\n                }\n                printBlock {\n                    if (field.isMutable && field.containsElement) {\n                  "}
{"code": "      // TODO: replace with smth normal\n                        if (typeName == \"FirWhenExpressionImpl\" && field.name == \"subject\") {\n                            println(\n                                \"\"\"\n                                |if (subjectVariable != null) {\n                                |            subjectVariable = subjectVariable?.transform(transformer, data)\n                                |            subject = subjectVariable?.initializer\n                                |        } else {\n                                |            subject = subject?.transform(transformer, data)\n                                |        }\n                                    \"\"\".trimMargin(),\n                            )\n                        } else {\n                            field.transform()\n                        }\n                    }\n                    println(\"return this\")\n                }\n            }\n\n            if (element.needTransformOtherChildren) {\n         "}
{"code": "       println()\n                transformOtherChildrenFunctionDeclaration(implementation, override = true, kind!!)\n                if (isInterface || isAbstract) {\n                    println()\n                } else {\n                    printBlock {\n                        for (field in allFields) {\n                            if (!field.isMutable || !field.containsElement || field.name == \"subjectVariable\") continue\n                            if (!field.needsSeparateTransform) {\n                                field.transform()\n                            }\n                            if (field.needTransformInOtherChildren) {\n                                println(\"transform${field.name.replaceFirstChar(Char::uppercaseChar)}(transformer, data)\")\n                            }\n                        }\n                        println(\"return this\")\n                    }\n                }\n            }\n\n            fun generateReplace(\n                field: Field,\n                o"}
{"code": "verridenType: TypeRefWithNullability? = null,\n                forceNullable: Boolean = false,\n                body: () -> Unit,\n            ) {\n                println()\n                if (field.name == \"source\") {\n                    println(\"@${firImplementationDetailType.render()}\")\n                }\n                replaceFunctionDeclaration(field, override = true, kind!!, overridenType, forceNullable)\n                if (isInterface || isAbstract) {\n                    println()\n                    return\n                }\n                print(\" {\")\n                if (!field.isMutable) {\n                    println(\"}\")\n                    return\n                }\n                println()\n                withIndent {\n                    body()\n                }\n                println(\"}\")\n            }\n\n            for (field in allFields.filter { it.withReplace }) {\n                val capitalizedFieldName = field.name.replaceFirstChar(Char::uppercaseChar)\n                va"}
{"code": "l newValue = \"new$capitalizedFieldName\"\n                generateReplace(field, forceNullable = field.useNullableForReplace) {\n                    when {\n                        field.implementationDefaultStrategy!!.withGetter -> {}\n\n                        field.origin is FieldList && !field.isMutableOrEmptyList -> {\n                            println(\"${field.name}.clear()\")\n                            println(\"${field.name}.addAll($newValue)\")\n                        }\n\n                        else -> {\n                            if (field.useNullableForReplace) {\n                                println(\"require($newValue != null)\")\n                            }\n                            print(\"${field.name} = $newValue\")\n                            if (field.origin is FieldList && field.isMutableOrEmptyList) {\n                                addImport(toMutableOrEmptyImport)\n                                print(\".toMutableOrEmpty()\")\n                            }\n              "}
{"code": "              println()\n                        }\n                    }\n                }\n\n                for (overridenType in field.overriddenTypes) {\n                    generateReplace(field, overridenType) {\n                        println(\"require($newValue is ${field.typeRef.render()})\")\n                        println(\"replace$capitalizedFieldName($newValue)\")\n                    }\n                }\n            }\n        }\n    }\n}\n\nprivate val Field.hasSymbolType: Boolean\n    get() = (typeRef as? ClassRef<*>)?.simpleName?.contains(\"Symbol\") ?: false\n"}
{"code": "// DO_NOT_CHECK_SYMBOL_RESTORE_K1\n// FILE: main.kt\nfun some() {\n    JavaClass.f<caret>ield;\n}\n\n// FILE: JavaClass.java\npublic class JavaClass {\n    public static int field = 1;\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.source\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators.AnalysisApiFirSourceTestConfigurator\nimport org.jetbrains.kotlin.light.classes.symbol.base.AbstractSymbolLightClassesParentingTestByPsi\n\nabstract class AbstractSymbolLightClassesParentingByPsiForSourceTest :\n    AbstractSymbolLightClassesParentingTestByPsi(\n        AnalysisApiFirSourceTestConfigurator(analyseInDependentSession = false),\n        EXTENSIONS.FIR_JAVA,\n        stopIfCompilationErrorDirectivePresent = false\n    )\n"}
{"code": "abstract class Base(val s: String)\n\nclass Outer {\n    class Derived(s: String) : Base(s)\n\n    object Obj : Base(\"\")\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental.utils\n\nimport org.jetbrains.kotlin.build.report.BuildReporter\nimport org.jetbrains.kotlin.build.report.metrics.BuildMetricsReporter\nimport org.jetbrains.kotlin.build.report.metrics.GradleBuildPerformanceMetric\nimport org.jetbrains.kotlin.build.report.metrics.GradleBuildTime\n\nclass TestBuildReporter(\n    val testICReporter: TestICReporter,\n    buildMetricsReporter: BuildMetricsReporter<GradleBuildTime, GradleBuildPerformanceMetric>\n) : BuildReporter<GradleBuildTime, GradleBuildPerformanceMetric>(testICReporter, buildMetricsReporter) {\n    fun reportCachesDump(cachesDump: String) {\n        testICReporter.cachesDump = cachesDump\n    }\n}"}
{"code": "// FILE: lib.kt\npackage lib\n\nclass Foo {\n    fun foo() {}\n}\n\n// FILE: main.kt\npackage main\n\nimport lib.Foo\n\nobject Main {\n    @JvmStatic\n    fun main(args: Array<String>) {\n        <caret>Foo().foo()\n    }\n}"}
{"code": "// SKIP_JAVAC\n// This directive is needed to skip this test in LazyBodyIsNotTouchedTilContractsPhaseTestGenerated,\n//  because it fails to parse module structure of multimodule test\n\n// MODULE: lib\npackage dependency\n\nabstract class A<T> {\n    fun foo() = \"\"\n}\n\n// MODULE: main(lib)\n// FILE: B.kt\npackage main\nimport c.C\nimport dependency.A\n\nclass D {\n    abstract class B : A<C>() {}\n}\n\nfun usage(b : D.B?) {\n    if (b != null) {\n        b.foo()\n    }\n}\n// FILE: C.kt\npackage c\nclass C"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.expressions\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.FirPureAbstractElement\nimport org.jetbrains.kotlin.fir.declarations.FirProperty\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\n\nabstract class FirCatch : FirPureAbstractElement(), FirElement {\n    abstract override val source: KtSourceElement?\n    abstract val parameter: FirProperty\n    abstract val block: FirBlock\n\n    override fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitCatch(this, data)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transformer.transformCatch(this, data) as E\n\n    abstract fun <D> transformParameter(tr"}
{"code": "ansformer: FirTransformer<D>, data: D): FirCatch\n\n    abstract fun <D> transformBlock(transformer: FirTransformer<D>, data: D): FirCatch\n\n    abstract fun <D> transformOtherChildren(transformer: FirTransformer<D>, data: D): FirCatch\n}\n"}
{"code": "annotation class A(vararg val strings: String)\n\n@A(strings = [\"foo\", \"bar\"])\nclass F<caret>oo\n"}
{"code": "// WITH_STDLIB\n\ninterface NavGraphBuilder\n\ninterface AnimatedContentTransitionScope<S>\n\ninterface NavBackStackEntry\n\ninterface EnterTransition\n\nfun NavGraphBuilder.compose(\n  enter<caret>Transition: (@JvmSuppressWildcards(suppress = false)\n    AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition?)? = null,\n) = TODO()"}
{"code": "// ISSUE: KT-46072\n\n// Case 1\nclass Foo {\n    fun bar() {}\n    fun f() = <!UNRESOLVED_REFERENCE!>Unresolved<!>()::bar // Type of Unresolved()::bar is implicit\n}\n\n// Case 2\ninterface IA\ninterface IB : IA\n\nfun IA.extFun(x: IB) {}\nfun IB.extFun(x: IA) {}\n\nfun testWithExpectedType() {\n    val extFun_AA_B: IA.(IA) -> Unit = IB::<!NONE_APPLICABLE!>extFun<!> // extFun is unresolved, type of IB::extFun is implicit\n}\n"}
{"code": "// FIR_IGNORE\n// Ignored for fir, as FIR does not support org.jetbrains.kotlin.load.java.InternalFlexibleTypeTransformer\n\n// KNM_K2_IGNORE\n// KNM_FE10_IGNORE\n\npackage test\n\nimport kotlin.internal.flexible.ft\n\nabstract class FlexibleTypes() {\n    abstract fun collection(): ft<List<Int>, List<Any>>\n\n    abstract val p: ft<Int, Int?>\n\n    fun withBody(): ft<Int, Int?> { return 1 }\n}"}
{"code": "val h: java.util.<caret>HashSet<Int>? = null\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir\n\nimport org.jetbrains.kotlin.fir.deserialization.LibraryPathFilter\nimport org.jetbrains.kotlin.fir.deserialization.ModuleDataProvider\nimport org.jetbrains.kotlin.fir.deserialization.MultipleModuleDataProvider\nimport org.jetbrains.kotlin.fir.deserialization.SingleModuleDataProvider\nimport java.nio.file.Path\nimport java.nio.file.Paths\n\nclass DependencyListForCliModule(\n    val regularDependencies: List<FirModuleData>,\n    val dependsOnDependencies: List<FirModuleData>,\n    val friendsDependencies: List<FirModuleData>,\n    val moduleDataProvider: ModuleDataProvider,\n) {\n    companion object {\n        inline fun build(binaryModuleData: BinaryModuleData, init: Builder.() -> Unit = {}): DependencyListForCliModule {\n            return Builder(binaryModuleData).apply(init).build()\n        }\n    }\n\n    class Builder(val binaryModuleData: BinaryModuleData) {\n        private val allRegularDependencies = mutableListOf<FirModuleData>()\n        private val allFrien"}
{"code": "dsDependencies = mutableListOf<FirModuleData>()\n        private val allDependsOnDependencies = mutableListOf<FirModuleData>()\n\n        private val filtersMap =\n            listOf(\n                binaryModuleData.dependsOn,\n                binaryModuleData.friends,\n                binaryModuleData.regular\n            ).associateWithTo(mutableMapOf<FirModuleData, MutableSet<Path>>()) { mutableSetOf() }\n\n        fun dependency(vararg path: Path) {\n            filtersMap.getValue(binaryModuleData.regular) += path\n        }\n\n        fun dependency(moduleData: FirModuleData, vararg path: Path) {\n            filtersMap.getOrPut(moduleData) {\n                allRegularDependencies.add(moduleData)\n                mutableSetOf()\n            } += path\n        }\n\n        fun dependency(vararg path: String) {\n            path.mapTo(filtersMap.getValue(binaryModuleData.regular)) { Paths.get(it) }\n        }\n\n        @JvmName(\"dependenciesString\")\n        fun dependencies(paths: Collection<String>) {"}
{"code": "\n            paths.mapTo(filtersMap.getValue(binaryModuleData.regular)) { Paths.get(it) }\n        }\n\n        @JvmName(\"dependenciesString\")\n        fun dependencies(moduleData: FirModuleData, paths: Collection<String>) {\n            paths.mapTo(\n                filtersMap.getOrPut(moduleData) {\n                    allRegularDependencies.add(moduleData)\n                    mutableSetOf()\n                }\n            ) {\n                Paths.get(it)\n            }\n        }\n\n        @JvmName(\"friendDependenciesString\")\n        fun friendDependencies(paths: Collection<String>) {\n            paths.mapTo(filtersMap.getValue(binaryModuleData.friends)) { Paths.get(it) }\n        }\n\n        @JvmName(\"dependsOnDependenciesString\")\n        fun dependsOnDependencies(paths: Collection<String>) {\n            paths.mapTo(filtersMap.getValue(binaryModuleData.dependsOn)) { Paths.get(it) }\n        }\n\n        fun dependencies(paths: Collection<Path>) {\n            filtersMap.getValue(binaryModuleData.re"}
{"code": "gular) += paths\n        }\n\n        fun friendDependencies(paths: Collection<Path>) {\n            filtersMap.getValue(binaryModuleData.friends) += paths\n        }\n\n        fun dependsOnDependencies(paths: Collection<Path>) {\n            filtersMap.getValue(binaryModuleData.dependsOn) += paths\n        }\n\n\n        // Potentially, a part of a public API, so we leave it even while it's unused\n        @Suppress(\"unused\")\n        fun sourceFriendsDependencies(modules: Collection<FirModuleData>) {\n            allFriendsDependencies += modules\n        }\n\n        // Potentially, a part of a public API, so we leave it even while it's unused\n        @Suppress(\"unused\")\n        fun sourceDependsOnDependencies(modules: Collection<FirModuleData>) {\n            allDependsOnDependencies += modules\n        }\n\n        fun build(): DependencyListForCliModule {\n            val pathFiltersMap: MutableMap<FirModuleData, LibraryPathFilter> = filtersMap\n                .filterValues { it.isNotEmpty() }\n       "}
{"code": "         .mapValues { LibraryPathFilter.LibraryList(it.value) }\n                .toMutableMap()\n\n            allRegularDependencies += binaryModuleData.regular\n            if (pathFiltersMap.isEmpty()) {\n                return DependencyListForCliModule(\n                    allRegularDependencies,\n                    dependsOnDependencies = allDependsOnDependencies,\n                    friendsDependencies = allFriendsDependencies,\n                    SingleModuleDataProvider(binaryModuleData.regular)\n                )\n            }\n            if (binaryModuleData.friends in pathFiltersMap) {\n                allFriendsDependencies += binaryModuleData.friends\n            }\n            if (binaryModuleData.dependsOn in pathFiltersMap) {\n                allDependsOnDependencies += binaryModuleData.dependsOn\n            }\n\n            val moduleDataProvider = MultipleModuleDataProvider(pathFiltersMap)\n            pathFiltersMap.putIfAbsent(binaryModuleData.regular, LibraryPathFilter.TakeAl"}
{"code": "l)\n            return DependencyListForCliModule(\n                allRegularDependencies,\n                allDependsOnDependencies,\n                allFriendsDependencies,\n                moduleDataProvider\n            )\n        }\n    }\n}\n"}
{"code": "class Foo {\n operator fun invoke(vararg a: Any) {}\n}\n\nfun test(f: Foo) {\n  f(<caret>)\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.lightTree.fir\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget.*\nimport org.jetbrains.kotlin.fakeElement\nimport org.jetbrains.kotlin.fir.FirModuleData\nimport org.jetbrains.kotlin.fir.builder.*\nimport org.jetbrains.kotlin.fir.copy\nimport org.jetbrains.kotlin.fir.copyWithNewSourceKind\nimport org.jetbrains.kotlin.fir.correspondingProperty\nimport org.jetbrains.kotlin.fir.declarations.FirDeclarationOrigin\nimport org.jetbrains.kotlin.fir.declarations.FirProperty\nimport org.jetbrains.kotlin.fir.declarations.FirValueParameter\nimport org.jetbrains.kotlin.fir.declarations.builder.buildProperty\nimport org.jetbrains.kotlin.fir.declarations.builder.buildValueParameter\nimport org.jetbrains.kotlin.fir.declarations.impl.FirDeclarationStatusImpl\nimport org.jetbrains.kotlin.fir.declarations.impl.FirDefaultPropertyBackingField\nimport org.jetbrains."}
{"code": "kotlin.fir.declarations.impl.FirDefaultPropertyGetter\nimport org.jetbrains.kotlin.fir.declarations.impl.FirDefaultPropertySetter\nimport org.jetbrains.kotlin.fir.declarations.utils.fromPrimaryConstructor\nimport org.jetbrains.kotlin.fir.declarations.utils.isFromVararg\nimport org.jetbrains.kotlin.fir.diagnostics.ConeSyntaxDiagnostic\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotationCall\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.expressions.builder.buildAnnotationCallCopy\nimport org.jetbrains.kotlin.fir.expressions.builder.buildPropertyAccessExpression\nimport org.jetbrains.kotlin.fir.lightTree.fir.modifier.Modifier\nimport org.jetbrains.kotlin.fir.references.builder.buildPropertyFromParameterResolvedNamedReference\nimport org.jetbrains.kotlin.fir.symbols.impl.FirFunctionSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol\nimport org.jetbrains.kotlin.fir.symbols.im"}
{"code": "pl.FirValueParameterSymbol\nimport org.jetbrains.kotlin.fir.types.ConeClassLikeType\nimport org.jetbrains.kotlin.fir.types.FirErrorTypeRef\nimport org.jetbrains.kotlin.fir.types.FirImplicitTypeRef\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.types.builder.buildErrorTypeRef\nimport org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.name.Name\n\nclass ValueParameter(\n    private val valueParameterSymbol: FirValueParameterSymbol,\n    private val isVal: Boolean,\n    private val isVar: Boolean,\n    private val modifiers: Modifier,\n    private val valueParameterAnnotations: List<FirAnnotationCall>,\n    val returnTypeRef: FirTypeRef,\n    val source: KtSourceElement,\n    private val moduleData: FirModuleData,\n    private val isFromPrimaryConstructor: Boolean,\n    private val additionalAnnotations: List<FirAnnotation>,\n    val name: Name,\n    val defaultValue: FirExpression?,\n    private val containingFunctionSymbol: FirFunctionSymbol<*>?,\n    val des"}
{"code": "tructuringDeclaration: DestructuringDeclaration? = null\n) {\n    fun hasValOrVar(): Boolean {\n        return isVal || isVar\n    }\n\n    val annotations: List<FirAnnotation> by lazy(LazyThreadSafetyMode.NONE) {\n        buildList {\n            if (!isFromPrimaryConstructor)\n                addAll(valueParameterAnnotations)\n            else\n                valueParameterAnnotations.filterTo(this) { it.useSiteTarget.appliesToPrimaryConstructorParameter() }\n            addAll(additionalAnnotations)\n        }\n    }\n\n    val firValueParameter: FirValueParameter by lazy(LazyThreadSafetyMode.NONE) {\n        buildValueParameter {\n            source = this@ValueParameter.source\n            moduleData = this@ValueParameter.moduleData\n            origin = FirDeclarationOrigin.Source\n            isVararg = modifiers.hasVararg()\n            returnTypeRef = if (isVararg && this@ValueParameter.returnTypeRef is FirErrorTypeRef) {\n                this@ValueParameter.returnTypeRef.wrapIntoArray()\n          "}
{"code": "  } else {\n                this@ValueParameter.returnTypeRef\n            }\n\n            this.name = this@ValueParameter.name\n            symbol = valueParameterSymbol\n            defaultValue = this@ValueParameter.defaultValue\n            isCrossinline = modifiers.hasCrossinline()\n            isNoinline = modifiers.hasNoinline()\n            containingFunctionSymbol = this@ValueParameter.containingFunctionSymbol\n                ?: error(\"containingFunctionSymbol should present when converting ValueParameter to a FirValueParameter\")\n\n            annotations += this@ValueParameter.annotations\n            annotations += additionalAnnotations\n        }\n    }\n\n    fun <T> toFirPropertyFromPrimaryConstructor(\n        moduleData: FirModuleData,\n        callableId: CallableId,\n        isExpect: Boolean,\n        currentDispatchReceiver: ConeClassLikeType?,\n        context: Context<T>\n    ): FirProperty {\n        val name = this.firValueParameter.name\n        var type = this.firValueParameter.ret"}
{"code": "urnTypeRef\n        if (type is FirImplicitTypeRef) {\n            type = buildErrorTypeRef { diagnostic = ConeSyntaxDiagnostic(\"Incomplete code\") }\n        }\n\n        return buildProperty {\n            val propertySource = firValueParameter.source?.fakeElement(KtFakeSourceElementKind.PropertyFromParameter)\n            source = propertySource\n            this.moduleData = moduleData\n            origin = FirDeclarationOrigin.Source\n            returnTypeRef = type.copyWithNewSourceKind(KtFakeSourceElementKind.PropertyFromParameter)\n            this.name = name\n            initializer = buildPropertyAccessExpression {\n                source = propertySource\n                calleeReference = buildPropertyFromParameterResolvedNamedReference {\n                    source = propertySource\n                    this.name = name\n                    resolvedSymbol = this@ValueParameter.firValueParameter.symbol\n                    source = propertySource\n                }\n            }\n\n            i"}
{"code": "sVar = this@ValueParameter.isVar\n            val propertySymbol = FirPropertySymbol(callableId)\n            val remappedAnnotations = valueParameterAnnotations.map {\n                buildAnnotationCallCopy(it) {\n                    containingDeclarationSymbol = propertySymbol\n                }\n            }\n\n            symbol = propertySymbol\n            dispatchReceiverType = currentDispatchReceiver\n            isLocal = false\n            status = FirDeclarationStatusImpl(modifiers.getVisibility(), modifiers.getModality(isClassOrObject = false)).apply {\n                this.isExpect = isExpect\n                isActual = modifiers.hasActual()\n                isOverride = modifiers.hasOverride()\n                isConst = modifiers.hasConst()\n                isLateInit = modifiers.hasLateinit()\n            }\n\n            val defaultAccessorSource = propertySource?.fakeElement(KtFakeSourceElementKind.DefaultAccessor)\n            backingField = FirDefaultPropertyBackingField(\n            "}
{"code": "    moduleData = moduleData,\n                origin = FirDeclarationOrigin.Source,\n                source = defaultAccessorSource,\n                annotations = remappedAnnotations.filter {\n                    it.useSiteTarget == FIELD || it.useSiteTarget == PROPERTY_DELEGATE_FIELD\n                }.toMutableList(),\n                returnTypeRef = returnTypeRef.copyWithNewSourceKind(KtFakeSourceElementKind.DefaultAccessor),\n                isVar = isVar,\n                propertySymbol = symbol,\n                status = status.copy(isLateInit = false),\n            )\n\n            annotations += remappedAnnotations.filterConstructorPropertyRelevantAnnotations(this.isVar)\n\n            getter = FirDefaultPropertyGetter(\n                defaultAccessorSource,\n                moduleData,\n                FirDeclarationOrigin.Source,\n                type.copyWithNewSourceKind(KtFakeSourceElementKind.DefaultAccessor),\n                modifiers.getVisibility(),\n                symbol,\n           "}
{"code": "     isInline = modifiers.hasInline(),\n            ).also {\n                it.initContainingClassAttr(context)\n                it.replaceAnnotations(remappedAnnotations.filterUseSiteTarget(PROPERTY_GETTER))\n            }\n            setter = if (this.isVar) FirDefaultPropertySetter(\n                defaultAccessorSource,\n                moduleData,\n                FirDeclarationOrigin.Source,\n                type.copyWithNewSourceKind(KtFakeSourceElementKind.DefaultAccessor),\n                modifiers.getVisibility(),\n                symbol,\n                parameterAnnotations = remappedAnnotations.filterUseSiteTarget(SETTER_PARAMETER),\n                isInline = modifiers.hasInline(),\n            ).also {\n                it.initContainingClassAttr(context)\n                it.replaceAnnotations(remappedAnnotations.filterUseSiteTarget(PROPERTY_SETTER))\n            } else null\n        }.apply {\n            if (firValueParameter.isVararg) {\n                this.isFromVararg = true\n     "}
{"code": "       }\n            firValueParameter.correspondingProperty = this\n            this.fromPrimaryConstructor = true\n        }\n    }\n}\n"}
{"code": "// ISSUE: KT-64500\nimport kotlin.contracts.*\n\nfun getCondition(): Boolean = true\n\n@OptIn(ExperimentalContracts::class)\nfun test_1(f: () -> Unit) {\n    <!WRONG_INVOCATION_KIND!>contract { callsInPlace(f, InvocationKind.AT_LEAST_ONCE) }<!>\n    while (true) {\n        f()\n    }\n}\n\n@OptIn(ExperimentalContracts::class)\nfun test_2(f: () -> Unit) {\n    contract { callsInPlace(f, InvocationKind.AT_LEAST_ONCE) }\n    do {\n        f()\n    } while (true)\n}\n\n@OptIn(ExperimentalContracts::class)\nfun test_3(f: () -> Unit) {\n    <!WRONG_INVOCATION_KIND!>contract { callsInPlace(f, InvocationKind.AT_LEAST_ONCE) }<!>\n    while (getCondition()) {\n        f()\n    }\n}\n\n@OptIn(ExperimentalContracts::class)\nfun test_4(f: () -> Unit) {\n    contract { callsInPlace(f, InvocationKind.AT_LEAST_ONCE) }\n    do {\n        f()\n    } while (getCondition())\n}\n\n"}
{"code": "// WITH_STDLIB\n\n// callable: kotlin/collections/listOf\n// DO_NOT_CHECK_SYMBOL_RESTORE_K1"}
{"code": "class Foo {\n    class Bar {\n        fun bar() {\n            <caret>bar()\n        }\n    }\n}"}
{"code": "fun test(b: Any?): Int {\n    if (<expr>(b)</expr> is Boolean) {\n        return 54\n    } else if (b is Int) {\n        return 87\n    } else {\n        return 0\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.transformers.body.resolve\n\nimport org.jetbrains.kotlin.fir.FirCallResolver\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.util.PrivateForInline\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.expressions.FirLazyBlock\nimport org.jetbrains.kotlin.fir.expressions.FirLazyExpression\nimport org.jetbrains.kotlin.fir.expressions.FirStatement\nimport org.jetbrains.kotlin.fir.resolve.*\nimport org.jetbrains.kotlin.fir.resolve.calls.ResolutionContext\nimport org.jetbrains.kotlin.fir.resolve.calls.ResolutionStageRunner\nimport org.jetbrains.kotlin.fir.resolve.dfa.FirDataFlowAnalyzer\nimport org.jetbrains.kotlin.fir.resolve.inference.FirCallCompleter\nimport org.jetbrains.kotlin.fir.resolve.inference.InferenceComponents\nimport org.jetbrains.kotlin.fir.resolve.inference.inferenceComponents\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProvider\nimport org"}
{"code": ".jetbrains.kotlin.fir.resolve.providers.symbolProvider\nimport org.jetbrains.kotlin.fir.resolve.transformers.*\nimport org.jetbrains.kotlin.fir.scopes.FirScope\nimport org.jetbrains.kotlin.fir.scopes.impl.FirLocalScope\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.types.impl.FirImplicitTypeRefImplWithoutSource\nimport org.jetbrains.kotlin.fir.utils.exceptions.withFirEntry\nimport org.jetbrains.kotlin.utils.exceptions.errorWithAttachment\n\nabstract class FirAbstractBodyResolveTransformer(phase: FirResolvePhase) : FirAbstractPhaseTransformer<ResolutionMode>(phase) {\n    abstract val context: BodyResolveContext\n    abstract val components: BodyResolveTransformerComponents\n    abstract val resolutionContext: ResolutionContext\n\n    @set:PrivateForInline\n    abstract var implicitTypeOnly: Boolean\n        internal set\n\n    final override val session: FirSession get() = components.session\n\n    @OptIn(PrivateForInline::class)\n    internal inline fun <T> withFullBody"}
{"code": "Resolve(crossinline l: () -> T): T {\n        val shouldSwitchMode = implicitTypeOnly\n        if (shouldSwitchMode) {\n            implicitTypeOnly = false\n        }\n        return try {\n            l()\n        } finally {\n            if (shouldSwitchMode) {\n                implicitTypeOnly = true\n            }\n        }\n    }\n\n    override fun transformLazyExpression(lazyExpression: FirLazyExpression, data: ResolutionMode): FirStatement {\n        suppressOrThrowError(\"FirLazyExpression should be calculated before accessing\", lazyExpression)\n        return lazyExpression\n    }\n\n    override fun transformLazyBlock(lazyBlock: FirLazyBlock, data: ResolutionMode): FirStatement {\n        suppressOrThrowError(\"FirLazyBlock should be calculated before accessing\", lazyBlock)\n        return lazyBlock\n    }\n\n    private fun suppressOrThrowError(message: String, element: FirElement) {\n        if (System.getProperty(\"kotlin.suppress.lazy.expression.access\").toBoolean()) return\n        errorWithAttac"}
{"code": "hment(message) {\n            withFirEntry(\"firElement\", element)\n        }\n    }\n\n    protected inline val localScopes: List<FirLocalScope> get() = components.localScopes\n\n    protected inline val noExpectedType: FirTypeRef get() = components.noExpectedType\n\n    protected inline val symbolProvider: FirSymbolProvider get() = components.symbolProvider\n\n    protected inline val implicitReceiverStack: ImplicitReceiverStack get() = components.implicitReceiverStack\n    protected inline val inferenceComponents: InferenceComponents get() = session.inferenceComponents\n    protected inline val resolutionStageRunner: ResolutionStageRunner get() = components.resolutionStageRunner\n    protected inline val samResolver: FirSamResolver get() = components.samResolver\n    protected inline val typeResolverTransformer: FirSpecificTypeResolverTransformer get() = components.typeResolverTransformer\n    protected inline val callResolver: FirCallResolver get() = components.callResolver\n    protected inline val"}
{"code": " callCompleter: FirCallCompleter get() = components.callCompleter\n    inline val dataFlowAnalyzer: FirDataFlowAnalyzer get() = components.dataFlowAnalyzer\n    protected inline val scopeSession: ScopeSession get() = components.scopeSession\n    protected inline val file: FirFile get() = components.file\n\n    val ResolutionMode.expectedType: FirTypeRef?\n        get() = expectedType(components)\n\n    open class BodyResolveTransformerComponents(\n        override val session: FirSession,\n        override val scopeSession: ScopeSession,\n        val transformer: FirAbstractBodyResolveTransformerDispatcher,\n        val context: BodyResolveContext\n    ) : BodyResolveComponents() {\n        override val fileImportsScope: List<FirScope> get() = context.fileImportsScope\n        override val towerDataElements: List<FirTowerDataElement> get() = context.towerDataContext.towerDataElements\n        override val localScopes: FirLocalScopes get() = context.towerDataContext.localScopes\n\n        override val to"}
{"code": "werDataContext: FirTowerDataContext get() = context.towerDataContext\n\n        override val file: FirFile get() = context.file\n        override val implicitReceiverStack: ImplicitReceiverStack get() = context.implicitReceiverStack\n        override val containingDeclarations: List<FirDeclaration> get() = context.containers\n        override val returnTypeCalculator: ReturnTypeCalculator get() = context.returnTypeCalculator\n        override val container: FirDeclaration get() = context.containerIfAny!!\n\n        override val noExpectedType: FirTypeRef = FirImplicitTypeRefImplWithoutSource\n        override val symbolProvider: FirSymbolProvider = session.symbolProvider\n\n        override val resolutionStageRunner: ResolutionStageRunner = ResolutionStageRunner()\n\n        override val callResolver: FirCallResolver = FirCallResolver(\n            this,\n        )\n        val typeResolverTransformer = FirSpecificTypeResolverTransformer(\n            session\n        )\n        override val callComplete"}
{"code": "r: FirCallCompleter = FirCallCompleter(transformer, this)\n        override val dataFlowAnalyzer: FirDataFlowAnalyzer =\n            FirDataFlowAnalyzer.createFirDataFlowAnalyzer(this, context.dataFlowAnalyzerContext)\n        override val syntheticCallGenerator: FirSyntheticCallGenerator = FirSyntheticCallGenerator(this)\n        override val doubleColonExpressionResolver: FirDoubleColonExpressionResolver = FirDoubleColonExpressionResolver(session)\n        override val outerClassManager: FirOuterClassManager = FirOuterClassManager(session, context.outerLocalClassForNested)\n        override val samResolver: FirSamResolver = FirSamResolver(session, scopeSession, outerClassManager)\n        override val integerLiteralAndOperatorApproximationTransformer: IntegerLiteralAndOperatorApproximationTransformer =\n            IntegerLiteralAndOperatorApproximationTransformer(session, scopeSession)\n    }\n}\n"}
{"code": "<expr>enum class Enum(val i: Int) {\n    TEST(45),\n    PROBE(45),\n    SONDE(45)\n}</expr>"}
{"code": "// LANGUAGE: +ContextSensitiveEnumResolutionInWhen\nenum class Some {\n    FIRST,\n    SECOND;\n}\n\ntypealias Other = Some\n\nfun foo(o: Other) = when (o) {\n    FIRST -> 1\n    SECOND -> 2\n}\n"}
{"code": "fun foo(func: Int.(Int) -> Int) {}\n\nfun test() {\n    foo {\n        this + it\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.range\n\nimport org.jetbrains.kotlin.codegen.AsmUtil\nimport org.jetbrains.kotlin.codegen.StackValue\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\n\n\nclass BoundedValue(\n    val lowBound: StackValue,\n    val isLowInclusive: Boolean = true,\n    val highBound: StackValue,\n    val isHighInclusive: Boolean = true\n) {\n\n    // It is necessary to maintain the proper evaluation order as of Kotlin 1.0 and 1.1\n    // to evaluate range bounds left to right and put them on stack as 'high; low'.\n    fun putHighLow(v: InstructionAdapter, type: Type) {\n        if (!lowBound.canHaveSideEffects() || !highBound.canHaveSideEffects()) {\n            highBound.put(type, v)\n            lowBound.put(type, v)\n        } else {\n            lowBound.put(type, v)\n            highBound.put(type, v)\n            AsmUtil.swap(v, type, type)\n        }\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.scopes.impl\n\nimport org.jetbrains.kotlin.config.LanguageVersionSettings\nimport org.jetbrains.kotlin.resolve.DefaultImportProvider\nimport org.jetbrains.kotlin.resolve.ImportPath\n\nenum class DefaultImportPriority {\n    HIGH {\n        override fun getAllDefaultImports(\n            defaultImportProvider: DefaultImportProvider?,\n            languageVersionSettings: LanguageVersionSettings\n        ): List<ImportPath>? =\n            defaultImportProvider?.getDefaultImports(languageVersionSettings, includeLowPriorityImports = false)\n    },\n    LOW {\n        override fun getAllDefaultImports(\n            defaultImportProvider: DefaultImportProvider?,\n            languageVersionSettings: LanguageVersionSettings\n        ): List<ImportPath>? =\n            defaultImportProvider?.defaultLowPriorityImports\n    };\n\n    abstract fun getAllDefaultImports(\n        defaultImportProvider: DefaultImportProvider?,\n        languageVersionSettings: LanguageVersionSettings\n   "}
{"code": " ): List<ImportPath>?\n}\n"}
{"code": "package test\n\nfun usage(list: List<Int>) {\n    for (<expr>loopVar</expr> in list) {}\n}"}
{"code": "fun case(): String {\n    val x0 = false\n    val x1: String\n    val x: Boolean\n    try {\n        <!VAL_REASSIGNMENT!>x0<!> = (throw Exception()) || true  //VAL_REASSIGNMENT should be\n        !<!UNINITIALIZED_VARIABLE!>x<!> //ok, unreachable code   UNINITIALIZED_VARIABLE should be\n        val a: Int = <!UNINITIALIZED_VARIABLE!>x1<!>.toInt() //ok, unreachable code UNINITIALIZED_VARIABLE should be\n    } catch (e: Exception) {\n        return \"OK\"\n    }\n    return \"NOK\"\n}\n"}
{"code": "fun myFun(i: Int): String = i.toString()\n\nfun test() {\n    ::<expr>myFun</expr>\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol\n\nclass FirIdRendererBasedSymbolRenderer : FirSymbolRenderer() {\n    override fun printReference(symbol: FirBasedSymbol<*>) {\n        when (symbol) {\n            is FirCallableSymbol<*> -> components.idRenderer.renderCallableId(symbol.callableId)\n            is FirClassLikeSymbol<*> -> components.idRenderer.renderClassId(symbol.classId)\n            else -> super.printReference(symbol)\n        }\n    }\n}"}
{"code": "// FILE: first/Some.java\n\npackage first;\n\npublic class Some {\n    public static void foo() {}\n}\n\n// FILE: second/Some.java\n\npackage second;\n\n class Some {\n    public static void bar() {}\n}\n\n// FILE: test/test.kt\n\npackage test\n\nimport first.*\nimport second.*\n\nfun test() {\n    Some.foo()\n}\n"}
{"code": "// SKIP_WHEN_OUT_OF_CONTENT_ROOT\n// MODULE: dependency\n// MODULE_KIND: LibraryBinary\n// FILE: dependency.kt\ninterface ToSubstitute\n\ninterface Intermediate : ToSubstitute\n\n// MODULE: main(dependency)\n// FILE: main.kt\ninterface ToSubs<caret>titute : Main\n\ninterface Main : Intermediate\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.optimization.common\n\nimport org.jetbrains.kotlin.codegen.inline.insnText\nimport org.jetbrains.kotlin.utils.SmartList\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.tree.*\nimport org.jetbrains.org.objectweb.asm.tree.analysis.AnalyzerException\nimport org.jetbrains.org.objectweb.asm.tree.analysis.Frame\nimport org.jetbrains.org.objectweb.asm.tree.analysis.Interpreter\nimport org.jetbrains.org.objectweb.asm.tree.analysis.Value\n\nabstract class FastAnalyzer<V : Value, F : Frame<V>>(\n    private val owner: String,\n    private val method: MethodNode,\n    private val interpreter: Interpreter<V>,\n    private val pruneExceptionEdges: Boolean,\n    private val useFastComputeExceptionHandlers: Boolean,\n    private val useFastMergeControlFlowEdge: Boolean,\n    private val newFrame: (Int, Int) -> F\n) {\n    private val nInsns = method.instructions.size()\n    private val frames: Array<"}
{"code": "Frame<V>?> = arrayOfNulls(nInsns)\n\n    private val handlers: Array<MutableList<TryCatchBlockNode>?> = arrayOfNulls(nInsns)\n    private val isTcbStart = BooleanArray(nInsns)\n    private val isMergeNode = findMergeNodes(method)\n\n    private val queued = BooleanArray(nInsns)\n    private val queue = IntArray(nInsns)\n    private var top = 0\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun getFrame(insn: AbstractInsnNode): F? = frames[insn.indexOf()] as? F\n\n    fun analyze(): Array<Frame<V>?> {\n        if (nInsns == 0) return frames\n\n        checkAssertions()\n        computeExceptionHandlers(method)\n\n        for (tcb in method.tryCatchBlocks) {\n            isTcbStart[tcb.start.indexOf() + 1] = true\n        }\n\n        beforeAnalyze()\n\n        analyzeMainLoop()\n\n        return frames\n    }\n\n    private fun analyzeMainLoop() {\n        val current = newFrame(method.maxLocals, method.maxStack)\n        val handler = newFrame(method.maxLocals, method.maxStack)\n        initLocals(current)\n        mergeContr"}
{"code": "olFlowEdge(0, current)\n\n        while (top > 0) {\n            val insn = queue[--top]\n\n            @Suppress(\"UNCHECKED_CAST\")\n            val f = frames[insn] as F\n            queued[insn] = false\n\n            val insnNode = method.instructions[insn]\n\n            try {\n                analyzeInstruction(insnNode, insn, f, current, handler)\n            } catch (e: AnalyzerException) {\n                throw AnalyzerException(\n                    e.node,\n                    \"Error at instruction #$insn ${insnNode.insnText(method.instructions)}: ${e.message}\\ncurrent: ${current.dump()}\",\n                    e\n                )\n            } catch (e: Exception) {\n                throw AnalyzerException(\n                    insnNode,\n                    \"Error at instruction #$insn ${insnNode.insnText(method.instructions)}: ${e.message}\\ncurrent: ${current.dump()}\",\n                    e\n                )\n            }\n        }\n    }\n\n    private fun analyzeInstruction(\n        insnNode: "}
{"code": "AbstractInsnNode,\n        insnIndex: Int,\n        currentlyAnalyzing: F,\n        current: F,\n        handler: F\n    ) {\n        val insnOpcode = insnNode.opcode\n        val insnType = insnNode.nodeType\n\n        if (insnType == AbstractInsnNode.LABEL ||\n            insnType == AbstractInsnNode.LINE ||\n            insnType == AbstractInsnNode.FRAME ||\n            insnOpcode == Opcodes.NOP\n        ) {\n            visitNopInsn(insnNode, currentlyAnalyzing, insnIndex)\n        } else {\n            current.init(currentlyAnalyzing)\n            if (insnOpcode != Opcodes.RETURN) {\n                // Don't care about possibly incompatible return type\n                current.execute(insnNode, interpreter)\n            }\n            visitMeaningfulInstruction(insnNode, insnType, insnOpcode, current, insnIndex)\n        }\n\n        // Jump by an exception edge clears the stack, putting exception on top.\n        // So, unless we have a store operation, anything we change on stack would be lost,\n        "}
{"code": "// and there's no need to analyze exception handler again.\n        // Add an exception edge from TCB start to make sure handler itself is still visited.\n        if (!pruneExceptionEdges ||\n            insnOpcode in Opcodes.ISTORE..Opcodes.ASTORE ||\n            insnOpcode == Opcodes.IINC ||\n            isTcbStart[insnIndex]\n        ) {\n            handlers[insnIndex]?.forEach { tcb ->\n                val exnType = Type.getObjectType(tcb.type ?: \"java/lang/Throwable\")\n                val jump = tcb.handler.indexOf()\n\n                handler.init(currentlyAnalyzing)\n                if (handler.maxStackSize > 0) {\n                    handler.clearStack()\n                    handler.push(interpreter.newExceptionValue(tcb, handler, exnType))\n                }\n                mergeControlFlowEdge(jump, handler)\n            }\n        }\n    }\n\n    private fun checkAssertions() {\n        if (method.instructions.any { it.opcode == Opcodes.JSR || it.opcode == Opcodes.RET })\n            throw Asser"}
{"code": "tionError(\"Subroutines are deprecated since Java 6\")\n    }\n\n    private fun computeExceptionHandlers(m: MethodNode) {\n        for (tcb in m.tryCatchBlocks) {\n            if (useFastComputeExceptionHandlers) computeExceptionHandlerFast(tcb) else computeExceptionHandlersForEachInsn(tcb)\n        }\n    }\n\n    private fun computeExceptionHandlersForEachInsn(tcb: TryCatchBlockNode) {\n        var current: AbstractInsnNode = tcb.start\n        val end = tcb.end\n\n        while (current != end) {\n            if (current.isMeaningful) {\n                val currentIndex = current.indexOf()\n                var insnHandlers: MutableList<TryCatchBlockNode>? = handlers[currentIndex]\n                if (insnHandlers == null) {\n                    insnHandlers = SmartList()\n                    handlers[currentIndex] = insnHandlers\n                }\n                insnHandlers.add(tcb)\n            }\n            current = current.next\n        }\n    }\n\n    private fun computeExceptionHandlerFast(tcb: TryCa"}
{"code": "tchBlockNode) {\n        val start = tcb.start.indexOf()\n        var insnHandlers: MutableList<TryCatchBlockNode>? = handlers[start]\n        if (insnHandlers == null) {\n            insnHandlers = ArrayList()\n            handlers[start] = insnHandlers\n        }\n        insnHandlers.add(tcb)\n    }\n\n    protected open fun beforeAnalyze() {}\n\n    private fun initLocals(current: F) {\n        current.setReturn(interpreter.newReturnTypeValue(Type.getReturnType(method.desc)))\n        val args = Type.getArgumentTypes(method.desc)\n        var local = 0\n        val isInstanceMethod = (method.access and Opcodes.ACC_STATIC) == 0\n        if (isInstanceMethod) {\n            val ctype = Type.getObjectType(owner)\n            current.setLocal(local, interpreter.newParameterValue(true, local, ctype))\n            local++\n        }\n        for (arg in args) {\n            current.setLocal(local, interpreter.newParameterValue(isInstanceMethod, local, arg))\n            local++\n            if (arg.size == 2) {\n"}
{"code": "                current.setLocal(local, interpreter.newEmptyValue(local))\n                local++\n            }\n        }\n        while (local < method.maxLocals) {\n            current.setLocal(local, interpreter.newEmptyValue(local))\n            local++\n        }\n    }\n\n    protected open fun visitControlFlowEdge(insnNode: AbstractInsnNode, successor: Int): Boolean = true\n\n    private fun processControlFlowEdge(current: F, insnNode: AbstractInsnNode, jump: Int, canReuse: Boolean = false) {\n        if (visitControlFlowEdge(insnNode, jump)) {\n            mergeControlFlowEdge(jump, current, canReuse)\n        }\n    }\n\n    private fun mergeControlFlowEdge(dest: Int, frame: F, canReuse: Boolean = false) {\n        if (useFastMergeControlFlowEdge) {\n            fastMergeControlFlowEdge(dest, frame, canReuse)\n        } else {\n            fullMergeControlFlowEdge(dest, frame, canReuse)\n        }\n    }\n\n    \n    private fun fullMergeControlFlowEdge(dest: Int, frame: F, canReuse: Boolean = false)"}
{"code": " {\n        val oldFrame = frames[dest]\n        val changes = when {\n            canReuse && !isMergeNode[dest] -> {\n                frames[dest] = frame\n                true\n            }\n            oldFrame == null -> {\n                frames[dest] = newFrame(frame.locals, frame.maxStackSize).apply { init(frame) }\n                true\n            }\n            !isMergeNode[dest] -> {\n                oldFrame.init(frame)\n                true\n            }\n            else -> try {\n                oldFrame.merge(frame, interpreter)\n            } catch (e: AnalyzerException) {\n                throw AnalyzerException(null, \"${e.message}\\nframe: ${frame.dump()}\\noldFrame: ${oldFrame.dump()}\")\n            }\n        }\n        updateQueue(changes, dest)\n    }\n\n    private fun fastMergeControlFlowEdge(dest: Int, frame: F, canReuse: Boolean) {\n        val oldFrame = frames[dest]\n        val changes = when {\n            oldFrame == null -> {\n                frames[dest] = if (canReuse && !isMer"}
{"code": "geNode[dest]) {\n                    frame\n                } else {\n                    newFrame(frame.locals, frame.maxStackSize).apply { init(frame) }\n                }\n                true\n            }\n            else -> false\n        }\n        updateQueue(changes, dest)\n    }\n\n    private fun updateQueue(changes: Boolean, dest: Int) {\n        if (changes && !queued[dest]) {\n            queued[dest] = true\n            queue[top++] = dest\n        }\n    }\n\n    private fun visitMeaningfulInstruction(insnNode: AbstractInsnNode, insnType: Int, insnOpcode: Int, current: F, insn: Int) {\n        when {\n            insnType == AbstractInsnNode.JUMP_INSN ->\n                visitJumpInsnNode(insnNode as JumpInsnNode, current, insn, insnOpcode)\n            insnType == AbstractInsnNode.LOOKUPSWITCH_INSN ->\n                visitLookupSwitchInsnNode(insnNode as LookupSwitchInsnNode, current)\n            insnType == AbstractInsnNode.TABLESWITCH_INSN ->\n                visitTableSwitchInsnNode(insn"}
{"code": "Node as TableSwitchInsnNode, current)\n            insnOpcode != Opcodes.ATHROW && (insnOpcode < Opcodes.IRETURN || insnOpcode > Opcodes.RETURN) ->\n                visitOpInsn(insnNode, current, insn)\n            else -> {\n            }\n        }\n    }\n\n    private fun visitNopInsn(insnNode: AbstractInsnNode, current: F, insn: Int) {\n        processControlFlowEdge(current, insnNode, insn + 1, canReuse = true)\n    }\n\n    private fun visitOpInsn(insnNode: AbstractInsnNode, current: F, insn: Int) {\n        processControlFlowEdge(current, insnNode, insn + 1)\n    }\n\n    private fun visitTableSwitchInsnNode(insnNode: TableSwitchInsnNode, current: F) {\n        processControlFlowEdge(current, insnNode, insnNode.dflt.indexOf())\n        // In most cases order of visiting switch labels should not matter\n        // The only one is a tableswitch being added in the beginning of coroutine method, these switch' labels may lead\n        // in the middle of try/catch block, and FastAnalyzer is not ready f"}
{"code": "or this (trying to restore stack before it was saved)\n        // So we just fix the order of labels being traversed: the first one should be one at the method beginning\n        // Using 'asReversed' is because nodes are processed in LIFO order\n        for (label in insnNode.labels.asReversed()) {\n            processControlFlowEdge(current, insnNode, label.indexOf())\n        }\n    }\n\n    private fun visitLookupSwitchInsnNode(insnNode: LookupSwitchInsnNode, current: F) {\n        processControlFlowEdge(current, insnNode, insnNode.dflt.indexOf())\n        for (label in insnNode.labels) {\n            processControlFlowEdge(current, insnNode, label.indexOf())\n        }\n    }\n\n    private fun visitJumpInsnNode(insnNode: JumpInsnNode, current: F, insn: Int, insnOpcode: Int) {\n        if (insnOpcode != Opcodes.GOTO) {\n            processControlFlowEdge(current, insnNode, insn + 1)\n        }\n        processControlFlowEdge(current, insnNode, insnNode.label.indexOf())\n    }\n\n    protected fun Abstr"}
{"code": "actInsnNode.indexOf() =\n        method.instructions.indexOf(this)\n\n    private fun Frame<V>.dump(): String {\n        return buildString {\n            append(\"{\\n\")\n            append(\"  locals: [\\n\")\n            for (i in 0 until method.maxLocals) {\n                append(\"    #$i: ${this@dump.getLocal(i)}\\n\")\n            }\n            append(\"  ]\\n\")\n            val stackSize = this@dump.stackSize\n            append(\"  stack: size=\")\n            append(stackSize)\n            if (stackSize == 0) {\n                append(\" []\\n\")\n            } else {\n                append(\" [\\n\")\n                for (i in 0 until stackSize) {\n                    append(\"    #$i: ${this@dump.getStack(i)}\\n\")\n                }\n                append(\"  ]\\n\")\n            }\n            append(\"}\\n\")\n        }\n    }\n\n    companion object {\n        fun findMergeNodes(method: MethodNode): BooleanArray {\n            val isMergeNode = BooleanArray(method.instructions.size())\n            for (insn in method.inst"}
{"code": "ructions) {\n                when (insn.nodeType) {\n                    AbstractInsnNode.JUMP_INSN -> {\n                        val jumpInsn = insn as JumpInsnNode\n                        isMergeNode[method.instructions.indexOf(jumpInsn.label)] = true\n                    }\n                    AbstractInsnNode.LOOKUPSWITCH_INSN -> {\n                        val switchInsn = insn as LookupSwitchInsnNode\n                        isMergeNode[method.instructions.indexOf(switchInsn.dflt)] = true\n                        for (label in switchInsn.labels) {\n                            isMergeNode[method.instructions.indexOf(label)] = true\n                        }\n                    }\n                    AbstractInsnNode.TABLESWITCH_INSN -> {\n                        val switchInsn = insn as TableSwitchInsnNode\n                        isMergeNode[method.instructions.indexOf(switchInsn.dflt)] = true\n                        for (label in switchInsn.labels) {\n                            isMergeNode[me"}
{"code": "thod.instructions.indexOf(label)] = true\n                        }\n                    }\n                }\n            }\n            for (tcb in method.tryCatchBlocks) {\n                isMergeNode[method.instructions.indexOf(tcb.handler)] = true\n            }\n            return isMergeNode\n        }\n    }\n}"}
{"code": "fun <AAA> (list: List<AAA>) {\n   println(<expr>list</expr>)\n}"}
{"code": "class Problem constru<caret>ctor() {\n    fun foo(i: Int) {\n\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.components\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.analysis.api.components.KtExpressionTypeProvider\nimport org.jetbrains.kotlin.analysis.api.fir.KtFirAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.fir.unwrapSafeCall\nimport org.jetbrains.kotlin.analysis.api.fir.utils.unwrap\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken\nimport org.jetbrains.kotlin.analysis.api.types.KtErrorType\nimport org.jetbrains.kotlin.analysis.api.types.KtFunctionalType\nimport org.jetbrains.kotlin.analysis.api.types.KtType\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.getOrBuildFir\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.getOrBuildFirSafe\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.resolveToFirSymbol\nimport org.jetbrains.kotlin.analysis.utils.errors.unexpectedElementError\nimport org.jetbrains.kotlin.fir.*\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrain"}
{"code": "s.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.references.FirNamedReference\nimport org.jetbrains.kotlin.fir.references.FirResolvedNamedReference\nimport org.jetbrains.kotlin.fir.references.FirSuperReference\nimport org.jetbrains.kotlin.fir.resolve.constructFunctionType\nimport org.jetbrains.kotlin.fir.resolve.substitution.ConeSubstitutor\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.fir.utils.exceptions.withFirEntry\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.psi\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.psi.psiUtil.getOutermostParenthesizerOrThis\nimport org.jetbrains.kotlin.util.OperatorNameConventions\nimport org.jetbrains.kotlin.utils.addToStdlib.applyIf\nimport org.jetbrains.kotlin.utils.exceptions.rethrowExceptionWithDetails\nimport org.jetbrains.kotlin.utils.exceptions.withPsiEntry\n\ninternal class KtFirExpressionTypeProvider(\n    override val anal"}
{"code": "ysisSession: KtFirAnalysisSession,\n    override val token: KtLifetimeToken,\n) : KtExpressionTypeProvider(), KtFirAnalysisSessionComponent {\n\n    override fun getKtExpressionType(expression: KtExpression): KtType? {\n        // There are various cases where we have no corresponding fir due to invalid code\n        // Some examples:\n        // ```\n        // when {\n        //   true, false -> {}\n        // }\n        // ```\n        // `false` does not have a corresponding elements on the FIR side and hence the containing `FirWhenBranch` is returned.\n        // ```\n        // @Volatile\n        // private var\n        // ```\n        // Volatile does not have corresponding element, so `FirFileImpl` is returned\n        val fir = expression.unwrap().getOrBuildFir(firResolveSession) ?: return null\n        return try {\n            getKtExpressionType(expression, fir)\n        } catch (e: Exception) {\n            rethrowExceptionWithDetails(\"Exception during resolving ${expression::class.simpleName}\""}
{"code": ", e) {\n                withPsiEntry(\"expression\", expression)\n                withFirEntry(\"fir\", fir)\n            }\n        }\n    }\n\n    private fun getKtExpressionType(expression: KtExpression, fir: FirElement): KtType? = when (fir) {\n        is FirFunctionCall -> getReturnTypeForArrayStyleAssignmentTarget(expression, fir) ?: fir.resolvedType.asKtType()\n        is FirPropertyAccessExpression -> {\n            // For unresolved `super`, we manually create an intersection type so that IDE features like completion can work correctly.\n            val containingClass = (fir.dispatchReceiver as? FirThisReceiverExpression)?.calleeReference?.boundSymbol as? FirClassSymbol<*>\n\n            if (fir.calleeReference is FirSuperReference && fir.resolvedType is ConeErrorType && containingClass != null) {\n                val superTypes = containingClass.resolvedSuperTypes\n                when (superTypes.size) {\n                    0 -> analysisSession.builtinTypes.ANY\n                    1 -> superT"}
{"code": "ypes.single().asKtType()\n                    else -> ConeIntersectionType(superTypes).asKtType()\n                }\n            } else {\n                fir.resolvedType.asKtType()\n            }\n        }\n        is FirVariableAssignment -> {\n            if (fir.lValue.source?.psi == expression) {\n                fir.lValue.resolvedType.asKtType()\n            } else if (expression is KtUnaryExpression && expression.operationToken in KtTokens.INCREMENT_AND_DECREMENT) {\n                fir.rValue.resolvedType.asKtType()\n            } else {\n                analysisSession.builtinTypes.UNIT\n            }\n        }\n        is FirExpression -> fir.resolvedType.asKtType()\n        is FirNamedReference -> fir.getCorrespondingTypeIfPossible()?.asKtType()\n        is FirStatement -> with(analysisSession) { builtinTypes.UNIT }\n        is FirTypeRef, is FirImport, is FirPackageDirective, is FirLabel, is FirTypeParameterRef -> null\n\n        // `listOf<_>(1)` where `expression` is `_`\n        is FirPl"}
{"code": "aceholderProjection -> null\n        else -> null\n    }\n\n    \n    private fun FirNamedReference.getCorrespondingTypeIfPossible(): ConeKotlinType? =\n        findOuterPropertyAccessExpression()?.resolvedType\n\n    \n    private fun FirNamedReference.findOuterPropertyAccessExpression(): FirExpression? {\n        val referenceExpression = psi as? KtExpression ?: return null\n        val outerExpression = referenceExpression.getOutermostParenthesizerOrThis().parent as? KtElement ?: return null\n\n        return when (val outerFirElement = outerExpression.getOrBuildFir(firResolveSession)) {\n            is FirVariableAssignment -> outerFirElement.lValue\n            is FirPropertyAccessExpression -> outerFirElement\n            is FirImplicitInvokeCall -> outerFirElement.explicitReceiver\n            is FirSafeCallExpression -> {\n                if (outerFirElement.selector is FirPropertyAccessExpression) outerFirElement else null\n            }\n            else -> null\n        }\n    }\n\n    private fun "}
{"code": "getReturnTypeForArrayStyleAssignmentTarget(\n        expression: KtExpression,\n        fir: FirFunctionCall,\n    ): KtType? {\n        // When we're in a call like `a[x] = y`, we want to get the `set` call's last argument's type.\n        if (fir.calleeReference !is FirResolvedNamedReference || fir.calleeReference.name != OperatorNameConventions.SET) return null\n        if (expression !is KtArrayAccessExpression) return null\n        val assignment = expression.parent as? KtBinaryExpression ?: return null\n        if (assignment.operationToken !in KtTokens.ALL_ASSIGNMENTS) return null\n        if (assignment.left != expression) return null\n        val setTargetParameterType = fir.argumentsToSubstitutedValueParameters()?.values?.lastOrNull()?.substitutedType ?: return null\n        return setTargetParameterType.asKtType()\n    }\n\n    private data class SubstitutedValueParameter(val parameter: FirValueParameter, val substitutedType: ConeKotlinType)\n\n    private fun FirCall.argumentsToSubstituted"}
{"code": "ValueParameters(\n        substituteWithErrorTypes: Boolean = true,\n    ): LinkedHashMap<FirExpression, SubstitutedValueParameter>? {\n        val substitutor = (this as? FirQualifiedAccessExpression)\n            ?.createConeSubstitutorFromTypeArguments(rootModuleSession, discardErrorTypes = !substituteWithErrorTypes)\n            ?: ConeSubstitutor.Empty\n\n        return resolvedArgumentMapping?.mapValuesTo(LinkedHashMap()) { (_, parameter) ->\n            SubstitutedValueParameter(parameter, substitutor.substituteOrSelf(parameter.returnTypeRef.coneType))\n        }\n    }\n\n    override fun getReturnTypeForKtDeclaration(declaration: KtDeclaration): KtType {\n        val firDeclaration = if (declaration is KtParameter && declaration.ownerFunction == null) {\n            declaration.getOrBuildFir(firResolveSession)\n        } else {\n            declaration.resolveToFirSymbol(firResolveSession, FirResolvePhase.TYPES).fir\n        }\n        return when (firDeclaration) {\n            is FirCallableDe"}
{"code": "claration -> firDeclaration.symbol.resolvedReturnType.asKtType()\n            is FirFunctionTypeParameter -> firDeclaration.returnTypeRef.coneType.asKtType()\n            else -> unexpectedElementError<FirElement>(firDeclaration)\n        }\n    }\n\n    override fun getFunctionalTypeForKtFunction(declaration: KtFunction): KtType {\n        val firFunction = declaration.resolveToFirSymbol(firResolveSession, FirResolvePhase.TYPES).fir as FirFunction\n        firFunction.symbol.calculateReturnType()\n        return firFunction.constructFunctionType(firFunction.specialFunctionTypeKind(firResolveSession.useSiteFirSession)).asKtType()\n    }\n\n    override fun getExpectedType(expression: PsiElement): KtType? {\n        val unwrapped = expression.unwrap()\n        val expectedType = getExpectedTypeByReturnExpression(unwrapped)\n            ?: getExpressionTypeByIfOrBooleanCondition(unwrapped)\n            ?: getExpectedTypeByTypeCast(unwrapped)\n            ?: getExpectedTypeOfFunctionParameter(unwrapped)\n "}
{"code": "           ?: getExpectedTypeOfIndexingParameter(unwrapped)\n            ?: getExpectedTypeOfInfixFunctionParameter(unwrapped)\n            ?: getExpectedTypeByVariableAssignment(unwrapped)\n            ?: getExpectedTypeByPropertyDeclaration(unwrapped)\n            ?: getExpectedTypeByFunctionExpressionBody(unwrapped)\n            ?: getExpectedTypeOfLastStatementInBlock(unwrapped)\n            ?: getExpectedTypeByIfExpression(unwrapped)\n            ?: getExpectedTypeOfWhenEntryExpression(unwrapped)\n            ?: getExpectedTypeByTryExpression(unwrapped)\n            ?: getExpectedTypeOfElvisOperand(unwrapped)\n            ?: getExpectedTypeByWhenEntryValue(unwrapped)\n        return expectedType\n    }\n\n    private fun getExpectedTypeByTypeCast(expression: PsiElement): KtType? {\n        val typeCastExpression =\n            expression.unwrapQualified<KtBinaryExpressionWithTypeRHS> { castExpr, expr -> castExpr.left == expr } ?: return null\n        return getKtExpressionType(typeCastExpression)\n"}
{"code": "    }\n\n    private fun getExpectedTypeOfFunctionParameter(expression: PsiElement): KtType? {\n        val (ktCallElement, argumentExpression) = expression.getFunctionCallAsWithThisAsParameter() ?: return null\n        val firCall = ktCallElement.getOrBuildFir(firResolveSession)?.unwrapSafeCall() as? FirCall ?: return null\n\n        val callee = (firCall.toReference(firResolveSession.useSiteFirSession) as? FirResolvedNamedReference)?.resolvedSymbol\n        if (callee?.fir?.origin == FirDeclarationOrigin.SamConstructor) {\n            val substitutor = (firCall as? FirQualifiedAccessExpression)\n                ?.createConeSubstitutorFromTypeArguments(rootModuleSession, discardErrorTypes = true)\n                ?: ConeSubstitutor.Empty\n            return substitutor.substituteOrSelf((callee.fir as FirSimpleFunction).returnTypeRef.coneType).asKtType()\n        }\n\n        val argumentsToParameters = firCall.argumentsToSubstitutedValueParameters(substituteWithErrorTypes = false) ?: return null\n  "}
{"code": "      val (firParameterForExpression, substitutedType) =\n            argumentsToParameters.entries.firstOrNull { (arg, _) ->\n                when (arg) {\n                    // TODO: better to utilize. See `createArgumentMapping` in [KtFirCallResolver]\n                    is FirNamedArgumentExpression, is FirSpreadArgumentExpression ->\n                        arg.psi == argumentExpression.parent\n                    else ->\n                        arg.psi == argumentExpression\n                }\n            }?.value ?: return null\n        return if (firParameterForExpression.isVararg)\n            substitutedType.varargElementType().asKtType()\n        else\n            substitutedType.asKtType()\n    }\n\n    \n    private fun getExpectedTypeOfIndexingParameter(expression: PsiElement): KtType? {\n        val arrayAccessExpression = expression.unwrapQualified<KtArrayAccessExpression> { arrayAccessExpression, currentExpression ->\n            currentExpression in arrayAccessExpression.indexExpress"}
{"code": "ions\n        } ?: return null\n        val firCall = arrayAccessExpression.getOrBuildFirSafe<FirFunctionCall>(firResolveSession) ?: return null\n        val firArgument = firCall.argumentList.arguments.firstOrNull { it.psi == expression } ?: return null\n\n        val argumentsToParameters = firCall.argumentsToSubstitutedValueParameters(substituteWithErrorTypes = false) ?: return null\n        return argumentsToParameters[firArgument]?.substitutedType?.asKtType()\n    }\n\n    private fun PsiElement.getFunctionCallAsWithThisAsParameter(): KtCallWithArgument? {\n        val valueArgument = unwrapQualified<KtValueArgument> { valueArg, expr ->\n            // If `valueArg` is [KtLambdaArgument], its [getArgumentExpression] could be labeled expression (e.g., l@{ ... }).\n            // That is not exactly `expr`, which would be [KtLambdaExpression]. So, we need [unwrap] here.\n            valueArg.getArgumentExpression()?.unwrap() == expr\n        } ?: return null\n        val callExpression =\n         "}
{"code": "   (valueArgument.parent as? KtValueArgumentList)?.parent as? KtCallElement\n                ?: valueArgument.parent as? KtCallElement // KtLambdaArgument\n                ?: return null\n        val argumentExpression = valueArgument.getArgumentExpression() ?: return null\n        return KtCallWithArgument(callExpression, argumentExpression)\n    }\n\n    private fun getExpectedTypeOfInfixFunctionParameter(expression: PsiElement): KtType? {\n        val infixCallExpression =\n            expression.unwrapQualified<KtBinaryExpression> { binaryExpr, expr -> binaryExpr.right == expr } ?: return null\n        val firCall = infixCallExpression.getOrBuildFirSafe<FirFunctionCall>(firResolveSession) ?: return null\n\n        // There is only one parameter for infix functions; get its type\n        val argumentsToParameters = firCall.argumentsToSubstitutedValueParameters(substituteWithErrorTypes = false) ?: return null\n        return argumentsToParameters.values.singleOrNull()?.substitutedType?.asKtType()\n"}
{"code": "    }\n\n    private fun getExpectedTypeByReturnExpression(expression: PsiElement): KtType? {\n        val returnParent = expression.getReturnExpressionWithThisType() ?: return null\n        val targetSymbol = with(analysisSession) { returnParent.getReturnTargetSymbol() } ?: return null\n        return targetSymbol.returnType\n    }\n\n    private fun PsiElement.getReturnExpressionWithThisType(): KtReturnExpression? =\n        unwrapQualified { returnExpr, target -> returnExpr.returnedExpression == target }\n\n    private fun getExpressionTypeByIfOrBooleanCondition(expression: PsiElement): KtType? = when {\n        expression.isWhileLoopCondition() || expression.isIfCondition() -> with(analysisSession) { builtinTypes.BOOLEAN }\n        else -> null\n    }\n\n    private fun getExpectedTypeByVariableAssignment(expression: PsiElement): KtType? {\n        // Given: `x = expression`\n        // Expected type of `expression` is type of `x`\n        val assignmentExpression =\n            expression.unwrapQuali"}
{"code": "fied<KtBinaryExpression> { binaryExpr, expr -> binaryExpr.right == expr && binaryExpr.operationToken == KtTokens.EQ }\n                ?: return null\n        val variableExpression = assignmentExpression.left as? KtNameReferenceExpression ?: return null\n        return getKtExpressionNonErrorType(variableExpression)\n    }\n\n    private fun getExpectedTypeByPropertyDeclaration(expression: PsiElement): KtType? {\n        // Given: `val x: T = expression`\n        // Expected type of `expression` is `T`\n        val property = expression.unwrapQualified<KtProperty> { property, expr -> property.initializer == expr } ?: return null\n        if (property.typeReference == null) return null\n        return getReturnTypeForKtDeclaration(property).nonErrorTypeOrNull()\n    }\n\n    private fun getExpectedTypeByFunctionExpressionBody(expression: PsiElement): KtType? {\n        // Given: `fun f(): T = expression`\n        // Expected type of `expression` is `T`\n        val function = expression.unwrapQualified"}
{"code": "<KtFunction> { function, expr -> function.bodyExpression == expr } ?: return null\n        if (function.bodyBlockExpression != null) {\n            // Given `fun f(...): R { blockExpression }`, `{ blockExpression }` is mapped to the enclosing anonymous function,\n            // which may raise an exception if we attempt to retrieve, e.g., callable declaration from it.\n            return null\n        }\n        if (function.typeReference == null) return null\n        return getReturnTypeForKtDeclaration(function).nonErrorTypeOrNull()\n    }\n\n    private fun getExpectedTypeOfLastStatementInBlock(expression: PsiElement): KtType? {\n        val blockExpression = expression.unwrapQualified<KtBlockExpression> { blockExpression, currentExpression ->\n            currentExpression == blockExpression.statements.lastOrNull()\n        } ?: return null\n\n        val functionLiteral = blockExpression.parent as? KtFunctionLiteral\n        return if (functionLiteral != null) {\n            val functionalType = g"}
{"code": "etExpectedType(functionLiteral) as? KtFunctionalType\n            functionalType?.returnType\n        } else {\n            getExpectedType(blockExpression)\n        }\n    }\n\n    private fun getExpectedTypeByIfExpression(expression: PsiElement): KtType? {\n        val ifExpression = expression.unwrapQualified<KtIfExpression> { ifExpression, currentExpression ->\n            currentExpression == ifExpression.then || currentExpression == ifExpression.`else`\n        } ?: return null\n        getExpectedType(ifExpression)?.let { return it }\n\n        // if `KtIfExpression` doesn't have an expected type, get the expected type of the current branch from the other branch\n        val otherBranch = (if (expression == ifExpression.then) ifExpression.`else` else ifExpression.then) ?: return null\n        return getKtExpressionNonErrorType(otherBranch)\n    }\n\n    private fun getExpectedTypeOfWhenEntryExpression(expression: PsiElement): KtType? {\n        val whenEntry = expression.unwrapQualified<KtWhenEntr"}
{"code": "y> { whenEntry, currentExpression ->\n            currentExpression == whenEntry.expression\n        } ?: return null\n        val whenExpression = whenEntry.parent as? KtWhenExpression ?: return null\n        getExpectedType(whenExpression)?.let { return it }\n\n        // if `KtWhenExpression` doesn't have an expected type, get the expected type of the current entry from the other entries\n        val entryExpressions = whenExpression.entries\n            .mapNotNull { it.expression }\n            .filter { entryExpression -> entryExpression != expression }\n        val types = entryExpressions.mapNotNull { getKtExpressionNonErrorType(it) }\n        return analysisSession.useSiteSession.typeContext.intersectTypesOrNull(types.map { it.coneType })?.asKtType()\n    }\n\n    private fun getExpectedTypeByTryExpression(expression: PsiElement): KtType? {\n        val tryExpression = expression.unwrapQualified<KtTryExpression> { tryExpression, currentExpression ->\n            currentExpression == tryExpres"}
{"code": "sion.tryBlock\n        } ?: return null\n        return getExpectedType(tryExpression)\n    }\n\n    private fun getExpectedTypeOfElvisOperand(expression: PsiElement): KtType? {\n        val binaryExpression = expression.unwrapQualified<KtBinaryExpression> { binaryExpression, operand ->\n            binaryExpression.operationToken == KtTokens.ELVIS && (operand == binaryExpression.left || operand == binaryExpression.right)\n        } ?: return null\n        if (expression !is KtExpression) return null\n        val type = getExpectedType(binaryExpression) ?: getElvisOperandExpectedTypeByOtherOperand(expression, binaryExpression)\n\n        return type?.applyIf(expression == binaryExpression.left) { withNullability(ConeNullability.NULLABLE) }\n    }\n\n    private fun getElvisOperandExpectedTypeByOtherOperand(operand: KtExpression, elvisExpression: KtBinaryExpression): KtType? {\n        val leftOperand = elvisExpression.left ?: return null\n        val rightOperand = elvisExpression.right ?: return null\n"}
{"code": "        return if (operand == leftOperand) {\n            getKtExpressionNonErrorType(rightOperand)\n        } else {\n            getKtExpressionNonErrorType(leftOperand)?.withNullability(ConeNullability.NOT_NULL)\n        }\n    }\n\n    private fun KtType.withNullability(nullability: ConeNullability): KtType =\n        coneType.withNullability(nullability, analysisSession.useSiteSession.typeContext).asKtType()\n\n    private fun getExpectedTypeByWhenEntryValue(expression: PsiElement): KtType? {\n        val condition = expression.parent as? KtWhenConditionWithExpression ?: return null\n        val whenExpression = (condition.parent as? KtWhenEntry)?.parent as? KtWhenExpression ?: return null\n        val subject = whenExpression.subjectExpression ?: return with(analysisSession) { builtinTypes.BOOLEAN }\n        return getKtExpressionNonErrorType(subject)\n    }\n\n    private fun getKtExpressionNonErrorType(expression: KtExpression): KtType? =\n        getKtExpressionType(expression)?.nonErrorTypeOrN"}
{"code": "ull()\n\n    private fun KtType.nonErrorTypeOrNull(): KtType? = takeUnless { it is KtErrorType }\n\n    private fun PsiElement.isWhileLoopCondition() =\n        unwrapQualified<KtWhileExpressionBase> { whileExpr, cond -> whileExpr.condition == cond } != null\n\n    private fun PsiElement.isIfCondition() =\n        unwrapQualified<KtIfExpression> { ifExpr, cond -> ifExpr.condition == cond } != null\n\n    override fun isDefinitelyNull(expression: KtExpression): Boolean =\n        getDefiniteNullability(expression) == DefiniteNullability.DEFINITELY_NULL\n\n    override fun isDefinitelyNotNull(expression: KtExpression): Boolean =\n        getDefiniteNullability(expression) == DefiniteNullability.DEFINITELY_NOT_NULL\n\n    private fun getDefiniteNullability(expression: KtExpression): DefiniteNullability {\n        fun FirExpression.isNotNullable() = with(analysisSession.useSiteSession.typeContext) {\n            !resolvedType.isNullableType()\n        }\n\n        when (val fir = expression.getOrBuildFir(analy"}
{"code": "sisSession.firResolveSession)) {\n            is FirSmartCastExpression -> if (fir.isStable) {\n                if (fir.smartcastTypeWithoutNullableNothing != null) {\n                    return DefiniteNullability.DEFINITELY_NULL\n                } else if (fir.isNotNullable()) {\n                    return DefiniteNullability.DEFINITELY_NOT_NULL\n                }\n            }\n            is FirExpression -> if (fir.isNotNullable()) {\n                return DefiniteNullability.DEFINITELY_NOT_NULL\n            }\n        }\n\n        return DefiniteNullability.UNKNOWN\n    }\n}\n\nprivate data class KtCallWithArgument(val call: KtCallElement, val argument: KtExpression)\n\nprivate inline fun <reified R : Any> PsiElement.unwrapQualified(check: (R, PsiElement) -> Boolean): R? {\n    val parent = nonContainerParent\n    return when {\n        parent is R && check(parent, this) -> parent\n        parent is KtQualifiedExpression && parent.selectorExpression == this -> {\n            val grandParent = parent.n"}
{"code": "onContainerParent\n            when {\n                grandParent is R && check(grandParent, parent) -> grandParent\n                else -> null\n            }\n        }\n        else -> null\n    }\n}\n\nprivate val PsiElement.nonContainerParent: PsiElement?\n    get() = when (val parent = parent) {\n        is KtContainerNode -> parent.nonContainerParent\n        is KtLabeledExpression -> parent.nonContainerParent\n        else -> parent\n    }\n\nprivate enum class DefiniteNullability { DEFINITELY_NULL, DEFINITELY_NOT_NULL, UNKNOWN }\n"}
{"code": "// MODULE: L1\n// MODULE_KIND: LibraryBinary\n// WILDCARD_MODIFICATION_EVENT\n// FILE: l1.kt\n\n// MODULE: L2\n// MODULE_KIND: LibraryBinary\n// FILE: l2.kt\n\n// MODULE: G\n\n// MODULE: F(L1)\n\n// MODULE: E\n\n// MODULE: D\n\n// MODULE: C(F, G, L2)\n\n// MODULE: B(D, E)\n\n// MODULE: A(B, C)\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.impl.base.test.cases.components.typeCreator\n\nimport org.jetbrains.kotlin.analysis.api.renderer.types.impl.KtTypeRendererForDebug\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.test.framework.services.TypeParser\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.builders.TestConfigurationBuilder\nimport org.jetbrains.kotlin.test.directives.model.SimpleDirectivesContainer\nimport org.jetbrains.kotlin.test.directives.model.singleValue\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.assertions\nimport org.jetbrains.kotlin.types.Variance\n\nabstract class AbstractBuildClassTypeTest : AbstractAnalysisApiBasedTest() {\n    override fun configureTest(builder: TestConfigurationBuilder) {\n        super.configureTest(builder)\n        "}
{"code": "with(builder) {\n            useDirectives(Directives)\n        }\n    }\n\n    override fun doTestByMainFile(mainFile: KtFile, mainModule: KtTestModule, testServices: TestServices) {\n        val typeString = mainModule.testModule.directives.singleValue(Directives.CLASS_TYPE)\n        val actual = analyseForTest(mainFile) {\n            val ktType = TypeParser.parseTypeFromString(typeString, mainFile, mainFile)\n            buildString {\n                appendLine(\"originalTypeString: $typeString\")\n                appendLine(\n                    \"ktType: ${\n                        ktType.render(\n                            renderer = KtTypeRendererForDebug.WITH_QUALIFIED_NAMES,\n                            position = Variance.INVARIANT,\n                        )\n                    }\"\n                )\n            }\n        }\n\n        testServices.assertions.assertEqualsToTestDataFileSibling(actual)\n    }\n\n    private object Directives : SimpleDirectivesContainer() {\n        val CLASS_TYPE by s"}
{"code": "tringDirective(\"Class type to create\")\n    }\n}\n"}
{"code": "// FILE: main.kt\npackage a.b.c\n\nimport dependency.foo\n\nfun foo() {}\n\nclass Outer {\n    class Inner {\n        fun test() {\n            <expr>Outer.Inner.foo()</expr>\n        }\n        companion object {\n            fun foo() {}\n        }\n    }\n}\n\n// FILE: dep.kt\npackage dependency\n\nfun foo() {}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.descriptors.Visibilities\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.extractArgumentsTypeRefAndSource\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.resolve.fullyExpandedType\nimport org.jetbrains.kotlin.fir.resolve.toSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.types.EnrichedProjectionKind\nimport org.jetbrains.kotlin.types.Variance\n\nobject FirClassVarianceChecker : FirCl"}
{"code": "assChecker(MppCheckerKind.Common) {\n    override fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {\n        checkTypeParameters(declaration.typeParameters, Variance.OUT_VARIANCE, context, reporter)\n\n        for (superTypeRef in declaration.superTypeRefs) {\n            checkVarianceConflict(superTypeRef, Variance.OUT_VARIANCE, context, reporter)\n        }\n\n        for (member in declaration.declarations) {\n            if (member is FirMemberDeclaration) {\n                if (Visibilities.isPrivate(member.status.visibility)) {\n                    continue\n                }\n            }\n\n            if (member is FirTypeParameterRefsOwner && member !is FirClass) {\n                checkTypeParameters(member.typeParameters, Variance.IN_VARIANCE, context, reporter)\n            }\n\n            if (member is FirCallableDeclaration) {\n                checkCallableDeclaration(member, context, reporter)\n            }\n        }\n    }\n\n    private fun checkCal"}
{"code": "lableDeclaration(\n        member: FirCallableDeclaration,\n        context: CheckerContext,\n        reporter: DiagnosticReporter\n    ) {\n        val memberSource = member.source\n        if (member is FirSimpleFunction) {\n            if (memberSource != null && memberSource.kind !is KtFakeSourceElementKind) {\n                for (param in member.valueParameters) {\n                    checkVarianceConflict(param.returnTypeRef, Variance.IN_VARIANCE, context, reporter)\n                }\n            }\n        }\n\n        val returnTypeVariance =\n            if (member is FirProperty && member.isVar) Variance.INVARIANT else Variance.OUT_VARIANCE\n\n        var returnSource = member.returnTypeRef.source\n        if (returnSource != null) {\n            if (memberSource != null && returnSource.kind is KtFakeSourceElementKind && memberSource.kind !is KtFakeSourceElementKind) {\n                returnSource = memberSource\n            }\n        } else {\n            returnSource = memberSource\n        }\n"}
{"code": "\n        checkVarianceConflict(member.returnTypeRef, returnTypeVariance, context, reporter, returnSource)\n\n        val receiverTypeRef = member.receiverParameter?.typeRef\n        if (receiverTypeRef != null) {\n            checkVarianceConflict(receiverTypeRef, Variance.IN_VARIANCE, context, reporter)\n        }\n    }\n\n    private fun checkTypeParameters(\n        typeParameters: List<FirTypeParameterRef>, variance: Variance,\n        context: CheckerContext, reporter: DiagnosticReporter\n    ) {\n        for (typeParameter in typeParameters) {\n            if (typeParameter is FirTypeParameter) {\n                for (bound in typeParameter.symbol.resolvedBounds) {\n                    checkVarianceConflict(bound, variance, context, reporter)\n                }\n            }\n        }\n    }\n\n    private fun checkVarianceConflict(\n        type: FirTypeRef, variance: Variance,\n        context: CheckerContext, reporter: DiagnosticReporter,\n        source: KtSourceElement? = null\n    ) {\n        ch"}
{"code": "eckVarianceConflict(type.coneType, variance, type, type.coneType, context, reporter, source)\n    }\n\n    private fun checkVarianceConflict(\n        type: ConeKotlinType,\n        variance: Variance,\n        typeRef: FirTypeRef?,\n        containingType: ConeKotlinType,\n        context: CheckerContext,\n        reporter: DiagnosticReporter,\n        source: KtSourceElement? = null,\n        isInAbbreviation: Boolean = false\n    ) {\n        if (type is ConeTypeParameterType) {\n            val fullyExpandedType = type.fullyExpandedType(context.session)\n            val typeParameterSymbol = type.lookupTag.typeParameterSymbol\n            val resultSource = source ?: typeRef?.source\n            if (resultSource != null &&\n                !typeParameterSymbol.variance.allowsPosition(variance) &&\n                !fullyExpandedType.attributes.contains(CompilerConeAttributes.UnsafeVariance)\n            ) {\n                val factory =\n                    if (isInAbbreviation) FirErrors.TYPE_VARIANCE_"}
{"code": "CONFLICT_IN_EXPANDED_TYPE else FirErrors.TYPE_VARIANCE_CONFLICT_ERROR\n                reporter.reportOn(\n                    resultSource,\n                    factory,\n                    typeParameterSymbol,\n                    typeParameterSymbol.variance,\n                    variance,\n                    containingType,\n                    context\n                )\n            }\n            return\n        }\n\n        if (type is ConeClassLikeType) {\n            val fullyExpandedType = type.fullyExpandedType(context.session)\n            val classSymbol = fullyExpandedType.lookupTag.toSymbol(context.session)\n            if (classSymbol is FirClassSymbol<*>) {\n                val typeRefAndSourcesForArguments = extractArgumentsTypeRefAndSource(typeRef)\n                for ((index, typeArgument) in fullyExpandedType.typeArguments.withIndex()) {\n                    val paramVariance = classSymbol.typeParameterSymbols.getOrNull(index)?.variance ?: continue\n\n                    val argVaria"}
{"code": "nce = when (typeArgument.kind) {\n                        ProjectionKind.IN -> Variance.IN_VARIANCE\n                        ProjectionKind.OUT -> Variance.OUT_VARIANCE\n                        ProjectionKind.INVARIANT -> Variance.INVARIANT\n                        else -> continue\n                    }\n\n                    val typeArgumentType = typeArgument.type ?: continue\n\n                    val newVariance = when (EnrichedProjectionKind.getEffectiveProjectionKind(paramVariance, argVariance)) {\n                        EnrichedProjectionKind.OUT -> variance\n                        EnrichedProjectionKind.IN -> variance.opposite()\n                        EnrichedProjectionKind.INV -> Variance.INVARIANT\n                        EnrichedProjectionKind.STAR -> null // CONFLICTING_PROJECTION error was reported\n                    }\n\n                    if (newVariance != null) {\n                        val subTypeRefAndSource = typeRefAndSourcesForArguments?.getOrNull(index)\n\n                "}
{"code": "        checkVarianceConflict(\n                            typeArgumentType, newVariance, subTypeRefAndSource?.typeRef, containingType,\n                            context, reporter, subTypeRefAndSource?.typeRef?.source ?: source,\n                            fullyExpandedType != type\n                        )\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.java\n\nimport com.intellij.openapi.vfs.StandardFileSystems\nimport com.intellij.openapi.vfs.VirtualFileManager\nimport com.intellij.psi.PsiElementFinder\nimport com.intellij.psi.impl.compiled.ClsClassImpl\nimport com.intellij.psi.search.GlobalSearchScope\nimport org.jetbrains.kotlin.KtInMemoryTextSourceFile\nimport org.jetbrains.kotlin.analyzer.ModuleInfo\nimport org.jetbrains.kotlin.asJava.finder.JavaElementFinder\nimport org.jetbrains.kotlin.checkers.BaseDiagnosticsTest\nimport org.jetbrains.kotlin.cli.jvm.compiler.KotlinCoreEnvironment\nimport org.jetbrains.kotlin.cli.jvm.compiler.PsiBasedProjectFileSearchScope\nimport org.jetbrains.kotlin.cli.jvm.compiler.TopDownAnalyzerFacadeForJVM\nimport org.jetbrains.kotlin.cli.jvm.compiler.VfsBasedProjectEnvironment\nimport org.jetbrains.kotlin.config.LanguageVersionSettingsImpl\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.builder.BodyBuildingMode\nimport org.jetbrains.kotlin.fir.builder.PsiRaw"}
{"code": "FirBuilder\nimport org.jetbrains.kotlin.fir.declarations.FirFile\nimport org.jetbrains.kotlin.fir.doFirResolveTestBench\nimport org.jetbrains.kotlin.fir.lightTree.LightTree2Fir\nimport org.jetbrains.kotlin.fir.resolve.providers.firProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.impl.FirProviderImpl\nimport org.jetbrains.kotlin.fir.resolve.transformers.createAllCompilerResolveProcessors\nimport org.jetbrains.kotlin.fir.session.FirSessionFactoryHelper\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.platform.TargetPlatform\nimport org.jetbrains.kotlin.platform.jvm.JvmPlatforms\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.resolve.PlatformDependentAnalyzerServices\nimport org.jetbrains.kotlin.resolve.jvm.platform.JvmPlatformAnalyzerServices\nimport org.jetbrains.kotlin.test.InTextDirectivesUtils\nimport org.jetbrains.kotlin.test.KotlinTestUtils\nimport org.jetbrains.kotlin.toSourceLinesMapping\nimport java.io.Fil"}
{"code": "e\n\nabstract class AbstractFirOldFrontendLightClassesTest : BaseDiagnosticsTest() {\n    override fun analyzeAndCheck(testDataFile: File, files: List<TestFile>) {\n        if (files.any { \"FIR_IGNORE\" in it.directives }) return\n        try {\n            analyzeAndCheckUnhandled(testDataFile, files, useLightTree)\n        } catch (t: AssertionError) {\n            throw t\n        } catch (t: Throwable) {\n            throw t\n        }\n    }\n\n    private val useLightTree: Boolean\n        get() = false\n\n    private val useLazyBodiesModeForRawFir: Boolean\n        get() = false\n\n    override fun setupEnvironment(environment: KotlinCoreEnvironment) {\n        PsiElementFinder.EP.getPoint(environment.project).unregisterExtension(JavaElementFinder::class.java)\n    }\n\n    private fun analyzeAndCheckUnhandled(testDataFile: File, files: List<TestFile>, useLightTree: Boolean = false) {\n        val groupedByModule = files.groupBy(TestFile::module)\n\n        val modules = createModules(groupedByModule)\n\n   "}
{"code": "     val sessionProvider = FirProjectSessionProvider()\n\n        //For BuiltIns, registered in sessionProvider automatically\n        val allProjectScope = GlobalSearchScope.allScope(project)\n\n        val configToSession = modules.mapValues { (config, info) ->\n            val moduleFiles = groupedByModule.getValue(config)\n            val scope = TopDownAnalyzerFacadeForJVM.newModuleSearchScope(\n                project,\n                moduleFiles.mapNotNull { it.ktFile }\n            )\n            val projectEnvironment = VfsBasedProjectEnvironment(\n                project,\n                VirtualFileManager.getInstance().getFileSystem(StandardFileSystems.FILE_PROTOCOL)\n            ) { environment.createPackagePartProvider(it) }\n\n            FirSessionFactoryHelper.createSessionWithDependencies(\n                Name.identifier(info.name.asString().removeSurrounding(\"<\", \">\")),\n                info.platform,\n                externalSessionProvider = sessionProvider,\n                project"}
{"code": "Environment,\n                config?.languageVersionSettings ?: LanguageVersionSettingsImpl.DEFAULT,\n                javaSourcesScope = PsiBasedProjectFileSearchScope(scope),\n                librariesScope = PsiBasedProjectFileSearchScope(allProjectScope),\n                lookupTracker = null,\n                enumWhenTracker = null,\n                importTracker = null,\n                incrementalCompilationContext = null,\n                extensionRegistrars = emptyList(),\n                needRegisterJavaElementFinder = true\n            ) {}\n        }\n\n        val firFilesPerSession = mutableMapOf<FirSession, List<FirFile>>()\n\n        // TODO: make module/session/transformer handling like in AbstractFirMultiModuleTest (IDE)\n        for ((testModule, testFilesInModule) in groupedByModule) {\n            val ktFiles = getKtFiles(testFilesInModule, true)\n\n            val session = configToSession.getValue(testModule)\n\n            val firFiles = mutableListOf<FirFile>()\n            mapKtFil"}
{"code": "esToFirFiles(session, ktFiles, firFiles, useLightTree)\n            firFilesPerSession[session] = firFiles\n        }\n\n        runAnalysis(testDataFile, firFilesPerSession)\n    }\n\n    private fun mapKtFilesToFirFiles(session: FirSession, ktFiles: List<KtFile>, firFiles: MutableList<FirFile>, useLightTree: Boolean) {\n        val firProvider = (session.firProvider as FirProviderImpl)\n        if (useLightTree) {\n            val lightTreeBuilder = LightTree2Fir(session, firProvider.kotlinScopeProvider)\n            ktFiles.mapTo(firFiles) {\n                val firFile =\n                    lightTreeBuilder.buildFirFile(\n                        it.text,\n                        KtInMemoryTextSourceFile(it.name, it.virtualFilePath, it.text),\n                        it.text.toSourceLinesMapping()\n                    )\n                (session.firProvider as FirProviderImpl).recordFile(firFile)\n                firFile\n            }\n        } else {\n            val firBuilder = PsiRawFirBuilder(\n  "}
{"code": "              session,\n                firProvider.kotlinScopeProvider,\n                bodyBuildingMode = BodyBuildingMode.lazyBodies(useLazyBodiesModeForRawFir)\n            )\n            ktFiles.mapTo(firFiles) {\n                val firFile = firBuilder.buildFirFile(it)\n                firProvider.recordFile(firFile)\n                firFile\n            }\n        }\n    }\n\n    private fun runAnalysis(testDataFile: File, firFilesPerSession: Map<FirSession, List<FirFile>>) {\n        for ((session, firFiles) in firFilesPerSession) {\n            doFirResolveTestBench(firFiles, createAllCompilerResolveProcessors(session), gc = false)\n        }\n        checkResultingFirFiles(testDataFile)\n    }\n\n    private fun checkResultingFirFiles(testDataFile: File) {\n        val ourFinders = PsiElementFinder.EP.getPoint(project).extensions.filterIsInstance<FirJavaElementFinder>()\n\n        assertNotEmpty(ourFinders)\n\n        val stringBuilder = StringBuilder()\n\n        for (qualifiedName in InTextDirecti"}
{"code": "vesUtils.findListWithPrefixes(testDataFile.readText(), \"// LIGHT_CLASS_FQ_NAME: \")) {\n            val fqName = FqName(qualifiedName)\n            val packageName = fqName.parent().asString()\n\n            val ourFinder = ourFinders.firstOrNull { finder -> finder.findPackage(packageName) != null }\n            assertNotNull(\"PsiPackage for ${fqName.parent()} was not found\", ourFinder)\n            ourFinder!!\n\n            val psiPackage = ourFinder.findPackage(fqName.parent().asString())\n            assertNotNull(\"PsiPackage for ${fqName.parent()} is null\", psiPackage)\n\n            val psiClass = assertInstanceOf(\n                ourFinder.findClass(qualifiedName, GlobalSearchScope.allScope(project)),\n                ClsClassImpl::class.java\n            )\n\n            psiClass.appendMirrorText(0, stringBuilder)\n            stringBuilder.appendLine()\n        }\n\n        val expectedPath = testDataFile.path.replace(\".kt\", \".txt\")\n        KotlinTestUtils.assertEqualsToFile(File(expectedPath), s"}
{"code": "tringBuilder.toString())\n    }\n\n    override fun createTestFileFromPath(filePath: String): File {\n        return File(filePath)\n    }\n\n    private fun createModules(groupedByModule: Map<TestModule?, List<TestFile>>): MutableMap<TestModule?, ModuleInfo> {\n        val modules =\n            HashMap<TestModule?, ModuleInfo>()\n\n        for (testModule in groupedByModule.keys) {\n            val module = if (testModule == null)\n                createSealedModule()\n            else\n                createModule(testModule.name)\n\n            modules[testModule] = module\n        }\n\n        for (testModule in groupedByModule.keys) {\n            if (testModule == null) continue\n\n            val module = modules[testModule]!!\n            val dependencies = ArrayList<ModuleInfo>()\n            dependencies.add(module)\n            for (dependency in testModule.dependencies) {\n                dependencies.add(modules[dependency as TestModule?]!!)\n            }\n\n\n            dependencies.add(builtInsModu"}
{"code": "leInfo)\n            (module as TestModuleInfo).dependencies.addAll(dependencies)\n        }\n\n        return modules\n    }\n\n    private val builtInsModuleInfo = BuiltInModuleInfo(Name.special(\"<built-ins>\"))\n\n    private fun createModule(moduleName: String): TestModuleInfo {\n        parseModulePlatformByName(moduleName)\n        return TestModuleInfo(Name.special(\"<$moduleName>\"))\n    }\n\n    private class BuiltInModuleInfo(override val name: Name) : ModuleInfo {\n        override val platform: TargetPlatform\n            get() = JvmPlatforms.unspecifiedJvmPlatform\n\n        override val analyzerServices: PlatformDependentAnalyzerServices\n            get() = JvmPlatformAnalyzerServices\n\n        override fun dependencies(): List<ModuleInfo> {\n            return listOf(this)\n        }\n    }\n\n    private class TestModuleInfo(override val name: Name) : ModuleInfo {\n        override val platform: TargetPlatform\n            get() = JvmPlatforms.unspecifiedJvmPlatform\n\n        override val analyzerS"}
{"code": "ervices: PlatformDependentAnalyzerServices\n            get() = JvmPlatformAnalyzerServices\n\n        val dependencies = mutableListOf<ModuleInfo>(this)\n        override fun dependencies(): List<ModuleInfo> {\n            return dependencies\n        }\n    }\n\n    private fun createSealedModule(): TestModuleInfo {\n        return createModule(\"test-module-jvm\").apply {\n            dependencies += builtInsModuleInfo\n        }\n    }\n}\n"}
{"code": "fun test() {\n    for (i in <expr>1..10</expr>){\n        4\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.providers\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.PsiElement\nimport com.intellij.psi.PsiField\nimport com.intellij.psi.search.GlobalSearchScope\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.symbols.*\nimport org.jetbrains.kotlin.analysis.providers.PsiDeclarationAndKtSymbolEqualityChecker.representsTheSameDeclaration\n\nobject DecompiledPsiDeclarationProvider {\n    fun KtAnalysisSession.findPsi(ktSymbol: KtSymbol, project: Project): PsiElement? {\n        return when (ktSymbol) {\n            is KtConstructorSymbol -> providePsiForConstructor(ktSymbol, project)\n            is KtFunctionLikeSymbol -> providePsiForFunction(ktSymbol, project)\n            is KtEnumEntrySymbol -> providePsiForEnumEntry(ktSymbol, project)\n            is KtVariableLikeSymbol -> providePsiForProperty(ktSymbol, project)\n            is KtClassLikeSymbol -> providePsiForClass(ktSymbol, project)\n    "}
{"code": "        else -> null\n        }\n    }\n\n    private fun KtAnalysisSession.providePsiForConstructor(\n        constructorSymbol: KtConstructorSymbol,\n        project: Project\n    ): PsiElement? {\n        val classId = constructorSymbol.containingClassIdIfNonLocal ?: return null\n        val psiClass = project.createPsiDeclarationProvider(constructorSymbol.scope(project))\n            ?.getClassesByClassId(classId)\n            ?.firstOrNull() ?: return null\n        return psiClass.constructors.find { psiMethod ->\n            representsTheSameDeclaration(psiMethod, constructorSymbol)\n        }\n    }\n\n    private fun KtAnalysisSession.providePsiForFunction(\n        functionLikeSymbol: KtFunctionLikeSymbol,\n        project: Project\n    ): PsiElement? {\n        return functionLikeSymbol.callableIdIfNonLocal?.let {\n            val candidates = project.createPsiDeclarationProvider(functionLikeSymbol.scope(project))\n                ?.getFunctions(it)\n            if (candidates?.size == 1)\n          "}
{"code": "      candidates.single()\n            else\n                candidates?.find { psiMethod ->\n                    representsTheSameDeclaration(psiMethod, functionLikeSymbol)\n                }\n        }\n    }\n\n    private fun providePsiForProperty(\n        variableLikeSymbol: KtVariableLikeSymbol,\n        project: Project\n    ): PsiElement? {\n        return variableLikeSymbol.callableIdIfNonLocal?.let {\n            val candidates = project.createPsiDeclarationProvider(variableLikeSymbol.scope(project))\n                ?.getProperties(it)\n            if (candidates?.size == 1)\n                candidates.single()\n            else {\n                // Weigh [PsiField]\n                candidates?.firstOrNull { psiMember -> psiMember is PsiField }\n                    ?: candidates?.firstOrNull()\n            }\n        }\n    }\n\n    private fun providePsiForClass(\n        classLikeSymbol: KtClassLikeSymbol,\n        project: Project\n    ): PsiElement? {\n        return classLikeSymbol.classIdIfNonLo"}
{"code": "cal?.let {\n            project.createPsiDeclarationProvider(classLikeSymbol.scope(project))\n                ?.getClassesByClassId(it)\n                ?.firstOrNull()\n        }\n    }\n\n    private fun providePsiForEnumEntry(\n        enumEntrySymbol: KtEnumEntrySymbol,\n        project: Project\n    ): PsiElement? {\n        val classId = enumEntrySymbol.containingEnumClassIdIfNonLocal ?: return null\n        val psiClass = project.createPsiDeclarationProvider(enumEntrySymbol.scope(project))\n            ?.getClassesByClassId(classId)\n            ?.firstOrNull() ?: return null\n        return psiClass.fields.find {\n            it.name == enumEntrySymbol.name.asString()\n        }\n    }\n\n    private fun KtSymbol.scope(project: Project): GlobalSearchScope {\n        // TODO: finding containing module and use a narrower scope?\n        return GlobalSearchScope.allScope(project)\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.checkers.generator.diagnostics\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.fir.checkers.generator.diagnostics.model.DiagnosticList\nimport org.jetbrains.kotlin.fir.checkers.generator.diagnostics.model.PositioningStrategy\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.util.PrivateForInline\n\n@Suppress(\"ClassName\", \"unused\")\n@OptIn(PrivateForInline::class)\nobject WASM_DIAGNOSTICS_LIST : DiagnosticList(\"FirWasmErrors\") {\n    val ANNOTATIONS by object : DiagnosticGroup(\"Annotations\") {\n        val JS_MODULE_PROHIBITED_ON_VAR by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT)\n        val JS_MODULE_PROHIBITED_ON_NON_EXTERNAL by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT)\n        val NESTED_JS_MODULE_PROHIBITED by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT)\n    }\n\n    val EXTERNALS by object : Diag"}
{"code": "nosticGroup(\"Externals\") {\n        val NON_EXTERNAL_TYPE_EXTENDS_EXTERNAL_TYPE by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT) {\n            parameter<ConeKotlinType>(\"superType\")\n        }\n        val EXTERNAL_TYPE_EXTENDS_NON_EXTERNAL_TYPE by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT) {\n            parameter<ConeKotlinType>(\"superType\")\n        }\n        val CALL_TO_DEFINED_EXTERNALLY_FROM_NON_EXTERNAL_DECLARATION by error<PsiElement>()\n        val WRONG_JS_INTEROP_TYPE by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT) {\n            parameter<ConeKotlinType>(\"type\")\n            parameter<String>(\"place\")\n        }\n        val NON_EXTERNAL_DECLARATION_IN_INAPPROPRIATE_FILE by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT) {\n            parameter<ConeKotlinType>(\"type\")\n        }\n    }\n\n    val JS_FUN by object : DiagnosticGroup(\"JsFun\") {\n        val WRONG_JS_FUN_TARGET by error<PsiEl"}
{"code": "ement>()\n    }\n\n    val JSCODE by object : DiagnosticGroup(\"JsCode\") {\n        val JSCODE_WRONG_CONTEXT by error<KtElement>(PositioningStrategy.NAME_IDENTIFIER)\n        val JSCODE_UNSUPPORTED_FUNCTION_KIND by error<KtElement>(PositioningStrategy.NAME_IDENTIFIER) {\n            parameter<String>(\"place\")\n        }\n        val JSCODE_INVALID_PARAMETER_NAME by error<KtElement>()\n    }\n\n    val WASM_INTEROP by object : DiagnosticGroup(\"Wasm interop\") {\n        val NESTED_WASM_EXPORT by error<KtElement>()\n        val WASM_EXPORT_ON_EXTERNAL_DECLARATION by error<KtElement>()\n        val JS_AND_WASM_EXPORTS_ON_SAME_DECLARATION by error<KtElement>()\n        val NESTED_WASM_IMPORT by error<KtElement>()\n        val WASM_IMPORT_ON_NON_EXTERNAL_DECLARATION by error<KtElement>()\n        val WASM_IMPORT_EXPORT_PARAMETER_DEFAULT_VALUE by error<KtElement>()\n        val WASM_IMPORT_EXPORT_VARARG_PARAMETER by error<KtElement>()\n        val WASM_IMPORT_EXPORT_UNSUPPORTED_PARAMETER_TYPE by error<KtElement>"}
{"code": "(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT) {\n            parameter<ConeKotlinType>(\"type\")\n        }\n        val WASM_IMPORT_EXPORT_UNSUPPORTED_RETURN_TYPE by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT) {\n            parameter<ConeKotlinType>(\"type\")\n        }\n    }\n\n    val WASI by object : DiagnosticGroup(\"WASI\") {\n        val WASI_EXTERNAL_NOT_TOP_LEVEL_FUNCTION by error<KtElement>()\n        val WASI_EXTERNAL_FUNCTION_WITHOUT_IMPORT by error<KtElement>()\n    }\n\n    val ASSOCIATED_OBJECTS by object : DiagnosticGroup(\"Associated object\") {\n        val ASSOCIATED_OBJECT_INVALID_BINDING by error<KtElement>()\n    }\n}\n"}
{"code": "import a.<expr>b</expr>.c"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.generator\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.analysis.api.symbols.*\nimport org.jetbrains.kotlin.analysis.api.types.KtType\nimport org.jetbrains.kotlin.builtins.functions.FunctionTypeKind\nimport org.jetbrains.kotlin.config.ApiVersion\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.config.LanguageVersionSettings\nimport org.jetbrains.kotlin.contracts.description.EventOccurrencesRange\nimport org.jetbrains.kotlin.descriptors.ClassKind\nimport org.jetbrains.kotlin.descriptors.EffectiveVisibility\nimport org.jetbrains.kotlin.descriptors.Visibility\nimport org.jetbrains.kotlin.diagnostics.Severity\nimport org.jetbrains.kotlin.diagnostics.WhenMissingCase\nimport org.jetbrains.kotlin.fir.FirModuleData\nimport org.jetbrains.kotlin.fir.checkers.generator.diagnostics.model.*\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.exp"}
{"code": "ressions.FirExpression\nimport org.jetbrains.kotlin.fir.expressions.FirQualifiedAccessExpression\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.*\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.lexer.KtKeywordToken\nimport org.jetbrains.kotlin.lexer.KtModifierKeywordToken\nimport org.jetbrains.kotlin.metadata.deserialization.VersionRequirement\nimport org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtExpression\nimport org.jetbrains.kotlin.resolve.ForbiddenNamedArgumentsTarget\nimport org.jetbrains.kotlin.resolve.deprecation.DeprecationInfo\nimport org.jetbrains.kotlin.resolve.multiplatform.ExpectActualAnnotationsIncompatibilityType\nimport org.jetbrains.kotlin.resolve.multiplatform.ExpectActualCompatibility\nimport org.jetb"}
{"code": "rains.kotlin.serialization.deserialization.IncompatibleVersionErrorData\nimport org.jetbrains.kotlin.types.Variance\nimport kotlin.reflect.KClass\nimport kotlin.reflect.KType\nimport kotlin.reflect.full.createType\nimport kotlin.reflect.full.isSubclassOf\n\nobject HLDiagnosticConverter {\n    fun convert(diagnosticList: DiagnosticList): HLDiagnosticList {\n        return HLDiagnosticList(diagnosticList.allDiagnostics.flatMap(::convertDiagnostic))\n    }\n\n    private fun convertDiagnostic(diagnostic: DiagnosticData): List<HLDiagnostic> {\n        return when (diagnostic){\n            is RegularDiagnosticData -> listOf(\n                HLDiagnostic(\n                    original = diagnostic,\n                    severity = null,\n                    className = diagnostic.getHLDiagnosticClassName(),\n                    implClassName = diagnostic.getHLDiagnosticImplClassName(),\n                    parameters = diagnostic.parameters.mapIndexed(::convertParameter)\n                )\n            )\n       "}
{"code": "     is DeprecationDiagnosticData -> listOf(Severity.ERROR, Severity.WARNING).map {\n                HLDiagnostic(\n                    original = diagnostic,\n                    severity = it,\n                    className = diagnostic.getHLDiagnosticClassName(it),\n                    implClassName = diagnostic.getHLDiagnosticImplClassName(it),\n                    parameters = diagnostic.parameters.mapIndexed(::convertParameter)\n                )\n            }\n        }\n    }\n\n    private fun convertParameter(index: Int, diagnosticParameter: DiagnosticParameter): HLDiagnosticParameter {\n        val conversion = FirToKtConversionCreator.createConversion(diagnosticParameter.type)\n        val convertedType = conversion.convertType(diagnosticParameter.type)\n        return HLDiagnosticParameter(\n            name = diagnosticParameter.name,\n            conversion = conversion,\n            originalParameterName = ('a' + index).toString(),\n            type = convertedType,\n            original "}
{"code": "= diagnosticParameter,\n            importsToAdd = conversion.importsToAdd\n        )\n    }\n\n    private fun RegularDiagnosticData.getHLDiagnosticClassName(): String = name.sanitizeName()\n\n    private fun RegularDiagnosticData.getHLDiagnosticImplClassName(): String =\n        \"${getHLDiagnosticClassName()}Impl\"\n\n    private fun DeprecationDiagnosticData.getHLDiagnosticClassName(severity: Severity): String {\n        val diagnosticName = \"${name}_${severity.name}\"\n        return diagnosticName.sanitizeName()\n    }\n\n    private fun DeprecationDiagnosticData.getHLDiagnosticImplClassName(severity: Severity): String {\n        return \"${getHLDiagnosticClassName(severity)}Impl\"\n    }\n\n    private fun String.sanitizeName(): String =\n        lowercase()\n            .split('_')\n            .joinToString(separator = \"\") {\n                it.replaceFirstChar(Char::uppercaseChar)\n            }\n\n}\n\ninternal object FirToKtConversionCreator {\n    fun createConversion(type: KType): HLParameterConversion {\n"}
{"code": "        val nullable = type.isMarkedNullable\n        val kClass = type.classifier as KClass<*>\n        return tryMapAllowedType(kClass)\n            ?: tryMapPsiElementType(kClass)\n            ?: tryMapFirTypeToKtType(kClass, nullable)\n            ?: tryMapPlatformType(type, kClass)\n            ?: error(\"Unsupported type $type, consider add corresponding mapping\")\n    }\n\n    fun getAllConverters(conversionForCollectionValues: HLParameterConversion): Map<KClass<*>, HLParameterConversion> {\n        return buildMap {\n            putAll(typeMapping)\n            put(\n                Map::class,\n                HLMapParameterConversion(\n                    \"key\",\n                    \"value\",\n                    conversionForCollectionValues,\n                    conversionForCollectionValues\n                )\n            )\n            put(\n                Collection::class,\n                HLCollectionParameterConversion(\"value\", conversionForCollectionValues)\n            )\n            put(\n  "}
{"code": "              Pair::class,\n                HLPairParameterConversion(\n                    conversionForCollectionValues,\n                    conversionForCollectionValues\n                )\n            )\n        }\n    }\n\n    private fun tryMapFirTypeToKtType(kClass: KClass<*>, nullable: Boolean): HLParameterConversion? {\n        return if (nullable) {\n            nullableTypeMapping[kClass] ?: typeMapping[kClass]\n        } else {\n            typeMapping[kClass]\n        }\n    }\n\n    private fun tryMapAllowedType(kClass: KClass<*>): HLParameterConversion? {\n        if (kClass in allowedTypesWithoutTypeParams) return HLIdParameterConversion\n        return null\n    }\n\n    private fun KType.toParameterName(): String {\n        return kClass.simpleName!!.replaceFirstChar(Char::lowercaseChar)\n    }\n\n    private fun tryMapPlatformType(type: KType, kClass: KClass<*>): HLParameterConversion? {\n        if (kClass.isSubclassOf(Collection::class)) {\n            val elementType = type.arguments.single"}
{"code": "().type ?: return HLIdParameterConversion\n            return HLCollectionParameterConversion(\n                parameterName = elementType.toParameterName(),\n                mappingConversion = createConversion(elementType)\n            )\n        }\n        if (kClass.isSubclassOf(Map::class)) {\n            val keyType = type.arguments.getOrNull(0)?.type\n            val valueType = type.arguments.getOrNull(1)?.type\n\n            val keyConversion = keyType?.let { createConversion(it) } ?: HLIdParameterConversion\n            val valueConversion = valueType?.let { createConversion(it) } ?: HLIdParameterConversion\n            if (keyConversion.isTrivial && valueConversion.isTrivial) return HLIdParameterConversion\n            return HLMapParameterConversion(\n                keyName = keyType?.toParameterName() ?: \"key\",\n                valueName = valueType?.toParameterName() ?: \"value\",\n                mappingConversionForKeys = keyConversion,\n                mappingConversionForValues = valu"}
{"code": "eConversion\n            )\n        }\n        if (kClass.isSubclassOf(Pair::class)) {\n            val first = type.arguments.getOrNull(0)?.type ?: return HLIdParameterConversion\n            val second = type.arguments.getOrNull(1)?.type ?: return HLIdParameterConversion\n            return HLPairParameterConversion(\n                mappingConversionFirst = createConversion(first),\n                mappingConversionSecond = createConversion(second)\n            )\n        }\n        return null\n    }\n\n    private fun tryMapPsiElementType(kClass: KClass<*>): HLParameterConversion? {\n        if (kClass.isSubclassOf(PsiElement::class)) {\n            return HLIdParameterConversion\n        }\n        return null\n    }\n\n    private val nullableTypeMapping: Map<KClass<*>, HLFunctionCallConversion> = mapOf(\n        FirExpression::class to HLFunctionCallConversion(\n            \"{0}?.source?.psi as? KtExpression\",\n            KtExpression::class.createType(nullable = true),\n            importsToAdd = lis"}
{"code": "tOf(\n                \"org.jetbrains.kotlin.psi.KtExpression\",\n                \"org.jetbrains.kotlin.psi\"\n            )\n        ),\n        KtSourceElement::class to HLFunctionCallConversion(\n            \"({0} as? KtPsiSourceElement)?.psi\",\n            PsiElement::class.createType(nullable = true),\n            importsToAdd = listOf(\n                \"org.jetbrains.kotlin.psi\",\n                \"org.jetbrains.kotlin.KtPsiSourceElement\"\n            )\n        ),\n    )\n\n    private val typeMapping: Map<KClass<*>, HLFunctionCallConversion> = mapOf(\n        // ------------------ symbols ------------------\n        FirRegularClass::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.classifierBuilder.buildClassLikeSymbol({0}.symbol) as KtNamedClassOrObjectSymbol\",\n            KtNamedClassOrObjectSymbol::class.createType(),\n            importsToAdd = listOf(\n                \"org.jetbrains.kotlin.fir.declarations.FirRegularClass\",\n                \"org.jetbrains.kotlin.analysis.api.symbo"}
{"code": "ls.KtNamedClassOrObjectSymbol\"\n            )\n        ),\n        FirValueParameterSymbol::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.buildSymbol({0})\",\n            KtSymbol::class.createType(),\n            importsToAdd = listOf(\"org.jetbrains.kotlin.fir.declarations.FirDeclaration\")\n        ),\n        FirEnumEntrySymbol::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.buildSymbol({0})\",\n            KtSymbol::class.createType(),\n        ),\n        FirRegularClassSymbol::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.classifierBuilder.buildClassLikeSymbol({0})\",\n            KtClassLikeSymbol::class.createType()\n        ),\n        FirNamedFunctionSymbol::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.functionLikeBuilder.buildFunctionSymbol({0})\",\n            KtFunctionLikeSymbol::class.createType()\n        ),\n        FirPropertySymbol::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.variableLikeBuil"}
{"code": "der.buildVariableSymbol({0})\",\n            KtVariableSymbol::class.createType()\n        ),\n        FirBackingFieldSymbol::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.variableLikeBuilder.buildVariableSymbol({0}.fir.propertySymbol)\",\n            KtVariableSymbol::class.createType()\n        ),\n        FirVariableSymbol::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.variableLikeBuilder.buildVariableLikeSymbol({0})\",\n            KtVariableLikeSymbol::class.createType()\n        ),\n        FirTypeParameterSymbol::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.classifierBuilder.buildTypeParameterSymbol({0})\",\n            KtTypeParameterSymbol::class.createType()\n        ),\n        FirCallableSymbol::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.callableBuilder.buildCallableSymbol({0})\",\n            KtCallableSymbol::class.createType()\n        ),\n        FirClassSymbol::class to HLFunctionCallConversion(\n            \"f"}
{"code": "irSymbolBuilder.classifierBuilder.buildClassLikeSymbol({0})\",\n            KtClassLikeSymbol::class.createType()\n        ),\n        FirClassLikeSymbol::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.classifierBuilder.buildClassLikeSymbol({0})\",\n            KtClassLikeSymbol::class.createType()\n        ),\n        FirBasedSymbol::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.buildSymbol({0})\",\n            KtSymbol::class.createType()\n        ),\n        // ------------------ FIR elements ------------------\n        FirClass::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.classifierBuilder.buildClassLikeSymbol({0}.symbol)\",\n            KtClassLikeSymbol::class.createType()\n        ),\n        FirTypeParameter::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.classifierBuilder.buildTypeParameterSymbol({0}.symbol)\",\n            KtTypeParameterSymbol::class.createType(),\n            importsToAdd = listOf(\"org.jetbrains.kotlin"}
{"code": ".fir.declarations.FirTypeParameter\")\n        ),\n        FirValueParameter::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.buildSymbol({0}.symbol)\",\n            KtSymbol::class.createType(),\n            importsToAdd = listOf(\"org.jetbrains.kotlin.fir.declarations.FirDeclaration\")\n        ),\n        FirFunction::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.buildSymbol({0})\",\n            KtSymbol::class.createType(),\n            importsToAdd = listOf(\"org.jetbrains.kotlin.fir.declarations.FirFunction\")\n        ),\n        FirCallableDeclaration::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.callableBuilder.buildCallableSymbol({0}.symbol)\",\n            KtCallableSymbol::class.createType(),\n            importsToAdd = listOf(\"org.jetbrains.kotlin.fir.declarations.FirCallableDeclaration\")\n        ),\n        FirMemberDeclaration::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.buildSymbol({0} as FirDeclaration)\",\n        "}
{"code": "    KtSymbol::class.createType(),\n            importsToAdd = listOf(\"org.jetbrains.kotlin.fir.declarations.FirDeclaration\")\n        ),\n        FirDeclaration::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.buildSymbol({0})\",\n            KtSymbol::class.createType(),\n            importsToAdd = listOf(\"org.jetbrains.kotlin.fir.declarations.FirDeclaration\")\n        ),\n        FirQualifiedAccessExpression::class to HLFunctionCallConversion(\n            \"{0}.source!!.psi as KtExpression\",\n            KtExpression::class.createType(),\n            importsToAdd = listOf(\n                \"org.jetbrains.kotlin.psi.KtExpression\",\n                \"org.jetbrains.kotlin.psi\"\n            )\n        ),\n        FirExpression::class to HLFunctionCallConversion(\n            \"{0}.source!!.psi as KtExpression\",\n            KtExpression::class.createType(),\n            importsToAdd = listOf(\n                \"org.jetbrains.kotlin.psi.KtExpression\",\n                \"org.jetbrains.kotlin.psi\"\n"}
{"code": "            )\n        ),\n        // ------------------ other ------------------\n\n        ConeKotlinType::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.typeBuilder.buildKtType({0})\",\n            KtType::class.createType()\n        ),\n        FirTypeRef::class to HLFunctionCallConversion(\n            \"firSymbolBuilder.typeBuilder.buildKtType({0})\",\n            KtType::class.createType()\n        ),\n        KtSourceElement::class to HLFunctionCallConversion(\n            \"({0} as KtPsiSourceElement).psi\",\n            PsiElement::class.createType(),\n            importsToAdd = listOf(\n                \"org.jetbrains.kotlin.psi\",\n                \"org.jetbrains.kotlin.KtPsiSourceElement\"\n            )\n        )\n    )\n\n    private val allowedTypesWithoutTypeParams = setOf(\n        Boolean::class,\n        String::class,\n        Int::class,\n        Name::class,\n        EventOccurrencesRange::class,\n        KtKeywordToken::class,\n        KtModifierKeywordToken::class,\n        Visib"}
{"code": "ility::class,\n        EffectiveVisibility::class,\n        WhenMissingCase::class,\n        ForbiddenNamedArgumentsTarget::class,\n        LanguageFeature::class,\n        LanguageVersionSettings::class,\n        Variance::class,\n        FqName::class,\n        ClassId::class,\n        FirModuleData::class,\n        ExpectActualCompatibility::class,\n        ExpectActualCompatibility.MismatchOrIncompatible::class,\n        ExpectActualAnnotationsIncompatibilityType::class,\n        DeprecationInfo::class,\n        ApiVersion::class,\n        CallableId::class,\n        ClassKind::class,\n        FunctionTypeKind::class,\n        VersionRequirement.Version::class,\n        IncompatibleVersionErrorData::class,\n    )\n\n    private val KType.kClass: KClass<*>\n        get() = classifier as KClass<*>\n}\n"}
{"code": "interface Foo {\n    val isValid: Boolean\n}\n\nfun test(obj: Any) {\n    if (obj is Foo || <expr>isValid(obj)</expr>) {\n        consume(obj)\n    }\n}\n\nfun isValid(obj: Any): Boolean = true\n\nfun consume(obj: Foo) {}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.dfa\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.references.FirControlFlowGraphReference\nimport org.jetbrains.kotlin.fir.resolve.dfa.cfg.CFGNode\nimport org.jetbrains.kotlin.fir.resolve.dfa.cfg.ControlFlowGraph\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\nclass FirControlFlowGraphReferenceImpl(\n    val controlFlowGraph: ControlFlowGraph,\n    val dataFlowInfo: DataFlowInfo? = null\n) : FirControlFlowGraphReference() {\n    override val source: KtSourceElement? get() = null\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {}\n\n    override fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirControlFlowGraphReference {\n        return this\n    }\n}\n\nclass DataFlowInfo(val variableStorage: VariableStorage)\n\nval FirControlFlowGraphReference.controlFlowGraph: ControlFlowGraph?\n    get() = (this as? FirControlFlowGra"}
{"code": "phReferenceImpl)?.controlFlowGraph\n\nval FirControlFlowGraphReference.dataFlowInfo: DataFlowInfo?\n    get() = (this as? FirControlFlowGraphReferenceImpl)?.dataFlowInfo\n"}
{"code": "// FILE: main.kt\npackage test\n\nimport dependency.Bar\nimport dependency.extFun\nimport dependency.extVal\nimport dependency.extCallable\n\nfun usage() {\n    Bar.extFun()\n\n    Bar.extVal\n\n    val ref = Bar::extCallable\n}\n\n// FILE: dependency.kt\npackage dependency\n\nobject Bar\n\nfun Bar.extFun() {}\n\nval Bar.extVal: Int get() = 10\n\nfun Bar.extCallable() {}"}
{"code": "// LOOK_UP_FOR_ELEMENT_OF_TYPE: org.jetbrains.kotlin.psi.KtClassInitializer\n\npackage one.two\n\nclass A\ntypealias Foo = A\nclass Foo {\n    <expr>init {\n        val i = 1\n    }</expr>\n}"}
{"code": "// FILE: JavaClass.java\n\npublic class JavaClass {\n    public static void bar() {}\n}\n\n// FILE: Test.kt\n\nopen class AA : JavaClass() {\n    object C\n}\n\nclass BB : AA() {\n    object D\n}\n\nfun test() {\n    val bbd = BB.D\n    val aac = AA.C\n    JavaClass.bar()\n\n    val errC = BB.<!UNRESOLVED_REFERENCE!>C<!>\n    val errBarViaBB = BB.<!UNRESOLVED_REFERENCE!>bar<!>()\n    val errBarViaAA = AA.<!UNRESOLVED_REFERENCE!>bar<!>()\n}\n"}
{"code": "fun a(): Int {\n    fun b(): Int {\n        var c: Int? = null\n        if (c == null ||\n            0 < c // FE 1.0: smart cast impossible, see KT-10240\n        ) c = 0\n        return c <!USELESS_ELVIS!>?: 0<!>\n    }\n\n    var c: Int = 0\n    c = 0\n    return c\n}\n\nfun myRun(f: () -> Unit) {\n    f()\n}\n\nfun println(arg: Int) {}\n\nfun d() {\n    myRun {\n        var koko: String? = \"Alpha\"\n        while (koko != null) {\n            println(koko.length)\n            koko = null\n        }\n    }\n    myRun {\n        var koko: String? = \"Omega\"\n        while (koko != null) {\n            println(koko.length) // FE 1.0: smart cast impossible, see KT-19446\n            koko = null\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.api.targets\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.FirDesignation\nimport org.jetbrains.kotlin.fir.FirElementWithResolveState\nimport org.jetbrains.kotlin.fir.declarations.*\n\n\ninternal class LLFirSingleResolveTarget(designation: FirDesignation) : LLFirResolveTarget(designation) {\n    override fun visitTargetElement(\n        element: FirElementWithResolveState,\n        visitor: LLFirResolveTargetVisitor,\n    ) {\n        if (element !is FirFile) {\n            visitor.performAction(element)\n        }\n    }\n}\n"}
{"code": "class Foo {\n    private fun foo() {\n        class Local {\n            fun call() {}\n        }\n\n        Lo<caret>cal().call()\n    }\n}"}
{"code": "package test\n\ninterface Foo\n\ninterface WithOperator {\n    operator fun plus(f: Foo): WithOperator\n}\n\nfun test(withOperator: WithOperator, foo: Foo) {\n    var variable = withOperator\n    variable <caret>= variable + foo\n}\n"}
{"code": "// FILE: main.kt\npackage test\n\nclass MyFoo\n\nfun constructorCall = MyFoo()\n\nval myDepFoo = <expr>dependency.MyFoo()</expr>\n\n// FILE: dependency.kt\npackage dependency\n\nclass MyFoo\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.declarations.renderers.callables\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.renderer.declarations.KtDeclarationRenderer\nimport org.jetbrains.kotlin.analysis.api.renderer.declarations.renderAnnotationsModifiersAndContextReceivers\nimport org.jetbrains.kotlin.analysis.api.symbols.KtCallableSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtNamedSymbol\nimport org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter\nimport org.jetbrains.kotlin.lexer.KtKeywordToken\n\npublic interface KtCallableSignatureRenderer {\n    context(KtAnalysisSession, KtDeclarationRenderer)\n    public fun renderCallableSignature(symbol: KtCallableSymbol, keyword: KtKeywordToken?, printer: PrettyPrinter)\n\n    public object FOR_SOURCE : KtCallableSignatureRenderer {\n        context(KtAnalysisSession, KtDeclarationRenderer)\n        override fun renderCallableSignature(symbol: KtCallableSymbol, k"}
{"code": "eyword: KtKeywordToken?, printer: PrettyPrinter): Unit = printer {\n            \" \".separated(\n                {\n                    if (keyword != null) renderAnnotationsModifiersAndContextReceivers(symbol, printer, keyword)\n                    else renderAnnotationsModifiersAndContextReceivers(symbol, printer)\n                },\n                { typeParametersRenderer.renderTypeParameters(symbol, printer) },\n                {\n                    val receiverSymbol = symbol.receiverParameter\n                    if (receiverSymbol != null) {\n                        withSuffix(\".\") { callableReceiverRenderer.renderReceiver(receiverSymbol, printer) }\n                    }\n\n                    if (symbol is KtNamedSymbol) {\n                        nameRenderer.renderName(symbol, printer)\n                    }\n                },\n            )\n            \" \".separated(\n                {\n                    valueParametersRenderer.renderValueParameters(symbol, printer)\n                    w"}
{"code": "ithPrefix(\": \") { returnTypeRenderer.renderReturnType(symbol, printer) }\n                },\n                { typeParametersRenderer.renderWhereClause(symbol, printer) },\n            )\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.checkers\n\nimport com.intellij.psi.tree.TokenSet\nimport org.jetbrains.kotlin.config.LanguageVersionSettings\nimport org.jetbrains.kotlin.diagnostics.Errors.CONFUSING_BRANCH_CONDITION\nimport org.jetbrains.kotlin.lexer.KtTokens.*\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.resolve.BindingTrace\n\nobject ConfusingWhenBranchSyntaxChecker {\n    private val prohibitedTokens = TokenSet.create(\n        IN_KEYWORD, NOT_IN,\n        LT, LTEQ, GT, GTEQ,\n        EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ,\n        ANDAND, OROR\n    )\n\n    fun check(whenExpression: KtWhenExpression, languageVersionSettings: LanguageVersionSettings, trace: BindingTrace) {\n        if (whenExpression.subjectExpression == null && whenExpression.subjectVariable == null) return\n        for (entry in whenExpression.entries) {\n            for (condition in entry.conditions) {\n                checkCondition(condition, languageVersionSettings, trace)\n            }\n        }\n    }\n\n    "}
{"code": "private fun checkCondition(condition: KtWhenCondition, languageVersionSettings: LanguageVersionSettings, trace: BindingTrace) {\n        when (condition) {\n            is KtWhenConditionWithExpression -> checkConditionExpression(condition.expression, languageVersionSettings, trace)\n            is KtWhenConditionInRange -> checkConditionExpression(condition.rangeExpression, languageVersionSettings, trace)\n        }\n    }\n\n    private fun checkConditionExpression(rawExpression: KtExpression?, languageVersionSettings: LanguageVersionSettings, trace: BindingTrace) {\n        if (rawExpression == null) return\n        if (rawExpression is KtParenthesizedExpression) return\n        val shouldReport = when (val expression = KtPsiUtil.safeDeparenthesize(rawExpression)) {\n            is KtIsExpression -> true\n            is KtBinaryExpression -> expression.operationToken in prohibitedTokens\n            else -> false\n        }\n        if (shouldReport) {\n            trace.report(CONFUSING_BRANCH_CON"}
{"code": "DITION.on(languageVersionSettings, rawExpression))\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.calls\n\nimport org.jetbrains.kotlin.fir.scopes.impl.isWrappedIntegerOperator\n\nobject ConeIntegerOperatorConflictResolver : ConeCallConflictResolver() {\n    override fun chooseMaximallySpecificCandidates(\n        candidates: Set<Candidate>,\n        discriminateAbstracts: Boolean\n    ): Set<Candidate> {\n        if (candidates.size <= 1) {\n            return candidates\n        }\n        val candidateWithWrappedIntegerOperator = candidates.firstOrNull { it.symbol.isWrappedIntegerOperator() }\n        return if (candidateWithWrappedIntegerOperator != null) {\n            setOf(candidateWithWrappedIntegerOperator)\n        } else {\n            candidates\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.scopes\n\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeOwner\nimport org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion\nimport org.jetbrains.kotlin.name.Name\n\npublic interface KtScopeLike : KtLifetimeOwner {\n    \n    public fun getAllPossibleNames(): Set<Name> = withValidityAssertion {\n        getPossibleCallableNames() + getPossibleClassifierNames()\n    }\n\n    \n    public fun getPossibleCallableNames(): Set<Name>\n\n    \n    public fun getPossibleClassifierNames(): Set<Name>\n\n    \n    public fun mayContainName(name: Name): Boolean = withValidityAssertion {\n        name in getPossibleCallableNames() || name in getPossibleClassifierNames()\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve\n\nimport com.intellij.codeInsight.completion.CompletionUtilCore\nimport com.intellij.psi.impl.source.DummyHolder\nimport com.intellij.util.SmartList\nimport org.jetbrains.kotlin.config.AnalysisFlags\nimport org.jetbrains.kotlin.config.LanguageVersionSettings\nimport org.jetbrains.kotlin.config.isLibraryToSourceAnalysisEnabled\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.incremental.KotlinLookupLocation\nimport org.jetbrains.kotlin.incremental.components.LookupLocation\nimport org.jetbrains.kotlin.incremental.components.NoLookupLocation\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.progress.ProgressIndicatorAndCompilationCanceledStatus\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.psi.codeFragmentUtil.suppressDiagnosticsInDebugMode\nimport org.jetbrains.kotlin.psi.psiUtil.getTopmostParentQualifiedExpressionForSe"}
{"code": "lector\nimport org.jetbrains.kotlin.resolve.calls.CallExpressionElement\nimport org.jetbrains.kotlin.resolve.calls.checkers.UnderscoreUsageChecker\nimport org.jetbrains.kotlin.resolve.calls.unrollToLeftMostQualifiedExpression\nimport org.jetbrains.kotlin.resolve.descriptorUtil.module\nimport org.jetbrains.kotlin.resolve.scopes.CompositePrioritizedImportingScope\nimport org.jetbrains.kotlin.resolve.scopes.ImportingScope\nimport org.jetbrains.kotlin.resolve.scopes.LexicalScope\nimport org.jetbrains.kotlin.resolve.scopes.receivers.*\nimport org.jetbrains.kotlin.resolve.scopes.utils.canBeResolvedWithoutDeprecation\nimport org.jetbrains.kotlin.resolve.scopes.utils.findClassifier\nimport org.jetbrains.kotlin.resolve.scopes.utils.findFirstClassifierWithDeprecationStatus\nimport org.jetbrains.kotlin.resolve.scopes.utils.memberScopeAsImportingScope\nimport org.jetbrains.kotlin.resolve.source.KotlinSourceElement\nimport org.jetbrains.kotlin.types.expressions.ExpressionTypingContext\nimport org.jetbrains.kotlin"}
{"code": ".types.expressions.isWithoutValueArguments\nimport org.jetbrains.kotlin.utils.CallOnceFunction\n\nclass QualifiedExpressionResolver(val languageVersionSettings: LanguageVersionSettings) {\n    fun resolvePackageHeader(\n        packageDirective: KtPackageDirective,\n        module: ModuleDescriptor,\n        trace: BindingTrace\n    ) {\n        val packageNames = packageDirective.packageNames\n        for ((index, nameExpression) in packageNames.withIndex()) {\n            storeResult(\n                trace, nameExpression, module.getPackage(packageDirective.getFqName(nameExpression)),\n                shouldBeVisibleFrom = null, position = QualifierPosition.PACKAGE_HEADER, isQualifier = index != packageNames.lastIndex\n            )\n        }\n    }\n\n    data class TypeQualifierResolutionResult(\n        val qualifierParts: List<ExpressionQualifierPart>,\n        val classifierDescriptor: ClassifierDescriptor? = null\n    ) {\n        val allProjections: List<KtTypeProjection>\n            get() = qual"}
{"code": "ifierParts.flatMap { it.typeArguments?.arguments.orEmpty() }\n    }\n\n    fun LexicalScope.findClassifierAndReportDeprecationIfNeeded(\n        name: Name,\n        lookupLocation: KotlinLookupLocation,\n        reportOn: KtExpression?,\n        trace: BindingTrace\n    ): ClassifierDescriptor? {\n        val (classifier, isDeprecated) = findFirstClassifierWithDeprecationStatus(name, lookupLocation) ?: return null\n\n        if (isDeprecated && reportOn != null) {\n            trace.record(BindingContext.DEPRECATED_SHORT_NAME_ACCESS, reportOn) // For IDE\n\n            // slow-path: we know that closest classifier is imported by the deprecated path, but before reporting\n            // deprecation, we have to recheck if there's some other import path, which isn't deprecated (e.g. explicit import)\n            if (!classifier.canBeResolvedWithoutDeprecation(this, lookupLocation)) {\n                trace.report(Errors.DEPRECATED_ACCESS_BY_SHORT_NAME.on(reportOn, classifier))\n            }\n        }\n\n  "}
{"code": "      return classifier\n    }\n\n    fun resolveDescriptorForType(\n        userType: KtUserType,\n        scope: LexicalScope,\n        trace: BindingTrace,\n        isDebuggerContext: Boolean\n    ): TypeQualifierResolutionResult {\n        val ownerDescriptor = if (!isDebuggerContext) scope.ownerDescriptor else null\n        if (userType.qualifier == null) {\n            val descriptor = userType.referenceExpression?.let { expression ->\n                val classifier = scope.findClassifierAndReportDeprecationIfNeeded(\n                    expression.getReferencedNameAsName(),\n                    KotlinLookupLocation(expression),\n                    expression,\n                    trace\n                )\n\n                checkNotEnumEntry(classifier, trace, expression)\n                storeResult(trace, expression, classifier, ownerDescriptor, position = QualifierPosition.TYPE, isQualifier = false)\n                classifier\n            }\n\n            return TypeQualifierResolutionResult(userTy"}
{"code": "pe.asQualifierPartList().first, descriptor)\n        }\n\n        val (qualifierPartList, hasError) = userType.asQualifierPartList()\n        if (hasError) {\n            val descriptor = resolveToPackageOrClass(\n                qualifierPartList, scope.ownerDescriptor.module, trace, ownerDescriptor, scope, position = QualifierPosition.TYPE\n            ) as? ClassifierDescriptor\n            return TypeQualifierResolutionResult(qualifierPartList, descriptor)\n        }\n\n        return resolveQualifierPartListForType(qualifierPartList, ownerDescriptor, scope, trace, isQualifier = false)\n    }\n\n    private fun resolveQualifierPartListForType(\n        qualifierPartList: List<ExpressionQualifierPart>,\n        ownerDescriptor: DeclarationDescriptor?,\n        scope: LexicalScope,\n        trace: BindingTrace,\n        isQualifier: Boolean\n    ): TypeQualifierResolutionResult {\n        assert(qualifierPartList.isNotEmpty()) { \"Qualifier list should not be empty\" }\n\n        val qualifier = resolveToPac"}
{"code": "kageOrClass(\n            qualifierPartList.subList(0, qualifierPartList.size - 1),\n            scope.ownerDescriptor.module, trace, ownerDescriptor, scope,\n            position = QualifierPosition.TYPE\n        ) ?: return TypeQualifierResolutionResult(qualifierPartList, null)\n\n        val lastPart = qualifierPartList.last()\n        val classifier = when (qualifier) {\n            is PackageViewDescriptor -> qualifier.memberScope.getContributedClassifier(lastPart.name, lastPart.location)\n            is ClassDescriptor -> {\n                val descriptor = qualifier.unsubstitutedInnerClassesScope.getContributedClassifier(lastPart.name, lastPart.location)\n                checkNotEnumEntry(descriptor, trace, lastPart.expression)\n                descriptor\n            }\n            else -> null\n        }\n        storeResult(trace, lastPart.expression, classifier, ownerDescriptor, position = QualifierPosition.TYPE, isQualifier = isQualifier)\n        return TypeQualifierResolutionResult(qualif"}
{"code": "ierPartList, classifier)\n    }\n\n    private fun checkNotEnumEntry(descriptor: DeclarationDescriptor?, trace: BindingTrace, expression: KtSimpleNameExpression?) {\n        expression ?: return\n        if (descriptor != null && DescriptorUtils.isEnumEntry(descriptor)) {\n            val qualifiedParent = expression.getTopmostParentQualifiedExpressionForSelector()\n            if (qualifiedParent == null || qualifiedParent.parent !is KtDoubleColonExpression) {\n                trace.report(Errors.ENUM_ENTRY_AS_TYPE.on(expression))\n            }\n        }\n    }\n\n    fun resolveDescriptorForDoubleColonLHS(\n        expression: KtExpression,\n        scope: LexicalScope,\n        trace: BindingTrace,\n        isDebuggerContext: Boolean\n    ): TypeQualifierResolutionResult {\n        val ownerDescriptor = if (!isDebuggerContext) scope.ownerDescriptor else null\n\n        val qualifierPartList = expression.asQualifierPartList(doubleColonLHS = true)\n        if (qualifierPartList.isEmpty()) {\n            r"}
{"code": "eturn TypeQualifierResolutionResult(qualifierPartList, null)\n        }\n\n        if (qualifierPartList.size == 1) {\n            val (name, simpleNameExpression) = qualifierPartList.single()\n            val descriptor = scope.findClassifierAndReportDeprecationIfNeeded(\n                name,\n                KotlinLookupLocation(simpleNameExpression),\n                simpleNameExpression,\n                trace\n            )\n            storeResult(trace, simpleNameExpression, descriptor, ownerDescriptor, position = QualifierPosition.TYPE, isQualifier = true)\n            return TypeQualifierResolutionResult(qualifierPartList, descriptor)\n        }\n\n        return resolveQualifierPartListForType(qualifierPartList, ownerDescriptor, scope, trace, isQualifier = true)\n    }\n\n    private fun KtUserType.asQualifierPartList(): Pair<List<ExpressionQualifierPart>, Boolean> {\n        var hasError = false\n        val result = SmartList<ExpressionQualifierPart>()\n        var userType: KtUserType? = this"}
{"code": "\n        while (userType != null) {\n            val referenceExpression = userType.referenceExpression\n            if (referenceExpression != null) {\n                result.add(\n                    ExpressionQualifierPart(\n                        referenceExpression.getReferencedNameAsName(),\n                        referenceExpression,\n                        userType.typeArgumentList\n                    )\n                )\n            } else {\n                hasError = true\n            }\n            userType = userType.qualifier\n        }\n        return result.asReversed() to hasError\n    }\n\n    fun processImportReference(\n        importDirective: KtImportInfo,\n        moduleDescriptor: ModuleDescriptor,\n        trace: BindingTrace,\n        excludedImportNames: Collection<FqName>,\n        packageFragmentForVisibilityCheck: PackageFragmentDescriptor?\n    ): ImportingScope? {\n        fun processReferenceInContextOf(moduleDescriptor: ModuleDescriptor): ImportingScope? =\n            doP"}
{"code": "rocessImportReference(\n                importDirective,\n                moduleDescriptor,\n                trace,\n                excludedImportNames,\n                packageFragmentForVisibilityCheck\n            )\n\n        val primaryImportingScope = processReferenceInContextOf(moduleDescriptor)\n        if (!languageVersionSettings.isLibraryToSourceAnalysisEnabled) return primaryImportingScope\n\n        val resolutionAnchor = moduleDescriptor.getResolutionAnchorIfAny() ?: return primaryImportingScope\n        val anchorImportingScope = processReferenceInContextOf(resolutionAnchor) ?: return primaryImportingScope\n        if (primaryImportingScope == null) return anchorImportingScope\n        return CompositePrioritizedImportingScope(anchorImportingScope, primaryImportingScope)\n    }\n\n    private fun doProcessImportReference(\n        importDirective: KtImportInfo,\n        moduleDescriptor: ModuleDescriptor,\n        trace: BindingTrace,\n        excludedImportNames: Collection<FqName>,\n      "}
{"code": "  packageFragmentForVisibilityCheck: PackageFragmentDescriptor?\n    ): ImportingScope? { // null if some error happened\n        ProgressIndicatorAndCompilationCanceledStatus.checkCanceled()\n\n        val importedReference = importDirective.importContent ?: return null\n        val path = importedReference.asQualifierPartList()\n        val lastPart = path.lastOrNull() ?: return null\n        val packageFragmentForCheck =\n            if (importDirective is KtImportDirective)\n                computePackageFragmentToCheck(importDirective.containingKtFile, packageFragmentForVisibilityCheck)\n            else\n                null\n\n        if (importDirective.isAllUnder) {\n            val packageOrClassDescriptor = resolveToPackageOrClass(\n                path, moduleDescriptor, trace, packageFragmentForCheck,\n                scopeForFirstPart = null, position = QualifierPosition.IMPORT\n            ).classDescriptorFromTypeAlias() ?: return null\n\n            if (packageOrClassDescriptor is ClassD"}
{"code": "escriptor && packageOrClassDescriptor.kind.isSingleton && lastPart.expression != null) {\n                trace.report(\n                    Errors.CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON.on(\n                        lastPart.expression!!,\n                        packageOrClassDescriptor\n                    )\n                ) // todo report on star\n                return null\n            }\n\n            return AllUnderImportScope.create(packageOrClassDescriptor, excludedImportNames)\n        } else {\n            return processSingleImport(moduleDescriptor, trace, importDirective, path, lastPart, packageFragmentForCheck)\n        }\n    }\n\n    private fun DeclarationDescriptor?.classDescriptorFromTypeAlias(): DeclarationDescriptor? {\n        return if (this is TypeAliasDescriptor) classDescriptor else this\n    }\n\n    private fun computePackageFragmentToCheck(\n        containingFile: KtFile,\n        packageFragmentForVisibilityCheck: PackageFragmentDescriptor?\n    ): PackageFragmentDescriptor? "}
{"code": "=\n        when {\n            containingFile.suppressDiagnosticsInDebugMode() -> null\n\n            packageFragmentForVisibilityCheck is DeclarationDescriptorWithSource &&\n                    packageFragmentForVisibilityCheck.source == SourceElement.NO_SOURCE -> {\n\n                PackageFragmentWithCustomSource(\n                    packageFragmentForVisibilityCheck,\n                    KotlinSourceElement(containingFile)\n                )\n            }\n            else -> packageFragmentForVisibilityCheck\n        }\n\n    private fun processSingleImport(\n        moduleDescriptor: ModuleDescriptor,\n        trace: BindingTrace,\n        importDirective: KtImportInfo,\n        path: List<QualifierPart>,\n        lastPart: QualifierPart,\n        packageFragmentForVisibilityCheck: PackageFragmentDescriptor?\n    ): ImportingScope? {\n        val aliasName = importDirective.importedName\n        if (aliasName == null) {\n            // import kotlin.\n            resolveToPackageOrClass(\n              "}
{"code": "  path,\n                moduleDescriptor,\n                trace,\n                packageFragmentForVisibilityCheck,\n                scopeForFirstPart = null,\n                position = QualifierPosition.IMPORT\n            )\n            return null\n        }\n\n        val resolvedDescriptor = resolveToPackageOrClass(\n            path.subList(0, path.size - 1), moduleDescriptor, trace,\n            packageFragmentForVisibilityCheck, scopeForFirstPart = null, position = QualifierPosition.IMPORT\n        ) ?: return null\n\n        val packageOrClassDescriptor =\n            (resolvedDescriptor as? TypeAliasDescriptor)?.let { it.classDescriptor ?: return null } ?: resolvedDescriptor\n\n        return LazyExplicitImportScope(\n            languageVersionSettings,\n            packageOrClassDescriptor,\n            packageFragmentForVisibilityCheck,\n            lastPart.name,\n            aliasName,\n            CallOnceFunction(Unit) { candidates ->\n                if (candidates.isNotEmpty()) {\n       "}
{"code": "             storeResult(\n                        trace,\n                        lastPart.expression,\n                        candidates,\n                        packageFragmentForVisibilityCheck,\n                        position = QualifierPosition.IMPORT,\n                        isQualifier = false\n                    )\n                } else {\n                    tryResolveDescriptorsWhichCannotBeImported(trace, moduleDescriptor, packageOrClassDescriptor, lastPart)\n                }\n            }\n        )\n    }\n\n    private fun tryResolveDescriptorsWhichCannotBeImported(\n        trace: BindingTrace,\n        moduleDescriptor: ModuleDescriptor,\n        packageOrClassDescriptor: DeclarationDescriptor,\n        lastPart: QualifierPart\n    ) {\n        val lastPartExpression = lastPart.expression ?: return\n\n        val descriptors = SmartList<DeclarationDescriptor>()\n        val lastName = lastPart.name\n        when (packageOrClassDescriptor) {\n            is PackageViewDescriptor -> {\n  "}
{"code": "              val packageDescriptor = moduleDescriptor.getPackage(packageOrClassDescriptor.fqName.child(lastName))\n                if (!packageDescriptor.isEmpty()) {\n                    trace.report(Errors.PACKAGE_CANNOT_BE_IMPORTED.on(lastPartExpression))\n                    descriptors.add(packageOrClassDescriptor)\n                }\n            }\n\n            is ClassDescriptor -> {\n                val memberScope = packageOrClassDescriptor.unsubstitutedMemberScope\n                descriptors.addAll(memberScope.getContributedFunctions(lastName, lastPart.location))\n                descriptors.addAll(memberScope.getContributedVariables(lastName, lastPart.location))\n                if (descriptors.isNotEmpty()) {\n                    trace.report(Errors.CANNOT_BE_IMPORTED.on(lastPartExpression, lastName))\n                }\n            }\n\n            else -> throw IllegalStateException(\"Should be class or package: $packageOrClassDescriptor\")\n        }\n        storeResult(\n            tra"}
{"code": "ce,\n            lastPart.expression,\n            descriptors,\n            shouldBeVisibleFrom = null,\n            position = QualifierPosition.IMPORT,\n            isQualifier = false\n        )\n    }\n\n    private fun KtImportInfo.ImportContent.asQualifierPartList(): List<QualifierPart> =\n        when (this) {\n            is KtImportInfo.ImportContent.ExpressionBased -> expression.asQualifierPartList()\n            is KtImportInfo.ImportContent.FqNameBased -> fqName.pathSegments().map { QualifierPart(it) }\n        }\n\n    private fun KtExpression.asQualifierPartList(doubleColonLHS: Boolean = false): List<ExpressionQualifierPart> {\n        val result = SmartList<ExpressionQualifierPart>()\n\n        fun addQualifierPart(expression: KtExpression?): Boolean {\n            if (expression is KtSimpleNameExpression) {\n                result.add(ExpressionQualifierPart(expression))\n                return true\n            }\n            if (doubleColonLHS && expression is KtCallExpression && expressio"}
{"code": "n.isWithoutValueArguments) {\n                val simpleName = expression.calleeExpression\n                if (simpleName is KtSimpleNameExpression) {\n                    result.add(ExpressionQualifierPart(simpleName.getReferencedNameAsName(), simpleName, expression.typeArgumentList))\n                    return true\n                }\n            }\n            return false\n        }\n\n        var expression: KtExpression? = this\n        while (true) {\n            if (addQualifierPart(expression)) break\n            if (expression !is KtQualifiedExpression) break\n\n            addQualifierPart(expression.selectorExpression)\n\n            expression = expression.receiverExpression\n        }\n\n        return result.asReversed()\n    }\n\n    open class QualifierPart(\n        val name: Name,\n        val typeArguments: KtTypeArgumentList? = null,\n        val location: LookupLocation = NoLookupLocation.FOR_DEFAULT_IMPORTS\n    ) {\n        open val expression: KtSimpleNameExpression? get() = null\n\n     "}
{"code": "   operator fun component1() = name\n        open operator fun component2() = expression\n        operator fun component3() = typeArguments\n    }\n\n    class ExpressionQualifierPart(\n        name: Name,\n        override val expression: KtSimpleNameExpression,\n        typeArguments: KtTypeArgumentList? = null\n    ) : QualifierPart(name, typeArguments, KotlinLookupLocation(expression)) {\n        constructor(expression: KtSimpleNameExpression) : this(expression.getReferencedNameAsName(), expression)\n\n        override fun component2() = expression\n    }\n\n    private fun resolveToPackageOrClass(\n        path: List<QualifierPart>,\n        moduleDescriptor: ModuleDescriptor,\n        trace: BindingTrace,\n        shouldBeVisibleFrom: DeclarationDescriptor?,\n        scopeForFirstPart: LexicalScope?,\n        position: QualifierPosition\n    ): DeclarationDescriptor? {\n        val (packageOrClassDescriptor, endIndex) =\n            resolveToPackageOrClassPrefix(path, moduleDescriptor, trace, shouldBeVi"}
{"code": "sibleFrom, scopeForFirstPart, position)\n\n        if (endIndex != path.size) {\n            return null\n        }\n\n        return packageOrClassDescriptor\n    }\n\n    private fun resolveInIDEMode(path: List<QualifierPart>): Boolean =\n        languageVersionSettings.getFlag(AnalysisFlags.ideMode) && path.size > 1 && path.first().name.asString() == ROOT_PREFIX_FOR_IDE_RESOLUTION_MODE\n\n    private fun resolveToPackageOrClassPrefix(\n        path: List<QualifierPart>,\n        moduleDescriptor: ModuleDescriptor,\n        trace: BindingTrace,\n        shouldBeVisibleFrom: DeclarationDescriptor?,\n        scopeForFirstPart: LexicalScope?,\n        position: QualifierPosition,\n        isValue: ((KtSimpleNameExpression) -> Boolean)? = null\n    ): Pair<DeclarationDescriptor?, Int> {\n        if (resolveInIDEMode(path)) {\n            return resolveToPackageOrClassPrefix(\n                path.subList(1, path.size),\n                moduleDescriptor,\n                trace,\n                shouldBeVisibleFrom"}
{"code": ",\n                scopeForFirstPart = null,\n                position = position,\n                isValue = null\n            ).let { it.first to it.second + 1 }\n        }\n\n        if (path.isEmpty()) {\n            return Pair(moduleDescriptor.getPackage(FqName.ROOT), 0)\n        }\n\n        val firstPart = path.first()\n\n        if (position == QualifierPosition.EXPRESSION) {\n            // In expression position, value wins against classifier (and package).\n            // If we see a function or variable (possibly ambiguous),\n            // tell resolver we have no qualifier and let it perform the context-dependent resolution.\n            if (scopeForFirstPart != null && isValue != null && firstPart.expression != null && isValue(firstPart.expression!!)) {\n                return Pair(null, 0)\n            }\n        }\n\n        val classifierDescriptor = scopeForFirstPart?.findClassifier(firstPart.name, firstPart.location)\n\n        if (classifierDescriptor != null) {\n            storeResult(t"}
{"code": "race, firstPart.expression, classifierDescriptor, shouldBeVisibleFrom, position)\n        }\n\n        val (prefixDescriptor, nextIndexAfterPrefix) =\n            if (classifierDescriptor != null)\n                Pair(classifierDescriptor, 1)\n            else\n                moduleDescriptor.quickResolveToPackage(path, trace, position)\n\n        var currentDescriptor: DeclarationDescriptor? = prefixDescriptor\n        for (qualifierPartIndex in nextIndexAfterPrefix until path.size) {\n            val qualifierPart = path[qualifierPartIndex]\n\n            val nextPackageOrClassDescriptor =\n                when (currentDescriptor) {\n                    is TypeAliasDescriptor -> // TODO type aliases as qualifiers? (would break some assumptions in TypeResolver)\n                        null\n                    is ClassDescriptor ->\n                        currentDescriptor.getContributedClassifier(qualifierPart)\n                    is PackageViewDescriptor -> {\n                        val packageVi"}
{"code": "ew =\n                            if (qualifierPart.typeArguments == null) {\n                                moduleDescriptor.getPackage(currentDescriptor.fqName.child(qualifierPart.name))\n                            } else null\n                        if (packageView != null && !packageView.isEmpty()) {\n                            packageView\n                        } else {\n                            currentDescriptor.memberScope.getContributedClassifier(qualifierPart.name, qualifierPart.location)\n                        }\n                    }\n                    else ->\n                        null\n                }\n\n            // If we are in expression, this name can denote a value (not a package or class).\n            if (!(position == QualifierPosition.EXPRESSION && nextPackageOrClassDescriptor == null)) {\n                storeResult(trace, qualifierPart.expression, nextPackageOrClassDescriptor, shouldBeVisibleFrom, position)\n            }\n\n            if (nextPackageOrClassDe"}
{"code": "scriptor == null) {\n                return Pair(currentDescriptor, qualifierPartIndex)\n            }\n\n            currentDescriptor = nextPackageOrClassDescriptor\n        }\n\n        return Pair(currentDescriptor, path.size)\n    }\n\n    fun ClassDescriptor.getContributedClassifier(qualifierPart: QualifierPart) =\n        unsubstitutedInnerClassesScope.getContributedClassifier(qualifierPart.name, qualifierPart.location)\n\n    fun resolveNameExpressionAsQualifierForDiagnostics(\n        expression: KtSimpleNameExpression,\n        receiver: Receiver?,\n        context: ExpressionTypingContext\n    ): Qualifier? {\n        val name = expression.getReferencedNameAsName()\n        if (!expression.isPhysical && !name.isSpecial && name.asString().endsWith(CompletionUtilCore.DUMMY_IDENTIFIER_TRIMMED)) {\n            return null\n        }\n\n        val location = KotlinLookupLocation(expression)\n        val qualifierDescriptor = when (receiver) {\n            is PackageQualifier -> {\n                val chi"}
{"code": "ldPackageFQN = receiver.descriptor.fqName.child(name)\n                receiver.descriptor.module.getPackage(childPackageFQN).takeUnless { it.isEmpty() }\n                    ?: receiver.descriptor.memberScope.getContributedClassifier(name, location)\n            }\n            is ClassQualifier -> receiver.staticScope.getContributedClassifier(name, location)\n            null -> context.scope.findClassifier(name, location)\n                ?: context.scope.ownerDescriptor.module.getPackage(FqName.ROOT.child(name)).takeUnless { it.isEmpty() }\n            is ReceiverValue -> receiver.type.memberScope.memberScopeAsImportingScope().findClassifier(name, location)\n            else -> null\n        }\n\n        if (qualifierDescriptor != null) {\n            return storeResult(context.trace, expression, qualifierDescriptor, context.scope.ownerDescriptor, QualifierPosition.EXPRESSION)\n        }\n\n        return null\n    }\n\n    data class QualifiedExpressionResolveResult(\n        val classOrPackage: Decl"}
{"code": "arationDescriptor?,\n        val memberName: Name?\n    ) {\n        companion object {\n            val UNRESOLVED = QualifiedExpressionResolveResult(null, null)\n        }\n    }\n\n    fun resolveClassOrPackageInQualifiedExpression(\n        expression: KtQualifiedExpression,\n        scope: LexicalScope,\n        context: BindingContext\n    ): QualifiedExpressionResolveResult {\n        val qualifiedExpressions = unrollToLeftMostQualifiedExpression(expression)\n        val path = mapToQualifierParts(qualifiedExpressions, 0)\n        val trace = DelegatingBindingTrace(context, \"Temp trace for resolving qualified expression\")\n\n        val (result, index) = resolveToPackageOrClassPrefix(\n            path = path,\n            moduleDescriptor = scope.ownerDescriptor.module,\n            trace = trace,\n            shouldBeVisibleFrom = scope.ownerDescriptor,\n            scopeForFirstPart = scope,\n            position = QualifierPosition.EXPRESSION\n        )\n\n        if (result == null) return Qualified"}
{"code": "ExpressionResolveResult.UNRESOLVED\n        return when (index) {\n            path.size -> QualifiedExpressionResolveResult(result, null)\n            path.size - 1 -> QualifiedExpressionResolveResult(result, path[index].name)\n            else -> QualifiedExpressionResolveResult.UNRESOLVED\n        }\n    }\n\n    fun resolveQualifierInExpressionAndUnroll(\n        expression: KtQualifiedExpression,\n        context: ExpressionTypingContext,\n        isValue: (KtSimpleNameExpression) -> Boolean\n    ): List<CallExpressionElement> {\n        val qualifiedExpressions = unrollToLeftMostQualifiedExpression(expression)\n        val maxPossibleQualifierPrefix = mapToQualifierParts(qualifiedExpressions, 1)\n\n        val nextIndexAfterPrefix = resolveToPackageOrClassPrefix(\n            path = maxPossibleQualifierPrefix,\n            moduleDescriptor = context.scope.ownerDescriptor.module,\n            trace = context.trace,\n            shouldBeVisibleFrom = context.scope.ownerDescriptor,\n            scopeFor"}
{"code": "FirstPart = context.scope,\n            position = QualifierPosition.EXPRESSION,\n            isValue = isValue\n        ).second\n\n        val nextExpressionIndexAfterQualifier =\n            if (nextIndexAfterPrefix == 0) 0 else nextIndexAfterPrefix - 1\n\n        return qualifiedExpressions\n            .subList(nextExpressionIndexAfterQualifier, qualifiedExpressions.size)\n            .map(::CallExpressionElement)\n    }\n\n    private fun mapToQualifierParts(\n        qualifiedExpressions: List<KtQualifiedExpression>,\n        skipLast: Int\n    ): List<QualifierPart> {\n        if (qualifiedExpressions.isEmpty()) return emptyList()\n\n        val first = qualifiedExpressions.first()\n        if (first !is KtDotQualifiedExpression) return emptyList()\n        val firstReceiver = first.receiverExpression\n        if (firstReceiver !is KtSimpleNameExpression) return emptyList()\n\n        // Qualifier parts are receiver name for the leftmost expression\n        //  and selector names for all but the rightm"}
{"code": "ost qualified expressions\n        //  (since rightmost selector should denote a value in expression position,\n        //  and thus can't be a qualifier part).\n        // E.g.:\n        //  qualified expression 'a.b': qualifier parts == ['a']\n        //  qualified expression 'a.b.c.d': qualifier parts == ['a', 'b', 'c']\n\n        val qualifierParts = arrayListOf<QualifierPart>()\n        qualifierParts.add(ExpressionQualifierPart(firstReceiver))\n\n        for (qualifiedExpression in qualifiedExpressions.dropLast(skipLast)) {\n            if (qualifiedExpression !is KtDotQualifiedExpression) break\n            val selector = qualifiedExpression.selectorExpression\n            if (selector !is KtSimpleNameExpression) break\n            qualifierParts.add(ExpressionQualifierPart(selector))\n        }\n\n        return qualifierParts\n    }\n\n    private fun ModuleDescriptor.quickResolveToPackage(\n        path: List<QualifierPart>,\n        trace: BindingTrace,\n        position: QualifierPosition\n    ): "}
{"code": "Pair<PackageViewDescriptor, Int> {\n        val possiblePackagePrefixSize = path.indexOfFirst { it.typeArguments != null }.let { if (it == -1) path.size else it + 1 }\n        var fqName = FqName.fromSegments(path.subList(0, possiblePackagePrefixSize).map { it.name.asString() })\n\n        var prefixSize = possiblePackagePrefixSize\n        while (!fqName.isRoot) {\n            val packageDescriptor = getPackage(fqName)\n            if (!packageDescriptor.isEmpty()) {\n                recordPackageViews(path.subList(0, prefixSize), packageDescriptor, trace, position)\n                return Pair(packageDescriptor, prefixSize)\n            }\n            fqName = fqName.parent()\n            prefixSize--\n        }\n        return Pair(getPackage(FqName.ROOT), 0)\n    }\n\n    private fun recordPackageViews(\n        path: List<QualifierPart>,\n        packageView: PackageViewDescriptor,\n        trace: BindingTrace,\n        position: QualifierPosition\n    ) {\n        path.foldRight(packageView) { qualifie"}
{"code": "rPart, currentView ->\n            storeResult(trace, qualifierPart.expression, currentView, shouldBeVisibleFrom = null, position = position)\n            currentView.containingDeclaration\n                ?: error(\n                    \"Containing Declaration must be not null for package with fqName: ${currentView.fqName}, \" +\n                            \"path: ${path.joinToString()}, packageView fqName: ${packageView.fqName}\"\n                )\n        }\n    }\n\n    private fun storeResult(\n        trace: BindingTrace,\n        referenceExpression: KtSimpleNameExpression?,\n        descriptors: Collection<DeclarationDescriptor>,\n        shouldBeVisibleFrom: DeclarationDescriptor?,\n        position: QualifierPosition,\n        isQualifier: Boolean = true\n    ) {\n        referenceExpression ?: return\n        if (descriptors.size > 1) {\n            val visibleDescriptors = descriptors.filter { isVisible(it, shouldBeVisibleFrom, position, languageVersionSettings) }\n            when {\n            "}
{"code": "    visibleDescriptors.isEmpty() -> {\n                    val descriptor = descriptors.first() as DeclarationDescriptorWithVisibility\n                    trace.report(Errors.INVISIBLE_REFERENCE.on(referenceExpression, descriptor, descriptor.visibility, descriptor))\n                }\n                visibleDescriptors.size > 1 -> {\n                    trace.record(BindingContext.AMBIGUOUS_REFERENCE_TARGET, referenceExpression, visibleDescriptors)\n                }\n                else -> {\n                    storeResult(trace, referenceExpression, visibleDescriptors.single(), null, position, isQualifier)\n                }\n            }\n        } else {\n            storeResult(trace, referenceExpression, descriptors.singleOrNull(), shouldBeVisibleFrom, position, isQualifier)\n        }\n    }\n\n    private fun storeResult(\n        trace: BindingTrace,\n        referenceExpression: KtSimpleNameExpression?,\n        descriptor: DeclarationDescriptor?,\n        shouldBeVisibleFrom: DeclarationDe"}
{"code": "scriptor?,\n        position: QualifierPosition,\n        isQualifier: Boolean = true\n    ): Qualifier? {\n        referenceExpression ?: return null\n        if (descriptor == null) {\n            trace.report(Errors.UNRESOLVED_REFERENCE.on(referenceExpression, referenceExpression))\n            return null\n        }\n\n        trace.record(BindingContext.REFERENCE_TARGET, referenceExpression, descriptor)\n\n        UnderscoreUsageChecker.checkSimpleNameUsage(descriptor, referenceExpression, trace)\n\n        if (descriptor is DeclarationDescriptorWithVisibility) {\n            val fromToCheck =\n                if (shouldBeVisibleFrom is PackageFragmentDescriptor && shouldBeVisibleFrom.source == SourceElement.NO_SOURCE && referenceExpression.containingFile !is DummyHolder) {\n                    PackageFragmentWithCustomSource(shouldBeVisibleFrom, KotlinSourceElement(referenceExpression.containingKtFile))\n                } else {\n                    shouldBeVisibleFrom\n                }\n           "}
{"code": " if (!isVisible(descriptor, fromToCheck, position, languageVersionSettings)) {\n                trace.report(Errors.INVISIBLE_REFERENCE.on(referenceExpression, descriptor, descriptor.visibility, descriptor))\n            }\n        }\n\n        return if (isQualifier) storeQualifier(trace, referenceExpression, descriptor) else null\n    }\n\n    private fun storeQualifier(\n        trace: BindingTrace,\n        referenceExpression: KtSimpleNameExpression,\n        descriptor: DeclarationDescriptor\n    ): Qualifier? {\n        val qualifier =\n            when (descriptor) {\n                is PackageViewDescriptor -> PackageQualifier(referenceExpression, descriptor)\n                is ClassDescriptor -> ClassQualifier(referenceExpression, descriptor)\n                is TypeParameterDescriptor -> TypeParameterQualifier(referenceExpression, descriptor)\n                is TypeAliasDescriptor -> {\n                    val classDescriptor = descriptor.classDescriptor ?: return null\n                    Ty"}
{"code": "peAliasQualifier(referenceExpression, descriptor, classDescriptor)\n                }\n                else -> return null\n            }\n\n        trace.record(BindingContext.QUALIFIER, qualifier.expression, qualifier)\n\n        return qualifier\n    }\n\n    companion object {\n        \n        const val ROOT_PREFIX_FOR_IDE_RESOLUTION_MODE = \"_root_ide_package_\"\n        const val ROOT_PREFIX_FOR_IDE_RESOLUTION_MODE_WITH_DOT = \"$ROOT_PREFIX_FOR_IDE_RESOLUTION_MODE.\"\n    }\n}\n\ninternal fun isVisible(\n    descriptor: DeclarationDescriptor,\n    shouldBeVisibleFrom: DeclarationDescriptor?,\n    position: QualifierPosition,\n    languageVersionSettings: LanguageVersionSettings\n): Boolean {\n    if (descriptor !is DeclarationDescriptorWithVisibility || shouldBeVisibleFrom == null) return true\n\n    val visibility = descriptor.visibility\n    if (position == QualifierPosition.IMPORT) {\n        if (DescriptorVisibilities.isPrivate(visibility)) return DescriptorVisibilities.inSameFile(descriptor, shouldBeVis"}
{"code": "ibleFrom)\n        if (!visibility.mustCheckInImports()) return true\n    }\n    return DescriptorVisibilityUtils.isVisibleIgnoringReceiver(descriptor, shouldBeVisibleFrom, languageVersionSettings)\n}\n\ninternal enum class QualifierPosition {\n    PACKAGE_HEADER, IMPORT, TYPE, EXPRESSION\n}\n\n\nprivate class PackageFragmentWithCustomSource(private val original: PackageFragmentDescriptor, private val source: SourceElement) :\n    PackageFragmentDescriptor by original {\n    override fun getSource(): SourceElement = source\n}\n"}
{"code": "@file:[<caret>S(\"message\")]\n\npackage foo\n\nimport kotlin.Suppress as S\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.lightTree.fir\n\nimport org.jetbrains.kotlin.KtLightSourceElement\nimport org.jetbrains.kotlin.descriptors.ClassKind\nimport org.jetbrains.kotlin.descriptors.Modality\nimport org.jetbrains.kotlin.descriptors.Visibilities\nimport org.jetbrains.kotlin.descriptors.Visibility\nimport org.jetbrains.kotlin.fir.declarations.builder.FirClassBuilder\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.lightTree.fir.modifier.Modifier\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\n\nclass ClassWrapper(\n    val modifiers: Modifier,\n    private val classKind: ClassKind,\n    val classBuilder: FirClassBuilder,\n    val hasSecondaryConstructor: Boolean,\n    val hasDefaultConstructor: Boolean,\n    val delegatedSelfTypeRef: FirTypeRef,\n    val delegatedSuperTypeRef: FirTypeRef,\n    val delegatedSuperCalls: List<DelegatedConstructorWrapper>,\n) {\n\n    fun isEnumEntry(): Boolean {\n        return classKind == ClassKind.ENUM_ENTRY\n    }\n\n    pr"}
{"code": "ivate fun isObject(): Boolean {\n        return classKind == ClassKind.OBJECT\n    }\n\n    fun isSealed(): Boolean {\n        return modifiers.hasModality(Modality.SEALED)\n    }\n\n    fun isEnum(): Boolean {\n        return modifiers.isEnum()\n    }\n\n    fun isInterface(): Boolean {\n        return classKind == ClassKind.INTERFACE\n    }\n\n    fun isInner(): Boolean {\n        return modifiers.isInner()\n    }\n\n    fun hasExpect(): Boolean {\n        return modifiers.hasExpect()\n    }\n\n    // See DescriptorUtils#getDefaultConstructorVisibility in core.descriptors\n    fun defaultConstructorVisibility(): Visibility {\n        return when {\n            isObject() || isEnum() || isEnumEntry() -> Visibilities.Private\n            isSealed() -> Visibilities.Protected\n            else -> Visibilities.Unknown\n        }\n    }\n}\n\ndata class DelegatedConstructorWrapper(\n    val delegatedSuperTypeRef: FirTypeRef,\n    val arguments: List<FirExpression>,\n    val source: KtLightSourceElement?,\n)\n"}
{"code": "package foo\n\nobject Foo {\n    operator fun invoke() {}\n}\n\nfun test() {\n    foo.<expr>Foo</expr>()\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.descriptors.ClassKind\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.*\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirProperty\nimport org.jetbrains.kotlin.fir.declarations.FirRegularClass\nimport org.jetbrains.kotlin.fir.declarations.utils.isConst\nimport org.jetbrains.kotlin.fir.expressions.ConstantArgumentKind\nimport org.jetbrains.kotlin.fir.expressions.canBeUsedForConstVal\nimport org.jetbrains.kotlin.fir.expressions.computeConstantExpressionKind\nimport org.jetbrains.kotlin.fir.resolve.fullyExpandedType\nimport org.jetbrains.kotlin.fir.types.ConeErrorType\nimport org.jetbrains.kotlin.fir.types.coneTyp"}
{"code": "e\nimport org.jetbrains.kotlin.lexer.KtTokens\n\nobject FirConstPropertyChecker : FirPropertyChecker(MppCheckerKind.Common) {\n    override fun check(declaration: FirProperty, context: CheckerContext, reporter: DiagnosticReporter) {\n        if (!declaration.isConst) return\n\n        if (declaration.isVar) {\n            val constModifier = declaration.getModifier(KtTokens.CONST_KEYWORD)\n            constModifier?.let {\n                reporter.reportOn(it.source, FirErrors.WRONG_MODIFIER_TARGET, it.token, \"vars\", context)\n            }\n        }\n\n        val classKind = (context.containingDeclarations.lastOrNull() as? FirRegularClass)?.classKind\n        if (classKind != ClassKind.OBJECT && context.containingDeclarations.size > 1) {\n            reporter.reportOn(declaration.source, FirErrors.CONST_VAL_NOT_TOP_LEVEL_OR_OBJECT, context)\n            return\n        }\n\n        val source = declaration.getter?.source\n        if (source != null && source.kind !is KtFakeSourceElementKind) {\n         "}
{"code": "   reporter.reportOn(source, FirErrors.CONST_VAL_WITH_GETTER, context)\n            return\n        }\n\n        if (declaration.delegate != null) {\n            reporter.reportOn(declaration.delegate?.source, FirErrors.CONST_VAL_WITH_DELEGATE, context)\n            return\n        }\n\n        val initializer = declaration.initializer\n        if (initializer == null) {\n            reporter.reportOn(declaration.source, FirErrors.CONST_VAL_WITHOUT_INITIALIZER, context)\n            return\n        }\n\n        val type = declaration.returnTypeRef.coneType.fullyExpandedType(context.session)\n        if ((type !is ConeErrorType) && !type.canBeUsedForConstVal()) {\n            reporter.reportOn(declaration.source, FirErrors.TYPE_CANT_BE_USED_FOR_CONST_VAL, declaration.returnTypeRef.coneType, context)\n            return\n        }\n\n        val errorKind = when (computeConstantExpressionKind(initializer, context.session, calledOnCheckerStage = true)) {\n            ConstantArgumentKind.VALID_CONST, ConstantA"}
{"code": "rgumentKind.RESOLUTION_ERROR -> return\n            ConstantArgumentKind.NOT_CONST_VAL_IN_CONST_EXPRESSION -> FirErrors.NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION\n            else -> FirErrors.CONST_VAL_WITH_NON_CONST_INITIALIZER\n        }\n        reporter.reportOn(initializer.source, errorKind, context)\n    }\n}\n"}
{"code": "// WITH_STDLIB\n\nfun foo(x: MutableMap<Int, MutableList<String>>) {\n    x.getOrPut(1) { <expr>mutableListOf</expr><String>() } += \"str\"\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.collectors.components\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.analysis.cfa.util.PropertyInitializationInfoData\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.declaration.DeclarationCheckers\nimport org.jetbrains.kotlin.fir.analysis.checkersComponent\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.expressions.FirDoWhileLoop\nimport org.jetbrains.kotlin.fir.expressions.FirLoop\nimport org.jetbrains.kotlin.fir.expressions.FirQualifiedAccessExpression\nimport org.jetbrains.kotlin.fir.references.toResolvedPropertySymbol\nimport org.jetbrains.kotlin.fir.resolve.dfa.cfg.ControlFlowGraph\nimport org.jetbrains.kotlin.fir.resolve.dfa.controlFlowGraph\nimp"}
{"code": "ort org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol\nimport org.jetbrains.kotlin.fir.visitors.FirDefaultVisitor\n\nclass ControlFlowAnalysisDiagnosticComponent(\n    session: FirSession,\n    reporter: DiagnosticReporter,\n    declarationCheckers: DeclarationCheckers,\n) : AbstractDiagnosticCollectorComponent(session, reporter) {\n    constructor(session: FirSession, reporter: DiagnosticReporter, mppKind: MppCheckerKind) : this(\n        session,\n        reporter,\n        when (mppKind) {\n            MppCheckerKind.Common -> session.checkersComponent.commonDeclarationCheckers\n            MppCheckerKind.Platform -> session.checkersComponent.platformDeclarationCheckers\n        }\n    )\n\n    private val cfaCheckers = declarationCheckers.controlFlowAnalyserCheckers\n    private val variableAssignmentCheckers = declarationCheckers.variableAssignmentCfaBasedCheckers\n\n    private fun analyze(declaration: FirControlFlowGraphOwner, context: CheckerContext) {\n        val graph = declaration.control"}
{"code": "FlowGraphReference?.controlFlowGraph ?: return\n        if (graph.isSubGraph) return\n        cfaCheckers.forEach { it.analyze(graph, reporter, context) }\n\n        val collector = LocalPropertyCollector().apply { declaration.acceptChildren(this, graph.subGraphs.toSet()) }\n        val properties = collector.properties\n        if (properties.isNotEmpty()) {\n            val data = PropertyInitializationInfoData(properties, collector.conditionallyInitializedProperties, receiver = null, graph)\n            variableAssignmentCheckers.forEach { it.analyze(data, reporter, context) }\n        }\n    }\n\n    // ------------------------------- File -------------------------------\n\n    override fun visitFile(file: FirFile, data: CheckerContext) {\n        analyze(file, data)\n    }\n\n    // ------------------------------- File -------------------------------\n\n    override fun visitScript(script: FirScript, data: CheckerContext) {\n        analyze(script, data)\n    }\n\n    // ------------------------------- C"}
{"code": "lass initializer -------------------------------\n\n    override fun visitRegularClass(regularClass: FirRegularClass, data: CheckerContext) {\n        analyze(regularClass, data)\n    }\n\n    override fun visitAnonymousObject(anonymousObject: FirAnonymousObject, data: CheckerContext) {\n        analyze(anonymousObject, data)\n    }\n\n    // ------------------------------- Property initializer -------------------------------\n\n    override fun visitProperty(property: FirProperty, data: CheckerContext) {\n        analyze(property, data)\n    }\n\n    // ------------------------------- Function -------------------------------\n\n    override fun visitFunction(function: FirFunction, data: CheckerContext) {\n        analyze(function, data)\n    }\n\n    override fun visitSimpleFunction(simpleFunction: FirSimpleFunction, data: CheckerContext) {\n        analyze(simpleFunction, data)\n    }\n\n    override fun visitPropertyAccessor(propertyAccessor: FirPropertyAccessor, data: CheckerContext) {\n        analyze(prope"}
{"code": "rtyAccessor, data)\n    }\n\n    override fun visitConstructor(constructor: FirConstructor, data: CheckerContext) {\n        analyze(constructor, data)\n    }\n\n    \n    private class LocalPropertyCollector : FirDefaultVisitor<Unit, Set<ControlFlowGraph>>() {\n        val properties = mutableSetOf<FirPropertySymbol>()\n\n        // Properties which may not be initialized when accessed, even if they have an initializer.\n        val conditionallyInitializedProperties = mutableSetOf<FirPropertySymbol>()\n\n        // Properties defined within do-while loops, and used within the condition of that same do-while loop, are considered conditionally\n        // initialized. It is possible they may not even be defined by the loop condition due to a `continue` in the do-while loop. Track\n        // do-while loop properties so those used in the condition can be recorded.\n        private val doWhileLoopProperties = ArrayDeque<Pair<FirLoop, MutableSet<FirPropertySymbol>>>()\n        private val insideDoWhileCond"}
{"code": "itions = mutableSetOf<FirLoop>()\n\n        override fun visitElement(element: FirElement, data: Set<ControlFlowGraph>) {\n            when (element) {\n                is FirControlFlowGraphOwner -> {\n                    // Only traverse elements that can have a graph when...\n                    // 1. They do not have a graph,\n                    // 2. Or their graph is in the allowed set of sub-graphs.\n                    val elementGraph = element.controlFlowGraphReference?.controlFlowGraph\n                    if (elementGraph == null) {\n                        element.acceptChildren(this, data)\n                    } else if (elementGraph in data) {\n                        element.acceptChildren(this, elementGraph.subGraphs.toSet())\n                    }\n                }\n                else -> element.acceptChildren(this, data)\n            }\n        }\n\n        override fun visitProperty(property: FirProperty, data: Set<ControlFlowGraph>) {\n            if (\n                !property.is"}
{"code": "Local ||\n                property.origin == FirDeclarationOrigin.ScriptCustomization.Parameter ||\n                property.origin == FirDeclarationOrigin.ScriptCustomization.ParameterFromBaseClass\n            ) return visitElement(property, data)\n\n            val symbol = property.symbol\n            properties.add(symbol)\n            doWhileLoopProperties.lastOrNull()?.second?.add(symbol)\n\n            visitElement(property, data)\n        }\n\n        override fun visitQualifiedAccessExpression(qualifiedAccessExpression: FirQualifiedAccessExpression, data: Set<ControlFlowGraph>) {\n            if (insideDoWhileConditions.isNotEmpty()) {\n                val symbol = qualifiedAccessExpression.calleeReference.toResolvedPropertySymbol() ?: return\n\n                // It is possible to nest do-while loops within do-while loop conditions via in-place lambda functions. Make sure to check\n                // all properties for all loop conditions.\n                if (doWhileLoopProperties.any { it.f"}
{"code": "irst in insideDoWhileConditions && symbol in it.second }) {\n                    conditionallyInitializedProperties.add(symbol)\n                }\n            }\n\n            visitElement(qualifiedAccessExpression, data)\n        }\n\n        override fun visitDoWhileLoop(doWhileLoop: FirDoWhileLoop, data: Set<ControlFlowGraph>) {\n            doWhileLoopProperties.addLast(doWhileLoop to mutableSetOf())\n\n            // Manually navigate children of do-while loop, so it is known when the loop condition is being navigated.\n            // Navigation of the annotations and label is not needed.\n            doWhileLoop.block.accept(this, data)\n\n            insideDoWhileConditions.add(doWhileLoop)\n            doWhileLoop.condition.accept(this, data)\n            insideDoWhileConditions.remove(doWhileLoop)\n\n            doWhileLoopProperties.removeLast()\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.wasm.checkers.expression\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.expression.FirFunctionCallChecker\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.wasm.FirWasmErrors\nimport org.jetbrains.kotlin.fir.analysis.wasm.checkers.hasValidJsCodeBody\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.declarations.utils.isExtension\nimport org.jetbrains.kotlin.fir.declarations.utils.isInline\nimport org.jetbrains.kotlin.fir.declarations.utils.isSuspend\nimport org.jetbrains.kotlin.fir.expressions.FirFunctionCall\nimport org.jetbrains.kotlin.fir.references.toResolvedCallableSymbol\nimport org.jetbrains.kotlin.js.common.isValidES5Identifier\nimport org.jetbrains.kotlin.name.Web"}
{"code": "CommonStandardClassIds\n\nobject FirWasmJsCodeCallChecker : FirFunctionCallChecker(MppCheckerKind.Common) {\n    override fun check(expression: FirFunctionCall, context: CheckerContext, reporter: DiagnosticReporter) {\n        val symbol = expression.calleeReference.toResolvedCallableSymbol() ?: return\n\n        if (symbol.callableId != WebCommonStandardClassIds.Callables.Js) {\n            return\n        }\n\n        val containingDeclarations = context.containingDeclarations\n\n        val containingDeclaration: FirDeclaration = containingDeclarations.lastOrNull() ?: return\n\n        val containingDeclarationOfContainingDeclaration =\n            containingDeclarations.getOrNull(containingDeclarations.size - 2)\n\n        val isContainingDeclarationTopLevel =\n            containingDeclarationOfContainingDeclaration is FirFile || containingDeclarationOfContainingDeclaration is FirScript\n\n        val source = expression.calleeReference.source\n\n        if (!isContainingDeclarationTopLevel) {\n        "}
{"code": "    reporter.reportOn(source, FirWasmErrors.JSCODE_WRONG_CONTEXT, context)\n            return\n        }\n\n        when (containingDeclaration) {\n            is FirSimpleFunction -> {\n                if (!containingDeclaration.hasValidJsCodeBody()) {\n                    reporter.reportOn(source, FirWasmErrors.JSCODE_WRONG_CONTEXT, context)\n                } else {\n                    if (containingDeclaration.isSuspend) {\n                        reporter.reportOn(source, FirWasmErrors.JSCODE_UNSUPPORTED_FUNCTION_KIND, \"suspend function\", context)\n                    }\n                    if (containingDeclaration.isInline) {\n                        reporter.reportOn(source, FirWasmErrors.JSCODE_UNSUPPORTED_FUNCTION_KIND, \"inline function\", context)\n                    }\n                    if (containingDeclaration.isExtension) {\n                        reporter.reportOn(\n                            source,\n                            FirWasmErrors.JSCODE_UNSUPPORTED_FUNCTION_KIND,\n     "}
{"code": "                       \"function with extension receiver\",\n                            context\n                        )\n                    }\n                    for (parameter in containingDeclaration.valueParameters) {\n                        if (parameter.name.identifierOrNullIfSpecial?.isValidES5Identifier() != true) {\n                            reporter.reportOn(parameter.source, FirWasmErrors.JSCODE_INVALID_PARAMETER_NAME, context)\n                        }\n                    }\n                }\n            }\n            is FirProperty -> {\n                if (!containingDeclaration.hasValidJsCodeBody()) {\n                    reporter.reportOn(source, FirWasmErrors.JSCODE_WRONG_CONTEXT, context)\n                }\n            }\n            else -> {\n                reporter.reportOn(source, FirWasmErrors.JSCODE_WRONG_CONTEXT, context)\n            }\n        }\n    }\n}\n"}
{"code": "val i: Int = 1\n  get() {\n      return f<caret>ield\n  }"}
{"code": "annotation class Ann\n\n@field:Ann\nval x: Int = 1\n\n@property:Ann\nval y: Int = 2\n\n@Ann\nval z: Int = 3\n\nclass Some(@field:Ann val x: Int, @property: Ann val y: Int, @param:Ann val z: Int, val w: Int) {\n    @field:Ann\n    val a: Int = 1\n\n    @property:Ann\n    val b: Int = 2\n\n    @Ann\n    val c: Int = 3\n}\n"}
{"code": "// FILE: main.kt\npackage nonRoot\n\nfun foo() {\n    java.lang.<caret>Fake() // qualification doesn't help, because we are in other package\n}\n\n\n// FILE: java.java\nclass java {\n    class lang {\n        class Fake()\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirClass\nimport org.jetbrains.kotlin.fir.types.ConeDynamicType\nimport org.jetbrains.kotlin.fir.types.coneType\n\nobject FirDynamicSupertypeChecker : FirClassChecker(MppCheckerKind.Common) {\n    override fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {\n        for (superType in declaration.superTypeRefs) {\n            if (superType.coneType is ConeDynamicType) {\n                reporter.reportOn(superType.source, FirErrors.DYNAMIC_SUPERTYPE, context)\n            }\n        }\n    }\n}\n"}
{"code": "// BODY_RESOLVE\n@Target(AnnotationTarget.TYPE)\nannotation class Anno(val position: String)\n\nconst val prop = \"str\"\n\nfun f<caret>oo(param: @Anno(\"parameter type $prop\") List<@Anno(\"nested parameter type $prop\") Collection<@Anno(\"nested nested parameter type $prop\") String>> = @Anno(\"defaultValue $prop\") fun(i: @Anno(\"anonymousFunction parameter type $prop\") Int): @Anno(\"anonymousFunction return type $prop\") Int {}) = param"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.inline.coroutines\n\nimport com.intellij.util.ArrayUtil\nimport org.jetbrains.kotlin.codegen.ClassBuilder\nimport org.jetbrains.kotlin.codegen.coroutines.*\nimport org.jetbrains.kotlin.codegen.inline.*\nimport org.jetbrains.kotlin.codegen.optimization.common.asSequence\nimport org.jetbrains.kotlin.codegen.optimization.transformer.MethodTransformer\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin\nimport org.jetbrains.org.objectweb.asm.MethodVisitor\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.tree.*\nimport org.jetbrains.org.objectweb.asm.tree.analysis.BasicInterpreter\nimport org.jetbrains.org.objectweb.asm.tree.analysis.BasicValue\nimport org.jetbrains.org.objectweb.asm.tree.analysis.Frame\n\nconst val FOR_INLINE_SUFFIX = \"\\$\\$forInline\"\n\nclass CoroutineTransformer(\n    private val inliningContext: Inli"}
{"code": "ningContext,\n    private val classBuilder: ClassBuilder,\n    private val methods: List<MethodNode>,\n    private val superClassName: String\n) {\n    private val state = inliningContext.state\n\n    // If we inline into inline function, we should generate both method with state-machine for Java interop and method without\n    // state-machine for further transformation/inlining.\n    private val generateForInline = inliningContext.callSiteInfo.isInlineOrInsideInline\n\n    fun shouldSkip(node: MethodNode): Boolean = methods.any { it.name == node.name + FOR_INLINE_SUFFIX && it.desc == node.desc }\n\n    fun shouldGenerateStateMachine(node: MethodNode): Boolean {\n        // Continuations are similar to lambdas from bird's view, but we should never generate state machine for them\n        if (isContinuationNotLambda()) return false\n        return isSuspendFunctionWithFakeConstructorCall(node) || (isSuspendLambda(node) && !isStateMachine(node))\n    }\n\n    // there can be suspend lambdas inside inline "}
{"code": "functions, which do not\n    // capture crossinline lambdas, thus, there is no need to transform them\n    fun suspendLambdaWithGeneratedStateMachine(node: MethodNode): Boolean =\n        !isContinuationNotLambda() && isSuspendLambda(node) && isStateMachine(node)\n\n    private fun isContinuationNotLambda(): Boolean = inliningContext.isContinuation && superClassName.endsWith(\"ContinuationImpl\")\n\n    private fun isStateMachine(node: MethodNode): Boolean =\n        node.instructions.asSequence().any { insn -> insn is LdcInsnNode && insn.cst == ILLEGAL_STATE_ERROR_MESSAGE }\n\n    private fun isSuspendLambda(node: MethodNode) = isInvokeSuspend(node)\n\n    fun newMethod(node: MethodNode): DeferredMethodVisitor {\n        return when {\n            isInvokeSuspend(node) -> {\n                assert(!isStateMachine(node)) {\n                    \"Inlining/transforming state-machine\"\n                }\n                newStateMachineForLambda(node)\n            }\n            isSuspendFunctionWithFakeConstruc"}
{"code": "torCall(node) -> newStateMachineForNamedFunction(node)\n            else -> error(\"no need to generate state maching for ${node.name}\")\n        }\n    }\n\n    private fun isInvokeSuspend(node: MethodNode): Boolean =\n        node.name.removeSuffix(FOR_INLINE_SUFFIX) == INVOKE_SUSPEND_METHOD_NAME && inliningContext.isContinuation\n\n    private fun isSuspendFunctionWithFakeConstructorCall(node: MethodNode): Boolean = findFakeContinuationConstructorClassName(node) != null\n\n    private fun newStateMachineForLambda(node: MethodNode): DeferredMethodVisitor {\n        val name = node.name.removeSuffix(FOR_INLINE_SUFFIX)\n        return DeferredMethodVisitor(\n            MethodNode(\n                node.access, name, node.desc, node.signature,\n                ArrayUtil.toStringArray(node.exceptions)\n            )\n        ) {\n            val sourceCompilerForInline = inliningContext.root.sourceCompilerForInline\n            val stateMachineBuilder = CoroutineTransformerMethodVisitor(\n                cr"}
{"code": "eateNewMethodFrom(node, name), node.access, name, node.desc, null, null,\n                containingClassInternalName = classBuilder.thisName,\n                obtainClassBuilderForCoroutineState = { classBuilder },\n                isForNamedFunction = false,\n                disableTailCallOptimizationForFunctionReturningUnit = false,\n                reportSuspensionPointInsideMonitor = { sourceCompilerForInline.reportSuspensionPointInsideMonitor(it) },\n                // TODO: this linenumbers might not be correct and since they are used only for step-over, check them.\n                lineNumber = inliningContext.callSiteInfo.lineNumber,\n                sourceFile = inliningContext.callSiteInfo.file?.name ?: \"\",\n            )\n\n            if (generateForInline)\n                SuspendForInlineCopyingMethodVisitor(stateMachineBuilder, node.access, name, node.desc, classBuilder::newMethod)\n            else\n                stateMachineBuilder\n        }\n    }\n\n    private fun newStateMachin"}
{"code": "eForNamedFunction(node: MethodNode): DeferredMethodVisitor {\n        val name = node.name.removeSuffix(FOR_INLINE_SUFFIX)\n        val continuationClassName = findFakeContinuationConstructorClassName(node)\n        assert(inliningContext is RegeneratedClassContext)\n        return DeferredMethodVisitor(\n            MethodNode(\n                node.access, name, node.desc, node.signature,\n                ArrayUtil.toStringArray(node.exceptions)\n            )\n        ) {\n            // If the node already has state-machine, it is safer to generate state-machine.\n            val disableTailCallOptimization = methods.find { it.name == name && it.desc == node.desc }?.let { isStateMachine(it) } ?: false\n            val sourceCompilerForInline = inliningContext.root.sourceCompilerForInline\n            val stateMachineBuilder = CoroutineTransformerMethodVisitor(\n                createNewMethodFrom(node, name), node.access, name, node.desc, null, null,\n                containingClassInternalName ="}
{"code": " classBuilder.thisName,\n                obtainClassBuilderForCoroutineState = { (inliningContext as RegeneratedClassContext).continuationBuilders[continuationClassName]!! },\n                isForNamedFunction = true,\n                disableTailCallOptimizationForFunctionReturningUnit = disableTailCallOptimization,\n                reportSuspensionPointInsideMonitor = { sourceCompilerForInline.reportSuspensionPointInsideMonitor(it) },\n                lineNumber = inliningContext.callSiteInfo.lineNumber,\n                sourceFile = inliningContext.callSiteInfo.file?.name ?: \"\",\n                needDispatchReceiver = true,\n                internalNameForDispatchReceiver = classBuilder.thisName,\n                putContinuationParameterToLvt = !state.isIrBackend,\n            )\n\n            if (generateForInline)\n                SuspendForInlineCopyingMethodVisitor(stateMachineBuilder, node.access, name, node.desc, classBuilder::newMethod)\n            else\n                stateMachineBuilder"}
{"code": "\n        }\n    }\n\n    private fun createNewMethodFrom(node: MethodNode, name: String): MethodVisitor {\n        return classBuilder.newMethod(\n            JvmDeclarationOrigin.NO_ORIGIN, node.access, name, node.desc, node.signature, ArrayUtil.toStringArray(node.exceptions)\n        )\n    }\n\n    fun replaceFakesWithReals(node: MethodNode) {\n        findFakeContinuationConstructorClassName(node)?.let(::unregisterClassBuilder)?.done(state.config.generateSmapCopyToAnnotation)\n        replaceFakeContinuationsWithRealOnes(\n            node, if (!inliningContext.isContinuation) getLastParameterIndex(node.desc, node.access) else 0\n        )\n    }\n\n    fun registerClassBuilder(continuationClassName: String) {\n        val context = inliningContext.parent?.parent as? RegeneratedClassContext ?: error(\"incorrect context\")\n        context.continuationBuilders[continuationClassName] = classBuilder\n    }\n\n    private fun unregisterClassBuilder(continuationClassName: String): ClassBuilder? =\n        (inl"}
{"code": "iningContext as RegeneratedClassContext).continuationBuilders.remove(continuationClassName)\n\n    // If tail-call optimization took place, we do not need continuation class anymore, unless it is used by $$forInline method\n    fun safeToRemoveContinuationClass(method: MethodNode): Boolean = !generateForInline && !isStateMachine(method)\n\n    fun oldContinuationFrom(method: MethodNode): String? =\n        methods.find { it.name == method.name + FOR_INLINE_SUFFIX && it.desc == method.desc }\n            ?.let { findFakeContinuationConstructorClassName(it) }\n\n    companion object {\n        fun findFakeContinuationConstructorClassName(node: MethodNode): String? {\n            val marker = node.instructions.asSequence().firstOrNull(::isBeforeFakeContinuationConstructorCallMarker) ?: return null\n            val new = marker.next\n            assert(new?.opcode == Opcodes.NEW)\n            return (new as TypeInsnNode).desc\n        }\n    }\n}\n\nprivate const val NOINLINE_CALL_MARKER = \"\\$\\$\\$\\$\\$NOINLIN"}
{"code": "E_CALL_MARKER\\$\\$\\$\\$\\$\"\n\nfun markNoinlineLambdaIfSuspend(mv: MethodVisitor, info: FunctionalArgument?) {\n    when (info) {\n        NonInlineArgumentForInlineSuspendParameter.OTHER ->\n            mv.visitMethodInsn(Opcodes.INVOKESTATIC, NOINLINE_CALL_MARKER, \"always\", \"()V\", false)\n        NonInlineArgumentForInlineSuspendParameter.INLINE_LAMBDA_AS_VARIABLE -> // depends on how it's substituted later\n            mv.visitMethodInsn(Opcodes.INVOKESTATIC, NOINLINE_CALL_MARKER, \"conditional\", \"()V\", false)\n    }\n}\n\nprivate fun Frame<BasicValue>.getSource(offset: Int): AbstractInsnNode? = (getStack(stackSize - offset - 1) as? PossibleLambdaLoad)?.insn\n\nfun surroundInvokesWithSuspendMarkersIfNeeded(node: MethodNode) {\n    val markers = node.instructions.asSequence().filter {\n        it.opcode == Opcodes.INVOKESTATIC && (it as MethodInsnNode).owner == NOINLINE_CALL_MARKER\n    }.toList()\n    if (markers.isEmpty()) return\n\n    val sourceFrames = MethodTransformer.analyze(\"fake\", node, CapturedL"}
{"code": "ambdaInterpreter())\n    val loads = markers.map { marker ->\n        val arity = (marker.next as MethodInsnNode).owner.removePrefix(NUMBERED_FUNCTION_PREFIX).toInt()\n        var receiver = sourceFrames[node.instructions.indexOf(marker) + 1]?.getSource(arity)\n        // Navigate the ALOAD+GETFIELD+... chain to the first instruction. We need to insert a stack\n        // spilling marker before it starts.\n        while (receiver?.opcode == Opcodes.GETFIELD) {\n            receiver = receiver.previous\n        }\n        receiver\n    }\n    for ((marker, load) in markers.zip(loads)) {\n        val conditional = (marker as MethodInsnNode).name == \"conditional\"\n        val invoke = marker.next as MethodInsnNode\n        node.instructions.remove(marker)\n        if (load == null) {\n            continue // dead code, doesn't matter\n        }\n        node.instructions.insertBefore(load, withInstructionAdapter {\n            addInlineMarker(this, isStartNotEnd = true)\n        })\n        node.instructions."}
{"code": "insertBefore(invoke, withInstructionAdapter {\n            addSuspendMarker(this, isStartNotEnd = true, inlinable = conditional)\n        })\n        node.instructions.insert(invoke, withInstructionAdapter {\n            addSuspendMarker(this, isStartNotEnd = false, inlinable = conditional)\n            addInlineMarker(this, isStartNotEnd = false)\n        })\n    }\n}\n\n// Interpreter, that keeps track of captured functional arguments\nprivate class PossibleLambdaLoad(val insn: AbstractInsnNode) : BasicValue(AsmTypes.OBJECT_TYPE)\n\nprivate class CapturedLambdaInterpreter : BasicInterpreter(Opcodes.API_VERSION) {\n    override fun newOperation(insn: AbstractInsnNode): BasicValue? {\n        if (insn.opcode == Opcodes.GETSTATIC) {\n            insn.fieldLoad()?.let { return it }\n        }\n\n        return super.newOperation(insn)\n    }\n\n    private fun AbstractInsnNode.fieldLoad(): PossibleLambdaLoad? {\n        if (this !is FieldInsnNode) return null\n        if (desc.startsWith('L') && Type.getType(de"}
{"code": "sc).internalName.isNumberedFunctionInternalName()) {\n            if ((opcode == Opcodes.GETSTATIC && name.startsWith(CAPTURED_FIELD_FOLD_PREFIX + CAPTURED_FIELD_PREFIX)) ||\n                (opcode == Opcodes.GETFIELD && isCapturedFieldName(name))\n            ) return PossibleLambdaLoad(this)\n        }\n        return null\n    }\n\n    override fun copyOperation(insn: AbstractInsnNode, value: BasicValue?): BasicValue? =\n        if (insn.opcode == Opcodes.ALOAD) PossibleLambdaLoad(insn) else super.copyOperation(insn, value)\n\n    override fun unaryOperation(insn: AbstractInsnNode, value: BasicValue?): BasicValue? {\n        if (insn.opcode == Opcodes.GETFIELD) {\n            insn.fieldLoad()?.let { return it }\n        }\n        return super.unaryOperation(insn, value)\n    }\n\n    override fun merge(v: BasicValue?, w: BasicValue?): BasicValue? =\n        if (v is PossibleLambdaLoad && w is PossibleLambdaLoad && v.insn == w.insn) v else super.merge(v, w)\n}\n"}
{"code": "interface Foo {\n    operator fun <T> invoke(t: T)\n}\n\nfun test(f: Foo) {\n    <expr>f(\"\")</expr>\n}"}
{"code": "interface A\ninterface B\n\nfun <T> T.foo() where T: A, T: B {}\n\nfun test(a: Any) {\n    if (a is A && a is B) {\n        <expr>a</expr>.foo()\n    }\n}"}
{"code": "interface MyMap<K, V> {\n    operator fun get(k: K): V\n    operator fun set(k: K, v: V)\n}\n\nfun test(m: MyMap<String, Int>) {\n    <expr>m[\"a\"]++</expr>\n}"}
{"code": "// FILE: KotlinFile.kt\n// FILE: JavaClass.java\nclass JavaClass {\n    void materialize(int[] va<caret>lues) {}\n}\n"}
{"code": "class Foo {\n    fun foo(string: String) {}\n\n    fun foo(number: Int) {}\n\n    private fun foo(boolean: Boolean) {}\n}\n\n\nfun usage() {}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.signatures\n\nimport org.jetbrains.kotlin.analysis.api.symbols.KtFunctionLikeSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtValueParameterSymbol\nimport org.jetbrains.kotlin.analysis.api.types.KtSubstitutor\n\n\npublic abstract class KtFunctionLikeSignature<out S : KtFunctionLikeSymbol> : KtCallableSignature<S>() {\n    \n    public abstract val valueParameters: List<KtVariableLikeSignature<KtValueParameterSymbol>>\n\n    abstract override fun substitute(substitutor: KtSubstitutor): KtFunctionLikeSignature<S>\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental\n\nimport com.intellij.openapi.util.io.FileUtil.toSystemIndependentName\nimport com.intellij.util.io.BooleanDataDescriptor\nimport org.jetbrains.annotations.TestOnly\nimport org.jetbrains.kotlin.build.GeneratedJvmClass\nimport org.jetbrains.kotlin.incremental.storage.*\nimport org.jetbrains.kotlin.inline.InlineFunction\nimport org.jetbrains.kotlin.inline.InlineFunctionOrAccessor\nimport org.jetbrains.kotlin.inline.InlinePropertyAccessor\nimport org.jetbrains.kotlin.load.kotlin.header.KotlinClassHeader\nimport org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache\nimport org.jetbrains.kotlin.load.kotlin.incremental.components.JvmPackagePartProto\nimport org.jetbrains.kotlin.metadata.ProtoBuf\nimport org.jetbrains.kotlin.metadata.jvm.deserialization.JvmProtoBufUtil\nimport org.jetbrains.kotlin.metadata.jvm.deserialization.ModuleMapping\nimport org.jetbrains.kotlin.metadata.jvm.serialization.JvmStringTable\nimport org.jetbrains.kotlin.name.Clas"}
{"code": "sId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.resolve.jvm.JvmClassName\nimport java.io.File\nimport java.security.MessageDigest\n\nconst val KOTLIN_CACHE_DIRECTORY_NAME = \"kotlin\"\n\nopen class IncrementalJvmCache(\n    targetDataRoot: File,\n    icContext: IncrementalCompilationContext,\n    targetOutputDir: File?,\n) : AbstractIncrementalCache<JvmClassName>(\n    workingDir = File(targetDataRoot, KOTLIN_CACHE_DIRECTORY_NAME),\n    icContext,\n), IncrementalCache {\n    companion object {\n        private const val PROTO_MAP = \"proto\"\n        private const val FE_PROTO_MAP = \"fe-proto\"\n        private const val CONSTANTS_MAP = \"constants\"\n        private const val PACKAGE_PARTS = \"package-parts\"\n        private const val MULTIFILE_CLASS_FACADES = \"multifile-class-facades\"\n        private const val MULTIFILE_CLASS_PARTS = \"multifile-class-parts\"\n        private const val INLINE_FUNCTIONS = \"inline-functions\"\n        private const val INTERNAL_NAME_TO_SOURCE = \"internal-name-"}
{"code": "to-source\"\n        private const val JAVA_SOURCES_PROTO_MAP = \"java-sources-proto-map\"\n\n        private const val MODULE_MAPPING_FILE_NAME = \".\" + ModuleMapping.MAPPING_FILE_EXT\n    }\n\n    override val sourceToClassesMap = registerMap(SourceToJvmNameMap(SOURCE_TO_CLASSES.storageFile, icContext))\n    override val dirtyOutputClassesMap = registerMap(DirtyClassesJvmNameMap(DIRTY_OUTPUT_CLASSES.storageFile, icContext))\n\n    private val protoMap = registerMap(ProtoMap(PROTO_MAP.storageFile, icContext))\n    private val feProtoMap = registerMap(ProtoMap(FE_PROTO_MAP.storageFile, icContext))\n    private val constantsMap = registerMap(ConstantsMap(CONSTANTS_MAP.storageFile, icContext))\n    private val packagePartMap = registerMap(PackagePartMap(PACKAGE_PARTS.storageFile, icContext))\n    private val multifileFacadeToParts = registerMap(MultifileClassFacadeMap(MULTIFILE_CLASS_FACADES.storageFile, icContext))\n    private val partToMultifileFacade = registerMap(MultifileClassPartMap(MULTIFILE_CLASS"}
{"code": "_PARTS.storageFile, icContext))\n    private val inlineFunctionsMap = registerMap(InlineFunctionsMap(INLINE_FUNCTIONS.storageFile, icContext))\n\n    // todo: try to use internal names only?\n    private val internalNameToSource = registerMap(InternalNameToSourcesMap(INTERNAL_NAME_TO_SOURCE.storageFile, icContext))\n\n    // gradle only\n    private val javaSourcesProtoMap = registerMap(JavaSourcesProtoMap(JAVA_SOURCES_PROTO_MAP.storageFile, icContext))\n\n    private val outputDir by lazy(LazyThreadSafetyMode.NONE) { requireNotNull(targetOutputDir) { \"Target is expected to have output directory\" } }\n\n    protected open fun debugLog(message: String) {}\n\n    fun isTrackedFile(file: File) = sourceToClassesMap.contains(file)\n\n    // used in gradle\n    @Suppress(\"unused\")\n    fun classesBySources(sources: Iterable<File>): Iterable<JvmClassName> =\n        sources.flatMap { sourceToClassesMap[it].orEmpty() }\n\n    fun sourcesByInternalName(internalName: String): Collection<File> =\n        internalName"}
{"code": "ToSource[internalName].orEmpty()\n\n    fun getAllPartsOfMultifileFacade(facade: JvmClassName): Collection<String>? {\n        return multifileFacadeToParts[facade]\n    }\n\n    fun isMultifileFacade(className: JvmClassName): Boolean =\n        className in multifileFacadeToParts\n\n    override fun getClassFilePath(internalClassName: String): String {\n        return toSystemIndependentName(File(outputDir, \"$internalClassName.class\").normalize().absolutePath)\n    }\n\n    override fun updateComplementaryFiles(dirtyFiles: Collection<File>, expectActualTracker: ExpectActualTrackerImpl) {\n        if (icContext.useCompilerMapsOnly) return\n        super.updateComplementaryFiles(dirtyFiles, expectActualTracker)\n    }\n\n    fun saveModuleMappingToCache(sourceFiles: Collection<File>, file: File) {\n        val jvmClassName = JvmClassName.byInternalName(MODULE_MAPPING_FILE_NAME)\n        protoMap.storeModuleMapping(jvmClassName, file.readBytes())\n        dirtyOutputClassesMap.notDirty(jvmClassName)\n        "}
{"code": "sourceFiles.forEach { sourceToClassesMap.append(it, jvmClassName) }\n    }\n\n    open fun saveFileToCache(generatedClass: GeneratedJvmClass, changesCollector: ChangesCollector) {\n        saveClassToCache(KotlinClassInfo.createFrom(generatedClass.outputClass), generatedClass.sourceFiles, changesCollector)\n    }\n\n    \n    fun saveClassToCache(kotlinClassInfo: KotlinClassInfo, sourceFiles: List<File>?, changesCollector: ChangesCollector) {\n        val className = kotlinClassInfo.className\n\n        dirtyOutputClassesMap.notDirty(className)\n\n        if (sourceFiles != null) {\n            sourceFiles.forEach {\n                sourceToClassesMap.append(it, className)\n            }\n            if (!icContext.useCompilerMapsOnly) internalNameToSource[className.internalName] = sourceFiles\n        }\n\n        if (kotlinClassInfo.classId.isLocal) return\n\n        when (kotlinClassInfo.classKind) {\n            KotlinClassHeader.Kind.FILE_FACADE -> {\n                if (sourceFiles != null) {\n          "}
{"code": "          assert(sourceFiles.size == 1) { \"Package part from several source files: $sourceFiles\" }\n                }\n                packagePartMap.addPackagePart(className)\n\n                protoMap.process(kotlinClassInfo, changesCollector)\n                if (!icContext.useCompilerMapsOnly) {\n                    constantsMap.process(kotlinClassInfo, changesCollector)\n                    inlineFunctionsMap.process(kotlinClassInfo, changesCollector)\n                }\n            }\n            KotlinClassHeader.Kind.MULTIFILE_CLASS -> {\n                val partNames = kotlinClassInfo.classHeaderData.toList()\n                check(partNames.isNotEmpty()) { \"Multifile class has no parts: $className\" }\n                multifileFacadeToParts[className] = partNames\n                // When a class is replaced with a facade with the same name,\n                // the class' proto wouldn't ever be deleted,\n                // because we don't write proto for multifile facades.\n                //"}
{"code": " As a workaround we can remove proto values for multifile facades.\n                if (className in protoMap) {\n                    changesCollector.collectSignature(className.fqNameForClassNameWithoutDollars, areSubclassesAffected = true)\n                }\n                protoMap.remove(className, changesCollector)\n                classFqNameToSourceMap.remove(className.fqNameForClassNameWithoutDollars)\n                if (!icContext.useCompilerMapsOnly) {\n\n                    classAttributesMap.remove(className.fqNameForClassNameWithoutDollars)\n                    internalNameToSource.remove(className.internalName)\n\n                    // TODO NO_CHANGES? (delegates only)\n                    constantsMap.process(kotlinClassInfo, changesCollector)\n                    inlineFunctionsMap.process(kotlinClassInfo, changesCollector)\n                }\n            }\n            KotlinClassHeader.Kind.MULTIFILE_CLASS_PART -> {\n                if (sourceFiles != null) {\n                    as"}
{"code": "sert(sourceFiles.size == 1) { \"Multifile class part from several source files: $sourceFiles\" }\n                }\n                packagePartMap.addPackagePart(className)\n                partToMultifileFacade[className] = kotlinClassInfo.multifileClassName!!\n                protoMap.process(kotlinClassInfo, changesCollector)\n                if (!icContext.useCompilerMapsOnly) {\n                    constantsMap.process(kotlinClassInfo, changesCollector)\n                    inlineFunctionsMap.process(kotlinClassInfo, changesCollector)\n                }\n            }\n            KotlinClassHeader.Kind.CLASS -> {\n                if (!icContext.useCompilerMapsOnly) {\n                    addToClassStorage(kotlinClassInfo.protoData as ClassProtoData, sourceFiles?.let { sourceFiles.single() })\n                }\n\n                protoMap.process(kotlinClassInfo, changesCollector)\n\n                if (!icContext.useCompilerMapsOnly) {\n                    constantsMap.process(kotlinClassInfo, chan"}
{"code": "gesCollector)\n                    inlineFunctionsMap.process(kotlinClassInfo, changesCollector)\n                }\n            }\n            KotlinClassHeader.Kind.UNKNOWN, KotlinClassHeader.Kind.SYNTHETIC_CLASS -> {\n            }\n        }\n    }\n\n    fun saveFrontendClassToCache(\n        classId: ClassId,\n        classProto: ProtoBuf.Class,\n        stringTable: JvmStringTable,\n        sourceFiles: List<File>?,\n        changesCollector: ChangesCollector,\n    ) {\n\n        val className = JvmClassName.byClassId(classId)\n\n        if (sourceFiles != null) {\n            internalNameToSource[className.internalName] = sourceFiles\n        }\n\n        if (classId.isLocal) return\n\n        val newProtoData = ClassProtoData(classProto, stringTable.toNameResolver())\n        addToClassStorage(newProtoData, sourceFiles?.let { sourceFiles.single() })\n\n        feProtoMap.putAndCollect(\n            className,\n            ProtoMapValue(\n                false,\n                JvmProtoBufUtil.writeDataBytes("}
{"code": "stringTable, classProto),\n                stringTable.strings.toTypedArray()\n            ),\n            newProtoData,\n            changesCollector\n        )\n    }\n\n    fun collectClassChangesByFeMetadata(\n        className: JvmClassName, classProto: ProtoBuf.Class, stringTable: JvmStringTable, changesCollector: ChangesCollector,\n    ) {\n        //class\n        feProtoMap.check(className, classProto, stringTable, changesCollector)\n    }\n\n    fun saveJavaClassProto(source: File?, serializedJavaClass: SerializedJavaClass, collector: ChangesCollector) {\n        val jvmClassName = JvmClassName.byClassId(serializedJavaClass.classId)\n\n        if (!icContext.useCompilerMapsOnly) {\n            javaSourcesProtoMap.process(jvmClassName, serializedJavaClass, collector)\n        }\n        source?.let { sourceToClassesMap.append(source, jvmClassName) }\n        if (!icContext.useCompilerMapsOnly) {\n            addToClassStorage(serializedJavaClass.toProtoData(), source)\n//        collector.addJavaProt"}
{"code": "o(ClassProtoData(proto, nameResolver))\n        }\n        dirtyOutputClassesMap.notDirty(jvmClassName)\n    }\n\n    fun getObsoleteJavaClasses(): Collection<ClassId> =\n        dirtyOutputClassesMap.getDirtyOutputClasses()\n            .mapNotNull {\n                javaSourcesProtoMap[it]?.classId\n            }\n\n    fun isJavaClassToTrack(classId: ClassId): Boolean {\n        val jvmClassName = JvmClassName.byClassId(classId)\n        return dirtyOutputClassesMap.isDirty(jvmClassName) ||\n                jvmClassName !in javaSourcesProtoMap\n    }\n\n    fun isJavaClassAlreadyInCache(classId: ClassId): Boolean {\n        val jvmClassName = JvmClassName.byClassId(classId)\n        return jvmClassName in javaSourcesProtoMap\n    }\n\n    override fun clearCacheForRemovedClasses(changesCollector: ChangesCollector) {\n        val dirtyClasses = dirtyOutputClassesMap.getDirtyOutputClasses()\n\n        val facadesWithRemovedParts = hashMapOf<JvmClassName, MutableSet<String>>()\n        for (dirtyClass in dirtyC"}
{"code": "lasses) {\n            val facade = partToMultifileFacade[dirtyClass] ?: continue\n            val facadeClassName = JvmClassName.byInternalName(facade)\n            val removedParts = facadesWithRemovedParts.getOrPut(facadeClassName) { hashSetOf() }\n            removedParts.add(dirtyClass.internalName)\n        }\n\n        for ((facade, removedParts) in facadesWithRemovedParts.entries) {\n            val allParts = multifileFacadeToParts[facade] ?: continue\n            val notRemovedParts = allParts.filter { it !in removedParts }\n\n            if (notRemovedParts.isEmpty()) {\n                multifileFacadeToParts.remove(facade)\n            } else {\n                multifileFacadeToParts[facade] = notRemovedParts\n            }\n        }\n\n        dirtyClasses.forEach {\n            protoMap.remove(it, changesCollector)\n            feProtoMap.remove(it, changesCollector)\n            packagePartMap.remove(it)\n            multifileFacadeToParts.remove(it)\n            partToMultifileFacade.remove("}
{"code": "it)\n            if (!icContext.useCompilerMapsOnly) {\n                constantsMap.remove(it)\n                inlineFunctionsMap.remove(it)\n                internalNameToSource.remove(it.internalName)\n                javaSourcesProtoMap.remove(it, changesCollector)\n            }\n        }\n\n        if (!icContext.useCompilerMapsOnly) {\n            removeAllFromClassStorage(dirtyClasses.map { it.fqNameForClassNameWithoutDollars }, changesCollector)\n        }\n        dirtyOutputClassesMap.clear()\n    }\n\n    override fun getObsoletePackageParts(): Collection<String> {\n        val obsoletePackageParts = dirtyOutputClassesMap.getDirtyOutputClasses().filter(packagePartMap::isPackagePart)\n        debugLog(\"Obsolete package parts: $obsoletePackageParts\")\n        return obsoletePackageParts.map { it.internalName }\n    }\n\n    override fun getPackagePartData(partInternalName: String): JvmPackagePartProto? {\n        return protoMap[JvmClassName.byInternalName(partInternalName)]?.let { value ->\n    "}
{"code": "        JvmPackagePartProto(value.bytes, value.strings)\n        }\n    }\n\n    override fun getObsoleteMultifileClasses(): Collection<String> {\n        val obsoleteMultifileClasses = linkedSetOf<String>()\n        for (dirtyClass in dirtyOutputClassesMap.getDirtyOutputClasses()) {\n            val dirtyFacade = partToMultifileFacade[dirtyClass] ?: continue\n            obsoleteMultifileClasses.add(dirtyFacade)\n        }\n        debugLog(\"Obsolete multifile class facades: $obsoleteMultifileClasses\")\n        return obsoleteMultifileClasses\n    }\n\n    override fun getStableMultifileFacadeParts(facadeInternalName: String): Collection<String>? {\n        val jvmClassName = JvmClassName.byInternalName(facadeInternalName)\n        val partNames = multifileFacadeToParts[jvmClassName] ?: return null\n        return partNames.filter { !dirtyOutputClassesMap.isDirty(JvmClassName.byInternalName(it)) }\n    }\n\n    override fun getModuleMappingData(): ByteArray? {\n        return protoMap[JvmClassName.byInter"}
{"code": "nalName(MODULE_MAPPING_FILE_NAME)]?.bytes\n    }\n\n    private inner class ProtoMap(\n        storageFile: File,\n        icContext: IncrementalCompilationContext,\n    ) : BasicStringMap<ProtoMapValue>(storageFile, ProtoMapValueExternalizer, icContext) {\n\n        @Synchronized\n        fun process(kotlinClassInfo: KotlinClassInfo, changesCollector: ChangesCollector) {\n            return putAndCollect(\n                kotlinClassInfo.className,\n                kotlinClassInfo.protoMapValue,\n                kotlinClassInfo.protoData,\n                changesCollector\n            )\n        }\n\n        // A module mapping (.kotlin_module file) is stored in a cache,\n        // because a corresponding file will be deleted on each round\n        // (it is reported as output for each [package part?] source file).\n        // If a mapping is not preserved, a resulting file will only contain data\n        // from files compiled during last round.\n        // However there is no need to compare old and new "}
{"code": "data in this case\n        // (also that would fail with exception).\n        @Synchronized\n        fun storeModuleMapping(className: JvmClassName, bytes: ByteArray) {\n            storage[className.internalName] = ProtoMapValue(isPackageFacade = false, bytes = bytes, strings = emptyArray())\n        }\n\n        @Synchronized\n        fun putAndCollect(\n            className: JvmClassName,\n            newMapValue: ProtoMapValue,\n            newProtoData: ProtoData,\n            changesCollector: ChangesCollector,\n        ) {\n            val key = className.internalName\n            val oldMapValue = storage[key]\n            storage[key] = newMapValue\n\n            changesCollector.collectProtoChanges(oldMapValue?.toProtoData(className.packageFqName), newProtoData, packageProtoKey = key)\n        }\n\n        fun check(\n            className: JvmClassName, classProto: ProtoBuf.Class, stringTable: JvmStringTable, changesCollector: ChangesCollector,\n        ) {\n            val key = className.interna"}
{"code": "lName\n            val oldProtoData = storage[key]?.toProtoData(className.packageFqName)\n            val newProtoData = ClassProtoData(classProto, stringTable.toNameResolver())\n            changesCollector.collectProtoChanges(oldProtoData, newProtoData, packageProtoKey = key)\n        }\n\n        operator fun contains(className: JvmClassName): Boolean =\n            className.internalName in storage\n\n        operator fun get(className: JvmClassName): ProtoMapValue? =\n            storage[className.internalName]\n\n        @Synchronized\n        fun remove(className: JvmClassName, changesCollector: ChangesCollector) {\n            val key = className.internalName\n            val oldValue = storage[key] ?: return\n            if (key != MODULE_MAPPING_FILE_NAME) {\n                changesCollector.collectProtoChanges(oldData = oldValue.toProtoData(className.packageFqName), newData = null)\n            }\n            storage.remove(key)\n        }\n\n        override fun dumpValue(value: ProtoMapValue): "}
{"code": "String {\n            return (if (value.isPackageFacade) \"1\" else \"0\") + java.lang.Long.toHexString(value.bytes.md5())\n        }\n    }\n\n    private inner class JavaSourcesProtoMap(\n        storageFile: File,\n        icContext: IncrementalCompilationContext,\n    ) :\n        BasicStringMap<SerializedJavaClass>(storageFile, JavaClassProtoMapValueExternalizer, icContext) {\n\n        @Synchronized\n        fun process(jvmClassName: JvmClassName, newData: SerializedJavaClass, changesCollector: ChangesCollector) {\n            val key = jvmClassName.internalName\n            val oldData = storage[key]\n            storage[key] = newData\n\n            changesCollector.collectProtoChanges(\n                oldData?.toProtoData(), newData.toProtoData(),\n                collectAllMembersForNewClass = true\n            )\n        }\n\n        @Synchronized\n        fun remove(className: JvmClassName, changesCollector: ChangesCollector) {\n            val key = className.internalName\n            val oldValue = s"}
{"code": "torage[key] ?: return\n            storage.remove(key)\n\n            changesCollector.collectProtoChanges(oldValue.toProtoData(), newData = null)\n        }\n\n        operator fun get(className: JvmClassName): SerializedJavaClass? =\n            storage[className.internalName]\n\n        operator fun contains(className: JvmClassName): Boolean =\n            className.internalName in storage\n\n        override fun dumpValue(value: SerializedJavaClass): String =\n            java.lang.Long.toHexString(value.proto.toByteArray().md5())\n    }\n\n    // todo: reuse code with InlineFunctionsMap?\n    private inner class ConstantsMap(\n        storageFile: File,\n        icContext: IncrementalCompilationContext,\n    ) :\n        BasicStringMap<Map<String, Long>>(storageFile, MapExternalizer(StringExternalizer, LongExternalizer), icContext) {\n\n        operator fun contains(className: JvmClassName): Boolean =\n            className.internalName in storage\n\n        @Synchronized\n        fun process(kotlinClassInf"}
{"code": "o: KotlinClassInfo, changesCollector: ChangesCollector) {\n            val key = kotlinClassInfo.className.internalName\n            val oldMap = storage[key] ?: emptyMap()\n\n            val newMap = kotlinClassInfo.extraInfo.constantSnapshots\n            if (newMap.isNotEmpty()) {\n                storage[key] = newMap\n            } else {\n                storage.remove(key)\n            }\n\n            val allConstants = oldMap.keys + newMap.keys\n            if (allConstants.isEmpty()) return\n\n            val scope = kotlinClassInfo.scopeFqName()\n            for (const in allConstants) {\n                changesCollector.collectMemberIfValueWasChanged(scope, const, oldMap[const], newMap[const])\n            }\n\n            // If a constant is defined in a companion object of class A, its name and type will be found in the Kotlin metadata of\n            // `A$Companion.class`, but its value will only be found in the Java bytecode code of `A.class` (see\n            // `org.jetbrains.kotlin.incr"}
{"code": "emental.classpathDiff.ConstantsInCompanionObjectImpact` for more details).\n            // Therefore, if the value of `CONSTANT` in `A.class` has changed, we will report that `A.CONSTANT` has changed in the code\n            // above, and report that `A.Companion.CONSTANT` is impacted in the code below.\n            kotlinClassInfo.companionObject?.let { companionObjectClassId ->\n                // Note that `companionObjectClassId` is the companion object of the current class. Here we assume that the previous class\n                // also has a companion object with the same name. If that is not the case, that change will be detected when comparing\n                // protos, and the report below will be imprecise/redundant, but it's okay to over-approximate the result.\n                val companionObjectFqName = companionObjectClassId.asSingleFqName()\n                for (const in allConstants) {\n                    changesCollector.collectMemberIfValueWasChanged(\n                       "}
{"code": " scope = companionObjectFqName, name = const, oldMap[const], newMap[const]\n                    )\n                }\n            }\n        }\n\n        @Synchronized\n        fun remove(className: JvmClassName) {\n            storage.remove(className.internalName)\n        }\n\n        override fun dumpValue(value: Map<String, Long>): String =\n            value.dumpMap(Long::toString)\n    }\n\n    private inner class PackagePartMap(\n        storageFile: File,\n        icContext: IncrementalCompilationContext,\n    ) : BasicStringMap<Boolean>(storageFile, BooleanDataDescriptor.INSTANCE, icContext) {\n        fun addPackagePart(className: JvmClassName) {\n            storage[className.internalName] = true\n        }\n\n        fun remove(className: JvmClassName) {\n            storage.remove(className.internalName)\n        }\n\n        fun isPackagePart(className: JvmClassName): Boolean =\n            className.internalName in storage\n\n        override fun dumpValue(value: Boolean) = \"\"\n    }\n\n    private inn"}
{"code": "er class MultifileClassFacadeMap(\n        storageFile: File,\n        icContext: IncrementalCompilationContext,\n    ) : AppendableBasicMap<JvmClassName, String>(\n        storageFile,\n        JvmClassNameExternalizer.toDescriptor(),\n        StringExternalizer,\n        icContext\n    )\n\n    private inner class MultifileClassPartMap(\n        storageFile: File,\n        icContext: IncrementalCompilationContext,\n    ) : AbstractBasicMap<JvmClassName, String>(\n        storageFile,\n        JvmClassNameExternalizer.toDescriptor(),\n        StringExternalizer,\n        icContext\n    )\n\n    inner class InternalNameToSourcesMap(\n        storageFile: File,\n        icContext: IncrementalCompilationContext,\n    ) : AppendableBasicMap<String, File>(\n        storageFile,\n        StringExternalizer.toDescriptor(),\n        icContext.fileDescriptorForSourceFiles,\n        icContext\n    )\n\n    private inner class InlineFunctionsMap(\n        storageFile: File,\n        icContext: IncrementalCompilationContext,\n  "}
{"code": "  ) :\n        BasicStringMap<Map<InlineFunctionOrAccessor, Long>>(\n            storageFile,\n            MapExternalizer(InlineFunctionOrAccessorExternalizer, LongExternalizer),\n            icContext\n        ) {\n\n        @Synchronized\n        fun process(kotlinClassInfo: KotlinClassInfo, changesCollector: ChangesCollector) {\n            val key = kotlinClassInfo.className.internalName\n            val oldMap = storage[key] ?: emptyMap()\n\n            val newMap = kotlinClassInfo.extraInfo.inlineFunctionOrAccessorSnapshots\n            if (newMap.isNotEmpty()) {\n                storage[key] = newMap\n            } else {\n                storage.remove(key)\n            }\n\n            // Note: If we detect a change in an inline function `foo` with @JvmName `fooJvmName`, we have two options:\n            //   1. Report that function `foo` has changed\n            //   2. Report that method `fooJvmName` has changed\n            //\n            // Similarly, if we detect a change in an inline propert"}
{"code": "y accessor with JvmName `getFoo` of property `foo`, we have two options:\n            //   1. Report that property `foo` has changed\n            //   2. Report that property accessor `getFoo` has changed\n            //\n            // The compiler is guaranteed to generate `LookupSymbol`s corresponding to option 1 when referencing inline functions/property\n            // accessors, but it is not guaranteed to generate `LookupSymbol`s corresponding to option 2. (Currently the compiler seems to\n            // support option 2 for *inline* functions/property accessors, but that may change.)\n            //\n            // In the following, we will choose option 1 as it is cleaner and safer.\n            val scope = kotlinClassInfo.scopeFqName()\n            (oldMap.keys + newMap.keys).forEach {\n                val name = when (it) {\n                    is InlineFunction -> it.kotlinFunctionName\n                    is InlinePropertyAccessor -> it.propertyName\n                }\n                ch"}
{"code": "angesCollector.collectMemberIfValueWasChanged(scope, name, oldMap[it], newMap[it])\n            }\n        }\n\n        @Synchronized\n        fun remove(className: JvmClassName) {\n            storage.remove(className.internalName)\n        }\n\n        override fun dumpValue(value: Map<InlineFunctionOrAccessor, Long>): String =\n            value.mapKeys { it.key.jvmMethodSignature.asString() }.dumpMap { java.lang.Long.toHexString(it) }\n    }\n\n    private fun KotlinClassInfo.scopeFqName() = when (classKind) {\n        KotlinClassHeader.Kind.CLASS -> classId.asSingleFqName()\n        else -> classId.packageFqName\n    }\n}\n\nsealed class ChangeInfo(val fqName: FqName) {\n    open class MembersChanged(fqName: FqName, val names: Collection<String>) : ChangeInfo(fqName) {\n        override fun toStringProperties(): String = super.toStringProperties() + \", names = $names\"\n    }\n\n    class Removed(fqName: FqName, names: Collection<String>) : MembersChanged(fqName, names)\n\n    class SignatureChanged(fqName:"}
{"code": " FqName, val areSubclassesAffected: Boolean) : ChangeInfo(fqName)\n\n    class ParentsChanged(fqName: FqName, val parentsChanged: Collection<FqName>) : ChangeInfo(fqName)\n\n    protected open fun toStringProperties(): String = \"fqName = $fqName\"\n\n    override fun toString(): String {\n        return this::class.java.simpleName + \"(${toStringProperties()})\"\n    }\n}\n\nfun ByteArray.md5(): Long {\n    val d = MessageDigest.getInstance(\"MD5\").digest(this)!!\n    return ((d[0].toLong() and 0xFFL)\n            or ((d[1].toLong() and 0xFFL) shl 8)\n            or ((d[2].toLong() and 0xFFL) shl 16)\n            or ((d[3].toLong() and 0xFFL) shl 24)\n            or ((d[4].toLong() and 0xFFL) shl 32)\n            or ((d[5].toLong() and 0xFFL) shl 40)\n            or ((d[6].toLong() and 0xFFL) shl 48)\n            or ((d[7].toLong() and 0xFFL) shl 56)\n            )\n}\n\n@TestOnly\nfun <K : Comparable<K>, V> Map<K, V>.dumpMap(dumpValue: (V) -> String): String =\n    buildString {\n        append(\"{\")\n        for (ke"}
{"code": "y in keys.sorted()) {\n            if (length != 1) {\n                append(\", \")\n            }\n\n            val value = get(key)?.let(dumpValue) ?: \"null\"\n            append(\"$key -> $value\")\n        }\n        append(\"}\")\n    }\n\n@TestOnly\nfun <T : Comparable<T>> Collection<T>.dumpCollection(): String =\n    \"[${sorted().joinToString(\", \", transform = Any::toString)}]\"\n"}
{"code": "interface Any\n\ninline fun <reified T : Any> Any.safeAs(): T? = this as? T\n\nabstract class Summator {\n    abstract fun <T> plus(first: T, second: T): T\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.calls\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.FirClassLikeDeclaration\nimport org.jetbrains.kotlin.fir.declarations.FirRegularClass\nimport org.jetbrains.kotlin.fir.declarations.FirTypeAlias\nimport org.jetbrains.kotlin.fir.declarations.utils.expandedConeType\nimport org.jetbrains.kotlin.fir.expressions.FirResolvedQualifier\nimport org.jetbrains.kotlin.fir.resolve.ScopeSession\nimport org.jetbrains.kotlin.fir.resolve.toSymbol\nimport org.jetbrains.kotlin.fir.scopes.FirScope\nimport org.jetbrains.kotlin.fir.scopes.impl.FirOnlyCallablesScope\nimport org.jetbrains.kotlin.fir.scopes.impl.FirOnlyClassifiersScope\nimport org.jetbrains.kotlin.fir.scopes.impl.FirPackageMemberScope\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol\n\nfun FirClassLikeDeclaration.fullyExpandedClass(useSiteSession: FirSession): FirRegularClass? {\n    if (t"}
{"code": "his is FirTypeAlias) return this.expandedConeType?.lookupTag?.toSymbol(useSiteSession)?.fir?.fullyExpandedClass(useSiteSession)\n    if (this is FirRegularClass) return this\n    error(\"Not supported: $this\")\n}\n\nfun createQualifierReceiver(\n    explicitReceiver: FirResolvedQualifier,\n    useSiteSession: FirSession,\n    scopeSession: ScopeSession,\n): QualifierReceiver? {\n    val classLikeSymbol = explicitReceiver.symbol\n    return when {\n        classLikeSymbol != null -> {\n            val classSymbol = classLikeSymbol.fir.fullyExpandedClass(useSiteSession)?.symbol ?: return null\n            ClassQualifierReceiver(explicitReceiver, classSymbol, classLikeSymbol, useSiteSession, scopeSession)\n        }\n        else -> PackageQualifierReceiver(explicitReceiver, useSiteSession)\n    }\n}\n\nabstract class QualifierReceiver(val explicitReceiver: FirResolvedQualifier) {\n    abstract fun classifierScope(): FirScope?\n    abstract fun callableScope(): FirScope?\n}\n\nclass ClassQualifierReceiver(\n    exp"}
{"code": "licitReceiver: FirResolvedQualifier,\n    val classSymbol: FirRegularClassSymbol,\n    val originalSymbol: FirClassLikeSymbol<*>,\n    val useSiteSession: FirSession,\n    val scopeSession: ScopeSession\n) : QualifierReceiver(explicitReceiver) {\n\n    override fun callableScope(): FirScope? {\n        val klass = classSymbol.fir\n        val provider = klass.scopeProvider\n        return provider.getStaticMemberScopeForCallables(klass, useSiteSession, scopeSession)\n    }\n\n    override fun classifierScope(): FirScope? {\n        val klass = classSymbol.fir\n        return klass.scopeProvider.getNestedClassifierScope(klass, useSiteSession, scopeSession)\n    }\n}\n\nclass PackageQualifierReceiver(\n    explicitReceiver: FirResolvedQualifier,\n    useSiteSession: FirSession\n) : QualifierReceiver(explicitReceiver) {\n    val scope = FirPackageMemberScope(explicitReceiver.packageFqName, useSiteSession)\n    override fun classifierScope(): FirScope {\n        return FirOnlyClassifiersScope(scope)\n    }\n\n    ove"}
{"code": "rride fun callableScope() = FirOnlyCallablesScope(scope)\n}\n"}
{"code": "\n\n@file:JvmName(\"JSStdlibLinker\")\n\npackage org.jetbrains.kotlin.cli.js.internal\n\nimport com.google.gwt.dev.js.ThrowExceptionOnErrorReporter\nimport org.jetbrains.kotlin.js.backend.JsToStringGenerationVisitor\nimport org.jetbrains.kotlin.js.backend.ast.*\nimport org.jetbrains.kotlin.js.sourceMap.SourceMapBuilderConsumer\nimport org.jetbrains.kotlin.js.inline.util.fixForwardNameReferences\nimport org.jetbrains.kotlin.js.parser.parse\nimport org.jetbrains.kotlin.js.parser.sourcemaps.*\nimport org.jetbrains.kotlin.js.sourceMap.SourceFilePathResolver\nimport org.jetbrains.kotlin.js.sourceMap.SourceMap3Builder\nimport org.jetbrains.kotlin.js.util.TextOutputImpl\nimport java.io.File\nimport kotlin.system.exitProcess\n\nfun main(args: Array<String>) {\n    val outputFile = File(args[0])\n    val baseDir = File(args[1]).canonicalFile\n    val wrapperFile = File(args[2])\n\n    val inputPaths = args.drop(3).map { File(it) }\n    mergeStdlibParts(outputFile, wrapperFile, baseDir, inputPaths)\n}\n\n\nprivate fun mergeSt"}
{"code": "dlibParts(outputFile: File, wrapperFile: File, baseDir: File, inputPaths: List<File>) {\n    val program = JsProgram()\n\n    fun File.makeRelativeIfNecessary(): String = canonicalFile.toRelativeString(baseDir)\n\n    val wrapper = parse(wrapperFile.readText(), ThrowExceptionOnErrorReporter, program.scope, wrapperFile.makeRelativeIfNecessary())\n        ?: error(\"Should not be null because of error reporter\")\n    val insertionPlace = wrapper.createInsertionPlace()\n\n    val allFiles = mutableListOf<File>()\n    inputPaths.forEach { collectFiles(it, allFiles) }\n\n    for (file in allFiles) {\n        val statements = parse(file.readText(), ThrowExceptionOnErrorReporter, program.scope, file.makeRelativeIfNecessary())\n            ?: error(\"Should not be null because of error reporter\")\n        val block = JsBlock(statements)\n        block.fixForwardNameReferences()\n\n        val sourceMapFile = File(file.parent, file.name + \".map\")\n        if (sourceMapFile.exists()) {\n            when (val sourceMa"}
{"code": "pParse = SourceMapParser.parse(sourceMapFile)) {\n                is SourceMapError -> {\n                    System.err.println(\"Error parsing source map file $sourceMapFile: ${sourceMapParse.message}\")\n                    exitProcess(1)\n                }\n\n                is SourceMapSuccess -> {\n                    val sourceMap = sourceMapParse.value\n                    val remapper = SourceMapLocationRemapper(sourceMap)\n                    remapper.remap(block)\n                }\n            }\n        }\n\n        insertionPlace.statements += statements\n    }\n\n    program.globalBlock.statements += wrapper\n\n    val sourceMapFile = File(outputFile.parentFile, outputFile.name + \".map\")\n    val textOutput = TextOutputImpl()\n    val sourceMapBuilder = SourceMap3Builder(outputFile, textOutput::getColumn, \"\")\n    val consumer = SourceMapBuilderConsumer(\n        File(\".\"),\n        sourceMapBuilder,\n        SourceFilePathResolver(mutableListOf()),\n        provideCurrentModuleContent = true,\n    "}
{"code": "    provideExternalModuleContent = true\n    )\n    program.globalBlock.accept(JsToStringGenerationVisitor(textOutput, consumer))\n    val sourceMapContent = sourceMapBuilder.build()\n\n    val programText = textOutput.toString()\n\n    outputFile.writeText(programText + \"\\n//# sourceMappingURL=${sourceMapFile.name}\\n\")\n\n    val sourceMapJson = parseJson(sourceMapContent)\n    val sources = (sourceMapJson as JsonObject).properties[\"sources\"] as JsonArray\n\n    sourceMapJson.properties[\"sourcesContent\"] = JsonArray(*sources.elements.map { sourcePath ->\n        val sourceFile = File((sourcePath as JsonString).value)\n        if (sourceFile.exists()) {\n            JsonString(sourceFile.readText())\n        } else {\n            JsonNull\n        }\n    }.toTypedArray())\n\n    sourceMapFile.writeText(sourceMapJson.toString())\n}\n\nprivate fun List<JsStatement>.createInsertionPlace(): JsBlock {\n    val block = JsCompositeBlock()\n\n    val visitor = object : JsVisitorWithContextImpl() {\n        override fun v"}
{"code": "isit(x: JsExpressionStatement, ctx: JsContext<in JsStatement>): Boolean {\n            return if (isInsertionPlace(x.expression)) {\n                ctx.replaceMe(block)\n                false\n            } else {\n                super.visit(x, ctx)\n            }\n        }\n\n        private fun isInsertionPlace(expression: JsExpression): Boolean {\n            if (expression !is JsInvocation || expression.arguments.isNotEmpty()) return false\n\n            val qualifier = expression.qualifier\n            if (qualifier !is JsNameRef || qualifier.qualifier != null) return false\n            return qualifier.ident == \"insertContent\"\n        }\n    }\n\n    for (statement in this) {\n        visitor.accept(statement)\n    }\n    return block\n}\n\nprivate fun collectFiles(rootFile: File, target: MutableList<File>) {\n    if (rootFile.isDirectory) {\n        for (child in (rootFile.listFiles() ?: error(\"Problem with listing files in $rootFile\")).sorted()) {\n            collectFiles(child, target)\n        }\n  "}
{"code": "  } else if (rootFile.extension == \"js\") {\n        target += rootFile\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.cfa.util\n\nimport org.jetbrains.kotlin.fir.resolve.dfa.cfg.CFGNode\nimport org.jetbrains.kotlin.fir.resolve.dfa.cfg.ControlFlowGraph\n\nfun ControlFlowGraph.getNodesInOrder(direction: TraverseDirection): List<CFGNode<*>> = when (direction) {\n    TraverseDirection.Forward -> nodes\n    TraverseDirection.Backward -> nodes.asReversed()\n}\n\nval CFGNode<*>.previousCfgNodes: List<CFGNode<*>>\n    get() = previousNodes.filter {\n        val kind = edgeFrom(it).kind\n        if (this.isDead) {\n            kind.usedInCfa\n        } else {\n            kind.usedInCfa && !kind.isDead\n        }\n    }\n\nval CFGNode<*>.followingCfgNodes: List<CFGNode<*>>\n    get() = followingNodes.filter {\n        val kind = edgeTo(it).kind\n        kind.usedInCfa && !kind.isDead\n    }\n"}
{"code": "// SKIP_JAVAC\n// This directive is needed to skip this test in LazyBodyIsNotTouchedTilContractsPhaseTestGenerated,\n//  because it fails to parse module structure of multimodule test\n\n// MODULE: lib\npackage dependency\n\nabstract class Test {\n    interface Result\n\n    class Success : Result\n}\n\n\n// MODULE: main(lib)\npackage main\n\nimport dependency.Test\n\nclass Main : Test() {\n    fun usage(): Result {\n        return Success()\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.java\n\nimport com.intellij.lang.java.JavaLanguage\nimport com.intellij.openapi.project.Project\nimport com.intellij.openapi.util.io.FileUtil\nimport com.intellij.openapi.util.text.StringUtilRt\nimport com.intellij.psi.PsiClass\nimport com.intellij.psi.PsiElementFinder\nimport com.intellij.psi.PsiFileFactory\nimport com.intellij.psi.PsiPackageStatement\nimport com.intellij.psi.impl.PsiFileFactoryImpl\nimport com.intellij.psi.search.GlobalSearchScope\nimport com.intellij.testFramework.LightVirtualFile\nimport org.jetbrains.kotlin.ObsoleteTestInfrastructure\nimport org.jetbrains.kotlin.asJava.finder.JavaElementFinder\nimport org.jetbrains.kotlin.cli.jvm.compiler.*\nimport org.jetbrains.kotlin.codegen.forTestCompile.ForTestCompileRuntime\nimport org.jetbrains.kotlin.fir.FirTestSessionFactoryHelper\nimport org.jetbrains.kotlin.fir.java.declarations.FirJavaClass\nimport org.jetbrains.kotlin.fir.renderer.FirRenderer\nimport org.jetbrains.kotlin.fir.resolve.providers.symbolProv"}
{"code": "ider\nimport org.jetbrains.kotlin.fir.symbols.SymbolInternals\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.psiUtil.getChildrenOfType\nimport org.jetbrains.kotlin.test.*\nimport org.jetbrains.kotlin.test.KotlinTestUtils.newConfiguration\nimport org.jetbrains.kotlin.test.testFramework.KtUsefulTestCase\nimport org.jetbrains.kotlin.test.util.KtTestUtil.getAnnotationsJar\nimport java.io.File\nimport java.io.IOException\nimport kotlin.reflect.jvm.javaField\n\n@OptIn(SymbolInternals::class)\nabstract class AbstractFirTypeEnhancementTest : KtUsefulTestCase() {\n    private lateinit var javaFilesDir: File\n\n    private lateinit var environment: KotlinCoreEnvironment\n\n    val project: Project\n        get() {\n            return environment.project\n        }\n\n    @Throws(Exception::class)\n    override fun setUp() {\n        super.setUp()\n        javaFilesDir = KotlinTestUtils.tmpDirForTest(this)\n    }\n\n    "}
{"code": "override fun tearDown() {\n        FileUtil.delete(javaFilesDir)\n        this::environment.javaField!![this] = null\n        super.tearDown()\n    }\n\n    private fun createJarWithForeignAnnotations(): List<File> {\n        val jsr305Jar =\n            MockLibraryUtilExt.compileJavaFilesLibraryToJar(JSR_305_SOURCES_PATH, \"jsr305\")\n\n        return listOf(\n            MockLibraryUtilExt.compileJavaFilesLibraryToJar(\n                FOREIGN_ANNOTATIONS_SOURCES_PATH, \"foreign-annotations\",\n                extraClasspath = listOf(jsr305Jar.absolutePath),\n            ),\n            jsr305Jar,\n        )\n    }\n\n    private fun createEnvironment(content: String): KotlinCoreEnvironment {\n        val classpath = mutableListOf(getAnnotationsJar(), ForTestCompileRuntime.runtimeJarForTests())\n        if (InTextDirectivesUtils.isDirectiveDefined(content, \"JVM_ANNOTATIONS\")) {\n            classpath.add(ForTestCompileRuntime.jvmAnnotationsForTests())\n        }\n        if (InTextDirectivesUtils.isDirectiveDef"}
{"code": "ined(content, \"FOREIGN_ANNOTATIONS\")) {\n            classpath.addAll(createJarWithForeignAnnotations())\n        }\n        return KotlinCoreEnvironment.createForTests(\n            testRootDisposable,\n            newConfiguration(\n                ConfigurationKind.JDK_NO_RUNTIME, TestJdkKind.FULL_JDK, classpath, listOf(javaFilesDir)\n            ),\n            EnvironmentConfigFiles.JVM_CONFIG_FILES\n        ).apply {\n            PsiElementFinder.EP.getPoint(project).unregisterExtension(JavaElementFinder::class.java)\n        }\n    }\n\n    @OptIn(ObsoleteTestInfrastructure::class)\n    fun doTest(path: String) {\n        val javaFile = File(path)\n        val javaLines = javaFile.readLines()\n        val content = javaLines.joinToString(separator = \"\\n\")\n        if (InTextDirectivesUtils.isDirectiveDefined(content, \"SKIP_IN_FIR_TEST\")) return\n\n        val srcFiles = TestFiles.createTestFiles(\n            javaFile.name, FileUtil.loadFile(javaFile, true),\n            object : TestFiles.TestFileFac"}
{"code": "toryNoModules<File>() {\n                override fun create(fileName: String, text: String, directives: Directives): File {\n                    var currentDir = javaFilesDir\n                    if (\"/\" !in fileName) {\n                        val packageFqName =\n                            text.split(\"\\n\").firstOrNull {\n                                it.startsWith(\"package\")\n                            }?.substringAfter(\"package\")?.trim()?.substringBefore(\";\")?.let { name ->\n                                FqName(name)\n                            } ?: FqName.ROOT\n                        for (segment in packageFqName.pathSegments()) {\n                            currentDir = File(currentDir, segment.asString()).apply { mkdir() }\n                        }\n                    }\n                    val targetFile = File(currentDir, fileName)\n                    try {\n                        FileUtil.writeToFile(targetFile, text)\n                    } catch (e: IOException) {\n              "}
{"code": "          throw AssertionError(e)\n                    }\n\n                    return targetFile\n                }\n            }\n        )\n        environment = createEnvironment(content)\n        val virtualFiles = srcFiles.map {\n            object : LightVirtualFile(\n                it.name, JavaLanguage.INSTANCE, StringUtilRt.convertLineSeparators(it.readText())\n            ) {\n                override fun getPath(): String {\n                    //TODO: patch LightVirtualFile\n                    return \"/${it.name}\"\n                }\n            }\n        }\n        val factory = PsiFileFactory.getInstance(project) as PsiFileFactoryImpl\n        val psiFiles = virtualFiles.map { factory.trySetupPsiForFile(it, JavaLanguage.INSTANCE, true, false)!! }\n\n        val scope = GlobalSearchScope.filesScope(project, virtualFiles)\n            .uniteWith(TopDownAnalyzerFacadeForJVM.AllJavaSourcesInProjectScope(project))\n        val session = FirTestSessionFactoryHelper.createSessionForTests(\n       "}
{"code": "     environment.toAbstractProjectEnvironment(),\n            scope.toAbstractProjectFileSearchScope()\n        )\n\n        val topPsiClasses = psiFiles.flatMap { it.getChildrenOfType<PsiClass>().toList() }\n\n        val javaFirDump = StringBuilder().also { builder ->\n            val renderer = FirRenderer(builder)\n            val processedJavaClasses = mutableSetOf<FirJavaClass>()\n            fun processClassWithChildren(psiClass: PsiClass, parentFqName: FqName) {\n                val classId = psiClass.classId(parentFqName)\n                val javaClass = session.symbolProvider.getClassLikeSymbolByClassId(classId)?.fir\n                    ?: throw AssertionError(classId.asString())\n                if (javaClass !is FirJavaClass || javaClass in processedJavaClasses) {\n                    return\n                }\n                processedJavaClasses += javaClass\n                renderJavaClass(renderer, javaClass, session) {\n                    for (innerClass in psiClass.innerClasses.sorte"}
{"code": "dBy { it.name }) {\n                        processClassWithChildren(innerClass, classId.relativeClassName)\n                    }\n                }\n\n            }\n            for (psiClass in topPsiClasses.sortedBy { it.name }) {\n                processClassWithChildren(psiClass, FqName.ROOT)\n            }\n        }.toString()\n\n        val expectedFile = File(javaFile.absolutePath.replace(\".java\", \".fir.txt\"))\n        KotlinTestUtils.assertEqualsToFile(expectedFile, javaFirDump)\n    }\n\n    private fun PsiClass.classId(parentFqName: FqName): ClassId {\n        val psiFile = this.containingFile\n        val packageStatement = psiFile.children.filterIsInstance<PsiPackageStatement>().firstOrNull()\n        val packageName = packageStatement?.packageName\n        val fqName = parentFqName.child(Name.identifier(this.name!!))\n        return ClassId(packageName?.let { FqName(it) } ?: FqName.ROOT, fqName, isLocal = false)\n    }\n\n    companion object {\n        private const val FOREIGN_ANNOTATIONS_SO"}
{"code": "URCES_PATH = \"third-party/annotations\"\n        private const val JSR_305_SOURCES_PATH = \"third-party/jsr305\"\n    }\n}\n\nabstract class AbstractOwnFirTypeEnhancementTest : AbstractFirTypeEnhancementTest()\n"}
{"code": "fun foo(a: Int): Int {\n    val b: Int = 1\n    <expr>if (a + b > 0) return 1\n    else if (a - b < 0) return 2\n    else return b</expr>\n}"}
{"code": "fun test(): Int {\n    var result = 58\n    val v = result<expr>++</expr>\n    return result + v\n}"}
{"code": "fun annotatedSwitch(str: String) =\n    when {\n        <expr>@Suppress(\"DEPRECATION\")</expr>\n        str.isBlank() -> null\n        str.isNotEmpty() != null -> null\n        else -> 1\n    }\n"}
{"code": "// SKIP_WHEN_OUT_OF_CONTENT_ROOT\n// MEMBER_NAME_FILTER: something\n// IS_GETTER: true\n// FILE: Derived.kt\nclass Der<caret>ived : Base() {\n    @Anno(\"number: ${prop}\")\n    override fun getSomething() = \"body: ${propertyFromBody}\"\n}\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)\nannotation class Anno(val s: String)\nval prop = 2.let { it + 1 }\nval propertyFromBody = \"str\" + 1.toString()\n\n// FILE: Base.java\npublic class Base {\n    public String getSomething() {\n        return \"\";\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.symbols\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.FirAnnotationContainer\nimport org.jetbrains.kotlin.fir.FirImplementationDetail\nimport org.jetbrains.kotlin.fir.FirModuleData\nimport org.jetbrains.kotlin.fir.declarations.FirDeclaration\nimport org.jetbrains.kotlin.fir.declarations.FirDeclarationOrigin\nimport org.jetbrains.kotlin.fir.declarations.FirResolvePhase\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotationCall\nimport org.jetbrains.kotlin.fir.expressions.arguments\nimport org.jetbrains.kotlin.fir.symbols.impl.FirBackingFieldSymbol\nimport org.jetbrains.kotlin.fir.types.ConeClassLikeType\nimport org.jetbrains.kotlin.fir.types.coneType\nimport org.jetbrains.kotlin.fir.utils.exceptions.withFirSymbolIdEntry\nimport org.jetbrains.kotlin.mpp.DeclarationSymbolMarker\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.utils.exceptions.errorWithAtt"}
{"code": "achment\n\nabstract class FirBasedSymbol<out E : FirDeclaration> : DeclarationSymbolMarker {\n    private var _fir: E? = null\n\n    @SymbolInternals\n    val fir: E\n        get() = _fir\n            ?: errorWithAttachment(\"Fir is not initialized for ${this::class}\") {\n                withFirSymbolIdEntry(\"symbol\", this@FirBasedSymbol)\n            }\n\n    @FirImplementationDetail\n    fun bind(e: @UnsafeVariance E) {\n        _fir = e\n    }\n\n    val isBound get() = _fir != null\n\n    val origin: FirDeclarationOrigin\n        get() = fir.origin\n\n    val source: KtSourceElement?\n        get() = fir.source\n\n    val moduleData: FirModuleData\n        get() = fir.moduleData\n\n    val annotations: List<FirAnnotation>\n        get() = fir.annotations\n\n    val resolvedAnnotationsWithArguments: List<FirAnnotation>\n        get() = fir.resolvedAnnotationsWithArguments(this)\n\n    val resolvedAnnotationsWithClassIds: List<FirAnnotation>\n        get() = fir.resolvedAnnotationsWithClassIds(this)\n\n    val resolvedCo"}
{"code": "mpilerAnnotationsWithClassIds: List<FirAnnotation>\n        get() = fir.resolvedCompilerRequiredAnnotations(this)\n\n    val resolvedAnnotationClassIds: List<ClassId>\n        get() = fir.resolvedAnnotationClassIds(this)\n}\n\n@SymbolInternals\nfun FirAnnotationContainer.resolvedCompilerRequiredAnnotations(anchorElement: FirBasedSymbol<*>): List<FirAnnotation> {\n    if (annotations.isEmpty()) return emptyList()\n\n    anchorElement.lazyResolveToPhase(FirResolvePhase.COMPILER_REQUIRED_ANNOTATIONS)\n    return annotations\n}\n\n@SymbolInternals\nfun FirAnnotationContainer.resolvedAnnotationsWithArguments(anchorElement: FirBasedSymbol<*>): List<FirAnnotation> {\n    if (isDefinitelyEmpty(anchorElement)) return emptyList()\n\n    annotations.resolveAnnotationsWithArguments(anchorElement)\n    // Note: this.annotations reference may be changed by the previous call!\n    return annotations\n}\n\n@SymbolInternals\nfun List<FirAnnotation>.resolveAnnotationsWithArguments(anchorElement: FirBasedSymbol<*>) {\n    \n    va"}
{"code": "r hasAnnotationCallWithArguments = false\n    for (i in indices) {\n        val currentAnnotation = get(i)\n        if (currentAnnotation is FirAnnotationCall && currentAnnotation.arguments.isNotEmpty()) {\n            hasAnnotationCallWithArguments = true\n            break\n        }\n    }\n\n    val phase = if (hasAnnotationCallWithArguments) {\n        FirResolvePhase.ANNOTATION_ARGUMENTS\n    } else {\n        FirResolvePhase.TYPES\n    }\n\n    anchorElement.lazyResolveToPhase(phase)\n}\n\nprivate fun FirAnnotationContainer.isDefinitelyEmpty(anchorElement: FirBasedSymbol<*>): Boolean {\n    if (annotations.isEmpty()) {\n        if (anchorElement !is FirBackingFieldSymbol) return true\n        if (anchorElement.propertySymbol.annotations.none { it.useSiteTarget == null }) return true\n    }\n    return false\n}\n\n@SymbolInternals\nfun FirAnnotationContainer.resolvedAnnotationsWithClassIds(anchorElement: FirBasedSymbol<*>): List<FirAnnotation> {\n    if (isDefinitelyEmpty(anchorElement)) return emptyList()\n"}
{"code": "\n    anchorElement.lazyResolveToPhase(FirResolvePhase.TYPES)\n\n    return annotations\n}\n\n@SymbolInternals\nfun resolveAnnotationsWithClassIds(anchorElement: FirBasedSymbol<*>) {\n    anchorElement.lazyResolveToPhase(FirResolvePhase.TYPES)\n}\n\n@SymbolInternals\nfun FirAnnotationContainer.resolvedAnnotationClassIds(anchorElement: FirBasedSymbol<*>): List<ClassId> {\n    return resolvedAnnotationsWithClassIds(anchorElement).mapNotNull {\n        (it.annotationTypeRef.coneType as? ConeClassLikeType)?.lookupTag?.classId\n    }\n}\n\n@RequiresOptIn\nannotation class SymbolInternals\n"}
{"code": "// FILE: usage.kt\n<expr>\nval propertyToResolve: String\n    get() = JavaClass.function()?.let { \" ($it)\" } ?: \"\"\n</expr>\n\n// FILE: Anno.java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.TYPE_USE)\npublic @interface Anno {\n    String value();\n}\n\n// FILE: JavaClass.java\npublic class JavaClass {\n    public static @Anno(\"outer\") List<@Anno(\"middle\") List<@Anno(\"inner\") Integer>> function() {\n        return null;\n    }\n}\n"}
{"code": "open class A(x: Int) {\n    constructor(z: String) : this(10)\n}\n\nclass B : A {\n    <!EXPLICIT_DELEGATION_CALL_REQUIRED!>constructor()<!>\n    constructor(z: String) : this()\n}\n\n<!SUPERTYPE_INITIALIZED_WITHOUT_PRIMARY_CONSTRUCTOR!>class <!CONFLICTING_OVERLOADS!>C<!> : A(20) {\n    <!CONFLICTING_OVERLOADS, EXPLICIT_DELEGATION_CALL_REQUIRED!>constructor()<!>\n    constructor(z: String) : <!OVERLOAD_RESOLUTION_AMBIGUITY!>this<!>()\n}<!>\n\nclass D() : A(20) {\n    <!PRIMARY_CONSTRUCTOR_DELEGATION_CALL_EXPECTED!>constructor(x: Int)<!>\n    constructor(z: String) : this()\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.calls.checkers\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\nimport org.jetbrains.kotlin.types.KotlinType\nimport org.jetbrains.kotlin.types.typeUtil.isArrayOfNothing\n\nclass CallReturnsArrayOfNothingChecker : CallChecker {\n    override fun check(resolvedCall: ResolvedCall<*>, reportOn: PsiElement, context: CallCheckerContext) {\n        if (resolvedCall.resultingDescriptor.returnType.containsArrayOfNothing()) {\n            context.trace.report(Errors.UNSUPPORTED.on(reportOn, \"Array<Nothing> in return type is illegal\"))\n        }\n    }\n\n    private fun KotlinType?.containsArrayOfNothing(): Boolean {\n        if (this == null || isComputingDeferredType(this)) return false\n\n        return isArrayOfNothing() ||\n                arguments.any { !it.isStarProjection && it.type.containsArrayOfNothing() }\n    }\n}\n"}
{"code": "interface A\n\nclass B<T> where T : A\nclass C : A\ntypealias GGG = C\ntypealias HHH = GGG\ntypealias JJJ = B<C>\n\nfun <T : A> fest() {\n\n}\n\nfun test() {\n    val b1 = B<<!UPPER_BOUND_VIOLATED!>Int<!>>()\n    val b2 = B<C>()\n    val b3 = B<<!UPPER_BOUND_VIOLATED!>Any?<!>>()\n    val b4 = B<<!UNRESOLVED_REFERENCE!>UnexistingType<!>>()<!UNRESOLVED_REFERENCE!>NL<!><!SYNTAX!><<!>Int<!SYNTAX!><!SYNTAX!>><!>()<!>NumberPhile<!SYNTAX!><!>\n    val b5 = B<<!UPPER_BOUND_VIOLATED!>B<<!UNRESOLVED_REFERENCE!>UnexistingType<!>><!>>()\n    fest<<!UPPER_BOUND_VIOLATED!>Boolean<!>>()\n    fest<C>()\n    fest<HHH>()\n    fest<<!UPPER_BOUND_VIOLATED!>JJJ<!>>()\n}\n\nopen class S<F, G : F>\nclass T<U, Y : U> : S<U, Y>()\nclass P<T0: Number, T1>\nclass P1<T2 : Number, T3 : Number>\n\n\nfun <K, L : K> rest() {\n    val o1 = S<K, L>()\n    val o2 = S<K, K>()\n    val o3 = S<L, L>()\n\n    val o4 = S<S<K, L>, T<K, L>>()\n    val o5 = S<S<K, L>, <!UPPER_BOUND_VIOLATED!>T<K, K><!>>()\n    val o6 = S<S<L, L>, <!UPPER_BOUND_VIOLATED!>T<K, L><!>"}
{"code": ">()\n\n    val o7 = S<Any, T<S<K, L>, <!UPPER_BOUND_VIOLATED!>String<!>>>()\n    val o8 = S<Any, T<S<K, L>, Nothing>>()\n    val o9 = P<<!UPPER_BOUND_VIOLATED!>String<!>, P1<<!UPPER_BOUND_VIOLATED!>String<!>, <!UPPER_BOUND_VIOLATED!>String<!>>>()\n}\n\nclass NumColl<T : Collection<Number>>\ntypealias NL<K> = NumColl<List<K>>\nval test7 = NL<Int>()<!UNRESOLVED_REFERENCE!>NumberPhile<!><!SYNTAX!><!>\nval test8 = <!UPPER_BOUND_VIOLATED!>NL<String>()<!>\n\nclass NumberPhile<T: Number>(x: T)\nval np1 = NumberPhile(10)\nval np2 = <!CANNOT_INFER_PARAMETER_TYPE!>NumberPhile<!>(<!ARGUMENT_TYPE_MISMATCH!>\"Test\"<!>)\n\nclass Test1<S1 : Test1<S1, K>, K : Any>\nclass Test2<S2 : Test1<S2, *>>\n\nclass Test3<S3 : Test3<S3, in K>, K : Any>\nclass Test4<S4 : Test3<S4, out Any>>\n\nclass Test5<S5 : Test5<S5, in K>, K : Any>\nclass Test6<S6 : Test5<S6, in Any>>\n\nclass Test7<S7 : Test7<S7, in K>, K : CharSequence>\nclass Test8<S8 : Test7<S8, <!UPPER_BOUND_VIOLATED!>in Any<!>>>\n\nclass Class<V : Any>\ntypealias Alias <V1> = (Class<"}
{"code": "V1>) -> Boolean\n\nabstract class Base<T : Base<T>> {}\nclass DerivedOut<out O : Base<out O>> {}\nclass DerivedIn<in I : Base<in I>> {}\n\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.components\n\nimport org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion\nimport org.jetbrains.kotlin.analysis.api.symbols.KtEnumEntrySymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtNamedClassOrObjectSymbol\n\npublic abstract class KtInheritorsProvider : KtAnalysisSessionComponent() {\n    public abstract fun getInheritorsOfSealedClass(classSymbol: KtNamedClassOrObjectSymbol): List<KtNamedClassOrObjectSymbol>\n    public abstract fun getEnumEntries(classSymbol: KtNamedClassOrObjectSymbol): List<KtEnumEntrySymbol>\n}\n\npublic interface KtInheritorsProviderMixIn : KtAnalysisSessionMixIn {\n    public fun KtNamedClassOrObjectSymbol.getSealedClassInheritors(): List<KtNamedClassOrObjectSymbol> =\n        withValidityAssertion { analysisSession.inheritorsProvider.getInheritorsOfSealedClass(this) }\n\n    public fun KtNamedClassOrObjectSymbol.getEnumEntries(): List<KtEnumEntrySymbol> =\n        withValidityAssertion { analysisSession.inheri"}
{"code": "torsProvider.getEnumEntries(this) }\n}"}
{"code": "val x: String\n    <expr>get() = \"\"</expr>"}
{"code": "import <expr>a</expr>.b.c"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.state\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.LLFirModuleResolveComponents\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.LLFirResolveSession\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.getModule\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.element.builder.getNonLocalContainingDeclaration\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.util.*\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.util.FirDeclarationForCompiledElementSearcher\nimport org.jetbrains.kotlin.analysis.project.structure.KtModule\nimport org.jetbrains.kotlin.analysis.utils.errors.withPsiEntry\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.fir.declarations.FirDeclaration\nimport org.jetbrains.kotlin.fir.declarations.FirFile\nimport org.jetbrains.kotlin.fir.declarations.FirResolvePhase\nimport org.jetbrains.kotlin.fir.expressions.FirAnonymousFunctionExpression\nimport org.jetbra"}
{"code": "ins.kotlin.fir.expressions.FirAnonymousObjectExpression\nimport org.jetbrains.kotlin.fir.resolve.providers.firProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.symbolProvider\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\nimport org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtElement\nimport org.jetbrains.kotlin.psi.KtExpression\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.psi.psiUtil.getElementTextWithContext\nimport org.jetbrains.kotlin.utils.exceptions.errorWithAttachment\n\ninternal class LLFirResolvableResolveSession(\n    moduleProvider: LLModuleProvider,\n    resolutionStrategyProvider: LLModuleResolutionStrategyProvider,\n    sessionProvider: LLSessionProvider,\n    diagnosticProvider: LLDiagnosticProvider\n) : LLFirResolveSession(\n    moduleProvider = moduleProvider,\n    resolutionStrategyProvider = resolutionStrategyProvider,\n    sessionProvider = sessionProvider,\n"}
{"code": "    scopeSessionProvider = LLDefaultScopeSessionProvider,\n    diagnosticProvider = diagnosticProvider\n) {\n    override fun getOrBuildFirFor(element: KtElement): FirElement? {\n        val moduleComponents = getModuleComponentsForElement(element)\n        return moduleComponents.elementsBuilder.getOrBuildFirFor(element)\n    }\n\n    override fun getOrBuildFirFile(ktFile: KtFile): FirFile {\n        val moduleComponents = getModuleComponentsForElement(ktFile)\n        return moduleComponents.firFileBuilder.buildRawFirFileWithCaching(ktFile)\n    }\n\n    private fun getModuleComponentsForElement(element: KtElement): LLFirModuleResolveComponents {\n        val module = getModule(element)\n        return sessionProvider.getResolvableSession(module).moduleComponents\n    }\n\n    override fun resolveToFirSymbol(\n        ktDeclaration: KtDeclaration,\n        phase: FirResolvePhase,\n    ): FirBasedSymbol<*> {\n        val containingKtFile = ktDeclaration.containingKtFile\n        val module = getModule(conta"}
{"code": "iningKtFile)\n\n        return when (getModuleResolutionStrategy(module)) {\n            LLModuleResolutionStrategy.LAZY -> findSourceFirSymbol(ktDeclaration).also { resolveFirToPhase(it.fir, phase) }\n            LLModuleResolutionStrategy.STATIC -> findFirCompiledSymbol(ktDeclaration, module)\n        }\n    }\n\n    private fun findFirCompiledSymbol(ktDeclaration: KtDeclaration, module: KtModule): FirBasedSymbol<*> {\n        require(ktDeclaration.containingKtFile.isCompiled) {\n            \"This method will only work on compiled declarations, but this declaration is not compiled: ${ktDeclaration.getElementTextWithContext()}\"\n        }\n\n        val session = getSessionFor(module)\n        val searcher = FirDeclarationForCompiledElementSearcher(session.symbolProvider)\n        val firDeclaration = searcher.findNonLocalDeclaration(ktDeclaration)\n        return firDeclaration.symbol\n    }\n\n    private fun findSourceFirSymbol(ktDeclaration: KtDeclaration): FirBasedSymbol<*> {\n        val targetDecl"}
{"code": "aration = ktDeclaration.originalDeclaration ?: ktDeclaration\n        val targetModule = getModule(targetDeclaration)\n        return findSourceFirDeclarationByDeclaration(targetDeclaration, targetModule)\n    }\n\n    private fun findSourceFirDeclarationByDeclaration(ktDeclaration: KtDeclaration, module: KtModule): FirBasedSymbol<*> {\n        require(getModuleResolutionStrategy(module) == LLModuleResolutionStrategy.LAZY) {\n            \"Declaration should be resolvable module, instead it had ${module::class}\"\n        }\n\n        val nonLocalDeclaration = getNonLocalContainingDeclaration(ktDeclaration.parentsWithSelfCodeFragmentAware)\n            ?: errorWithAttachment(\"Declaration should have non-local container\") {\n                withPsiEntry(\"ktDeclaration\", ktDeclaration, ::getModule)\n                withEntry(\"module\", module) { it.moduleDescription }\n            }\n\n        if (ktDeclaration == nonLocalDeclaration) {\n            val session = sessionProvider.getResolvableSession(module)"}
{"code": "\n            return nonLocalDeclaration.findSourceNonLocalFirDeclaration(\n                firFileBuilder = session.moduleComponents.firFileBuilder,\n                provider = session.firProvider,\n            ).symbol\n        }\n\n        return findDeclarationInSourceViaResolve(ktDeclaration)\n    }\n\n    private fun getModuleResolutionStrategy(module: KtModule): LLModuleResolutionStrategy {\n        return resolutionStrategyProvider.getKind(module)\n    }\n\n    private fun findDeclarationInSourceViaResolve(ktDeclaration: KtExpression): FirBasedSymbol<*> {\n        val firDeclaration = when (val fir = getOrBuildFirFor(ktDeclaration)) {\n            is FirDeclaration -> fir\n            is FirAnonymousFunctionExpression -> fir.anonymousFunction\n            is FirAnonymousObjectExpression -> fir.anonymousObject\n            else -> errorWithFirSpecificEntries(\n                \"FirDeclaration was not found for ${ktDeclaration::class}, fir is ${fir?.let { it::class }}\",\n                fir = fir,\n   "}
{"code": "             psi = ktDeclaration,\n            )\n        }\n        return firDeclaration.symbol\n    }\n\n    override fun resolveFirToPhase(declaration: FirDeclaration, toPhase: FirResolvePhase) {\n        declaration.lazyResolveToPhase(toPhase)\n    }\n}"}
{"code": "// RUNTIME\n\n// callable: kotlin/LazyThreadSafetyMode.SYNCHRONIZED\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\")\n\npackage org.jetbrains.kotlin.fir.expressions.impl\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget\nimport org.jetbrains.kotlin.fir.MutableOrEmptyList\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.diagnostics.ConeDiagnostic\nimport org.jetbrains.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.references.FirReference\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.types.FirTypeProjection\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.types.coneTypeOrNull\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.f"}
{"code": "ir.visitors.transformInplace\n\ninternal class FirErrorAnnotationCallImpl(\n    override val source: KtSourceElement?,\n    override var useSiteTarget: AnnotationUseSiteTarget?,\n    override var annotationTypeRef: FirTypeRef,\n    override var typeArguments: MutableOrEmptyList<FirTypeProjection>,\n    override var argumentList: FirArgumentList,\n    override var calleeReference: FirReference,\n    override val containingDeclarationSymbol: FirBasedSymbol<*>,\n    override val diagnostic: ConeDiagnostic,\n    override var argumentMapping: FirAnnotationArgumentMapping,\n) : FirErrorAnnotationCall() {\n    @OptIn(UnresolvedExpressionTypeAccess::class)\n    override val coneTypeOrNull: ConeKotlinType?\n        get() = annotationTypeRef.coneTypeOrNull\n    override val annotations: List<FirAnnotation>\n        get() = emptyList()\n    override var annotationResolvePhase: FirAnnotationResolvePhase = FirAnnotationResolvePhase.Types\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {\n "}
{"code": "       annotationTypeRef.accept(visitor, data)\n        typeArguments.forEach { it.accept(visitor, data) }\n        argumentList.accept(visitor, data)\n        calleeReference.accept(visitor, data)\n    }\n\n    override fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirErrorAnnotationCallImpl {\n        transformAnnotationTypeRef(transformer, data)\n        transformTypeArguments(transformer, data)\n        argumentList = argumentList.transform(transformer, data)\n        transformCalleeReference(transformer, data)\n        return this\n    }\n\n    override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirErrorAnnotationCallImpl {\n        return this\n    }\n\n    override fun <D> transformAnnotationTypeRef(transformer: FirTransformer<D>, data: D): FirErrorAnnotationCallImpl {\n        annotationTypeRef = annotationTypeRef.transform(transformer, data)\n        return this\n    }\n\n    override fun <D> transformTypeArguments(transformer: FirTransformer<D>, dat"}
{"code": "a: D): FirErrorAnnotationCallImpl {\n        typeArguments.transformInplace(transformer, data)\n        return this\n    }\n\n    override fun <D> transformCalleeReference(transformer: FirTransformer<D>, data: D): FirErrorAnnotationCallImpl {\n        calleeReference = calleeReference.transform(transformer, data)\n        return this\n    }\n\n    override fun replaceConeTypeOrNull(newConeTypeOrNull: ConeKotlinType?) {}\n\n    override fun replaceAnnotations(newAnnotations: List<FirAnnotation>) {}\n\n    override fun replaceUseSiteTarget(newUseSiteTarget: AnnotationUseSiteTarget?) {\n        useSiteTarget = newUseSiteTarget\n    }\n\n    override fun replaceAnnotationTypeRef(newAnnotationTypeRef: FirTypeRef) {\n        annotationTypeRef = newAnnotationTypeRef\n    }\n\n    override fun replaceTypeArguments(newTypeArguments: List<FirTypeProjection>) {\n        typeArguments = newTypeArguments.toMutableOrEmpty()\n    }\n\n    override fun replaceArgumentList(newArgumentList: FirArgumentList) {\n        argumentLis"}
{"code": "t = newArgumentList\n    }\n\n    override fun replaceCalleeReference(newCalleeReference: FirReference) {\n        calleeReference = newCalleeReference\n    }\n\n    override fun replaceAnnotationResolvePhase(newAnnotationResolvePhase: FirAnnotationResolvePhase) {\n        annotationResolvePhase = newAnnotationResolvePhase\n    }\n\n    override fun replaceArgumentMapping(newArgumentMapping: FirAnnotationArgumentMapping) {\n        argumentMapping = newArgumentMapping\n    }\n}\n"}
{"code": "package m2.second\n\nimport a.b.c.prop as prp\n\nfun t() {\n    prp\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.java\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.builtins.jvm.JavaToKotlinClassMap\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.diagnostics.ConeSimpleDiagnostic\nimport org.jetbrains.kotlin.fir.diagnostics.DiagnosticKind\nimport org.jetbrains.kotlin.fir.java.enhancement.readOnlyToMutable\nimport org.jetbrains.kotlin.fir.languageVersionSettings\nimport org.jetbrains.kotlin.fir.resolve.diagnostics.ConeUnresolvedNameError\nimport org.jetbrains.kotlin.fir.resolve.toFirRegularClassSymbol\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.fir.types.builder.buildResolvedTypeRef\nimport org.jetbrains.kotlin.fir.types.impl.ConeTypeParameterTypeImpl\nimport org.jetbrains.kotlin.fir.types.jvm.FirJavaTypeRef\nimport org.jetbrains.kotlin.fir.types.jvm.buildJavaTypeRef\nimport org.jetbrains.kotlin.load.java.structure.*\nimport org.jetbrains.kotlin.na"}
{"code": "me.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.StandardClassIds\nimport org.jetbrains.kotlin.types.Variance\nimport org.jetbrains.kotlin.utils.exceptions.errorWithAttachment\n\nprivate fun ClassId.toConeFlexibleType(\n    typeArguments: Array<out ConeTypeProjection>,\n    typeArgumentsForUpper: Array<out ConeTypeProjection>,\n    attributes: ConeAttributes\n) = toLookupTag().run {\n    ConeFlexibleType(\n        constructClassType(typeArguments, isNullable = false, attributes),\n        constructClassType(typeArgumentsForUpper, isNullable = true, attributes)\n    )\n}\n\nenum class FirJavaTypeConversionMode {\n    DEFAULT, ANNOTATION_MEMBER, ANNOTATION_CONSTRUCTOR_PARAMETER, SUPERTYPE,\n    TYPE_PARAMETER_BOUND_FIRST_ROUND, TYPE_PARAMETER_BOUND_AFTER_FIRST_ROUND;\n\n    val insideAnnotation: Boolean get() = this == ANNOTATION_MEMBER || this == ANNOTATION_CONSTRUCTOR_PARAMETER\n}\n\nfun FirTypeRef.resolveIfJavaType(\n    session: FirSession, javaTypeParameterStack: JavaTyp"}
{"code": "eParameterStack,\n    source: KtSourceElement?,\n    mode: FirJavaTypeConversionMode = FirJavaTypeConversionMode.DEFAULT\n): FirTypeRef = when (this) {\n    is FirResolvedTypeRef -> this\n    is FirJavaTypeRef -> type.toFirResolvedTypeRef(session, javaTypeParameterStack, source, mode)\n    else -> this\n}\n\ninternal fun FirTypeRef.toConeKotlinTypeProbablyFlexible(\n    session: FirSession, javaTypeParameterStack: JavaTypeParameterStack,\n    source: KtSourceElement?,\n    mode: FirJavaTypeConversionMode = FirJavaTypeConversionMode.DEFAULT\n): ConeKotlinType =\n    (resolveIfJavaType(session, javaTypeParameterStack, source, mode) as? FirResolvedTypeRef)?.type\n        ?: ConeErrorType(ConeSimpleDiagnostic(\"Type reference in Java not resolved: ${this::class.java}\", DiagnosticKind.Java))\n\ninternal fun JavaType.toFirJavaTypeRef(session: FirSession, source: KtSourceElement?): FirJavaTypeRef = buildJavaTypeRef {\n    annotationBuilder = { convertAnnotationsToFir(session, source) }\n    type = this@toFirJava"}
{"code": "TypeRef\n    this.source = source\n}\n\ninternal fun JavaType?.toFirResolvedTypeRef(\n    session: FirSession, javaTypeParameterStack: JavaTypeParameterStack,\n    source: KtSourceElement?,\n    mode: FirJavaTypeConversionMode = FirJavaTypeConversionMode.DEFAULT\n): FirResolvedTypeRef {\n    return buildResolvedTypeRef {\n        type = toConeKotlinType(session, javaTypeParameterStack, mode, source)\n            .let { if (mode == FirJavaTypeConversionMode.SUPERTYPE) it.lowerBoundIfFlexible() else it }\n        annotations += type.attributes.customAnnotations\n        this.source = source\n    }\n}\n\nprivate fun JavaType?.toConeKotlinType(\n    session: FirSession, javaTypeParameterStack: JavaTypeParameterStack,\n    mode: FirJavaTypeConversionMode, source: KtSourceElement?,\n    additionalAnnotations: Collection<JavaAnnotation>? = null\n): ConeKotlinType =\n    toConeTypeProjection(session, javaTypeParameterStack, Variance.INVARIANT, mode, source, additionalAnnotations).type\n        ?: StandardClassIds.An"}
{"code": "y.toConeFlexibleType(emptyArray(), emptyArray(), ConeAttributes.Empty)\n\nprivate fun JavaType?.toConeTypeProjection(\n    session: FirSession, javaTypeParameterStack: JavaTypeParameterStack,\n    parameterVariance: Variance, mode: FirJavaTypeConversionMode,\n    source: KtSourceElement?,\n    additionalAnnotations: Collection<JavaAnnotation>? = null\n): ConeTypeProjection {\n    val attributes = if (this != null && (annotations.isNotEmpty() || additionalAnnotations != null)) {\n        val convertedAnnotations = buildList {\n            if (annotations.isNotEmpty()) {\n                addAll(this@toConeTypeProjection.convertAnnotationsToFir(session, source))\n            }\n\n            if (additionalAnnotations != null) {\n                addAll(additionalAnnotations.convertAnnotationsToFir(session, source))\n            }\n        }\n\n        ConeAttributes.create(listOf(CustomAnnotationTypeAttribute(convertedAnnotations)))\n    } else {\n        ConeAttributes.Empty\n    }\n\n    return when (this) {\n  "}
{"code": "      is JavaClassifierType -> {\n            val lowerBound = toConeKotlinTypeForFlexibleBound(session, javaTypeParameterStack, mode, attributes, source)\n            if (mode.insideAnnotation) {\n                return lowerBound\n            }\n            val upperBound = toConeKotlinTypeForFlexibleBound(session, javaTypeParameterStack, mode, attributes, source, lowerBound)\n\n            val finalLowerBound = when {\n                !session.languageVersionSettings.supportsFeature(LanguageFeature.JavaTypeParameterDefaultRepresentationWithDNN) ->\n                    lowerBound\n                lowerBound is ConeTypeParameterType ->\n                    ConeDefinitelyNotNullType.create(\n                        lowerBound, session.typeContext,\n                        // Upper bounds might be not initialized properly yet, so we force creating DefinitelyNotNullType\n                        // It should not affect semantics, since it would be still a valid type anyway\n                        avoid"}
{"code": "ComprehensiveCheck = true,\n                    ) ?: lowerBound\n\n                else -> lowerBound\n            }\n\n            if (isRaw) ConeRawType.create(finalLowerBound, upperBound) else ConeFlexibleType(finalLowerBound, upperBound)\n        }\n\n        is JavaArrayType -> {\n            val (classId, arguments) = when (val componentType = componentType) {\n                is JavaPrimitiveType ->\n                    StandardClassIds.byName(componentType.type!!.arrayTypeName.identifier) to arrayOf()\n\n                else ->\n                    StandardClassIds.Array to arrayOf(componentType.toConeKotlinType(session, javaTypeParameterStack, mode, source))\n            }\n            val argumentsWithOutProjection = Array(arguments.size) { ConeKotlinTypeProjectionOut(arguments[it]) }\n            when (mode) {\n                FirJavaTypeConversionMode.ANNOTATION_CONSTRUCTOR_PARAMETER ->\n                    classId.constructClassLikeType(argumentsWithOutProjection, isNullable = false, attribut"}
{"code": "es)\n                FirJavaTypeConversionMode.ANNOTATION_MEMBER ->\n                    classId.constructClassLikeType(arguments, isNullable = false, attributes)\n                else ->\n                    classId.toConeFlexibleType(arguments, typeArgumentsForUpper = argumentsWithOutProjection, attributes)\n            }\n        }\n\n        is JavaPrimitiveType ->\n            StandardClassIds.byName(type?.typeName?.identifier ?: \"Unit\")\n                .constructClassLikeType(emptyArray(), isNullable = false, attributes)\n\n        is JavaWildcardType -> {\n            // TODO: this discards annotations on wildcards, allowed since Java 8 - what do they mean?\n            //    List<@NotNull ? extends @Nullable Object>\n            val bound = this.bound\n            val argumentVariance = if (isExtends) Variance.OUT_VARIANCE else Variance.IN_VARIANCE\n            if (bound == null || (parameterVariance != Variance.INVARIANT && parameterVariance != argumentVariance)) {\n                ConeStarPro"}
{"code": "jection\n            } else {\n                val nullabilityAnnotationOnWildcard = extractNullabilityAnnotationOnBoundedWildcard(this)?.let(::listOf)\n                val boundType = bound.toConeKotlinType(session, javaTypeParameterStack, mode, source, nullabilityAnnotationOnWildcard)\n                if (isExtends) ConeKotlinTypeProjectionOut(boundType) else ConeKotlinTypeProjectionIn(boundType)\n            }\n        }\n\n        null -> ConeStarProjection\n        else -> errorWithAttachment(\"Strange JavaType: ${this::class.java}\") {\n            withEntry(\"type\", this@toConeTypeProjection) { it.toString() }\n        }\n    }\n}\n\nprivate fun JavaClassifierType.toConeKotlinTypeForFlexibleBound(\n    session: FirSession,\n    javaTypeParameterStack: JavaTypeParameterStack,\n    mode: FirJavaTypeConversionMode,\n    attributes: ConeAttributes,\n    source: KtSourceElement?,\n    lowerBound: ConeLookupTagBasedType? = null\n): ConeLookupTagBasedType {\n    return when (val classifier = classifier) {\n     "}
{"code": "   is JavaClass -> {\n            var classId = if (mode.insideAnnotation) {\n                JavaToKotlinClassMap.mapJavaToKotlinIncludingClassMapping(classifier.fqName!!)\n            } else {\n                JavaToKotlinClassMap.mapJavaToKotlin(classifier.fqName!!)\n            } ?: classifier.classId!!\n\n            if (lowerBound == null || argumentsMakeSenseOnlyForMutableContainer(classId, session)) {\n                classId = classId.readOnlyToMutable() ?: classId\n            }\n\n            val lookupTag = classId.toLookupTag()\n            // When converting type parameter bounds we should not attempt to load any classes, as this may trigger\n            // enhancement of type parameter bounds on some other class that depends on this one. Also, in case of raw\n            // types specifically there could be an infinite recursion on the type parameter itself.\n            val mappedTypeArguments = when {\n                isRaw -> {\n                    val typeParameterSymbols =\n         "}
{"code": "               lookupTag.takeIf { lowerBound == null && mode != FirJavaTypeConversionMode.TYPE_PARAMETER_BOUND_FIRST_ROUND }\n                            ?.toFirRegularClassSymbol(session)?.typeParameterSymbols\n                    // Given `C<T : X>`, `C` -> `C<X>..C<*>?`.\n                    when {\n                        mode.insideAnnotation -> Array(classifier.allTypeParametersNumber()) { ConeStarProjection }\n                        else -> typeParameterSymbols?.getProjectionsForRawType(session, nullabilities = null)\n                            ?: Array(classifier.allTypeParametersNumber()) { ConeStarProjection }\n                    }\n                }\n\n                lookupTag != lowerBound?.lookupTag && typeArguments.isNotEmpty() -> {\n                    val typeParameterSymbols =\n                        lookupTag.takeIf { mode != FirJavaTypeConversionMode.TYPE_PARAMETER_BOUND_FIRST_ROUND }\n                            ?.toFirRegularClassSymbol(session)?.typeParameterSymbols\n     "}
{"code": "               Array(typeArguments.size) { index ->\n                        // TODO: check this\n                        val newMode = if (mode.insideAnnotation) FirJavaTypeConversionMode.DEFAULT else mode\n                        val argument = typeArguments[index]\n                        val variance = typeParameterSymbols?.getOrNull(index)?.fir?.variance ?: Variance.INVARIANT\n                        argument.toConeTypeProjection(session, javaTypeParameterStack, variance, newMode, source)\n                    }\n                }\n\n                else -> lowerBound?.typeArguments\n            }\n\n            lookupTag.constructClassType(mappedTypeArguments ?: ConeTypeProjection.EMPTY_ARRAY, isNullable = lowerBound != null, attributes)\n        }\n\n        is JavaTypeParameter -> {\n            val symbol = javaTypeParameterStack[classifier]\n            if (symbol != null) {\n                ConeTypeParameterTypeImpl(symbol.toLookupTag(), isNullable = lowerBound != null, attributes)\n           "}
{"code": " } else {\n                ConeErrorType(ConeUnresolvedNameError(classifier.name))\n            }\n        }\n\n        null -> {\n            val classId = ClassId.topLevel(FqName(this.classifierQualifiedName))\n            classId.constructClassLikeType(emptyArray(), isNullable = lowerBound != null, attributes)\n        }\n\n        else -> ConeErrorType(ConeSimpleDiagnostic(\"Unexpected classifier: $classifier\", DiagnosticKind.Java))\n    }\n}\n\nprivate fun JavaClass.allTypeParametersNumber(): Int {\n    var current: JavaClass? = this\n    var result = 0\n    while (current != null) {\n        result += current.typeParameters.size\n        current = if (current.isStatic) null else current.outerClass\n    }\n    return result\n}\n\n// Returns true for covariant read-only container that has mutable pair with invariant parameter\n// List<in A> does not make sense, but MutableList<in A> does\n// Same for Map<K, in V>\n// But both Iterable<in A>, MutableIterable<in A> don't make sense as they are covariant, so ret"}
{"code": "urn false\nprivate fun JavaClassifierType.argumentsMakeSenseOnlyForMutableContainer(\n    classId: ClassId,\n    session: FirSession,\n): Boolean {\n    if (!JavaToKotlinClassMap.isReadOnly(classId.asSingleFqName().toUnsafe())) return false\n    val mutableClassId = classId.readOnlyToMutable() ?: return false\n\n    if (!typeArguments.lastOrNull().isSuperWildcard()) return false\n    val mutableLastParameterVariance =\n        mutableClassId.toLookupTag().toFirRegularClassSymbol(session)?.typeParameterSymbols?.lastOrNull()?.variance\n            ?: return false\n\n    return mutableLastParameterVariance != Variance.OUT_VARIANCE\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.types\n\nimport org.jetbrains.kotlin.builtins.functions.FunctionTypeKind\nimport org.jetbrains.kotlin.builtins.functions.isBasicFunctionOrKFunction\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.FirClass\nimport org.jetbrains.kotlin.fir.declarations.FirFunction\nimport org.jetbrains.kotlin.fir.declarations.FirResolvePhase\nimport org.jetbrains.kotlin.fir.originalForSubstitutionOverride\nimport org.jetbrains.kotlin.fir.resolve.ScopeSession\nimport org.jetbrains.kotlin.fir.resolve.fullyExpandedType\nimport org.jetbrains.kotlin.fir.resolve.scope\nimport org.jetbrains.kotlin.fir.resolve.toSymbol\nimport org.jetbrains.kotlin.fir.scopes.CallableCopyTypeCalculator\nimport org.jetbrains.kotlin.fir.scopes.ProcessorAction\nimport org.jetbrains.kotlin.fir.scopes.processOverriddenFunctions\nimport org.jetbrains.kotlin.fir.scopes.unsubstitutedScope\nimport org.jetbrains.kotlin.fir.symbols.ConeClassLikeLookupTag\nimport org.jetbrains.kotlin"}
{"code": ".fir.symbols.impl.FirFunctionSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol\nimport org.jetbrains.kotlin.fir.utils.exceptions.withConeTypeEntry\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.types.AbstractTypeChecker\nimport org.jetbrains.kotlin.util.OperatorNameConventions\nimport org.jetbrains.kotlin.utils.addToStdlib.runUnless\nimport org.jetbrains.kotlin.utils.exceptions.errorWithAttachment\n\n// ---------------------------------------------- is type is a function type ----------------------------------------------\n\nfun ConeKotlinType.functionTypeKind(session: FirSession): FunctionTypeKind? {\n    if (this !is ConeClassLikeType) return null\n    return fullyExpandedType(session).lookupTag.functionTypeKind(session)\n}\n\nprivate fun ConeClassLikeLookupTag.functionTypeKind(session: FirSession): FunctionTypeKind? {\n    val classId = classId\n    return session.functionTypeService.getKindByClassNamePrefix(classId.packageFqName, classId.shortClassNa"}
{"code": "me.asString())\n}\n\nprivate inline fun ConeKotlinType.isFunctionTypeWithPredicate(\n    session: FirSession,\n    errorOnNotFunctionType: Boolean = false,\n    predicate: (FunctionTypeKind) -> Boolean\n): Boolean {\n    val kind = functionTypeKind(session)\n        ?: if (errorOnNotFunctionType) errorWithAttachment(\"${this::class.java} is not a function type\") {\n            withConeTypeEntry(\"type\", this@isFunctionTypeWithPredicate)\n        } else return false\n    return predicate(kind)\n}\n\n// Function\nfun ConeKotlinType.isBasicFunctionType(session: FirSession): Boolean {\n    return isFunctionTypeWithPredicate(session) { it == FunctionTypeKind.Function }\n}\n\n// Function, SuspendFunction, KSuspendFunction, [Custom]Function, K[Custom]Function\nfun ConeKotlinType.isNonKFunctionType(session: FirSession): Boolean {\n    return isFunctionTypeWithPredicate(session) { it != FunctionTypeKind.KFunction }\n}\n\n// SuspendFunction, KSuspendFunction\nfun ConeKotlinType.isSuspendOrKSuspendFunctionType(session: FirS"}
{"code": "ession): Boolean {\n    return isFunctionTypeWithPredicate(session) {\n        it == FunctionTypeKind.SuspendFunction || it == FunctionTypeKind.KSuspendFunction\n    }\n}\n\n// KFunction, KSuspendFunction, K[Custom]Function\nfun ConeKotlinType.isReflectFunctionType(session: FirSession): Boolean {\n    return isFunctionTypeWithPredicate(session) { it.isReflectType }\n}\n\n// Function, SuspendFunction, [Custom]Function\nfun ConeKotlinType.isNonReflectFunctionType(session: FirSession): Boolean {\n    return isFunctionTypeWithPredicate(session) { !it.isReflectType }\n}\n\n// Function, SuspendFunction, [Custom]Function, KFunction, KSuspendFunction, K[Custom]Function\nfun ConeKotlinType.isSomeFunctionType(session: FirSession): Boolean {\n    return functionTypeKind(session) != null\n}\n\n// Function, SuspendFunction, [Custom]Function, KFunction, KSuspendFunction, K[Custom]Function\nfun ConeClassLikeLookupTag.isSomeFunctionType(session: FirSession): Boolean {\n    return functionTypeKind(session) != null\n}\n\n// Susp"}
{"code": "endFunction, [Custom]Function, KSuspendFunction, K[Custom]Function\nfun ConeKotlinType.isNotBasicFunctionType(session: FirSession): Boolean {\n    return isFunctionTypeWithPredicate(session, errorOnNotFunctionType = false) { !it.isBasicFunctionOrKFunction }\n}\n\n// ---------------------------------------------- function type conversions ----------------------------------------------\n\n\nfun ConeKotlinType.customFunctionTypeToSimpleFunctionType(session: FirSession): ConeClassLikeType {\n    val kind = functionTypeKind(session)\n    require(kind != null && kind != FunctionTypeKind.Function && kind != FunctionTypeKind.KFunction)\n    val newKind = if (kind.isReflectType) {\n        FunctionTypeKind.KFunction\n    } else {\n        FunctionTypeKind.Function\n    }\n    return createFunctionTypeWithNewKind(session, newKind)\n}\n\nfun ConeKotlinType.createFunctionTypeWithNewKind(\n    session: FirSession,\n    kind: FunctionTypeKind,\n    updateTypeArguments: (Array<out ConeTypeProjection>.() -> Array<out ConeT"}
{"code": "ypeProjection>)? = null,\n): ConeClassLikeType {\n    val expandedType = fullyExpandedType(session)\n    val functionTypeId = ClassId(kind.packageFqName, kind.numberedClassName(expandedType.typeArguments.size - 1))\n    val typeArguments = expandedType.typeArguments\n    return functionTypeId.toLookupTag().constructClassType(\n        updateTypeArguments?.let { typeArguments.updateTypeArguments() } ?: typeArguments,\n        isNullable = expandedType.isNullable,\n        attributes = expandedType.attributes\n    )\n}\n\n// ---------------------------------------------- function type subtyping ----------------------------------------------\n\n// expectedfunctionType is kotlin.FunctionN or kotlin.reflect.KFunctionN\nfun ConeKotlinType.findSubtypeOfBasicFunctionType(session: FirSession, expectedFunctionType: ConeClassLikeType): ConeKotlinType? {\n    require(expectedFunctionType.isFunctionOrKFunctionType(session, errorOnNotFunctionType = true))\n    return findSubtypeOfBasicFunctionTypeImpl(session, expec"}
{"code": "tedFunctionType)\n}\n\n// Function, KFunction\nprivate fun ConeKotlinType.isFunctionOrKFunctionType(session: FirSession, errorOnNotFunctionType: Boolean): Boolean {\n    return isFunctionTypeWithPredicate(session, errorOnNotFunctionType) { it.isBasicFunctionOrKFunction }\n}\n\nprivate fun ConeKotlinType.findSubtypeOfBasicFunctionTypeImpl(\n    session: FirSession,\n    expectedFunctionType: ConeClassLikeType\n): ConeKotlinType? {\n    return when (this) {\n        is ConeClassLikeType -> {\n            when {\n                // Expect the argument type is a simple function type.\n                isNotBasicFunctionType(session) -> null\n                isSubtypeOfFunctionType(session, expectedFunctionType) -> this\n                else -> null\n            }\n        }\n\n        is ConeIntersectionType -> {\n            runUnless(intersectedTypes.any { it.isNotBasicFunctionType(session) }) {\n                intersectedTypes.find { it.findSubtypeOfBasicFunctionTypeImpl(session, expectedFunctionType) != null "}
{"code": "}\n            }\n        }\n\n        is ConeTypeParameterType -> {\n            val bounds = lookupTag.typeParameterSymbol.resolvedBounds.map { it.coneType }\n            runUnless(bounds.any { it.isNotBasicFunctionType(session) }) {\n                bounds.find { it.findSubtypeOfBasicFunctionTypeImpl(session, expectedFunctionType) != null }\n            }\n        }\n        else -> null\n    }\n}\n\nprivate fun ConeKotlinType.isSubtypeOfFunctionType(session: FirSession, expectedFunctionType: ConeClassLikeType): Boolean {\n    return AbstractTypeChecker.isSubtypeOf(session.typeContext, this, expectedFunctionType.replaceArgumentsWithStarProjections())\n}\n\n// ---------------------------------------------- function type scope utils ----------------------------------------------\n\nfun ConeClassLikeType.findBaseInvokeSymbol(session: FirSession, scopeSession: ScopeSession): FirNamedFunctionSymbol? {\n    require(this.isSomeFunctionType(session))\n    val functionN = (lookupTag.toSymbol(session)?.fir as? Fir"}
{"code": "Class) ?: return null\n    var baseInvokeSymbol: FirNamedFunctionSymbol? = null\n    functionN.unsubstitutedScope(\n        session,\n        scopeSession,\n        withForcedTypeCalculator = false,\n        memberRequiredPhase = null,\n    ).processFunctionsByName(OperatorNameConventions.INVOKE) { functionSymbol ->\n        baseInvokeSymbol = functionSymbol\n        return@processFunctionsByName\n    }\n    return baseInvokeSymbol\n}\n\nfun ConeKotlinType.findContributedInvokeSymbol(\n    session: FirSession,\n    scopeSession: ScopeSession,\n    expectedFunctionType: ConeClassLikeType,\n    shouldCalculateReturnTypesOfFakeOverrides: Boolean\n): FirFunctionSymbol<*>? {\n    val baseInvokeSymbol = expectedFunctionType.findBaseInvokeSymbol(session, scopeSession) ?: return null\n\n    val callableCopyTypeCalculator = if (shouldCalculateReturnTypesOfFakeOverrides) {\n        CallableCopyTypeCalculator.Forced\n    } else {\n        CallableCopyTypeCalculator.DoNothing\n    }\n\n    val scope = scope(\n        useSiteS"}
{"code": "ession = session,\n        scopeSession = scopeSession,\n        callableCopyTypeCalculator = callableCopyTypeCalculator,\n        requiredMembersPhase = FirResolvePhase.STATUS,\n    ) ?: return null\n\n    var declaredInvoke: FirNamedFunctionSymbol? = null\n    scope.processFunctionsByName(OperatorNameConventions.INVOKE) { functionSymbol ->\n        if (functionSymbol.fir.valueParameters.size == baseInvokeSymbol.fir.valueParameters.size) {\n            declaredInvoke = functionSymbol\n            return@processFunctionsByName\n        }\n    }\n\n    var overriddenInvoke: FirFunctionSymbol<*>? = null\n    if (declaredInvoke != null) {\n        // Make sure the user-contributed or type-substituted invoke we just found above is an override of base invoke.\n        scope.processOverriddenFunctions(declaredInvoke!!) { functionSymbol ->\n            if (functionSymbol == baseInvokeSymbol || functionSymbol.originalForSubstitutionOverride == baseInvokeSymbol) {\n                overriddenInvoke = functionSymbo"}
{"code": "l\n                ProcessorAction.STOP\n            } else {\n                ProcessorAction.NEXT\n            }\n        }\n    }\n\n    return if (overriddenInvoke != null) declaredInvoke else null\n}\n\n// ---------------------------------------------- function type type argument extraction ----------------------------------------------\n\nfun ConeKotlinType.contextReceiversTypes(session: FirSession): List<ConeKotlinType> {\n    if (!isSomeFunctionType(session)) return emptyList()\n    return fullyExpandedType(session).let { expanded ->\n        val contextReceivers = expanded.typeArguments.take(expanded.contextReceiversNumberForFunctionType)\n        contextReceivers.map { it.typeOrDefault(session.builtinTypes.nothingType.type) }\n    }\n}\n\nfun ConeKotlinType.receiverType(session: FirSession): ConeKotlinType? {\n    if (!isSomeFunctionType(session) || !isExtensionFunctionType(session)) return null\n    return fullyExpandedType(session).let { expanded ->\n        expanded.typeArguments[expanded.context"}
{"code": "ReceiversNumberForFunctionType].typeOrDefault(session.builtinTypes.nothingType.type)\n    }\n}\n\nfun ConeKotlinType.returnType(session: FirSession): ConeKotlinType {\n    require(this is ConeClassLikeType)\n    // TODO: add requirement\n    return fullyExpandedType(session).typeArguments.last().typeOrDefault(session.builtinTypes.nullableAnyType.type)\n}\n\nfun ConeKotlinType.valueParameterTypesWithoutReceivers(session: FirSession): List<ConeKotlinType> {\n    require(this is ConeClassLikeType)\n    // TODO: add requirement\n    val expandedType = fullyExpandedType(session)\n\n    val receiversNumber = expandedType.contextReceiversNumberForFunctionType + if (expandedType.isExtensionFunctionType) 1 else 0\n    val valueParameters = expandedType.typeArguments.drop(receiversNumber).dropLast(1)\n\n    return valueParameters.map { it.typeOrDefault(session.builtinTypes.nothingType.type) }\n}\n\nfun ConeKotlinType.valueParameterTypesIncludingReceiver(session: FirSession): List<ConeKotlinType> {\n    require(this i"}
{"code": "s ConeClassLikeType)\n    // TODO: add requirement\n    return fullyExpandedType(session).typeArguments.dropLast(1).map { it.typeOrDefault(session.builtinTypes.nothingType.type) }\n}\n\nprivate fun ConeTypeProjection.typeOrDefault(default: ConeKotlinType): ConeKotlinType = when (this) {\n    is ConeKotlinTypeProjection -> type\n    is ConeStarProjection -> default\n}\n\n// ----------------- TODO fir utils\n\nfun FirFunction.specialFunctionTypeKind(session: FirSession): FunctionTypeKind? {\n    return (symbol as? FirNamedFunctionSymbol)?.let {\n        session.functionTypeService.extractSingleSpecialKindForFunction(it)\n    }\n}\n"}
{"code": "fun test(flag: Boolean) {\n    block {\n        consume(\"before\")\n\n        <expr>if (flag) {\n            return@block 1\n        }\n\n        2</expr>\n    }\n}\n\nfun block(block: () -> Int) {\n    block()\n}\n\nfun consume(text: String) {}"}
{"code": "\n\npackage org.jetbrains.kotlin.config\n\nenum class JvmStringConcat(val description: String) {\n    INLINE(\"inline\"),\n    INDY_WITH_CONSTANTS(\"indy-with-constants\"), // makeConcatWithConstants\n    INDY(\"indy\"); // makeConcat\n\n    val isDynamic\n        get() = this != INLINE\n\n    companion object {\n        @JvmStatic\n        fun fromString(string: String) = entries.find { it.description == string }\n    }\n}"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\")\n\npackage org.jetbrains.kotlin.fir.references.impl\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.references.FirSuperReference\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\ninternal class FirExplicitSuperReference(\n    override val source: KtSourceElement?,\n    override val labelName: String?,\n    override var superTypeRef: FirTypeRef,\n) : FirSuperReference() {\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {\n        superTypeRef.accept(visitor, data)\n    }\n\n    override fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirExplicitSuperReference {\n        superTypeRef = superTypeRef.transform(transformer, data)\n        return this\n    }\n\n    overri"}
{"code": "de fun replaceSuperTypeRef(newSuperTypeRef: FirTypeRef) {\n        superTypeRef = newSuperTypeRef\n    }\n}\n"}
{"code": "package test\n\nclass OuterClass {\n    class Nested\n\n    object NestedObject {\n        class Nested\n\n        <expr>fun usage(\n            first: test.OuterClass.Nested,\n            second: test.OuterClass.NestedObject.Nested,\n        ) {}</expr>\n    }\n}"}
{"code": "fun foo(vararg x: String) {}\n\nfun foo() {}\n\nfun main() {\n    foo()\n    foo(\"!\")\n}\n"}
{"code": "// WITH_STDLIB\n\nval list1: List<Int> = listOf(1)\nval list = list1.<!USELESS_CALL_ON_NOT_NULL!>orEmpty()<!>.map { \"$it\" }"}
{"code": "fun resolve<caret>Me(foo: Foo) {\n    foo.util()\n}\n\ninterface Foo\ninterface Bar<T : Foo>\n\nfun <F : Foo, B : Bar<F>> F.util(): B = null!!"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.serialization\n\nimport org.jetbrains.kotlin.fir.declarations.FirDeclaration\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\n\nabstract class FirAdditionalMetadataProvider {\n    abstract fun findGeneratedAnnotationsFor(declaration: FirDeclaration): List<FirAnnotation>\n    abstract fun hasGeneratedAnnotationsFor(declaration: FirDeclaration): Boolean\n}\n"}
{"code": "// EXPECTED: org.jetbrains.kotlin.light.classes.symbol.methods.SymbolLightAccessorMethod\n// EXPECTED: org.jetbrains.kotlin.light.classes.symbol.fields.SymbolLightFieldForProperty\n@get:JvmName(\"getBar\")\nval <caret>p: Int = 42"}
{"code": "class SomeClass() {}\n\nfun someFun() {\n    when {\n        is SomeClass\n    }\n}\n"}
{"code": "// FILE: main.kt\npackage a.b.c\n\nfun test(n: Int) {\n    return if (<expr>x.y.z.Outer.Inner.VALUE0 > x.y.z.Outer.Inner.VALUE1</expr>) 1\n    else n\n}\n// FILE: values.kt\npackage x.y.z\n\nclass Outer {\n    object Inner {\n        val VALUE0 = 13\n        val VALUE1 = 17\n    }\n}"}
{"code": "class Foo {\n    fun <<expr>T</expr>> foo(obj: T) {}\n    fun other() {}\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.annotations\n\nimport com.intellij.psi.PsiAnnotation\n\ninternal object AlwaysAllowedAnnotationFilter : AnnotationFilter {\n    override fun isAllowed(qualifiedName: String): Boolean = true\n    override fun filtered(annotations: Collection<PsiAnnotation>): Collection<PsiAnnotation> = annotations\n}\n"}
{"code": "// ISSUE: KT-55493, KT-59744\n// WITH_STDLIB\n\nval z: String = \"ok\"\n\nval Some.y: String\n    get() = \"ok\"\n\nclass Some {\n    val x: String = \"ok\"\n\n    init {\n        <!VAL_REASSIGNMENT!>x<!> = \"error\"\n        <!VAL_REASSIGNMENT!>y<!> = \"error\"\n        <!VAL_REASSIGNMENT!>z<!> = \"error\"\n    }\n\n    val a: String = run {\n        <!VAL_REASSIGNMENT!>x<!> = \"error\"\n        <!VAL_REASSIGNMENT!>y<!> = \"error\"\n        <!VAL_REASSIGNMENT!>z<!> = \"error\"\n        \"hello\"\n    }\n\n    var b: String = \"hello\"\n        get() {\n            <!VAL_REASSIGNMENT!>x<!> = \"error\"\n            <!VAL_REASSIGNMENT!>y<!> = \"error\"\n            <!VAL_REASSIGNMENT!>z<!> = \"error\"\n            return field\n        }\n        set(value) {\n            <!VAL_REASSIGNMENT!>x<!> = value\n            <!VAL_REASSIGNMENT!>y<!> = value\n            <!VAL_REASSIGNMENT!>z<!> = value\n            field = value\n        }\n\n    var c: String\n        get() {\n            <!VAL_REASSIGNMENT!>x<!> = \"error\"\n            <!VAL_REASSIGNMENT!>y<!> ="}
{"code": " \"error\"\n            <!VAL_REASSIGNMENT!>z<!> = \"error\"\n            return \"hello\"\n        }\n        set(value) {\n            <!VAL_REASSIGNMENT!>x<!> = value\n            <!VAL_REASSIGNMENT!>y<!> = value\n            <!VAL_REASSIGNMENT!>z<!> = value\n        }\n\n    fun test_1() {\n        <!VAL_REASSIGNMENT!>x<!> = \"error\"\n        <!VAL_REASSIGNMENT!>y<!> = \"error\"\n        <!VAL_REASSIGNMENT!>z<!> = \"error\"\n    }\n}\n\nfun Some.test_2() {\n    <!VAL_REASSIGNMENT!>x<!> = \"error\"\n    <!VAL_REASSIGNMENT!>y<!> = \"error\"\n    <!VAL_REASSIGNMENT!>z<!> = \"error\"\n}\n\nfun test_3(some: Some) {\n    some.<!VAL_REASSIGNMENT!>x<!> = \"error\"\n    some.<!VAL_REASSIGNMENT!>y<!> = \"error\"\n    <!VAL_REASSIGNMENT!>z<!> = \"error\"\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.daemon.report\n\nimport org.jetbrains.kotlin.daemon.common.*\nimport java.io.PrintStream\n\ninterface DaemonMessageReporter {\n    fun report(severity: ReportSeverity, message: String)\n}\n\nfun DaemonMessageReporter(\n        servicesFacade: CompilerServicesFacadeBase,\n        compilationOptions: CompilationOptions\n): DaemonMessageReporter =\n        if (ReportCategory.DAEMON_MESSAGE.code in compilationOptions.reportCategories) {\n            val mySeverity = ReportSeverity.fromCode(compilationOptions.reportSeverity)\n            DaemonMessageReporterImpl(servicesFacade, mySeverity)\n        }\n        else {\n            DummyDaemonMessageReporter\n        }\n\ninternal class DaemonMessageReporterPrintStreamAdapter(private val out: PrintStream): DaemonMessageReporter {\n    override fun report(severity: ReportSeverity, message: String) {\n        out.print(\"[Kotlin compile daemon][$severity] $message\")\n    }\n}\n\nprivate class DaemonMessageReporterImpl(\n        private val se"}
{"code": "rvicesFacade: CompilerServicesFacadeBase,\n        private val mySeverity: ReportSeverity\n): DaemonMessageReporter {\n    override fun report(severity: ReportSeverity, message: String) {\n        if (severity.code <= mySeverity.code) {\n            servicesFacade.report(ReportCategory.DAEMON_MESSAGE.code, severity.code, message, attachment = null)\n        }\n    }\n}\n\nprivate object DummyDaemonMessageReporter : DaemonMessageReporter {\n    override fun report(severity: ReportSeverity, message: String) {\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.decompiled\n\nimport org.jetbrains.kotlin.light.classes.symbol.base.AbstractSymbolLightClassesParentingTestByFqName\nimport org.jetbrains.kotlin.light.classes.symbol.decompiled.test.configurators.AnalysisApiSymbolLightClassesDecompiledTestConfigurator\n\nabstract class AbstractSymbolLightClassesParentingByFqNameForLibraryTest :\n    AbstractSymbolLightClassesParentingTestByFqName(\n        AnalysisApiSymbolLightClassesDecompiledTestConfigurator,\n        EXTENSIONS.LIB_JAVA,\n        stopIfCompilationErrorDirectivePresent = true\n    )"}
{"code": "fun function(a: Int, b: (String) -> Boolean) {}\n\nfun call() {\n    <expr>function(1, { s -> true })</expr>\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.expression\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.FirSessionComponent\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.analysis.getChild\nimport org.jetbrains.kotlin.fir.declarations.FirResolvePhase\nimport org.jetbrains.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.references.toResolvedTypeParameterSymbol\nimport org.jetbrains.kotlin.fir.resolve.fullyExpandedType\nimport org.jetbrains.kotlin.fir.scopes.impl.toConeType\nimport org.jetbrains.kotlin.fir.symbols.impl.FirTypeParameterSymbol\nimport org.jetbra"}
{"code": "ins.kotlin.fir.symbols.lazyResolveToPhase\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.lexer.KtTokens.QUEST\nimport org.jetbrains.kotlin.resolve.checkers.OptInNames\n\nobject FirClassLiteralChecker : FirGetClassCallChecker(MppCheckerKind.Common) {\n    override fun check(expression: FirGetClassCall, context: CheckerContext, reporter: DiagnosticReporter) {\n        val source = expression.source ?: return\n        if (source.kind is KtFakeSourceElementKind) return\n        val argument = expression.argument\n        if (argument is FirResolvedQualifier) {\n            val classId = argument.classId\n            if (classId == OptInNames.REQUIRES_OPT_IN_CLASS_ID || classId == OptInNames.OPT_IN_CLASS_ID) {\n                reporter.reportOn(argument.source, FirErrors.OPT_IN_CAN_ONLY_BE_USED_AS_ANNOTATION, context)\n            }\n        }\n\n        // Note that raw FIR drops marked nullability \"?\" in, e.g., `A?::class`, `A<T?>::class`, or `A<T?>?::class`.\n        // That is, AST"}
{"code": " structures for those expressions have token type QUEST, whereas FIR element doesn't have any information about it.\n        //\n        // A?::class -> CLASS_LITERAL_EXPRESSION(REFERENCE_EXPRESSION QUEST COLONCOLON \"class\")\n        // A<T?>::class -> CLASS_LITERAL_EXPRESSION(REFERENCE_EXPRESSION TYPE_ARGUMENT_LIST COLONCOLON \"class\")\n        // A<T?>?::class -> CLASS_LITERAL_EXPRESSION(REFERENCE_EXPRESSION TYPE_ARGUMENT_LIST QUEST COLONCOLON \"class\")\n        //   where TYPE_ARGUMENT_LIST may have QUEST in it\n        //\n        // Only the 2nd example is valid, and we want to check if token type QUEST doesn't exist at the same level as COLONCOLON.\n        val markedNullable = source.getChild(QUEST, depth = 1) != null\n        val resolvedFullyExpandedType = argument.resolvedType.fullyExpandedType(context.session)\n        val isNullable = markedNullable ||\n                (argument as? FirResolvedQualifier)?.isNullableLHSForCallableReference == true ||\n                resolvedFullyExpanded"}
{"code": "Type.isMarkedNullable ||\n                resolvedFullyExpandedType.isNullableTypeParameter(context.session.typeContext)\n        if (isNullable) {\n            if (argument.canBeDoubleColonLHSAsType) {\n                reporter.reportOn(source, FirErrors.NULLABLE_TYPE_IN_CLASS_LITERAL_LHS, context)\n            } else {\n                reporter.reportOn(\n                    argument.source,\n                    FirErrors.EXPRESSION_OF_NULLABLE_TYPE_IN_CLASS_LITERAL_LHS,\n                    argument.resolvedType,\n                    context\n                )\n            }\n            return\n        }\n\n        argument.safeAsTypeParameterSymbol?.let {\n            if (!it.isReified) {\n                // E.g., fun <T: Any> foo(): Any = T::class\n                reporter.reportOn(source, FirErrors.TYPE_PARAMETER_AS_REIFIED, it, context)\n            }\n        }\n\n        if (argument !is FirResolvedQualifier) return\n        if (argument.typeArguments.isNotEmpty() && !resolvedFullyExpandedType.isAll"}
{"code": "owedInClassLiteral(context)) {\n            val symbol = argument.symbol\n            symbol?.lazyResolveToPhase(FirResolvePhase.TYPES)\n            // Among type parameter references, only count actual type parameter while discarding [FirOuterClassTypeParameterRef]\n            val expectedTypeArgumentSize = symbol?.ownTypeParameterSymbols?.size ?: 0\n            if (expectedTypeArgumentSize != argument.typeArguments.size) {\n                if (symbol != null) {\n                    reporter.reportOn(argument.source, FirErrors.WRONG_NUMBER_OF_TYPE_ARGUMENTS, expectedTypeArgumentSize, symbol, context)\n                }\n                return\n            }\n            reporter.reportOn(source, FirErrors.CLASS_LITERAL_LHS_NOT_A_CLASS, context)\n        }\n    }\n\n    private fun ConeKotlinType.isNullableTypeParameter(context: ConeInferenceContext): Boolean {\n        if (this !is ConeTypeParameterType) return false\n        val typeParameter = lookupTag.typeParameterSymbol\n        with(context) {\n "}
{"code": "           return !typeParameter.isReified &&\n                    // E.g., fun <T> f2(t: T): Any = t::class\n                    typeParameter.toConeType().isNullableType()\n        }\n    }\n\n    private val FirExpression.canBeDoubleColonLHSAsType: Boolean\n        get() {\n            return this is FirResolvedQualifier ||\n                    this is FirResolvedReifiedParameterReference ||\n                    safeAsTypeParameterSymbol != null\n        }\n\n    private val FirExpression.safeAsTypeParameterSymbol: FirTypeParameterSymbol?\n        get() {\n            return (this as? FirQualifiedAccessExpression)?.calleeReference?.toResolvedTypeParameterSymbol()\n        }\n\n    private fun ConeKotlinType.isAllowedInClassLiteral(context: CheckerContext): Boolean =\n        when (this) {\n            is ConeClassLikeType -> {\n                val isPlatformThatAllowsNonPrimitiveArrays = context.session.firGenericArrayClassLiteralSupport.isEnabled\n                val isOldVersionThatAllowsNonPrimitiveAr"}
{"code": "rays =\n                    !context.languageVersionSettings.supportsFeature(LanguageFeature.ProhibitGenericArrayClassLiteral)\n                if (isNonPrimitiveArray && (isPlatformThatAllowsNonPrimitiveArrays || isOldVersionThatAllowsNonPrimitiveArrays)) {\n                    typeArguments.none { typeArgument ->\n                        when (typeArgument) {\n                            is ConeStarProjection -> true\n                            is ConeKotlinTypeProjection -> !typeArgument.type.isAllowedInClassLiteral(context)\n                        }\n                    }\n                } else\n                    typeArguments.isEmpty()\n            }\n            is ConeTypeParameterType -> this.lookupTag.typeParameterSymbol.isReified\n            else -> false\n        }\n}\n\ninterface FirGenericArrayClassLiteralSupport : FirSessionComponent {\n    val isEnabled: Boolean\n\n    object Enabled : FirGenericArrayClassLiteralSupport {\n        override val isEnabled: Boolean = true\n    }\n\n    objec"}
{"code": "t Disabled : FirGenericArrayClassLiteralSupport {\n        override val isEnabled: Boolean = false\n    }\n}\n\nval FirSession.firGenericArrayClassLiteralSupport: FirGenericArrayClassLiteralSupport by FirSession.sessionComponentAccessor()\n"}
{"code": "package foo\n\n@Target(AnnotationTarget.TYPE)\nannotation class MyAnno(val s: String)\n\n@Target(AnnotationTarget.TYPE)\nannotation class AnotherAnnotation(val k: KClass<*>)\n\nclass Nested\n\nfun f<caret>oo(): @MyAnno(\"outer\") List<@MyAnno(\"middle\") List<@AnotherAnnotation(Nested::class) String>> {\n\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.analysis.api.components.*\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeOwner\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken\nimport org.jetbrains.kotlin.analysis.api.symbols.*\nimport org.jetbrains.kotlin.analysis.api.symbols.pointers.KtSymbolPointer\nimport org.jetbrains.kotlin.analysis.project.structure.KtModule\nimport org.jetbrains.kotlin.analysis.project.structure.ProjectStructureProvider\n\n\n@OptIn(KtAnalysisApiInternals::class, KtAnalysisNonPublicApi::class)\n@Suppress(\"AnalysisApiMissingLifetimeCheck\")\npublic abstract class KtAnalysisSession(final override val token: KtLifetimeToken) : KtLifetimeOwner,\n    KtSmartCastProviderMixIn,\n    KtCallResolverMixIn,\n    KtSamResolverMixIn,\n    KtDiagnosticProviderMixIn,\n    KtScopeProviderMixIn,\n    KtCompletionCandidateCheckerMixIn,\n    KtSymbolDeclarationOverridesProviderMixIn,\n    KtExpressionTypeProvi"}
{"code": "derMixIn,\n    KtPsiTypeProviderMixIn,\n    KtJvmTypeMapperMixIn,\n    KtTypeProviderMixIn,\n    KtTypeInfoProviderMixIn,\n    KtSymbolProviderMixIn,\n    KtSymbolContainingDeclarationProviderMixIn,\n    KtSymbolInfoProviderMixIn,\n    KtSubtypingComponentMixIn,\n    KtExpressionInfoProviderMixIn,\n    KtCompileTimeConstantProviderMixIn,\n    KtSymbolsMixIn,\n    KtReferenceResolveMixIn,\n    KtReferenceShortenerMixIn,\n    KtImportOptimizerMixIn,\n    KtSymbolDeclarationRendererMixIn,\n    KtVisibilityCheckerMixIn,\n    KtMemberSymbolProviderMixin,\n    KtMultiplatformInfoProviderMixin,\n    KtOriginalPsiProviderMixIn,\n    KtInheritorsProviderMixIn,\n    KtTypeCreatorMixIn,\n    KtAnalysisScopeProviderMixIn,\n    KtSignatureSubstitutorMixIn,\n    KtScopeSubstitutionMixIn,\n    KtSymbolProviderByJavaPsiMixIn,\n    KtResolveExtensionInfoProviderMixIn,\n    KtCompilerFacilityMixIn,\n    KtMetadataCalculatorMixIn,\n    KtSubstitutorProviderMixIn,\n    KtDataFlowInfoProviderMixin,\n    KtKlibSourceFileProviderMixIn {\n\n"}
{"code": "    public abstract val useSiteModule: KtModule\n\n    override val analysisSession: KtAnalysisSession get() = this\n\n    internal val smartCastProvider: KtSmartCastProvider get() = smartCastProviderImpl\n    protected abstract val smartCastProviderImpl: KtSmartCastProvider\n\n    internal val diagnosticProvider: KtDiagnosticProvider get() = diagnosticProviderImpl\n    protected abstract val diagnosticProviderImpl: KtDiagnosticProvider\n\n    internal val scopeProvider: KtScopeProvider get() = scopeProviderImpl\n    protected abstract val scopeProviderImpl: KtScopeProvider\n\n    internal val containingDeclarationProvider: KtSymbolContainingDeclarationProvider get() = containingDeclarationProviderImpl\n    protected abstract val containingDeclarationProviderImpl: KtSymbolContainingDeclarationProvider\n\n    internal val symbolProvider: KtSymbolProvider get() = symbolProviderImpl\n    protected abstract val symbolProviderImpl: KtSymbolProvider\n\n    internal val callResolver: KtCallResolver get() = call"}
{"code": "ResolverImpl\n    protected abstract val callResolverImpl: KtCallResolver\n\n    internal val samResolver: KtSamResolver get() = samResolverImpl\n    protected abstract val samResolverImpl: KtSamResolver\n\n    internal val completionCandidateChecker: KtCompletionCandidateChecker get() = completionCandidateCheckerImpl\n    protected abstract val completionCandidateCheckerImpl: KtCompletionCandidateChecker\n\n    internal val symbolDeclarationOverridesProvider: KtSymbolDeclarationOverridesProvider get() = symbolDeclarationOverridesProviderImpl\n    protected abstract val symbolDeclarationOverridesProviderImpl: KtSymbolDeclarationOverridesProvider\n\n    internal val referenceShortener: KtReferenceShortener get() = referenceShortenerImpl\n    protected abstract val referenceShortenerImpl: KtReferenceShortener\n\n    internal val importOptimizer: KtImportOptimizer get() = importOptimizerImpl\n    protected abstract val importOptimizerImpl: KtImportOptimizer\n\n    internal val symbolDeclarationRendererProv"}
{"code": "ider: KtSymbolDeclarationRendererProvider get() = symbolDeclarationRendererProviderImpl\n    protected abstract val symbolDeclarationRendererProviderImpl: KtSymbolDeclarationRendererProvider\n\n    internal val expressionTypeProvider: KtExpressionTypeProvider get() = expressionTypeProviderImpl\n    protected abstract val expressionTypeProviderImpl: KtExpressionTypeProvider\n\n    internal val psiTypeProvider: KtPsiTypeProvider get() = psiTypeProviderImpl\n    protected abstract val psiTypeProviderImpl: KtPsiTypeProvider\n\n    internal val jvmTypeMapper: KtJvmTypeMapper get() = jvmTypeMapperImpl\n    protected abstract val jvmTypeMapperImpl: KtJvmTypeMapper\n\n    internal val typeProvider: KtTypeProvider get() = typeProviderImpl\n    protected abstract val typeProviderImpl: KtTypeProvider\n\n    internal val typeInfoProvider: KtTypeInfoProvider get() = typeInfoProviderImpl\n    protected abstract val typeInfoProviderImpl: KtTypeInfoProvider\n\n    internal val subtypingComponent: KtSubtypingComponent g"}
{"code": "et() = subtypingComponentImpl\n    protected abstract val subtypingComponentImpl: KtSubtypingComponent\n\n    internal val expressionInfoProvider: KtExpressionInfoProvider get() = expressionInfoProviderImpl\n    protected abstract val expressionInfoProviderImpl: KtExpressionInfoProvider\n\n    internal val compileTimeConstantProvider: KtCompileTimeConstantProvider get() = compileTimeConstantProviderImpl\n    protected abstract val compileTimeConstantProviderImpl: KtCompileTimeConstantProvider\n\n    internal val visibilityChecker: KtVisibilityChecker get() = visibilityCheckerImpl\n    protected abstract val visibilityCheckerImpl: KtVisibilityChecker\n\n    internal val overrideInfoProvider: KtOverrideInfoProvider get() = overrideInfoProviderImpl\n    protected abstract val overrideInfoProviderImpl: KtOverrideInfoProvider\n\n    internal val inheritorsProvider: KtInheritorsProvider get() = inheritorsProviderImpl\n    protected abstract val inheritorsProviderImpl: KtInheritorsProvider\n\n    internal val "}
{"code": "multiplatformInfoProvider: KtMultiplatformInfoProvider get() = multiplatformInfoProviderImpl\n    protected abstract val multiplatformInfoProviderImpl: KtMultiplatformInfoProvider\n\n    internal val originalPsiProvider: KtOriginalPsiProvider get() = originalPsiProviderImpl\n    protected abstract val originalPsiProviderImpl: KtOriginalPsiProvider\n\n    internal val symbolInfoProvider: KtSymbolInfoProvider get() = symbolInfoProviderImpl\n    protected abstract val symbolInfoProviderImpl: KtSymbolInfoProvider\n\n    internal val analysisScopeProvider: KtAnalysisScopeProvider get() = analysisScopeProviderImpl\n    protected abstract val analysisScopeProviderImpl: KtAnalysisScopeProvider\n\n    internal val referenceResolveProvider: KtReferenceResolveProvider get() = referenceResolveProviderImpl\n    protected abstract val referenceResolveProviderImpl: KtReferenceResolveProvider\n\n    internal val signatureSubstitutor: KtSignatureSubstitutor get() = signatureSubstitutorImpl\n    protected abstract val "}
{"code": "signatureSubstitutorImpl: KtSignatureSubstitutor\n\n    internal val scopeSubstitution: KtScopeSubstitution get() = scopeSubstitutionImpl\n    protected abstract val scopeSubstitutionImpl: KtScopeSubstitution\n\n    internal val resolveExtensionInfoProvider: KtResolveExtensionInfoProvider get() = resolveExtensionInfoProviderImpl\n    protected abstract val resolveExtensionInfoProviderImpl: KtResolveExtensionInfoProvider\n\n    internal val compilerFacility: KtCompilerFacility get() = compilerFacilityImpl\n    protected abstract val compilerFacilityImpl: KtCompilerFacility\n\n    @KtAnalysisApiInternals\n    public val substitutorFactory: KtSubstitutorFactory get() = substitutorFactoryImpl\n    protected abstract val substitutorFactoryImpl: KtSubstitutorFactory\n\n    @KtAnalysisApiInternals\n    public val symbolProviderByJavaPsi: KtSymbolProviderByJavaPsi get() = symbolProviderByJavaPsiImpl\n    @KtAnalysisApiInternals\n    protected abstract val symbolProviderByJavaPsiImpl: KtSymbolProviderByJavaPsi\n\n"}
{"code": "    internal val metadataCalculator: KtMetadataCalculator get() = metadataCalculatorImpl\n    protected abstract val metadataCalculatorImpl: KtMetadataCalculator\n\n    @PublishedApi\n    internal val typesCreator: KtTypeCreator\n        get() = typesCreatorImpl\n    protected abstract val typesCreatorImpl: KtTypeCreator\n\n    internal val substitutorProvider: KtSubstitutorProvider get() = substitutorProviderImpl\n    protected abstract val substitutorProviderImpl: KtSubstitutorProvider\n\n    @KtAnalysisNonPublicApi\n    internal val dataFlowInfoProvider: KtDataFlowInfoProvider get() = dataFlowInfoProviderImpl\n    @KtAnalysisNonPublicApi\n    protected abstract val dataFlowInfoProviderImpl: KtDataFlowInfoProvider\n\n    internal val klibSourceFileProvider: KtKlibSourceFileNameProvider get() = klibSourceFileProviderImpl\n    protected abstract val klibSourceFileProviderImpl: KtKlibSourceFileNameProvider\n}\n\npublic fun KtAnalysisSession.getModule(element: PsiElement): KtModule {\n    return ProjectStruc"}
{"code": "tureProvider.getModule(useSiteModule.project, element, useSiteModule)\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.contracts.description\n\nimport org.jetbrains.kotlin.contracts.description.*\nimport org.jetbrains.kotlin.fir.contracts.*\nimport org.jetbrains.kotlin.fir.declarations.FirContractDescriptionOwner\nimport org.jetbrains.kotlin.fir.declarations.FirDeclaration\nimport org.jetbrains.kotlin.fir.diagnostics.ConeDiagnostic\nimport org.jetbrains.kotlin.fir.renderer.FirRendererComponents\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.types.renderForDebugging\n\nclass ConeContractRenderer : KtContractDescriptionVisitor<Unit, Nothing?, ConeKotlinType, ConeDiagnostic>() {\n\n    internal lateinit var components: FirRendererComponents\n    private val printer get() = components.printer\n    private val visitor get() = components.visitor\n\n    fun render(declaration: FirDeclaration) {\n        val contractDescription = (declaration as? FirContractDescriptionOwner)?.contractDescription ?: return\n        render(contractDescription)\n    }\n\n    fu"}
{"code": "n render(contractDescription: FirContractDescription) {\n        printer.pushIndent()\n        printer.newLine()\n        val prefix = if (contractDescription is FirResolvedContractDescription) \"R|\" else \"\"\n        printer.print(\"[${prefix}Contract description]\")\n        when (contractDescription) {\n            is FirLegacyRawContractDescription -> render(contractDescription)\n            is FirRawContractDescription -> render(contractDescription)\n            is FirResolvedContractDescription -> {\n                printer.println()\n                render(contractDescription)\n            }\n        }\n        printer.popIndent()\n    }\n\n    fun render(effectDeclaration: FirEffectDeclaration) {\n        printer.newLine()\n        printer.println(\"[Effect declaration] <\")\n        effectDeclaration.effect.accept(this, null)\n        printer.println()\n        printer.println(\">\")\n    }\n\n    internal fun render(legacyRawContractDescription: FirLegacyRawContractDescription) {\n        printer.renderInBra"}
{"code": "ces(\"<\", \">\") {\n            legacyRawContractDescription.contractCall.accept(visitor)\n            printer.newLine()\n        }\n    }\n\n    internal fun render(rawContractDescription: FirRawContractDescription) {\n        printer.renderInBraces(\"<\", \">\") {\n            printer.renderSeparatedWithNewlines(rawContractDescription.rawEffects, visitor)\n            printer.newLine()\n        }\n    }\n\n    internal fun render(resolvedContractDescription: FirResolvedContractDescription) {\n        printer.println(\" <\")\n        printer.pushIndent()\n        resolvedContractDescription.effects.forEach { declaration ->\n            declaration.effect.accept(this, null)\n            printer.println()\n        }\n        printer.popIndent()\n        printer.println(\">\")\n    }\n\n    override fun visitConditionalEffectDeclaration(conditionalEffect: KtConditionalEffectDeclaration<ConeKotlinType, ConeDiagnostic>, data: Nothing?) {\n        conditionalEffect.effect.accept(this, data)\n        printer.print(\" -> \")\n     "}
{"code": "   conditionalEffect.condition.accept(this, data)\n    }\n\n    override fun visitReturnsEffectDeclaration(returnsEffect: KtReturnsEffectDeclaration<ConeKotlinType, ConeDiagnostic>, data: Nothing?) {\n        printer.print(\"Returns(\")\n        returnsEffect.value.accept(this, data)\n        printer.print(\")\")\n    }\n\n    override fun visitCallsEffectDeclaration(callsEffect: KtCallsEffectDeclaration<ConeKotlinType, ConeDiagnostic>, data: Nothing?) {\n        printer.print(\"CallsInPlace(\")\n        callsEffect.valueParameterReference.accept(this, data)\n        printer.print(\", ${callsEffect.kind})\")\n    }\n\n    override fun visitLogicalBinaryOperationContractExpression(binaryLogicExpression: KtBinaryLogicExpression<ConeKotlinType, ConeDiagnostic>, data: Nothing?) {\n        inBracketsIfNecessary(binaryLogicExpression, binaryLogicExpression.left) { binaryLogicExpression.left.accept(this, data) }\n        printer.print(\" ${binaryLogicExpression.kind.token} \")\n        inBracketsIfNecessary(binaryLogicE"}
{"code": "xpression, binaryLogicExpression.right) { binaryLogicExpression.right.accept(this, data) }\n    }\n\n    override fun visitLogicalNot(logicalNot: KtLogicalNot<ConeKotlinType, ConeDiagnostic>, data: Nothing?) {\n        inBracketsIfNecessary(logicalNot, logicalNot.arg) { printer.print(\"!\") }\n        logicalNot.arg.accept(this, data)\n    }\n\n    override fun visitIsInstancePredicate(isInstancePredicate: KtIsInstancePredicate<ConeKotlinType, ConeDiagnostic>, data: Nothing?) {\n        isInstancePredicate.arg.accept(this, data)\n        printer.print(\" ${if (isInstancePredicate.isNegated) \"!\" else \"\"}is ${isInstancePredicate.type.renderForDebugging()}\")\n    }\n\n    override fun visitIsNullPredicate(isNullPredicate: KtIsNullPredicate<ConeKotlinType, ConeDiagnostic>, data: Nothing?) {\n        isNullPredicate.arg.accept(this, data)\n        printer.print(\" ${if (isNullPredicate.isNegated) \"!=\" else \"==\"} null\")\n    }\n\n    override fun visitConstantDescriptor(constantReference: KtConstantReference<Cone"}
{"code": "KotlinType, ConeDiagnostic>, data: Nothing?) {\n        printer.print(constantReference.name)\n    }\n\n    override fun visitValueParameterReference(valueParameterReference: KtValueParameterReference<ConeKotlinType, ConeDiagnostic>, data: Nothing?) {\n        printer.print(valueParameterReference.name)\n    }\n\n    private fun inBracketsIfNecessary(parent: KtContractDescriptionElement<ConeKotlinType, ConeDiagnostic>, child: KtContractDescriptionElement<ConeKotlinType, ConeDiagnostic>, block: () -> Unit) {\n        if (needsBrackets(parent, child)) {\n            printer.print(\"(\")\n            block()\n            printer.print(\")\")\n        } else {\n            block()\n        }\n    }\n\n    private fun KtContractDescriptionElement<ConeKotlinType, ConeDiagnostic>.isAtom(): Boolean =\n        this is KtValueParameterReference || this is KtConstantReference || this is KtIsNullPredicate || this is KtIsInstancePredicate\n\n    private fun needsBrackets(parent: KtContractDescriptionElement<ConeKotlinType,"}
{"code": " ConeDiagnostic>, child: KtContractDescriptionElement<ConeKotlinType, ConeDiagnostic>): Boolean {\n        if (child.isAtom()) return false\n        if (parent is KtLogicalNot) return true\n        return parent::class != child::class\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.optimization.temporaryVals\n\nimport org.jetbrains.kotlin.codegen.optimization.common.FastAnalyzer\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode\nimport org.jetbrains.org.objectweb.asm.tree.IincInsnNode\nimport org.jetbrains.org.objectweb.asm.tree.MethodNode\nimport org.jetbrains.org.objectweb.asm.tree.VarInsnNode\nimport org.jetbrains.org.objectweb.asm.tree.analysis.Frame\nimport org.jetbrains.org.objectweb.asm.tree.analysis.Interpreter\nimport org.jetbrains.org.objectweb.asm.tree.analysis.Value\n\nclass StoreLoadFrame<V : Value>(val maxLocals: Int) : Frame<V>(maxLocals, 0) {\n    override fun execute(insn: AbstractInsnNode, interpreter: Interpreter<V>) {\n        when (insn.opcode) {\n            in Opcodes.ISTORE..Opcodes.ASTORE -> {\n                val varInsn = insn as VarInsnNode\n                setLocal(varInsn.`var`, interpreter.copyOperation(varInsn, null))\n            }\n            in Opco"}
{"code": "des.ILOAD..Opcodes.ALOAD -> {\n                val varInsn = insn as VarInsnNode\n                interpreter.copyOperation(varInsn, this.getLocal(varInsn.`var`))\n            }\n            Opcodes.IINC -> {\n                val iincInsn = insn as IincInsnNode\n                interpreter.unaryOperation(iincInsn, this.getLocal(iincInsn.`var`))\n            }\n        }\n    }\n}\n\nclass FastStoreLoadAnalyzer<V : Value>(\n    owner: String,\n    method: MethodNode,\n    interpreter: Interpreter<V>,\n    newFrame: (Int, Int) -> StoreLoadFrame<V> = { nLocals, _ -> StoreLoadFrame(nLocals) }\n) : FastAnalyzer<V, StoreLoadFrame<V>>(\n    owner, method, interpreter,\n    pruneExceptionEdges = false,\n    useFastComputeExceptionHandlers = false,\n    useFastMergeControlFlowEdge = false,\n    newFrame\n)\n"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental.classpathDiff\n\nimport com.google.gson.GsonBuilder\nimport org.jetbrains.kotlin.buildtools.api.jvm.ClassSnapshotGranularity\nimport org.jetbrains.kotlin.cli.common.isWindows\nimport org.jetbrains.kotlin.incremental.classpathDiff.ClasspathSnapshotTestCommon.ClassFileUtil.snapshot\nimport org.jetbrains.kotlin.incremental.classpathDiff.ClasspathSnapshotTestCommon.CompileUtil.compile\nimport org.jetbrains.kotlin.incremental.classpathDiff.ClasspathSnapshotTestCommon.CompileUtil.compileAll\nimport org.jetbrains.kotlin.incremental.classpathDiff.ClasspathSnapshotTestCommon.SourceFile.KotlinSourceFile\nimport org.jetbrains.kotlin.incremental.storage.fromByteArray\nimport org.jetbrains.kotlin.incremental.storage.toByteArray\nimport org.jetbrains.kotlin.test.KotlinTestUtils\nimport org.junit.Rule\nimport org.junit.rules.TemporaryFolder\nimport java.io.File\nimport java.lang.ProcessBuilder.Redirect\n\nabstract class ClasspathSnapshotTestCommon {\n\n    @get:Rule\n    val tm"}
{"code": "pDir = TemporaryFolder()\n\n    // Use Gson to compare objects\n    private val gson by lazy { GsonBuilder().setPrettyPrinting().create() }\n    protected fun ClassSnapshot.toGson(): String = gson.toJson(\n        // Serialize and deserialize the object to unset lazy properties' values as they are not essential and can add noise when comparing\n        // objects\n        ClassSnapshotExternalizer.fromByteArray(ClassSnapshotExternalizer.toByteArray(this))\n    )\n\n    sealed class SourceFile(val baseDir: File, relativePath: String) {\n        val unixStyleRelativePath: String\n\n        init {\n            unixStyleRelativePath = relativePath.replace('\\\\', '/')\n        }\n\n        fun asFile() = File(baseDir, unixStyleRelativePath)\n\n        class KotlinSourceFile(baseDir: File, relativePath: String, val preCompiledClassFiles: List<ClassFile>) :\n            SourceFile(baseDir, relativePath) {\n\n            constructor(baseDir: File, relativePath: String, preCompiledClassFile: ClassFile) :\n            "}
{"code": "        this(baseDir, relativePath, listOf(preCompiledClassFile))\n        }\n\n        class JavaSourceFile(baseDir: File, relativePath: String) : SourceFile(baseDir, relativePath)\n    }\n\n    \n    open class TestSourceFile(val sourceFile: SourceFile, private val tmpDir: TemporaryFolder) {\n\n        fun asFile() = sourceFile.asFile()\n\n        \n        @Suppress(\"MemberVisibilityCanBePrivate\")\n        fun compile(): List<ClassFile> = sourceFile.compile(tmpDir)\n\n        fun compileSingle(): ClassFile = compile().single()\n\n        fun compileAndSnapshot() = compileSingle().snapshot()\n    }\n\n    object CompileUtil {\n\n        fun SourceFile.compile(tmpDir: TemporaryFolder): List<ClassFile> {\n            return if (this is KotlinSourceFile) {\n                preCompiledClassFiles.forEach {\n                    compileKotlin(srcDir = baseDir, classesDir = it.classRoot, classpath = emptyList())\n                }\n                preCompiledClassFiles\n            } else {\n                val srcDir ="}
{"code": " tmpDir.newFolder()\n                asFile().copyTo(File(srcDir, unixStyleRelativePath))\n                compileAll(srcDir, tmpDir)\n            }\n        }\n\n        \n        fun compileAll(srcDir: File, tmpDir: TemporaryFolder, classpath: List<File> = emptyList()): List<ClassFile> {\n            val classesDir = srcDir.path.let {\n                File(it.substringBeforeLast(\"src\") + \"classes\" + it.substringAfterLast(\"src\"))\n            }\n            val kotlinClasses = compileKotlin(srcDir, classesDir, classpath)\n\n            val javaClasspath = classpath + listOfNotNull(kotlinClasses.firstOrNull()?.classRoot)\n            val javaClasses = compileJava(srcDir, classesDir = tmpDir.newFolder(), javaClasspath)\n\n            return kotlinClasses + javaClasses\n        }\n\n        \n        private const val GENERATE_KOTLIN_CLASS_FILES = false\n\n        private val alreadyCompiledKotlinSrcDirs = mutableSetOf<File>()\n\n        private fun compileKotlin(srcDir: File, classesDir: File, classpath: List<"}
{"code": "File>): List<ClassFile> {\n            if (GENERATE_KOTLIN_CLASS_FILES) {\n                // This block may be called concurrently so add this synchronization to be safe\n                synchronized(alreadyCompiledKotlinSrcDirs) {\n                    if (!alreadyCompiledKotlinSrcDirs.contains(srcDir)) {\n                        doCompileKotlin(srcDir, classesDir, classpath)\n                        alreadyCompiledKotlinSrcDirs.add(srcDir)\n                    }\n                }\n            }\n            return getClassFilesInDir(classesDir)\n        }\n\n        private fun doCompileKotlin(srcDir: File, classesDir: File, classpath: List<File>) {\n            classesDir.deleteRecursively()\n            classesDir.mkdirs()\n            if (srcDir.walk().none { it.path.endsWith(\".kt\") }) {\n                return\n            }\n\n            // Note: Calling the following is simpler:\n            //     org.jetbrains.kotlin.test.MockLibraryUtil.compileKotlin(\n            //         srcDir.path, classe"}
{"code": "sDir, extraClasspath = classpath.map { it.path }.toTypedArray())\n            // However, it currently fails with UnsupportedClassVersionError, so we have to launch a new kotlinc process instead.\n            val kotlincBinary = if (isWindows) \"dist/kotlinc/bin/kotlinc.bat\" else \"dist/kotlinc/bin/kotlinc\"\n            check(File(kotlincBinary).exists()) { \"'${File(kotlincBinary).absolutePath}' not found. Run ./gradlew dist first.\" }\n            val commandAndArgs = listOf(\n                kotlincBinary,\n                srcDir.path,\n                \"-d\", classesDir.path,\n                \"-classpath\", (listOf(srcDir) + classpath).joinToString(File.pathSeparator) { it.path }\n            )\n            runCommandInNewProcess(commandAndArgs)\n\n            classesDir.resolve(\"META-INF\").deleteRecursively()\n        }\n\n        private fun compileJava(srcDir: File, classesDir: File, classpath: List<File>): List<ClassFile> {\n            doCompileJava(srcDir, classesDir, classpath)\n            return "}
{"code": "getClassFilesInDir(classesDir)\n        }\n\n        private fun doCompileJava(srcDir: File, classesDir: File, classpath: List<File>) {\n            classesDir.deleteRecursively()\n            classesDir.mkdirs()\n            val javaFiles = srcDir.walk().toList().filter { it.path.endsWith(\".java\") }\n            if (javaFiles.isEmpty()) {\n                return\n            }\n\n            val classpathOption =\n                if (classpath.isNotEmpty()) listOf(\"-classpath\", classpath.joinToString(File.pathSeparator)) else emptyList()\n            KotlinTestUtils.compileJavaFiles(javaFiles, listOf(\"-d\", classesDir.path) + classpathOption)\n        }\n\n        private fun getClassFilesInDir(classesDir: File): List<ClassFile> {\n            return classesDir.walk().toList()\n                .filter { it.isFile && it.path.endsWith(\".class\") }\n                .map { ClassFile(classesDir, it.toRelativeString(classesDir)) }\n                .sortedBy { it.unixStyleRelativePath.substringBefore(\".class\") }\n"}
{"code": "        }\n    }\n\n    object ClassFileUtil {\n\n        // `ClassFile`s in production code could be in a jar, but the `ClassFile`s in tests are currently in a directory, so converting it\n        // to a File is possible.\n        fun ClassFile.asFile() = File(classRoot, unixStyleRelativePath)\n\n        fun ClassFile.readBytes() = asFile().readBytes()\n\n        fun ClassFile.snapshot(granularity: ClassSnapshotGranularity? = null): ClassSnapshot = listOf(this).snapshot(granularity).single()\n\n        fun List<ClassFile>.snapshot(granularity: ClassSnapshotGranularity? = null): List<ClassSnapshot> {\n            val classes = map { ClassFileWithContentsProvider(it) { it.readBytes() } }\n            return ClassSnapshotter.snapshot(classes, granularity ?: ClassSnapshotGranularity.CLASS_MEMBER_LEVEL)\n        }\n    }\n}\n\ninternal fun snapshotClasspath(\n    classpathSourceDir: File,\n    tmpDir: TemporaryFolder,\n    granularity: ClassSnapshotGranularity? = null\n): ClasspathSnapshot {\n    val classpath = "}
{"code": "mutableListOf<File>()\n    val classpathEntrySourceDirs = if (classpathSourceDir.listFiles()!!.size == 1) {\n        listOf(classpathSourceDir)\n    } else {\n        classpathSourceDir.listFiles()!!.sortedBy { it.name }\n    }\n    val classpathEntrySnapshots = classpathEntrySourceDirs.map { classpathEntrySourceDir ->\n        val classFiles = compileAll(classpathEntrySourceDir, tmpDir, classpath)\n        classpath.addAll(listOfNotNull(classFiles.firstOrNull()?.classRoot))\n\n        val relativePaths = classFiles.map { it.unixStyleRelativePath }\n        val classSnapshots = classFiles.snapshot(granularity)\n        ClasspathEntrySnapshot(\n            classSnapshots = relativePaths.zip(classSnapshots).toMap(LinkedHashMap())\n        )\n    }\n    return ClasspathSnapshot(classpathEntrySnapshots)\n}\n\nprivate fun runCommandInNewProcess(commandAndArgs: List<String>) {\n    val processBuilder = ProcessBuilder(commandAndArgs)\n    processBuilder.redirectInput(Redirect.INHERIT)\n    processBuilder.redirectO"}
{"code": "utput(Redirect.INHERIT)\n    processBuilder.redirectErrorStream(true)\n    val process = processBuilder.start()\n\n    val exitCode = try {\n        process.waitFor()\n    } finally {\n        process.destroyForcibly()\n    }\n    check(exitCode == 0) {\n        \"Process returned exit code: $exitCode\\n\" +\n                \"commandAndArgs = ${commandAndArgs.joinToString(\" \")}\"\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.resolve.jvm.checkers\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.builtins.KotlinBuiltIns\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.descriptors.CallableDescriptor\nimport org.jetbrains.kotlin.descriptors.FunctionDescriptor\nimport org.jetbrains.kotlin.descriptors.PackageFragmentDescriptor\nimport org.jetbrains.kotlin.psi.KtPsiUtil\nimport org.jetbrains.kotlin.resolve.calls.checkers.CallChecker\nimport org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm\nimport org.jetbrains.kotlin.resolve.jvm.getCompileTimeConstant\n\nobject ApiVersionIsAtLeastArgumentsChecker : CallChecker {\n    override fun check(resolvedCall: ResolvedCall<*>, reportOn: PsiElement, context: CallCheckerContext) {\n        if (!isApiVersionIsAtLeast(resolvedCall.resultingDescriptor)) return\n\n        val binding"}
{"code": "Context = context.trace.bindingContext\n        val shouldInlineConstVals = context.languageVersionSettings.supportsFeature(LanguageFeature.InlineConstVals)\n\n        for ((_, resolvedValueArgument) in resolvedCall.valueArguments) {\n            for (valueArgument in resolvedValueArgument.arguments) {\n                val ktExpression =  KtPsiUtil.deparenthesize(valueArgument.getArgumentExpression() ?: continue) ?: continue\n\n                val constant = getCompileTimeConstant(ktExpression, bindingContext, false, shouldInlineConstVals)\n                if (constant == null) {\n                    context.trace.report(ErrorsJvm.API_VERSION_IS_AT_LEAST_ARGUMENT_SHOULD_BE_CONSTANT.on(ktExpression))\n                }\n            }\n        }\n    }\n\n    private fun isApiVersionIsAtLeast(descriptor: CallableDescriptor): Boolean {\n        val functionDescriptor = descriptor as? FunctionDescriptor ?: return false\n\n        if (functionDescriptor.name.asString() != \"apiVersionIsAtLeast\") return false\n"}
{"code": "\n        val returnType = functionDescriptor.returnType ?: return false\n        if (!KotlinBuiltIns.isBoolean(returnType)) return false\n\n        if (!functionDescriptor.valueParameters.all { KotlinBuiltIns.isInt(it.type) }) return false\n\n        val containingPackage = functionDescriptor.containingDeclaration as? PackageFragmentDescriptor ?: return false\n        return containingPackage.fqName.asString() == \"kotlin.internal\"\n    }\n}"}
{"code": "// ISSUE: KT-41984\n\n// FILE: A.java\n\nimport org.jetbrains.annotations.NotNull;\n\npublic abstract class A<T, V> {\n    @NotNull\n    public abstract String take(@NotNull V value);\n\n    @NotNull\n    public abstract String takeInv(@NotNull Inv<@NotNull V> value);\n}\n\n// FILE: main.kt\n\nclass Inv<T>\n\nopen <!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class B<!><V> : A<Any, V>() {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun take(value: V): String {\n        return \"\"\n    }\n\n    <!NOTHING_TO_OVERRIDE!>override<!> fun takeInv(value: Inv<V>): String = \"\"\n}\n\nfun test_1(b: B<Int>, x: Int, inv: Inv<Int>) {\n    b.<!OVERLOAD_RESOLUTION_AMBIGUITY!>take<!>(x)\n    b.<!NONE_APPLICABLE!>take<!>(null)\n    b.<!OVERLOAD_RESOLUTION_AMBIGUITY!>takeInv<!>(inv)\n}\n"}
{"code": "// DECLARATION_TYPE: org.jetbrains.kotlin.psi.KtFunction\n\n@Y\nfun fn() {\n}\n\nannotation class Y\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirConstructor\nimport org.jetbrains.kotlin.fir.declarations.FirRegularClass\nimport org.jetbrains.kotlin.fir.declarations.utils.isEnumClass\n\nobject FirDelegationSuperCallInEnumConstructorChecker : FirRegularClassChecker(MppCheckerKind.Common) {\n    override fun check(declaration: FirRegularClass, context: CheckerContext, reporter: DiagnosticReporter) {\n        if (!declaration.isEnumClass) {\n            return\n        }\n\n        for (it in declaration.declarations) {\n            if (\n                it is FirConstructor && "}
{"code": "!it.isPrimary &&\n                it.delegatedConstructor?.isThis == false &&\n                it.delegatedConstructor?.source?.kind !is KtFakeSourceElementKind\n            ) {\n                reporter.reportOn(it.delegatedConstructor?.source, FirErrors.DELEGATION_SUPER_CALL_IN_ENUM_CONSTRUCTOR, context)\n            }\n        }\n    }\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.fir.visitors.FirVisitorVoid\n\n\ninterface FirElement {\n    val source: KtSourceElement?\n\n    \n    fun <R, D> accept(visitor: FirVisitor<R, D>, data: D): R =\n        visitor.visitElement(this, data)\n\n    \n    @Suppress(\"UNCHECKED_CAST\")\n    fun <E : FirElement, D> transform(transformer: FirTransformer<D>, data: D): E =\n        transformer.transformElement(this, data) as E\n\n    \n    fun accept(visitor: FirVisitorVoid) = accept(visitor, null)\n\n    \n    fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D)\n\n    \n    fun acceptChildren(visitor: FirVisitorVoid) = acceptChildren(visitor, null)\n\n    \n    fun <D> transformChildren(transformer: FirTransformer"}
{"code": "<D>, data: D): FirElement\n}\n"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\")\n\npackage org.jetbrains.kotlin.fir.expressions.impl\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirBlock\nimport org.jetbrains.kotlin.fir.expressions.FirStatement\nimport org.jetbrains.kotlin.fir.expressions.UnresolvedExpressionTypeAccess\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\n\nclass FirEmptyExpressionBlock : FirBlock() {\n    override val source: KtSourceElement?\n        get() = null\n    @OptIn(UnresolvedExpressionTypeAccess::class)\n    override var coneTypeOrNull: ConeKotlinType? = null\n    override val annotations: List<FirAnnotation>\n        get() = emptyList()\n    override val statements: List<FirStatement>\n   "}
{"code": "     get() = emptyList()\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {}\n\n    override fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirEmptyExpressionBlock {\n        transformOtherChildren(transformer, data)\n        return this\n    }\n\n    override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirEmptyExpressionBlock {\n        return this\n    }\n\n    override fun <D> transformStatements(transformer: FirTransformer<D>, data: D): FirEmptyExpressionBlock {\n        return this\n    }\n\n    override fun <D> transformOtherChildren(transformer: FirTransformer<D>, data: D): FirEmptyExpressionBlock {\n        return this\n    }\n\n    override fun replaceConeTypeOrNull(newConeTypeOrNull: ConeKotlinType?) {\n        coneTypeOrNull = newConeTypeOrNull\n    }\n\n    override fun replaceAnnotations(newAnnotations: List<FirAnnotation>) {}\n}\n"}
{"code": "\n\n\npackage org.jetbrains.kotlin.analysis.api.standalone.fir.test.cases.session.builder\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisApiInternals\nimport org.jetbrains.kotlin.analysis.api.analyze\nimport org.jetbrains.kotlin.analysis.api.annotations.annotations\nimport org.jetbrains.kotlin.analysis.api.calls.KtSuccessCallInfo\nimport org.jetbrains.kotlin.analysis.api.calls.successfulFunctionCallOrNull\nimport org.jetbrains.kotlin.analysis.api.calls.symbol\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeTokenProvider\nimport org.jetbrains.kotlin.analysis.api.standalone.KtAlwaysAccessibleLifetimeTokenProvider\nimport org.jetbrains.kotlin.analysis.api.standalone.buildStandaloneAnalysisAPISession\nimport org.jetbrains.kotlin.analysis.api.symbols.KtConstructorSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtFunctionSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtLocalVariableSymbol\nimport org.jetbrains.kotlin.analysis.api.types.KtNonErrorClassType\nimport org.jet"}
{"code": "brains.kotlin.analysis.project.structure.KtDanglingFileModule\nimport org.jetbrains.kotlin.analysis.project.structure.KtSourceModule\nimport org.jetbrains.kotlin.analysis.project.structure.ProjectStructureProvider\nimport org.jetbrains.kotlin.analysis.project.structure.builder.buildKtLibraryModule\nimport org.jetbrains.kotlin.analysis.project.structure.builder.buildKtSdkModule\nimport org.jetbrains.kotlin.analysis.project.structure.builder.buildKtSourceModule\nimport org.jetbrains.kotlin.analysis.test.framework.TestWithDisposable\nimport org.jetbrains.kotlin.analysis.utils.errors.requireIsInstance\nimport org.jetbrains.kotlin.idea.references.mainReference\nimport org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.platform.CommonPlatforms\nimport org.jetbrains.kotlin.platform.jvm.JvmPlatforms\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.psi.psiUtil."}
{"code": "findDescendantOfType\nimport org.junit.jupiter.api.Assertions\nimport org.junit.jupiter.api.Test\nimport java.nio.file.Paths\nimport kotlin.test.assertEquals\n\n@OptIn(KtAnalysisApiInternals::class)\nclass StandaloneSessionBuilderTest : TestWithDisposable() {\n    @Test\n    fun testJdkSessionBuilder() {\n        lateinit var sourceModule: KtSourceModule\n        val session = buildStandaloneAnalysisAPISession(disposable) {\n            registerProjectService(KtLifetimeTokenProvider::class.java, KtAlwaysAccessibleLifetimeTokenProvider())\n\n            buildKtModuleProvider {\n                platform = JvmPlatforms.defaultJvmPlatform\n                val sdk = addModule(\n                    buildKtSdkModule {\n                        addBinaryRootsFromJdkHome(Paths.get(System.getProperty(\"java.home\")), isJre = true)\n                        addBinaryRootsFromJdkHome(Paths.get(System.getProperty(\"java.home\")), isJre = false)\n                        platform = JvmPlatforms.defaultJvmPlatform\n            "}
{"code": "            sdkName = \"JDK\"\n                    }\n                )\n                sourceModule = addModule(\n                    buildKtSourceModule {\n                        addSourceRoot(testDataPath(\"jdkClassUsage\"))\n                        addRegularDependency(sdk)\n                        platform = JvmPlatforms.defaultJvmPlatform\n                        moduleName = \"source\"\n                    }\n                )\n            }\n        }\n        val ktFile = session.modulesWithFiles.getValue(sourceModule).single() as KtFile\n        analyze(ktFile) {\n            val ktCallExpression = ktFile.findDescendantOfType<KtCallExpression>()!!\n            val ktCallInfo = ktCallExpression.resolveCall()\n            Assertions.assertInstanceOf(KtSuccessCallInfo::class.java, ktCallInfo); ktCallInfo as KtSuccessCallInfo\n            val symbol = ktCallInfo.successfulFunctionCallOrNull()?.symbol\n            Assertions.assertInstanceOf(KtConstructorSymbol::class.java, symbol); symbol as KtConstruc"}
{"code": "torSymbol\n            Assertions.assertEquals(ClassId.topLevel(FqName(\"java.lang.Thread\")), symbol.containingClassIdIfNonLocal)\n        }\n    }\n\n    @Test\n    fun testJvmInlineOnCommon() {\n        // Example from https://youtrack.jetbrains.com/issue/KT-55085\n        val root = \"jvmInlineOnCommon\"\n        lateinit var sourceModule: KtSourceModule\n        val session = buildStandaloneAnalysisAPISession(disposable) {\n            registerProjectService(KtLifetimeTokenProvider::class.java, KtAlwaysAccessibleLifetimeTokenProvider())\n\n            buildKtModuleProvider {\n                platform = CommonPlatforms.defaultCommonPlatform\n                val stdlib = addModule(\n                    buildKtLibraryModule {\n                        addBinaryRoot(Paths.get(\"dist/common/kotlin-stdlib-common.jar\"))\n                        platform = CommonPlatforms.defaultCommonPlatform\n                        libraryName = \"stdlib\"\n                    }\n                )\n                val commonModule "}
{"code": "= addModule(\n                    buildKtSourceModule {\n                        addSourceRoot(testDataPath(root).resolve(\"commonMain\"))\n                        addRegularDependency(stdlib)\n                        platform = CommonPlatforms.defaultCommonPlatform\n                        moduleName = \"common\"\n                    }\n                )\n                sourceModule = addModule(\n                    buildKtSourceModule {\n                        addSourceRoot(testDataPath(root).resolve(\"androidMain\"))\n                        addDependsOnDependency(commonModule)\n                        platform = JvmPlatforms.defaultJvmPlatform\n                        moduleName = \"android\"\n                    }\n                )\n            }\n        }\n        val ktFile = session.modulesWithFiles.getValue(sourceModule).single() as KtFile\n\n        // Test dependsOn dependency: expect in the common module, actual \"typealias\" in the platform-specific module\n        val testFunction = ktFile.findDesc"}
{"code": "endantOfType<KtFunction>()!!\n        val localVariable = testFunction.findDescendantOfType<KtProperty>()!!\n        analyze(localVariable) {\n            val localVariableSymbol = localVariable.getVariableSymbol()\n            val type = localVariableSymbol.returnType as KtNonErrorClassType\n            Assertions.assertEquals(\n                ClassId(FqName(\"test.pkg\"), FqName(\"NativePointerKeyboardModifiers\"), isLocal = false),\n                type.classId\n            )\n            // expanded to `actual` `typealias`\n            val expandedType = type.fullyExpandedType\n            Assertions.assertTrue(expandedType.isInt)\n        }\n\n        // Test stdlib-common: @JvmInline in the common module\n        val actualClass = ktFile.findDescendantOfType<KtClassOrObject>()!!\n        val actualProperty = actualClass.findDescendantOfType<KtProperty>()!!\n        analyze(actualProperty) {\n            val symbol = actualProperty.getVariableSymbol()\n            val type = symbol.returnType as KtNonE"}
{"code": "rrorClassType\n            Assertions.assertEquals(\n                ClassId.fromString(\"kotlin/jvm/JvmInline\"),\n                type.classSymbol.annotations.single().classId\n            )\n        }\n    }\n\n    @Test\n    fun testResolveAgainstCommonKlib() {\n        val root = \"resolveAgainstCommonKLib\"\n        lateinit var sourceModule: KtSourceModule\n        val session = buildStandaloneAnalysisAPISession(disposable) {\n            registerProjectService(KtLifetimeTokenProvider::class.java, KtAlwaysAccessibleLifetimeTokenProvider())\n\n            buildKtModuleProvider {\n                platform = CommonPlatforms.defaultCommonPlatform\n                val kLib = addModule(\n                    buildKtLibraryModule {\n                        val compiledKLibRoot = compileCommonKlib(testDataPath(root).resolve(\"klibSrc\"))\n                        addBinaryRoot(compiledKLibRoot)\n                        platform = CommonPlatforms.defaultCommonPlatform\n                        libraryName = \"klib\"\n   "}
{"code": "                 }\n                )\n                sourceModule = addModule(\n                    buildKtSourceModule {\n                        addSourceRoot(testDataPath(root).resolve(\"src\"))\n                        addRegularDependency(kLib)\n                        platform = CommonPlatforms.defaultCommonPlatform\n                        moduleName = \"source\"\n                    }\n                )\n            }\n        }\n        val ktFile = session.modulesWithFiles.getValue(sourceModule).single() as KtFile\n\n        val ktCallExpression = ktFile.findDescendantOfType<KtCallExpression>()!!\n        ktCallExpression.assertIsCallOf(CallableId(FqName(\"commonKLib\"), Name.identifier(\"commonKLibFunction\")))\n    }\n\n    @Test\n    fun testResolveAgainstCommonKlibFromOtherModule() {\n        val root = \"resolveAgainstCommonKLibFromOtherModule\"\n        lateinit var commonModule: KtSourceModule\n        lateinit var sourceModule: KtSourceModule\n        val session = buildStandaloneAnalysisAPISession"}
{"code": "(disposable) {\n            registerProjectService(KtLifetimeTokenProvider::class.java, KtAlwaysAccessibleLifetimeTokenProvider())\n\n            buildKtModuleProvider {\n                platform = CommonPlatforms.defaultCommonPlatform\n                val kLib = addModule(\n                    buildKtLibraryModule {\n                        val compiledKLibRoot = compileCommonKlib(testDataPath(root).resolve(\"klibSrc\"))\n                        addBinaryRoot(compiledKLibRoot)\n                        platform = CommonPlatforms.defaultCommonPlatform\n                        libraryName = \"klib\"\n                    }\n                )\n                commonModule = addModule(\n                    buildKtSourceModule {\n                        addSourceRoot(testDataPath(root).resolve(\"commonMain\"))\n                        addRegularDependency(kLib)\n                        platform = CommonPlatforms.defaultCommonPlatform\n                        moduleName = \"common\"\n                    }\n             "}
{"code": "   )\n                sourceModule = addModule(\n                    buildKtSourceModule {\n                        addSourceRoot(testDataPath(root).resolve(\"jvmMain\"))\n                        addRegularDependency(kLib)\n                        addRegularDependency(commonModule)\n                        platform = JvmPlatforms.defaultJvmPlatform\n                        moduleName = \"app\"\n                    }\n                )\n            }\n        }\n\n        val ktFileInCommon = session.modulesWithFiles.getValue(commonModule).single() as KtFile\n        val callInCommon = ktFileInCommon.findDescendantOfType<KtCallExpression>()!!\n        callInCommon.assertIsCallOf(CallableId(FqName(\"some.example\"), FqName(\"Person\"), Name.identifier(\"greet\")))\n\n        val ktFileInJvm = session.modulesWithFiles.getValue(sourceModule).single() as KtFile\n        val callInJvm = ktFileInJvm.findDescendantOfType<KtCallExpression>()!!\n        callInJvm.assertIsCallOf(CallableId(FqName(\"common\"), Name.identifier(\""}
{"code": "greetEachOther\")))\n    }\n\n    @Test\n    fun testKotlinSourceModuleSessionBuilder() {\n        val root = \"otherModuleUsage\"\n        lateinit var sourceModule: KtSourceModule\n        val session = buildStandaloneAnalysisAPISession(disposable) {\n            registerProjectService(KtLifetimeTokenProvider::class.java, KtAlwaysAccessibleLifetimeTokenProvider())\n\n            buildKtModuleProvider {\n                platform = JvmPlatforms.defaultJvmPlatform\n                val main = addModule(\n                    buildKtSourceModule {\n                        addSourceRoot(testDataPath(root).resolve(\"dependent\"))\n                        platform = JvmPlatforms.defaultJvmPlatform\n                        moduleName = \"dependent\"\n                    }\n                )\n                sourceModule = addModule(\n                    buildKtSourceModule {\n                        addSourceRoot(testDataPath(root).resolve(\"main\"))\n                        addRegularDependency(main)\n                      "}
{"code": "  platform = JvmPlatforms.defaultJvmPlatform\n                        moduleName = \"main\"\n                    }\n                )\n            }\n        }\n        val ktFile = session.modulesWithFiles.getValue(sourceModule).single() as KtFile\n        val ktCallExpression = ktFile.findDescendantOfType<KtCallExpression>()!!\n        ktCallExpression.assertIsCallOf(CallableId(FqName.ROOT, Name.identifier(\"foo\")))\n\n        assertEquals(\"main\", sourceModule.moduleName)\n        assertEquals(sourceModule.moduleName, sourceModule.stableModuleName)\n    }\n\n    @Test\n    fun testKotlinSourceModuleSessionWithVirtualFile() {\n        val root = \"otherModuleUsage\"\n        lateinit var sourceModule: KtSourceModule\n        val session = buildStandaloneAnalysisAPISession(disposable) {\n            registerProjectService(KtLifetimeTokenProvider::class.java, KtAlwaysAccessibleLifetimeTokenProvider())\n\n            buildKtModuleProvider {\n                platform = JvmPlatforms.defaultJvmPlatform\n              "}
{"code": "  val dep = addModule(\n                    buildKtSourceModule {\n                        addSourceRoot(testDataPath(root).resolve(\"dependent\"))\n                        platform = JvmPlatforms.defaultJvmPlatform\n                        moduleName = \"dependent\"\n                    }\n                )\n                sourceModule = addModule(\n                    buildKtSourceModule {\n                        // addSourceRoot(testDataPath(root).resolve(\"main\"))\n                        // Instead, add [VirtualFile] on-the-fly\n                        val virtualFile = createDumbVirtualFile(\n                            project,\n                            \"test.kt\",\n                            \"\"\"\n                                fun main() {\n                                    foo()\n                                }\n                            \"\"\".trimIndent()\n                        )\n                        addSourceVirtualFile(virtualFile)\n                        addRegularDependency(dep)\n "}
{"code": "                       platform = JvmPlatforms.defaultJvmPlatform\n                        moduleName = \"main\"\n                    }\n                )\n            }\n        }\n        val ktFile = session.modulesWithFiles.getValue(sourceModule).single() as KtFile\n        val ktCallExpression = ktFile.findDescendantOfType<KtCallExpression>()!!\n        ktCallExpression.assertIsCallOf(CallableId(FqName.ROOT, Name.identifier(\"foo\")))\n    }\n\n    @Test\n    fun testCodeFragment() {\n        val root = \"codeFragment\"\n\n        lateinit var contextModule: KtSourceModule\n        val session = buildStandaloneAnalysisAPISession(disposable) {\n            registerProjectService(KtLifetimeTokenProvider::class.java, KtAlwaysAccessibleLifetimeTokenProvider())\n\n            buildKtModuleProvider {\n                platform = JvmPlatforms.defaultJvmPlatform\n                contextModule = addModule(\n                    buildKtSourceModule {\n                        addSourceRoot(testDataPath(root))\n            "}
{"code": "            platform = JvmPlatforms.defaultJvmPlatform\n                        moduleName = \"context\"\n                    }\n                )\n            }\n        }\n\n        val contextFile = session.modulesWithFiles.getValue(contextModule).single() as KtFile\n        val contextElement = contextFile.findDescendantOfType<KtVariableDeclaration> { it.name == \"y\" }!!\n\n        val project = contextFile.project\n        val codeFragment = KtExpressionCodeFragment(project, \"fragment.kt\", \"x - 1\", imports = null, contextElement)\n\n        val codeFragmentModule = ProjectStructureProvider.getModule(project, codeFragment, contextualModule = contextModule)\n        requireIsInstance<KtDanglingFileModule>(codeFragmentModule)\n        assertEquals(codeFragmentModule.contextModule, contextModule)\n\n        analyze(codeFragment) {\n            val fileSymbol = codeFragment.getFileSymbol()\n            assertEquals(fileSymbol.getContainingModule(), codeFragmentModule)\n\n            val referenceExpression = "}
{"code": "codeFragment.findDescendantOfType<KtSimpleNameExpression> { it.text == \"x\" }!!\n            val variableSymbol = referenceExpression.mainReference.resolveToSymbol()\n            assert(variableSymbol is KtLocalVariableSymbol)\n        }\n    }\n\n    @Test\n    fun testNonPhysicalFile() {\n        val root = \"nonPhysicalFile\"\n\n        lateinit var contextModule: KtSourceModule\n        val session = buildStandaloneAnalysisAPISession(disposable) {\n            registerProjectService(KtLifetimeTokenProvider::class.java, KtAlwaysAccessibleLifetimeTokenProvider())\n\n            buildKtModuleProvider {\n                platform = JvmPlatforms.defaultJvmPlatform\n                contextModule = addModule(\n                    buildKtSourceModule {\n                        addSourceRoot(testDataPath(root))\n                        platform = JvmPlatforms.defaultJvmPlatform\n                        moduleName = \"context\"\n                    }\n                )\n            }\n        }\n\n        val contextFile ="}
{"code": " session.modulesWithFiles.getValue(contextModule).single() as KtFile\n\n        val project = contextFile.project\n\n        val dummyFile = KtPsiFactory\n            .contextual(contextFile, markGenerated = false, eventSystemEnabled = false)\n            .createFile(\"dummy.kt\", \"fun usage() { test() }\")\n\n        assert(dummyFile.virtualFile == null)\n\n        val dummyModule = ProjectStructureProvider.getModule(project, dummyFile, contextualModule = null)\n        requireIsInstance<KtDanglingFileModule>(dummyModule)\n        assertEquals(dummyModule.contextModule, contextModule)\n\n        analyze(dummyFile) {\n            val fileSymbol = dummyFile.getFileSymbol()\n            assertEquals(fileSymbol.getContainingModule(), dummyModule)\n\n            val callExpression = dummyFile.findDescendantOfType<KtCallExpression>()!!\n            val call = callExpression.resolveCall()?.successfulFunctionCallOrNull() ?: error(\"Call inside a dummy file is unresolved\")\n            assert(call.symbol is KtFunctio"}
{"code": "nSymbol)\n        }\n    }\n}"}
{"code": "annotation class Annotation(vararg val values: String)\n\n@Annotation(<expr>\"42\"</expr>)\nclass C\n"}
{"code": "class C {\n    <expr>typealias Local<T> = List<T></expr>\n}"}
{"code": "package a.b.c.<expr>e</expr>\n"}
{"code": "// MODULE: lib\n// FILE: lib.kt\n\npackage lib\n\nfun lib(a: Int = 5): String {\n    return \"$a\"\n}\n\n// MODULE: main(lib)\n// FILE: main.kt\n\nimport lib.lib\n\nfun test() {\n    <caret>lib()\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.light.classes.symbol\n\nimport com.intellij.psi.JavaPsiFacade\nimport com.intellij.psi.PsiElement\nimport com.intellij.psi.ResolveState\nimport com.intellij.psi.scope.PsiScopeProcessor\nimport org.jetbrains.kotlin.asJava.classes.KtLightClass\nimport org.jetbrains.kotlin.asJava.elements.FakeFileForLightClass\nimport org.jetbrains.kotlin.psi.KtClassOrObject\n\ninternal class SymbolFakeFile(classOrObject: KtClassOrObject, ktClass: KtLightClass) : FakeFileForLightClass(\n    classOrObject.containingKtFile,\n    ktClass,\n) {\n    override fun findReferenceAt(offset: Int) = ktFile.findReferenceAt(offset)\n\n    override fun processDeclarations(\n        processor: PsiScopeProcessor,\n        state: ResolveState,\n        lastParent: PsiElement?,\n        place: PsiElement\n    ): Boolean {\n        if (!super.processDeclarations(processor, state, lastParent, place)) return false\n\n        // We have to explicitly process package declarations if current file belongs to default packag"}
{"code": "e\n        // so that Java resolve can find classes located in that package\n        val packageName = packageName\n        if (packageName.isNotEmpty()) return true\n        val aPackage = JavaPsiFacade.getInstance(project).findPackage(packageName)\n        if (aPackage != null && !aPackage.processDeclarations(processor, state, null, place)) return false\n\n        return true\n    }\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators\n\nimport com.intellij.openapi.Disposable\nimport org.jetbrains.kotlin.analysis.api.impl.base.test.configurators.AnalysisApiLibraryBaseTestServiceRegistrar\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModuleFactory\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtSourceTestModuleFactory\nimport org.jetbrains.kotlin.analysis.test.framework.services.DependencyKindModuleStructureTransformer\nimport org.jetbrains.kotlin.analysis.test.framework.test.configurators.AnalysisApiTestServiceRegistrar\nimport org.jetbrains.kotlin.test.TestInfrastructureInternals\nimport org.jetbrains.kotlin.test.builders.TestConfigurationBuilder\n\nopen class AnalysisApiFirSourceTestConfigurator(\n    analyseInDependentSession: Boolean\n) : AnalysisApiFirSourceLikeTestConfigurator(analyseInDependentSession) {\n    override fun configureTest(builder: TestConfigurationBuilder, disposable: Disposable"}
{"code": ") {\n        super.configureTest(builder, disposable)\n\n        builder.apply {\n            useAdditionalService<KtTestModuleFactory> { KtSourceTestModuleFactory }\n\n            @OptIn(TestInfrastructureInternals::class)\n            useModuleStructureTransformers(DependencyKindModuleStructureTransformer)\n        }\n\n        AnalysisApiFirLibraryBinaryDecompiledTestConfigurator.configureLibraryCompilationSupport(builder)\n    }\n\n    override val serviceRegistrars: List<AnalysisApiTestServiceRegistrar>\n        get() = super.serviceRegistrars + AnalysisApiLibraryBaseTestServiceRegistrar\n}\n"}
{"code": "val p : Double = <expr>3.14</expr>\n"}
{"code": "abstract class A<X : CharSequence> {\n    inner class Inner\n    fun foo(x: Inner.() -> Unit) {}\n}\n\nobject B : A<String>() {\n\n    fun bar() {\n        val y: Inner.() -> Unit = {}\n        foo(y)\n        baz(y)\n    }\n}\n\nfun baz(x: (A<String>.Inner) -> Unit) {}\n"}
{"code": "// FILE: main.kt\n\n\nfun foo<caret>(): a.b.c.dependency.Foo = t\n\n// FILE: dependency.kt\npackage a.b.c.dependency\n\nclass Foo {\n    class Nested\n}\n"}
{"code": "class Foo {\n  operator fun invoke(vararg a: Any) {}\n}\n\nfun test(f: Foo) {\n  f(1<caret>)\n}\n"}
{"code": "interface Foo\nclass FooImpl : Foo\nclass Bar\n\nfun <T : Foo> foo(t: T) = t\n\n\nfun main(fooImpl: FooImpl, bar: Bar) {\n    val a = foo(fooImpl)\n    val b = <!CANNOT_INFER_PARAMETER_TYPE!>foo<!>(<!ARGUMENT_TYPE_MISMATCH!>bar<!>)\n}\n"}
{"code": "package test\n\nclass Foo<F> {\n    inner class Bar<B> {\n        fun test(f: F, b: B) {\n            <expr>consume(f)</expr>\n        }\n    }\n}\n\nfun consume(obj: Any) {}"}
{"code": "open class A()\nopen class B(): A()\nclass C(): <caret>A(), B()\n"}
{"code": "package test\n\nclass Foo\ntypealias FooAlias = Foo\n\nfun Foo.fooExt() {}\nfun FooAlias.fooAliasExt() {}\n\nfun Any.anyExt() {}\n\nclass Other\nfun Other.otherExt() {}\n\n\nfun usage() {}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.extended\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.KtNodeTypes\nimport org.jetbrains.kotlin.contracts.description.canBeRevisited\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.cfa.AbstractFirPropertyInitializationChecker\nimport org.jetbrains.kotlin.fir.analysis.cfa.requiresInitialization\nimport org.jetbrains.kotlin.fir.analysis.cfa.util.PropertyInitializationInfoData\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.expressions.calleeReference\nimport org.jetbrains.kotlin.fir.references.toResolvedPropertySymbol\nimport org.jetbrains.kotlin.fir.resolve.dfa.cfg.CFGNode\nimport org.jetbrains.kotlin.fir.resolve.dfa.cfg.Cont"}
{"code": "rolFlowGraph\nimport org.jetbrains.kotlin.fir.resolve.dfa.cfg.ControlFlowGraphVisitorVoid\nimport org.jetbrains.kotlin.fir.resolve.dfa.cfg.VariableAssignmentNode\nimport org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol\nimport org.jetbrains.kotlin.util.getChildren\n\nobject CanBeValChecker : AbstractFirPropertyInitializationChecker(MppCheckerKind.Common) {\n    override fun analyze(data: PropertyInitializationInfoData, reporter: DiagnosticReporter, context: CheckerContext) {\n        val collector = ReassignedVariableCollector(data).apply { data.graph.traverse(this) }\n        val iterator = data.properties.iterator()\n        for (symbol in iterator) {\n            val source = symbol.source ?: continue\n            val canBeVal = if (source.elementType == KtNodeTypes.DESTRUCTURING_DECLARATION) {\n                // var (a, b) -> { val _tmp; var a; var b }\n                val count = source.lighterASTNode.getChildren(source.treeStructure).count {\n                    it.tokenType == KtNodeTy"}
{"code": "pes.DESTRUCTURING_DECLARATION_ENTRY\n                }\n                // Weird way of writing `and { ... }` that will always call `next()` N times.\n                (0 until count).fold(true) { acc, _ -> iterator.hasNext() && collector.canBeVal(iterator.next()) && acc }\n            } else {\n                collector.canBeVal(symbol)\n            }\n            if (canBeVal) {\n                reporter.reportOn(source, FirErrors.CAN_BE_VAL, context)\n            }\n        }\n    }\n\n    private class ReassignedVariableCollector(val data: PropertyInitializationInfoData) : ControlFlowGraphVisitorVoid() {\n        private val reassigned = mutableSetOf<FirPropertySymbol>()\n\n        override fun visitNode(node: CFGNode<*>) {}\n\n        override fun visitVariableAssignmentNode(node: VariableAssignmentNode) {\n            val symbol = node.fir.calleeReference?.toResolvedPropertySymbol() ?: return\n            if (symbol.isVar && symbol.source?.kind !is KtFakeSourceElementKind && symbol in data.properties"}
{"code": ") {\n                val isForInitialization = data.graph.kind == ControlFlowGraph.Kind.Class || data.graph.kind == ControlFlowGraph.Kind.File\n                if (!symbol.requiresInitialization(isForInitialization) || data.getValue(node).values.any { it[symbol]?.canBeRevisited() == true }) {\n                    reassigned.add(symbol)\n                }\n            }\n        }\n\n        fun canBeVal(symbol: FirPropertySymbol): Boolean =\n            symbol.isVar && !symbol.hasDelegate && symbol.source?.kind !is KtFakeSourceElementKind? && symbol !in reassigned\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cli.common.extensions\n\nimport com.intellij.core.JavaCoreProjectEnvironment\nimport org.jetbrains.kotlin.cli.common.repl.ReplCompiler\nimport org.jetbrains.kotlin.config.CompilerConfiguration\nimport org.jetbrains.kotlin.extensions.ProjectExtensionDescriptor\nimport java.io.File\n\ninterface ReplFactoryExtension {\n    companion object : ProjectExtensionDescriptor<ReplFactoryExtension>(\n        \"org.jetbrains.kotlin.replFactoryExtension\",\n        ReplFactoryExtension::class.java\n    )\n\n    fun makeReplCompiler(\n        templateClassName: String,\n        templateClasspath: List<File>,\n        baseClassLoader: ClassLoader?,\n        configuration: CompilerConfiguration,\n        projectEnvironment: JavaCoreProjectEnvironment\n    ): ReplCompiler\n}\n"}
{"code": "package test\n\nclass A\n\nclass Test {\n    fun some(vararg a: A) = <caret>a\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cfg.pseudocode.instructions.jumps\n\nimport org.jetbrains.kotlin.psi.KtElement\nimport org.jetbrains.kotlin.cfg.Label\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.BlockScope\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.InstructionVisitor\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.InstructionVisitorWithResult\n\nclass ReturnNoValueInstruction(\n    element: KtElement,\n    blockScope: BlockScope,\n    targetLabel: Label,\n    val subroutine: KtElement\n) : AbstractJumpInstruction(element, targetLabel, blockScope) {\n    override fun accept(visitor: InstructionVisitor) {\n        visitor.visitReturnNoValue(this)\n    }\n\n    override fun <R> accept(visitor: InstructionVisitorWithResult<R>): R = visitor.visitReturnNoValue(this)\n\n    override fun toString(): String = \"ret $targetLabel\"\n\n    override fun createCopy(newLabel: Label, blockScope: BlockScope): AbstractJumpInstruction =\n        ReturnNoValueInstruction(element, blockScope, newL"}
{"code": "abel, subroutine)\n}\n"}
{"code": "package test\n\nclass WithGenerics<T>\n\nfun WithGenerics<Int>.intExt() {}\n\nfun WithGenerics<String>.stringExt() {}\n\n\nfun usage() {}"}
{"code": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\")\n\npackage org.jetbrains.kotlin.fir.expressions.impl\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fakeElement\nimport org.jetbrains.kotlin.fir.MutableOrEmptyList\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.expressions.FirSmartCastExpression\nimport org.jetbrains.kotlin.fir.expressions.UnresolvedExpressionTypeAccess\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.visitors.FirTransformer\nimport org.jetbrains.kotlin.fir.visitors.FirVisitor\nimport org.jetbrains.kotlin.fir.visitors.transformInplace\nimport org.jetbrains.k"}
{"code": "otlin.types.SmartcastStability\n\n@OptIn(UnresolvedExpressionTypeAccess::class)\ninternal class FirSmartCastExpressionImpl(\n    @property:UnresolvedExpressionTypeAccess\n    override var coneTypeOrNull: ConeKotlinType?,\n    override var annotations: MutableOrEmptyList<FirAnnotation>,\n    override var originalExpression: FirExpression,\n    override val typesFromSmartCast: Collection<ConeKotlinType>,\n    override var smartcastType: FirTypeRef,\n    override var smartcastTypeWithoutNullableNothing: FirTypeRef?,\n    override val smartcastStability: SmartcastStability,\n) : FirSmartCastExpression() {\n    override val source: KtSourceElement? = originalExpression.source?.fakeElement(KtFakeSourceElementKind.SmartCastExpression)\n    override val isStable: Boolean\n        get() = smartcastStability == SmartcastStability.STABLE_VALUE\n\n    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {\n        annotations.forEach { it.accept(visitor, data) }\n        originalExpression.accept(v"}
{"code": "isitor, data)\n        smartcastType.accept(visitor, data)\n        smartcastTypeWithoutNullableNothing?.accept(visitor, data)\n    }\n\n    override fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirSmartCastExpressionImpl {\n        transformAnnotations(transformer, data)\n        transformOriginalExpression(transformer, data)\n        smartcastType = smartcastType.transform(transformer, data)\n        smartcastTypeWithoutNullableNothing = smartcastTypeWithoutNullableNothing?.transform(transformer, data)\n        return this\n    }\n\n    override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirSmartCastExpressionImpl {\n        annotations.transformInplace(transformer, data)\n        return this\n    }\n\n    override fun <D> transformOriginalExpression(transformer: FirTransformer<D>, data: D): FirSmartCastExpressionImpl {\n        originalExpression = originalExpression.transform(transformer, data)\n        return this\n    }\n\n    override fun replaceConeT"}
{"code": "ypeOrNull(newConeTypeOrNull: ConeKotlinType?) {\n        coneTypeOrNull = newConeTypeOrNull\n    }\n\n    override fun replaceAnnotations(newAnnotations: List<FirAnnotation>) {\n        annotations = newAnnotations.toMutableOrEmpty()\n    }\n\n    override fun replaceOriginalExpression(newOriginalExpression: FirExpression) {\n        originalExpression = newOriginalExpression\n    }\n}\n"}
{"code": "\n// KNM_K2_IGNORE\n\n\npackage test\n\nimport test.E.E1\nimport kotlin.reflect.KClass\n\nconst val CONSTANT = 12\n\nclass AnnotationValues {\n    @Simple(\n        12,\n        12L,\n        12,\n\n        3.3,\n        f = 3.3F,\n\n        c = 'a',\n\n        b1 = true,\n        b2 = false\n    )\n    class WithSimple\n\n    @StringLiteral(\"some\", \"\", \"H$CONSTANT\")\n    class WithStringLiteral\n\n    @EnumLiteral(E1, E.E2, e3 = test.E.E2)\n    class WithEnumLiteral\n\n    @VarArg(1, 2, 3)\n    class WithVarArg\n\n    @Arrays(\n        [1, 2, 3],\n        [1L],\n        [],\n        [2.2],\n        ['a'],\n        [true, false]\n    )\n    class WithArrays\n\n    @ClassLiteral(\n        WithClassLiteral::class,\n        String::class\n    )\n    class WithClassLiteral<T>\n\n    @Outer(\"value\", nested = Nested(12, \"nested value\"))\n    class WithNested\n}\n\nannotation class Simple(\n    val i: Int,\n    val l: Long,\n    val b: Byte,\n\n    val d: Double,\n    val f: Float,\n\n    val c: Char,\n\n    val b1: Boolean,\n    val b2: Boolean\n)\n\nannotatio"}
{"code": "n class StringLiteral(\n    val s1: String,\n    val s2: String,\n    val s3: String\n)\n\nenum class E {\n    E1, E2\n}\nannotation class EnumLiteral(\n    val e1: E,\n    val e2: E,\n    val e3: E\n)\n\nannotation class VarArg(\n    vararg val v: Int\n)\n\nannotation class Arrays(\n    val ia: IntArray,\n    val la: LongArray,\n    val fa: FloatArray,\n    val da: DoubleArray,\n    val ca: CharArray,\n    val ba: BooleanArray\n)\n\nannotation class ClassLiteral(\n    val c1: KClass<*>,\n    val c2: KClass<*>\n)\n\n\nannotation class Nested(\n    val i: Int,\n    val s: String\n)\n\nannotation class Outer(\n    val some: String,\n    val nested: Nested\n)\n"}
{"code": "annotation class WithErrorSecondaryConstructor cons<caret>tructor(val a: Int) {\n    constructor(): this(0)\n}\n"}
{"code": "interface A<out T>\n\ninterface MutableA<T> : A<T> {\n    fun add(x: T)\n}\n\ninterface MutableString : MutableA<String>\n\nfun test(a: A<String>) {\n    (a as? MutableA)?.add(\"\")\n    (a as MutableA).add(\"\")\n}\n\nfun test2(a: A<String>) {\n    val b = a as MutableString\n    b.add(\"\")\n}\n\nfun test3(a: A<String>) {\n    if (a is MutableA) {\n        a.add(\"\")\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.transformers\n\nimport org.jetbrains.kotlin.fir.*\nimport org.jetbrains.kotlin.fir.declarations.FirFile\nimport org.jetbrains.kotlin.fir.declarations.FirImport\nimport org.jetbrains.kotlin.fir.declarations.FirResolvePhase\nimport org.jetbrains.kotlin.fir.declarations.builder.buildResolvedImport\nimport org.jetbrains.kotlin.fir.resolve.ScopeSession\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.symbolProvider\nimport org.jetbrains.kotlin.name.FqName\n\nclass FirImportResolveProcessor(session: FirSession, scopeSession: ScopeSession) : FirTransformerBasedResolveProcessor(\n    session, scopeSession, FirResolvePhase.IMPORTS\n) {\n    override val transformer = FirImportResolveTransformer(session)\n}\n\nopen class FirImportResolveTransformer protected constructor(\n    final override val session: FirSession,\n    phase: FirResolvePhase\n) : FirAbstractTreeTransformer<Any?>(phase) {\n    override fu"}
{"code": "n <E : FirElement> transformElement(element: E, data: Any?): E {\n        return element\n    }\n\n    constructor(session: FirSession) : this(session, FirResolvePhase.IMPORTS)\n\n    private val symbolProvider: FirSymbolProvider = session.symbolProvider\n\n    private var currentFile: FirFile? = null\n\n    override fun transformFile(file: FirFile, data: Any?): FirFile {\n        checkSessionConsistency(file)\n        withFileAnalysisExceptionWrapping(file) {\n            val prevValue = currentFile\n            currentFile = file\n            try {\n                file.transformChildren(this, null)\n            } finally {\n                currentFile = prevValue\n            }\n        }\n        return file\n    }\n\n    override fun transformImport(import: FirImport, data: Any?): FirImport {\n        val fqName = import.importedFqName?.takeUnless { it.isRoot } ?: return import\n\n        if (!fqName.isAcceptable) return import\n\n        if (import.isAllUnder) {\n            return transformImportForFqName(fq"}
{"code": "Name, import)\n        }\n\n        currentFile?.let {\n            session.lookupTracker?.recordFqNameLookup(fqName, import.source, it.source)\n        }\n        return transformImportForFqName(fqName.parent(), import)\n    }\n\n    protected open val FqName.isAcceptable: Boolean\n        get() = true\n\n    private fun transformImportForFqName(fqName: FqName, delegate: FirImport): FirImport {\n        val (packageFqName, relativeClassFqName) = findLongestExistingPackage(symbolProvider, fqName)\n\n        return buildResolvedImport {\n            this.delegate = delegate\n            this.packageFqName = packageFqName\n            this.relativeParentClassName = relativeClassFqName\n        }\n    }\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.decompiler.stub.files\n\nimport com.intellij.psi.stubs.StubElement\nimport org.jetbrains.kotlin.contracts.description.*\nimport org.jetbrains.kotlin.psi.KtProjectionKind\nimport org.jetbrains.kotlin.psi.stubs.impl.*\n\nfun extractAdditionalStubInfo(stub: StubElement<*>): String {\n    val builder = StringBuilder()\n    extractAdditionInfo(stub, builder, 0)\n    return builder.toString()\n}\n\nprivate fun extractAdditionInfo(stub: StubElement<*>, builder: StringBuilder, level: Int) {\n    builder.append(stub.toString())\n    when (stub) {\n        is KotlinUserTypeStubImpl -> {\n            val upperBound = stub.upperBound\n            if (upperBound != null) {\n                builder.append(\"    ft: \")\n                appendFlexibleTypeInfo(builder, upperBound)\n            }\n        }\n        is KotlinFunctionStubImpl -> {\n            val contract = stub.contract\n            if (contract != null) {\n                for (element in contract) {\n                    bu"}
{"code": "ilder.append(\"\\n\" + \"  \".repeat(level)).append(\"effect:\")\n                    element.accept(KotlinContractRenderer(builder), null)\n                }\n            }\n        }\n        is KotlinPropertyStubImpl -> {\n            val initializer = stub.constantInitializer\n            if (initializer != null) {\n                builder.append(\"\\n\").append(\"  \".repeat(level)).append(\"initializer: ${initializer.value}\")\n            }\n        }\n        is KotlinAnnotationEntryStubImpl -> {\n            val arguments = stub.valueArguments\n            if (arguments != null) {\n                builder\n                    .append(\"\\n\")\n                    .append(\"  \".repeat(level))\n                    .append(\"valueArguments: \")\n                    .append(arguments.entries.joinToString(\", \", \"(\", \")\") { \"${it.key.asString()} = ${it.value}\" })\n            }\n        }\n        is KotlinParameterStubImpl -> {\n            stub.functionTypeParameterName?.let { builder.append(\"   paramNameByAnnotation: \")."}
{"code": "append(it) }\n        }\n    }\n    for (child in stub.childrenStubs) {\n        builder.append(\"\\n\").append(\"  \".repeat(level))\n        extractAdditionInfo(child, builder, level + 1)\n    }\n}\n\nprivate fun appendFlexibleTypeInfo(builder: StringBuilder, typeBean: KotlinTypeBean) {\n    when (typeBean) {\n        is KotlinClassTypeBean -> {\n            builder.append(typeBean.classId.asFqNameString())\n            val arguments = typeBean.arguments\n            if (arguments.isNotEmpty()) {\n                builder.append(\"<\")\n                arguments.forEachIndexed { index, arg ->\n                    if (index > 0) builder.append(\", \")\n                    if (arg.projectionKind != KtProjectionKind.NONE) {\n                        builder.append(arg.projectionKind.name)\n                    }\n                    if (arg.projectionKind != KtProjectionKind.STAR) {\n                        appendFlexibleTypeInfo(builder, arg.type!!)\n                    }\n                }\n                builder.append"}
{"code": "(\">\")\n            }\n            if (typeBean.nullable) {\n                builder.append(\"?\")\n            }\n        }\n        is KotlinTypeParameterTypeBean -> {\n            builder.append(typeBean.typeParameterName)\n            if (typeBean.nullable) {\n                builder.append(\"?\")\n            }\n            if (typeBean.definitelyNotNull) {\n                builder.append(\" & Any\")\n            }\n        }\n\n        is KotlinFlexibleTypeBean -> {\n            appendFlexibleTypeInfo(builder, typeBean.lowerBound)\n            builder.append(\" .. \")\n            appendFlexibleTypeInfo(builder, typeBean.upperBound)\n        }\n    }\n}\n\nclass KotlinContractRenderer(private val buffer: StringBuilder) : KtContractDescriptionVisitor<Unit, Nothing?, KotlinTypeBean, Nothing?>() {\n    override fun visitConditionalEffectDeclaration(conditionalEffect: KtConditionalEffectDeclaration<KotlinTypeBean, Nothing?>, data: Nothing?) {\n        conditionalEffect.effect.accept(this, data)\n        buffer.append(\""}
{"code": " -> \")\n        conditionalEffect.condition.accept(this, data)\n    }\n\n    override fun visitReturnsEffectDeclaration(returnsEffect: KtReturnsEffectDeclaration<KotlinTypeBean, Nothing?>, data: Nothing?) {\n        buffer.append(\"Returns(\")\n        returnsEffect.value.accept(this, data)\n        buffer.append(\")\")\n    }\n\n    override fun visitCallsEffectDeclaration(callsEffect: KtCallsEffectDeclaration<KotlinTypeBean, Nothing?>, data: Nothing?) {\n        buffer.append(\"CallsInPlace(\")\n        callsEffect.valueParameterReference.accept(this, data)\n        buffer.append(\", ${callsEffect.kind})\")\n    }\n\n    override fun visitLogicalBinaryOperationContractExpression(binaryLogicExpression: KtBinaryLogicExpression<KotlinTypeBean, Nothing?>, data: Nothing?) {\n        binaryLogicExpression.left.accept(this, data)\n        buffer.append(\" ${binaryLogicExpression.kind.token} \")\n        binaryLogicExpression.right.accept(this, data)\n    }\n\n    override fun visitLogicalNot(logicalNot: KtLogicalNot<Kotli"}
{"code": "nTypeBean, Nothing?>, data: Nothing?) {\n        logicalNot.arg.accept(this, data)\n    }\n\n    override fun visitIsInstancePredicate(isInstancePredicate: KtIsInstancePredicate<KotlinTypeBean, Nothing?>, data: Nothing?) {\n        isInstancePredicate.arg.accept(this, data)\n        buffer.append(\" ${if (isInstancePredicate.isNegated) \"!\" else \"\"}is ${isInstancePredicate.type}\")\n    }\n\n    override fun visitIsNullPredicate(isNullPredicate: KtIsNullPredicate<KotlinTypeBean, Nothing?>, data: Nothing?) {\n        isNullPredicate.arg.accept(this, data)\n        buffer.append(\" ${if (isNullPredicate.isNegated) \"!=\" else \"==\"} null\")\n    }\n\n    override fun visitConstantDescriptor(constantReference: KtConstantReference<KotlinTypeBean, Nothing?>, data: Nothing?) {\n        buffer.append(constantReference.name)\n    }\n\n    override fun visitValueParameterReference(valueParameterReference: KtValueParameterReference<KotlinTypeBean, Nothing?>, data: Nothing?) {\n        buffer.append(\"param(\").append(valueP"}
{"code": "arameterReference.parameterIndex).append(\")\")\n    }\n}\n"}
{"code": "fun foo() {\n    return@<caret>foo\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir\n\nimport com.intellij.psi.util.PsiTreeUtil\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators.AnalysisApiFirScriptTestConfigurator\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators.AnalysisApiFirSourceTestConfigurator\nimport org.jetbrains.kotlin.analysis.providers.impl.declarationProviders.FileBasedKotlinDeclarationProvider\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.test.builders.TestConfigurationBuilder\nimport org.jetbrains.kotlin.test.directives.model.SimpleDirectivesContainer\nimport org.jetbrains.kotlin.test.services.TestModuleStructure"}
{"code": "\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.moduleStructure\nimport kotlin.test.assertContains\nimport kotlin.test.assertNotNull\n\nabstract class AbstractFileBasedKotlinDeclarationProviderTest : AbstractAnalysisApiBasedTest() {\n    override fun configureTest(builder: TestConfigurationBuilder) {\n        super.configureTest(builder)\n        with(builder) {\n            useDirectives(Directives)\n        }\n    }\n\n    override fun doTestByMainFile(mainFile: KtFile, mainModule: KtTestModule, testServices: TestServices) {\n        val provider = FileBasedKotlinDeclarationProvider(mainFile)\n        assertContains(provider.findFilesForFacadeByPackage(mainFile.packageFqName), mainFile)\n\n        checkByDirectives(testServices.moduleStructure, provider)\n        checkByVisitor(mainFile, provider)\n    }\n\n    private fun checkByDirectives(moduleStructure: TestModuleStructure, provider: FileBasedKotlinDeclarationProvider) {\n        for (directive in mod"}
{"code": "uleStructure.allDirectives[Directives.CLASS]) {\n            val classId = ClassId.fromString(directive)\n            assert(provider.getAllClassesByClassId(classId).isNotEmpty()) { \"Class $classId not found\" }\n            assertNotNull(provider.getClassLikeDeclarationByClassId(classId)) { \"Class-like declaration $classId not found\" }\n        }\n\n        for (directive in moduleStructure.allDirectives[Directives.TYPE_ALIAS]) {\n            val classId = ClassId.fromString(directive)\n            assert(provider.getAllTypeAliasesByClassId(classId).isNotEmpty()) { \"Type alias $classId not found\" }\n            assertNotNull(provider.getClassLikeDeclarationByClassId(classId)) { \"Class-like declaration $classId not found\" }\n        }\n\n        for (directive in moduleStructure.allDirectives[Directives.FUNCTION]) {\n            val callableId = parseCallableId(directive)\n            assert(provider.getTopLevelFunctions(callableId).isNotEmpty()) { \"Function $callableId not found\" }\n        }\n\n      "}
{"code": "  for (directive in moduleStructure.allDirectives[Directives.PROPERTY]) {\n            val callableId = parseCallableId(directive)\n            assert(provider.getTopLevelProperties(callableId).isNotEmpty()) { \"Property $callableId not found\" }\n        }\n    }\n\n    private fun checkByVisitor(ktFile: KtFile, provider: FileBasedKotlinDeclarationProvider) {\n        ktFile.accept(object : KtTreeVisitorVoid() {\n            override fun visitClass(klass: KtClass) {\n                super.visitClass(klass)\n                processClassLikeDeclaration(klass)\n            }\n\n            override fun visitTypeAlias(typeAlias: KtTypeAlias) {\n                super.visitTypeAlias(typeAlias)\n                processClassLikeDeclaration(typeAlias)\n            }\n\n            private fun processClassLikeDeclaration(declaration: KtClassLikeDeclaration) {\n                val classId = declaration.getClassId() ?: return\n                val shortName = classId.shortClassName\n\n                if (!classId.isNeste"}
{"code": "dClass) {\n                    assertContains(provider.getTopLevelKotlinClassLikeDeclarationNamesInPackage(classId.packageFqName), shortName)\n                }\n\n                when (declaration) {\n                    is KtClassOrObject -> assertContains(provider.getAllClassesByClassId(classId), declaration)\n                    is KtTypeAlias -> assertContains(provider.getAllTypeAliasesByClassId(classId), declaration)\n                }\n            }\n\n            override fun visitNamedFunction(function: KtNamedFunction) {\n                super.visitNamedFunction(function)\n                processCallableDeclaration(function)\n            }\n\n            override fun visitProperty(property: KtProperty) {\n                super.visitProperty(property)\n                processCallableDeclaration(property)\n            }\n\n            private fun processCallableDeclaration(declaration: KtCallableDeclaration) {\n                val callableId = declaration.callableId ?: return\n\n                if (c"}
{"code": "allableId.classId == null) {\n                    assertContains(provider.getTopLevelCallableFiles(callableId), ktFile)\n                    assertContains(provider.getTopLevelCallableNamesInPackage(callableId.packageName), callableId.callableName)\n\n                    when (declaration) {\n                        is KtFunction -> assertContains(provider.getTopLevelFunctions(callableId), declaration)\n                        is KtProperty -> assertContains(provider.getTopLevelProperties(callableId), declaration)\n                    }\n                }\n            }\n        })\n    }\n\n    object Directives : SimpleDirectivesContainer() {\n        val CLASS by stringDirective(\"ClassId of a class or object to be checked for presence\")\n        val TYPE_ALIAS by stringDirective(\"ClassId of a type alias to be checked for presence\")\n        val FUNCTION by stringDirective(\"CallableId of a function to be checked for presence\")\n        val PROPERTY by stringDirective(\"CallableId of a property to be c"}
{"code": "hecked for presence\")\n    }\n}\n\nprivate val KtCallableDeclaration.callableId: CallableId?\n    get() {\n        val callableName = this.nameAsName ?: return null\n        when (val owner = PsiTreeUtil.getParentOfType(this, KtDeclaration::class.java, KtFile::class.java)) {\n            is KtClassOrObject -> {\n                val classId = owner.getClassId() ?: return null\n                return CallableId(classId, callableName)\n            }\n            is KtFile -> {\n                return CallableId(owner.packageFqName, callableName)\n            }\n            else -> return null\n        }\n    }\n\nprivate fun parseCallableId(rawString: String): CallableId {\n    val chunks = rawString.split('#')\n    assert(chunks.size == 2) { \"Invalid CallableId string format: $rawString\" }\n\n    val rawQualifier = chunks[0]\n    val rawCallableName = chunks[1]\n\n    val callableName = Name.identifier(rawCallableName)\n\n    return when {\n        rawQualifier.endsWith('/') -> CallableId(FqName(rawQualifier.dropLas"}
{"code": "t(1).replace('/', '.')), callableName)\n        else -> CallableId(ClassId.fromString(rawQualifier, false), callableName)\n    }\n}\n\nabstract class AbstractSourceFileBasedKotlinDeclarationProviderTest : AbstractFileBasedKotlinDeclarationProviderTest() {\n    override val configurator = AnalysisApiFirSourceTestConfigurator(analyseInDependentSession = false)\n}\n\nabstract class AbstractScriptFileBasedKotlinDeclarationProviderTest : AbstractFileBasedKotlinDeclarationProviderTest() {\n    override val configurator = AnalysisApiFirScriptTestConfigurator(analyseInDependentSession = false)\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.diagnostics.rendering\n\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.renderer.DescriptorRenderer\nimport org.jetbrains.kotlin.types.KotlinType\n\nclass SmartTypeRenderer(private val baseRenderer: DescriptorRenderer) : DiagnosticParameterRenderer<KotlinType> {\n    override fun render(obj: KotlinType, renderingContext: RenderingContext): String {\n        val adaptiveRenderer = baseRenderer.withOptions {\n            classifierNamePolicy = renderingContext.adaptiveClassifierPolicy\n        }\n        return adaptiveRenderer.renderType(obj)\n    }\n}\n\nclass SmartDescriptorRenderer(private val baseRenderer: DescriptorRenderer) : DiagnosticParameterRenderer<DeclarationDescriptor> {\n    override fun render(obj: DeclarationDescriptor, renderingContext: RenderingContext): String {\n        val adaptiveRenderer = baseRenderer.withOptions {\n            classifierNamePolicy = renderingContext.adaptiveClassifierPolicy\n        }\n     "}
{"code": "   return adaptiveRenderer.render(obj)\n    }\n}\n\n"}
{"code": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE_K1\n// PRETTY_RENDERER_OPTION: FULLY_EXPANDED_TYPES\n@Target(AnnotationTarget.TYPE)\nannotation class Anno1(val s: String)\n@Target(AnnotationTarget.TYPE)\nannotation class Anno2\n\n@Target(AnnotationTarget.TYPE)\nannotation class BaseAnnotation\n\ntypealias FirstTypeAlias = @Anno1(\"s\") BaseAnnotation\ntypealias SecondTypeAlias = @Anno2 FirstTypeAlias\n\nfun <T> T.f<caret>oo2(): List<List<@SecondTypeAlias T>>? = null\n"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental\n\nimport org.jetbrains.kotlin.incremental.components.InlineConstTracker\n\n@Suppress(\"unused\")\nclass InlineConstTrackerImpl : InlineConstTracker {\n    private val inlineConst = hashMapOf<String, MutableSet<ConstantRef>>()\n\n    val inlineConstMap: Map<String, Collection<ConstantRef>>\n        get() = inlineConst\n\n    override fun report(filePath: String, owner: String, name: String, constType: String) {\n        inlineConst.getOrPut(filePath) { hashSetOf() }.add(ConstantRef(owner, name, constType))\n    }\n}\n\ndata class ConstantRef(var owner: String, var name: String, var constType: String)\n"}
{"code": "\n\npackage org.jetbrains.kotlin.incremental\n\nimport org.jetbrains.kotlin.build.report.BuildReporter\nimport org.jetbrains.kotlin.build.report.info\nimport org.jetbrains.kotlin.build.report.metrics.*\nimport org.jetbrains.kotlin.incremental.multiproject.ModulesApiHistory\nimport org.jetbrains.kotlin.incremental.util.Either\nimport org.jetbrains.kotlin.name.FqName\nimport java.io.File\n\ninternal fun getClasspathChanges(\n    classpath: List<File>,\n    changedFiles: ChangedFiles.Known,\n    lastBuildInfo: BuildInfo,\n    modulesApiHistory: ModulesApiHistory,\n    reporter: BuildReporter<GradleBuildTime, GradleBuildPerformanceMetric>,\n    abiSnapshots: Map<String, AbiSnapshot>,\n    withSnapshot: Boolean,\n    caches: IncrementalCacheCommon,\n    scopes: Collection<String>\n): ChangesEither {\n    val classpathSet = HashSet<File>()\n    for (file in classpath) {\n        when {\n            file.isFile -> classpathSet.add(file)\n            file.isDirectory -> file.walk().filterTo(classpathSet) { it.isFile }\n "}
{"code": "       }\n    }\n\n    val modifiedClasspath = changedFiles.modified.filterTo(HashSet()) { it in classpathSet }\n    val removedClasspath = changedFiles.removed.filterTo(HashSet()) { it in classpathSet }\n\n    // todo: removed classes could be processed normally\n    if (removedClasspath.isNotEmpty()) {\n        reporter.info { \"Some files are removed from classpath: $removedClasspath\" }\n        return ChangesEither.Unknown(BuildAttribute.DEP_CHANGE_REMOVED_ENTRY)\n    }\n\n    if (modifiedClasspath.isEmpty()) return ChangesEither.Known()\n\n    if (withSnapshot) {\n        fun analyzeJarFiles(): ChangesEither {\n            val symbols = HashSet<LookupSymbol>()\n            val fqNames = HashSet<FqName>()\n\n            for ((module, abiSnapshot) in abiSnapshots) {\n                val actualAbiSnapshot = lastBuildInfo.dependencyToAbiSnapshot[module]\n                if (actualAbiSnapshot == null) {\n\n                    reporter.info { \"Some jar are removed from classpath $module\" }\n                    "}
{"code": "return ChangesEither.Unknown(BuildAttribute.DEP_CHANGE_REMOVED_ENTRY)\n                }\n                val diffData = AbiSnapshotDiffService.doCompute(abiSnapshot, actualAbiSnapshot, caches, scopes)\n                symbols.addAll(diffData.dirtyLookupSymbols)\n                fqNames.addAll(diffData.dirtyClassesFqNames)\n\n            }\n            return ChangesEither.Known(symbols, fqNames)\n        }\n        return reporter.measure(GradleBuildTime.IC_ANALYZE_JAR_FILES) {\n            analyzeJarFiles()\n        }\n    } else {\n        val lastBuildTS = lastBuildInfo.startTS\n\n        val symbols = HashSet<LookupSymbol>()\n        val fqNames = HashSet<FqName>()\n\n        val historyFilesEither =\n            reporter.measure(GradleBuildTime.IC_FIND_HISTORY_FILES) {\n                modulesApiHistory.historyFilesForChangedFiles(modifiedClasspath)\n            }\n\n        val historyFiles = when (historyFilesEither) {\n            is Either.Success<Set<File>> -> historyFilesEither.value\n            i"}
{"code": "s Either.Error -> {\n                reporter.info { \"Could not find history files: ${historyFilesEither.reason}\" }\n                return ChangesEither.Unknown(BuildAttribute.DEP_CHANGE_HISTORY_IS_NOT_FOUND)\n            }\n        }\n\n        fun analyzeHistoryFiles(): ChangesEither {\n            for (historyFile in historyFiles) {\n                val allBuilds = BuildDiffsStorage.readDiffsFromFile(historyFile, reporter = reporter)\n                    ?: return run {\n                        reporter.info { \"Could not read diffs from $historyFile\" }\n                        ChangesEither.Unknown(BuildAttribute.DEP_CHANGE_HISTORY_CANNOT_BE_READ)\n                    }\n\n                val (knownBuilds, newBuilds) = allBuilds.partition { it.ts <= lastBuildTS }\n                if (knownBuilds.isEmpty()) {\n                    reporter.info { \"No previously known builds for $historyFile\" }\n                    return ChangesEither.Unknown(BuildAttribute.DEP_CHANGE_HISTORY_NO_KNOWN_BUILDS)\n       "}
{"code": "         }\n\n\n                for (buildDiff in newBuilds) {\n                    if (!buildDiff.isIncremental) {\n                        reporter.info { \"Non-incremental build from dependency $historyFile\" }\n                        return ChangesEither.Unknown(BuildAttribute.DEP_CHANGE_NON_INCREMENTAL_BUILD_IN_DEP)\n\n                    }\n                    val dirtyData = buildDiff.dirtyData\n                    symbols.addAll(dirtyData.dirtyLookupSymbols)\n                    fqNames.addAll(dirtyData.dirtyClassesFqNames)\n                }\n            }\n\n            return ChangesEither.Known(symbols, fqNames)\n        }\n\n        return reporter.measure(GradleBuildTime.IC_ANALYZE_HISTORY_FILES) {\n            analyzeHistoryFiles()\n        }\n    }\n}"}
{"code": "fun resolve<caret>Me() {\n    receive(withGetterAndSetter)\n    withGetterAndSetter = 123\n}\n\nfun receive(value: Int) {}\n\nvar withGetterAndSetter: Int = 42\n    get() = field\n    set(value) {\n        field = value\n    }\n"}
{"code": "fun test(v: Any?) {\n    (<expr>v</expr> as String).length\n}"}
{"code": "fun test() {\n    return@blah\n}\n\nval i = {\n    return\n}\n\nval i = {\n    return@i\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.symbols\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisApiInternals\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.fir.KtFirAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.fir.annotations.KtFirAnnotationListForDeclaration\nimport org.jetbrains.kotlin.analysis.api.fir.findPsi\nimport org.jetbrains.kotlin.analysis.api.fir.symbols.pointers.requireOwnerPointer\nimport org.jetbrains.kotlin.analysis.api.fir.utils.cached\nimport org.jetbrains.kotlin.analysis.api.impl.base.symbols.pointers.KtPropertyAccessorSymbolPointer\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken\nimport org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion\nimport org.jetbrains.kotlin.analysis.api.symbols.KtPropertyGetterSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtReceiverParameterSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.K"}
{"code": "tValueParameterSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.pointers.KtPsiBasedSymbolPointer\nimport org.jetbrains.kotlin.analysis.api.symbols.pointers.KtSymbolPointer\nimport org.jetbrains.kotlin.analysis.api.types.KtType\nimport org.jetbrains.kotlin.descriptors.Modality\nimport org.jetbrains.kotlin.descriptors.Visibility\nimport org.jetbrains.kotlin.fir.declarations.impl.FirDefaultPropertyAccessor\nimport org.jetbrains.kotlin.fir.declarations.synthetic.FirSyntheticPropertyAccessor\nimport org.jetbrains.kotlin.fir.declarations.utils.*\nimport org.jetbrains.kotlin.fir.symbols.impl.FirPropertyAccessorSymbol\nimport org.jetbrains.kotlin.name.CallableId\n\ninternal class KtFirPropertyGetterSymbol(\n    override val firSymbol: FirPropertyAccessorSymbol,\n    override val analysisSession: KtFirAnalysisSession,\n) : KtPropertyGetterSymbol(), KtFirSymbol<FirPropertyAccessorSymbol> {\n    override val token: KtLifetimeToken get() = builder.token\n    init {\n        require(firSymbol.isGetter)\n    }"}
{"code": "\n\n    override val psi: PsiElement? by cached { firSymbol.findPsi() }\n\n    override val isDefault: Boolean get() = withValidityAssertion { firSymbol.fir is FirDefaultPropertyAccessor }\n    override val isInline: Boolean get() = withValidityAssertion { firSymbol.isInline }\n    override val isOverride: Boolean\n        get() = withValidityAssertion {\n            if (firSymbol.isOverride) return@withValidityAssertion true\n            return firSymbol.fir.propertySymbol.isOverride\n        }\n\n    override val hasBody: Boolean get() = withValidityAssertion { firSymbol.fir.hasBody }\n\n    override val modality: Modality get() = withValidityAssertion { firSymbol.modality }\n    override val visibility: Visibility get() = withValidityAssertion { firSymbol.visibility }\n\n\n    override val returnType: KtType get() = withValidityAssertion { firSymbol.returnType(builder) }\n    override val receiverParameter: KtReceiverParameterSymbol? get() = withValidityAssertion { firSymbol.fir.propertySymbol.receive"}
{"code": "r(builder) }\n\n    override val annotationsList by cached {\n        KtFirAnnotationListForDeclaration.create(firSymbol, builder)\n    }\n\n    \n    override val callableIdIfNonLocal: CallableId? by cached {\n        val fir = firSymbol.fir\n        if (fir is FirSyntheticPropertyAccessor) {\n            fir.delegate.symbol.callableId\n        } else null\n    }\n\n    override val valueParameters: List<KtValueParameterSymbol> get() = withValidityAssertion { emptyList() }\n\n    override val hasStableParameterNames: Boolean\n        get() = withValidityAssertion { true }\n\n    context(KtAnalysisSession)\n    @OptIn(KtAnalysisApiInternals::class)\n    override fun createPointer(): KtSymbolPointer<KtPropertyGetterSymbol> = withValidityAssertion {\n        KtPsiBasedSymbolPointer.createForSymbolFromSource<KtPropertyGetterSymbol>(this)?.let { return it }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        KtPropertyAccessorSymbolPointer(requireOwnerPointer(), isGetter = true) as KtSymbolPointer<KtPropertyGetterSymb"}
{"code": "ol>\n    }\n\n    override fun equals(other: Any?): Boolean = symbolEquals(other)\n    override fun hashCode(): Int = symbolHashCode()\n}\n"}
{"code": "fun test(map: Map<String?, List<String>>) {\n    val sortedMap = map.toSortedMap(nullsLast())\n}\n"}
{"code": "\n\npackage org.jetbrains.kotlin.codegen.optimization.fixStack\n\nimport org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode\nimport org.jetbrains.org.objectweb.asm.tree.MethodNode\nimport kotlin.math.max\n\ninternal class LocalVariablesManager(val context: FixStackContext, val methodNode: MethodNode) {\n    private class AllocatedHandle(val savedStackDescriptor: SavedStackDescriptor, var numRestoreMarkers: Int) {\n        fun isFullyEmitted(): Boolean =\n            numRestoreMarkers == 0\n\n        fun markRestoreNodeEmitted() {\n            assert(numRestoreMarkers > 0) { \"Emitted more restore markers than expected for $savedStackDescriptor\" }\n            numRestoreMarkers--\n        }\n    }\n\n    private val initialMaxLocals = methodNode.maxLocals\n    private val allocatedHandles = hashMapOf<AbstractInsnNode, AllocatedHandle>()\n\n    private fun updateMaxLocals(newValue: Int) {\n        methodNode.maxLocals = max(methodNode.maxLocals, newValue)\n    }\n\n    fun allocateVariablesForSaveStackMarker(\n "}
{"code": "       saveStackMarker: AbstractInsnNode,\n        savedStackValues: List<FixStackValue>\n    ): SavedStackDescriptor {\n        val numRestoreStackMarkers = context.restoreStackMarkersForSaveMarker[saveStackMarker]!!.size\n        return allocateNewHandle(numRestoreStackMarkers, saveStackMarker, savedStackValues)\n    }\n\n    private fun allocateNewHandle(\n        numRestoreStackMarkers: Int,\n        saveStackMarker: AbstractInsnNode,\n        savedStackValues: List<FixStackValue>\n    ): SavedStackDescriptor {\n        if (savedStackValues.any { it == FixStackValue.UNINITIALIZED }) {\n            throw AssertionError(\"Uninitialized value on stack at ${methodNode.instructions.indexOf(saveStackMarker)}: $savedStackValues\")\n        }\n\n        val firstUnusedLocalVarIndex = getFirstUnusedLocalVariableIndex()\n        val savedStackDescriptor = SavedStackDescriptor(savedStackValues, firstUnusedLocalVarIndex)\n        updateMaxLocals(savedStackDescriptor.firstUnusedLocalVarIndex)\n        val allocated"}
{"code": "Handle = AllocatedHandle(savedStackDescriptor, numRestoreStackMarkers)\n        allocatedHandles[saveStackMarker] = allocatedHandle\n        return savedStackDescriptor\n    }\n\n    fun getSavedStackDescriptor(restoreStackMarker: AbstractInsnNode): SavedStackDescriptor {\n        val saveStackMarker = context.saveStackMarkerForRestoreMarker[restoreStackMarker]\n        return allocatedHandles[saveStackMarker]!!.savedStackDescriptor\n    }\n\n    private fun getFirstUnusedLocalVariableIndex(): Int =\n        allocatedHandles.values.fold(initialMaxLocals) { index, handle ->\n            max(index, handle.savedStackDescriptor.firstUnusedLocalVarIndex)\n        }\n\n    fun markRestoreStackMarkerEmitted(restoreStackMarker: AbstractInsnNode) {\n        val saveStackMarker = context.saveStackMarkerForRestoreMarker[restoreStackMarker]\n        markEmitted(saveStackMarker!!)\n    }\n\n    fun allocateVariablesForBeforeInlineMarker(\n        beforeInlineMarker: AbstractInsnNode,\n        savedStackValues: List<FixS"}
{"code": "tackValue>\n    ): SavedStackDescriptor {\n        return allocateNewHandle(1, beforeInlineMarker, savedStackValues)\n    }\n\n    fun getBeforeInlineDescriptor(afterInlineMarker: AbstractInsnNode): SavedStackDescriptor {\n        val beforeInlineMarker = context.openingInlineMethodMarker[afterInlineMarker]\n        return allocatedHandles[beforeInlineMarker]!!.savedStackDescriptor\n    }\n\n    fun markAfterInlineMarkerEmitted(afterInlineMarker: AbstractInsnNode) {\n        val beforeInlineMarker = context.openingInlineMethodMarker[afterInlineMarker]\n        markEmitted(beforeInlineMarker!!)\n    }\n\n    private fun markEmitted(saveStackMarker: AbstractInsnNode) {\n        val allocatedHandle = allocatedHandles[saveStackMarker]!!\n        allocatedHandle.markRestoreNodeEmitted()\n        if (allocatedHandle.isFullyEmitted()) {\n            allocatedHandles.remove(saveStackMarker)\n        }\n    }\n\n    fun createReturnValueVariable(returnValue: FixStackValue): Int {\n        val returnValueIndex = getFir"}
{"code": "stUnusedLocalVariableIndex()\n        updateMaxLocals(returnValueIndex + returnValue.size)\n        return returnValueIndex\n    }\n}\n"}
{"code": "fun test(n: Nothing?) {\n    <caret>when (n) {\n    }\n}\n"}
{"code": "fun <T> T.foo(): (a: T) -> Unit = TODO()\n\nfun call() {\n    val x = 123.foo()\n    <expr>x(1)</expr>\n}\n"}
{"code": "fun foo(first: Int, second: Double = 3.14, third: Boolean = false) {}\nfun bar(first: Int, second: Double = 2.71, third: Boolean, fourth: String = \"\") {}\nfun baz(x: Int, vararg y: String, z: Boolean = false) {}\n\nfun test() {\n    foo(1)\n    foo(1, 2.0)\n    foo(1, 2.0, true)\n    foo(1, third = true)\n\n    foo<!NO_VALUE_FOR_PARAMETER!>()<!>\n    foo(0, 0.0, false, <!TOO_MANY_ARGUMENTS!>\"\"<!>)\n\n    bar(1, third = true)\n    bar(1, 2.0, true)\n    bar(1, 2.0, true, \"my\")\n\n    bar(1, <!NO_VALUE_FOR_PARAMETER!><!ARGUMENT_TYPE_MISMATCH!>true<!>)<!>\n\n    baz(1)\n    baz(1, \"my\", \"yours\")\n    baz(1, z = true)\n\n    baz(0, \"\", <!ARGUMENT_TYPE_MISMATCH!>false<!>)\n}\n\n"}
{"code": "annotation class Anno(val str: String)\nval constant = \"const\"\n\nlateinit var d: IntermediateClass<Int>\nclass MyC<caret>lass : IntermediateClass<@Anno(\"class $constant\") Int> by d {\n    override fun isSchemeFile(name: CharSequence): Boolean = name != \"str\"\n}\n\ninterface IntermediateClass<SCHEME : @Anno(\"bound $constant\") Number> : BaseClass<@Anno(\"super $constant\") SCHEME, @Anno(\"super $constant\") Int> {\n}\n\ninterface BaseClass<SCHEME : @Anno(\"base bound $constant\") Number, MUTABLE_SCHEME> {\n    fun isSchemeFile(name: CharSequence): Boolean = true\n    fun anotherFunction(name: SCHEME = genericCall<SCHEME>()): Boolean = true\n\n    @Anno(\"property $constant\")\n    @get:Anno(\"property $constant\")\n    @set:Anno(\"property $constant\")\n    @setparam:Anno(\"property $constant\")\n    var propertyWithAnnotations: SCHEME\n\n    var property: SCHEME\n}\n\nfun <T> genericCall(): T = null!!\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.utils.printer\n\nimport kotlinx.collections.immutable.PersistentList\nimport kotlinx.collections.immutable.persistentListOf\nimport org.jetbrains.kotlin.utils.addToStdlib.ifTrue\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\n\n@OptIn(ExperimentalContracts::class)\npublic class PrettyPrinter(public val indentSize: Int = 2) : Appendable {\n    @PublishedApi\n    internal val builder: StringBuilder = StringBuilder()\n\n    @PublishedApi\n    internal var prefixesToPrint: PersistentList<String> = persistentListOf()\n\n    @PublishedApi\n    internal var indent: Int = 0\n\n    override fun append(seq: CharSequence): Appendable = apply {\n        if (seq.isEmpty()) return@apply\n        printPrefixes()\n        seq.split('\\n').forEachIndexed { index, line ->\n            if (index > 0) {\n                builder.append('\\n')\n            }\n            appendIndentIfNeeded()\n            builder.append(lin"}
{"code": "e)\n        }\n    }\n\n    override fun append(seq: CharSequence, start: Int, end: Int): Appendable = apply {\n        append(seq.subSequence(start, end))\n    }\n\n    override fun append(c: Char): Appendable = apply {\n        printPrefixes()\n        if (c != '\\n') {\n            appendIndentIfNeeded()\n        }\n        builder.append(c)\n    }\n\n    private fun printPrefixes() {\n        if (prefixesToPrint.isNotEmpty()) {\n            appendIndentIfNeeded()\n            prefixesToPrint.forEach { builder.append(it) }\n            prefixesToPrint = persistentListOf()\n        }\n    }\n\n    public inline fun withIndent(block: PrettyPrinter.() -> Unit) {\n        indent += 1\n        block(this)\n        indent -= 1\n    }\n\n    public inline fun withIndents(indentCount: Int, block: PrettyPrinter.() -> Unit) {\n        require(indentCount >= 0) { \"Number of indents should be non-negative\" }\n        indent += indentCount\n        block(this)\n        indent -= indentCount\n    }\n\n    public inline fun withIndent"}
{"code": "InBraces(block: PrettyPrinter.() -> Unit) {\n        withIndentWrapped(before = \"{\", after = \"}\", block)\n    }\n\n    public inline fun withIndentInSquareBrackets(block: PrettyPrinter.() -> Unit) {\n        withIndentWrapped(before = \"[\", after = \"]\", block)\n    }\n\n    public inline fun withIndentWrapped(before: String, after: String, block: PrettyPrinter.() -> Unit) {\n        append(before)\n        appendLine()\n        withIndent(block)\n        appendLine()\n        append(after)\n    }\n\n    public inline fun <T> printCollection(\n        collection: Iterable<T>,\n        separator: String = \", \",\n        prefix: String = \"\",\n        postfix: String = \"\",\n        renderItem: PrettyPrinter.(T) -> Unit\n    ) {\n        append(prefix)\n        val iterator = collection.iterator()\n        while (iterator.hasNext()) {\n            renderItem(iterator.next())\n            if (iterator.hasNext()) {\n                append(separator)\n            }\n        }\n        append(postfix)\n    }\n\n\n    public inlin"}
{"code": "e fun <T> printCollectionIfNotEmpty(\n        collection: Iterable<T>,\n        separator: String = \", \",\n        prefix: String = \"\",\n        postfix: String = \"\",\n        renderItem: PrettyPrinter.(T) -> Unit\n    ) {\n        if (!collection.iterator().hasNext()) return\n        printCollection(collection, separator, prefix, postfix, renderItem)\n    }\n\n    public fun printCharIfNotThere(char: Char) {\n        if (builder.lastOrNull() != char) {\n            append(char)\n        }\n    }\n\n    private fun appendIndentIfNeeded() {\n        if (builder.isEmpty() || builder[builder.lastIndex] == '\\n') {\n            builder.append(\" \".repeat(indentSize * indent))\n        }\n    }\n\n    override fun toString(): String {\n        return builder.toString()\n    }\n\n    public inline fun checkIfPrinted(render: () -> Unit): Boolean {\n        contract { callsInPlace(render, InvocationKind.EXACTLY_ONCE) }\n        val initialSize = builder.length\n        render()\n        return initialSize != builder.length\n  "}
{"code": "  }\n\n    public inline operator fun invoke(print: PrettyPrinter.() -> Unit) {\n        this.print()\n    }\n\n    public inline fun String.separated(p1: () -> Unit, p2: () -> Unit) {\n        contract {\n            callsInPlace(p1, InvocationKind.EXACTLY_ONCE)\n            callsInPlace(p2, InvocationKind.EXACTLY_ONCE)\n        }\n        val firstRendered = checkIfPrinted { p1() }\n        if (firstRendered) {\n            withPrefix(this, p2)\n        } else {\n            p2()\n        }\n    }\n\n    public inline fun String.separated(p1: () -> Unit, p2: () -> Unit, p3: () -> Unit) {\n        contract {\n            callsInPlace(p1, InvocationKind.EXACTLY_ONCE)\n            callsInPlace(p2, InvocationKind.EXACTLY_ONCE)\n            callsInPlace(p3, InvocationKind.EXACTLY_ONCE)\n        }\n        separated({ separated(p1, p2) }, p3)\n    }\n\n    public inline fun String.separated(p1: () -> Unit, p2: () -> Unit, p3: () -> Unit, p4: () -> Unit) {\n        contract {\n            callsInPlace(p1, InvocationKind"}
{"code": ".EXACTLY_ONCE)\n            callsInPlace(p2, InvocationKind.EXACTLY_ONCE)\n            callsInPlace(p3, InvocationKind.EXACTLY_ONCE)\n            callsInPlace(p4, InvocationKind.EXACTLY_ONCE)\n        }\n        separated({ separated(p1, p2, p3) }, p4)\n    }\n\n    public inline fun String.separated(p1: () -> Unit, p2: () -> Unit, p3: () -> Unit, p4: () -> Unit, p5: () -> Unit) {\n        contract {\n            callsInPlace(p1, InvocationKind.EXACTLY_ONCE)\n            callsInPlace(p2, InvocationKind.EXACTLY_ONCE)\n            callsInPlace(p3, InvocationKind.EXACTLY_ONCE)\n            callsInPlace(p5, InvocationKind.EXACTLY_ONCE)\n        }\n        separated({ separated(p1, p2, p3, p4) }, p5)\n    }\n\n    public inline fun withPrefix(prefix: String, print: () -> Unit) {\n        contract {\n            callsInPlace(print, InvocationKind.EXACTLY_ONCE)\n        }\n        val currentPrefixes = prefixesToPrint\n        prefixesToPrint = prefixesToPrint.add(prefix)\n        try {\n            print()\n        }"}
{"code": " finally {\n            if (prefixesToPrint.isNotEmpty()) {\n                prefixesToPrint = currentPrefixes\n            }\n        }\n    }\n\n    public inline fun withSuffix(suffix: String, p1: () -> Unit) {\n        checkIfPrinted { p1() }.ifTrue { append(suffix) }\n    }\n}\n\npublic inline fun prettyPrint(body: PrettyPrinter.() -> Unit): String =\n    PrettyPrinter().apply(body).toString()\n\n@OptIn(ExperimentalContracts::class)\npublic inline fun prettyPrintWithSettingsFrom(other: PrettyPrinter, body: PrettyPrinter.() -> Unit): String {\n    contract {\n        callsInPlace(body, InvocationKind.EXACTLY_ONCE)\n    }\n    return PrettyPrinter(other.indentSize).apply(body).toString()\n}\n"}
{"code": "// MODULE: topmost\n// FILE: topmost.kt\npackage org.example\n\ninterface Base {\n    fun topmost()\n}\n\ninterface Topmost : Base\n\n// MODULE: top(topmost)\n// FILE: top.kt\npackage org.example\n\ninterface Base : <!CYCLIC_INHERITANCE_HIERARCHY!>TopAdditional<!> {\n    fun top()\n}\n\n// FILE: TopAdditional.java\npackage org.example;\n\npublic interface TopAdditional extends Top {\n\n}\n\n// FILE: Top.java\npackage org.example;\n\npublic interface Top extends Topmost {\n\n}\n\n// MODULE: middle(top)\n// FILE: middle.kt\npackage org.example\n\ninterface Base : <!CYCLIC_INHERITANCE_HIERARCHY!>MiddleAdditional<!> {\n    fun middle()\n}\n\ninterface MiddleAdditional : <!CYCLIC_INHERITANCE_HIERARCHY!>Middle<!>\n\ninterface Middle : <!CYCLIC_INHERITANCE_HIERARCHY!>Top<!>\n\n// MODULE: bottom(middle)\n// FILE: bottom.kt\npackage org.example\n\ninterface Base : BottomAdditional {\n    fun bottom()\n}\n\ninterface BottomAdditional : Bottom\n\ninterface Bottom : Middle\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators\n\nimport com.intellij.openapi.Disposable\nimport org.jetbrains.kotlin.analysis.api.impl.base.test.configurators.AnalysisApiLibraryBaseTestServiceRegistrar\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtCodeFragmentTestModuleFactory\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModuleFactory\nimport org.jetbrains.kotlin.analysis.test.framework.services.DependencyKindModuleStructureTransformer\nimport org.jetbrains.kotlin.analysis.test.framework.test.configurators.AnalysisApiTestServiceRegistrar\nimport org.jetbrains.kotlin.test.TestInfrastructureInternals\nimport org.jetbrains.kotlin.test.builders.TestConfigurationBuilder\n\nclass AnalysisApiFirCodeFragmentTestConfigurator(\n    analyseInDependentSession: Boolean\n) : AnalysisApiFirSourceLikeTestConfigurator(analyseInDependentSession) {\n    override fun configureTest(builder: TestConfigurationBuilder, disposable: Dis"}
{"code": "posable) {\n        super.configureTest(builder, disposable)\n\n        builder.apply {\n            useAdditionalService<KtTestModuleFactory> { KtCodeFragmentTestModuleFactory }\n\n            @OptIn(TestInfrastructureInternals::class)\n            useModuleStructureTransformers(DependencyKindModuleStructureTransformer)\n        }\n\n        AnalysisApiFirLibraryBinaryDecompiledTestConfigurator.configureLibraryCompilationSupport(builder)\n    }\n\n    override val serviceRegistrars: List<AnalysisApiTestServiceRegistrar>\n        get() = super.serviceRegistrars + AnalysisApiLibraryBaseTestServiceRegistrar\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.fir.resolve.calls\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.fakeElement\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.FirResolvePhase\nimport org.jetbrains.kotlin.fir.expressions.FirCheckNotNullCall\nimport org.jetbrains.kotlin.fir.expressions.FirExpression\nimport org.jetbrains.kotlin.fir.expressions.FirSmartCastExpression\nimport org.jetbrains.kotlin.fir.expressions.arguments\nimport org.jetbrains.kotlin.fir.expressions.builder.buildInaccessibleReceiverExpression\nimport org.jetbrains.kotlin.fir.expressions.builder.buildSmartCastExpression\nimport org.jetbrains.kotlin.fir.expressions.builder.buildThisReceiverExpression\nimport org.jetbrains.kotlin.fir.references.builder.buildImplicitThisReference\nimport org.jetbrains.kotlin.fir.resolve.ScopeSession\nimport org.jetbrains.kotlin.fir.resolve.scope\nimport org.jetbrains.kotlin.fir.resolve.smartcastScope\nimport org.jetbrains.kotlin.fir.sc"}
{"code": "opes.CallableCopyTypeCalculator\nimport org.jetbrains.kotlin.fir.scopes.FirTypeScope\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirScriptSymbol\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.fir.types.builder.buildResolvedTypeRef\nimport org.jetbrains.kotlin.fir.types.constructType\nimport org.jetbrains.kotlin.fir.types.resolvedType\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.types.SmartcastStability\n\nabstract class ReceiverValue {\n    abstract val type: ConeKotlinType\n\n    abstract val receiverExpression: FirExpression\n\n    open fun scope(useSiteSession: FirSession, scopeSession: ScopeSession): FirTypeScope? = type.scope(\n        useSiteSession = useSiteSession,\n        scopeSession = scopeSession,\n        callableCopyTypeCalculator = CallableCopyTypeCalcu"}
{"code": "lator.DoNothing,\n        requiredMembersPhase = FirResolvePhase.STATUS,\n    )\n}\n\nclass ExpressionReceiverValue(override val receiverExpression: FirExpression) : ReceiverValue() {\n    override val type: ConeKotlinType\n        get() = receiverExpression.resolvedType\n\n    override fun scope(useSiteSession: FirSession, scopeSession: ScopeSession): FirTypeScope? {\n        var receiverExpr: FirExpression? = receiverExpression\n        // Unwrap `x!!` to `x` and use the resulted expression to derive receiver type. This is necessary so that smartcast types inside\n        // `!!` is handled correctly.\n        if (receiverExpr is FirCheckNotNullCall) {\n            receiverExpr = receiverExpr.arguments.firstOrNull()\n        }\n\n        if (receiverExpr is FirSmartCastExpression) {\n            return receiverExpr.smartcastScope(\n                useSiteSession,\n                scopeSession,\n                requiredMembersPhase = FirResolvePhase.STATUS,\n            )\n        }\n\n        return type.sco"}
{"code": "pe(\n            useSiteSession,\n            scopeSession,\n            CallableCopyTypeCalculator.DoNothing,\n            requiredMembersPhase = FirResolvePhase.STATUS,\n        )\n    }\n}\n\nsealed class ImplicitReceiverValue<S : FirBasedSymbol<*>>(\n    val boundSymbol: S,\n    type: ConeKotlinType,\n    val useSiteSession: FirSession,\n    protected val scopeSession: ScopeSession,\n    private val mutable: Boolean,\n    val contextReceiverNumber: Int = -1,\n    private val inaccessibleReceiver: Boolean = false\n) : ReceiverValue() {\n    final override var type: ConeKotlinType = type\n        private set\n\n    abstract val isContextReceiver: Boolean\n\n    // Type before smart cast\n    val originalType: ConeKotlinType = type\n\n    var implicitScope: FirTypeScope? =\n        type.scope(\n            useSiteSession,\n            scopeSession,\n            CallableCopyTypeCalculator.DoNothing,\n            requiredMembersPhase = FirResolvePhase.STATUS\n        )\n        private set\n\n    override fun scope(useSi"}
{"code": "teSession: FirSession, scopeSession: ScopeSession): FirTypeScope? = implicitScope\n\n    private var receiverIsSmartcasted: Boolean = false\n    private var originalReceiverExpression: FirExpression =\n        receiverExpression(boundSymbol, type, contextReceiverNumber, inaccessibleReceiver)\n    private var _receiverExpression: FirExpression? = null\n\n    private fun computeReceiverExpression(): FirExpression {\n        _receiverExpression?.let { return it }\n        val actualReceiverExpression = if (receiverIsSmartcasted) {\n            buildSmartCastExpression {\n                originalExpression = originalReceiverExpression\n                smartcastType = buildResolvedTypeRef {\n                    source = originalReceiverExpression.source?.fakeElement(KtFakeSourceElementKind.SmartCastedTypeRef)\n                    type = this@ImplicitReceiverValue.type\n                }\n                typesFromSmartCast = listOf(this@ImplicitReceiverValue.type)\n                smartcastStability = Smartc"}
{"code": "astStability.STABLE_VALUE\n                coneTypeOrNull = this@ImplicitReceiverValue.type\n            }\n        } else {\n            originalReceiverExpression\n        }\n        _receiverExpression = actualReceiverExpression\n        return actualReceiverExpression\n    }\n\n    \n    final override val receiverExpression: FirExpression\n        get() = computeReceiverExpression()\n\n    @RequiresOptIn\n    annotation class ImplicitReceiverInternals\n\n    \n    @ImplicitReceiverInternals\n    fun updateTypeFromSmartcast(type: ConeKotlinType) {\n        if (type == this.type) return\n        if (!mutable) error(\"Cannot mutate an immutable ImplicitReceiverValue\")\n        this.type = type\n        receiverIsSmartcasted = type != this.originalType\n        _receiverExpression = null\n        implicitScope = type.scope(\n            useSiteSession = useSiteSession,\n            scopeSession = scopeSession,\n            callableCopyTypeCalculator = CallableCopyTypeCalculator.DoNothing,\n            requiredMemb"}
{"code": "ersPhase = FirResolvePhase.STATUS,\n        )\n    }\n\n    abstract fun createSnapshot(keepMutable: Boolean): ImplicitReceiverValue<S>\n}\n\nprivate fun receiverExpression(\n    symbol: FirBasedSymbol<*>,\n    type: ConeKotlinType,\n    contextReceiverNumber: Int,\n    inaccessibleReceiver: Boolean\n): FirExpression {\n    // NB: we can't use `symbol.fir.source` as the source of `this` receiver. For instance, if this is an implicit receiver for a class,\n    // the entire class itself will be set as a source. If combined with an implicit type operation, a certain assertion, like null\n    // check assertion, will retrieve source as an assertion message, which is literally the entire class (!).\n    val calleeReference = buildImplicitThisReference {\n        boundSymbol = symbol\n        this.contextReceiverNumber = contextReceiverNumber\n    }\n    return when (inaccessibleReceiver) {\n        false -> buildThisReceiverExpression {\n            this.calleeReference = calleeReference\n            this.coneTy"}
{"code": "peOrNull = type\n            isImplicit = true\n        }\n        true -> buildInaccessibleReceiverExpression {\n            this.calleeReference = calleeReference\n            this.coneTypeOrNull = type\n        }\n    }\n}\n\nclass ImplicitDispatchReceiverValue(\n    boundSymbol: FirClassSymbol<*>,\n    type: ConeKotlinType,\n    useSiteSession: FirSession,\n    scopeSession: ScopeSession,\n    mutable: Boolean = true,\n) : ImplicitReceiverValue<FirClassSymbol<*>>(boundSymbol, type, useSiteSession, scopeSession, mutable) {\n    constructor(\n        boundSymbol: FirClassSymbol<*>, useSiteSession: FirSession, scopeSession: ScopeSession\n    ) : this(\n        boundSymbol, boundSymbol.constructType(typeArguments = emptyArray(), isNullable = false),\n        useSiteSession, scopeSession\n    )\n\n    override fun createSnapshot(keepMutable: Boolean): ImplicitReceiverValue<FirClassSymbol<*>> {\n        return ImplicitDispatchReceiverValue(boundSymbol, type, useSiteSession, scopeSession, keepMutable)\n    }\n\n    "}
{"code": "override val isContextReceiver: Boolean\n        get() = false\n}\n\nclass ImplicitExtensionReceiverValue(\n    boundSymbol: FirCallableSymbol<*>,\n    type: ConeKotlinType,\n    useSiteSession: FirSession,\n    scopeSession: ScopeSession,\n    mutable: Boolean = true,\n) : ImplicitReceiverValue<FirCallableSymbol<*>>(boundSymbol, type, useSiteSession, scopeSession, mutable) {\n    override fun createSnapshot(keepMutable: Boolean): ImplicitReceiverValue<FirCallableSymbol<*>> {\n        return ImplicitExtensionReceiverValue(boundSymbol, type, useSiteSession, scopeSession, keepMutable)\n    }\n\n    override val isContextReceiver: Boolean\n        get() = false\n}\n\n\nclass InaccessibleImplicitReceiverValue(\n    boundSymbol: FirClassSymbol<*>,\n    type: ConeKotlinType,\n    useSiteSession: FirSession,\n    scopeSession: ScopeSession,\n    mutable: Boolean = true,\n) : ImplicitReceiverValue<FirClassSymbol<*>>(boundSymbol, type, useSiteSession, scopeSession, mutable, inaccessibleReceiver = true) {\n    override fu"}
{"code": "n createSnapshot(keepMutable: Boolean): ImplicitReceiverValue<FirClassSymbol<*>> {\n        return InaccessibleImplicitReceiverValue(boundSymbol, type, useSiteSession, scopeSession, keepMutable)\n    }\n\n    override val isContextReceiver: Boolean\n        get() = false\n}\n\nsealed class ContextReceiverValue<S : FirBasedSymbol<*>>(\n    boundSymbol: S,\n    type: ConeKotlinType,\n    val labelName: Name?,\n    useSiteSession: FirSession,\n    scopeSession: ScopeSession,\n    mutable: Boolean = true,\n    contextReceiverNumber: Int,\n) : ImplicitReceiverValue<S>(\n    boundSymbol, type, useSiteSession, scopeSession, mutable, contextReceiverNumber,\n) {\n    abstract override fun createSnapshot(keepMutable: Boolean): ContextReceiverValue<S>\n\n    override val isContextReceiver: Boolean\n        get() = true\n}\n\nclass ContextReceiverValueForCallable(\n    boundSymbol: FirCallableSymbol<*>,\n    type: ConeKotlinType,\n    labelName: Name?,\n    useSiteSession: FirSession,\n    scopeSession: ScopeSession,\n    mutab"}
{"code": "le: Boolean = true,\n    contextReceiverNumber: Int,\n) : ContextReceiverValue<FirCallableSymbol<*>>(\n    boundSymbol, type, labelName, useSiteSession, scopeSession, mutable, contextReceiverNumber\n) {\n    override fun createSnapshot(keepMutable: Boolean): ContextReceiverValue<FirCallableSymbol<*>> =\n        ContextReceiverValueForCallable(boundSymbol, type, labelName, useSiteSession, scopeSession, keepMutable, contextReceiverNumber)\n}\n\nclass ContextReceiverValueForClass(\n    boundSymbol: FirClassSymbol<*>,\n    type: ConeKotlinType,\n    labelName: Name?,\n    useSiteSession: FirSession,\n    scopeSession: ScopeSession,\n    mutable: Boolean = true,\n    contextReceiverNumber: Int,\n) : ContextReceiverValue<FirClassSymbol<*>>(\n    boundSymbol, type, labelName, useSiteSession, scopeSession, mutable, contextReceiverNumber\n) {\n    override fun createSnapshot(keepMutable: Boolean): ContextReceiverValue<FirClassSymbol<*>> =\n        ContextReceiverValueForClass(boundSymbol, type, labelName, useSiteSe"}
{"code": "ssion, scopeSession, keepMutable, contextReceiverNumber)\n}\n\nclass ImplicitReceiverValueForScript(\n    boundSymbol: FirScriptSymbol,\n    type: ConeKotlinType,\n    labelName: Name?,\n    useSiteSession: FirSession,\n    scopeSession: ScopeSession,\n    mutable: Boolean = true,\n    contextReceiverNumber: Int,\n) : ContextReceiverValue<FirScriptSymbol>(\n    boundSymbol, type, labelName, useSiteSession, scopeSession, mutable, contextReceiverNumber\n) {\n    override fun createSnapshot(keepMutable: Boolean): ContextReceiverValue<FirScriptSymbol> =\n        ImplicitReceiverValueForScript(boundSymbol, type, labelName, useSiteSession, scopeSession, keepMutable, contextReceiverNumber)\n}\n\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.sessions\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.search.GlobalSearchScope\nimport com.intellij.psi.search.ProjectScope\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.LLFirGlobalResolveComponents\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.LLFirLazyDeclarationResolver\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.LLFirModuleResolveComponents\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.project.structure.*\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.providers.*\nimport org.jetbrains.kotlin.analysis.project.structure.*\nimport org.jetbrains.kotlin.analysis.providers.KotlinAnchorModuleProvider\nimport org.jetbrains.kotlin.analysis.providers.KotlinDeclarationProvider\nimport org.jetbrains.kotlin.analysis.providers.createAnnotationResolver\nimport org.jetbrains.kotlin.analysis.providers.createDeclarationProvider\nimport org.jetbrains.kotlin.analysis.providers.impl."}
{"code": "declarationProviders.FileBasedKotlinDeclarationProvider\nimport org.jetbrains.kotlin.analysis.providers.impl.util.mergeInto\nimport org.jetbrains.kotlin.analysis.utils.errors.withKtModuleEntry\nimport org.jetbrains.kotlin.assignment.plugin.AssignmentCommandLineProcessor\nimport org.jetbrains.kotlin.assignment.plugin.AssignmentConfigurationKeys\nimport org.jetbrains.kotlin.assignment.plugin.k2.FirAssignmentPluginExtensionRegistrar\nimport org.jetbrains.kotlin.cli.plugins.processCompilerPluginsOptions\nimport org.jetbrains.kotlin.compiler.plugin.ExperimentalCompilerApi\nimport org.jetbrains.kotlin.config.CompilerConfiguration\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.config.LanguageVersionSettings\nimport org.jetbrains.kotlin.fir.BuiltinTypes\nimport org.jetbrains.kotlin.fir.PrivateSessionConstructor\nimport org.jetbrains.kotlin.fir.SessionConfiguration\nimport org.jetbrains.kotlin.fir.analysis.checkersComponent\nimport org.jetbrains.kotlin.fir.analysis.extensions"}
{"code": ".additionalCheckers\nimport org.jetbrains.kotlin.fir.backend.jvm.FirJvmTypeMapper\nimport org.jetbrains.kotlin.fir.extensions.*\nimport org.jetbrains.kotlin.fir.java.JavaSymbolProvider\nimport org.jetbrains.kotlin.fir.languageVersionSettings\nimport org.jetbrains.kotlin.fir.resolve.providers.DEPENDENCIES_SYMBOL_PROVIDER_QUALIFIED_KEY\nimport org.jetbrains.kotlin.fir.resolve.providers.FirProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.dependenciesSymbolProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.impl.FirCompositeSymbolProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.impl.FirExtensionSyntheticFunctionInterfaceProvider\nimport org.jetbrains.kotlin.fir.resolve.providers.symbolProvider\nimport org.jetbrains.kotlin.fir.resolve.scopes.wrapScopeWithJvmMapped\nimport org.jetbrains.kotlin.fir.resolve.transformers.FirDummyCompilerLazyDeclarationResolver\nimport org.jetbrains.kotlin.fir.scopes.FirKotlinSc"}
{"code": "opeProvider\nimport org.jetbrains.kotlin.fir.session.*\nimport org.jetbrains.kotlin.fir.symbols.FirLazyDeclarationResolver\nimport org.jetbrains.kotlin.platform.jvm.JvmPlatforms\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.resolve.jvm.modules.JavaModuleResolver\nimport org.jetbrains.kotlin.scripting.compiler.plugin.FirScriptingSamWithReceiverExtensionRegistrar\nimport org.jetbrains.kotlin.scripting.definitions.findScriptDefinition\nimport org.jetbrains.kotlin.utils.exceptions.errorWithAttachment\nimport org.jetbrains.kotlin.utils.exceptions.requireWithAttachment\nimport org.jetbrains.kotlin.utils.exceptions.withPsiEntry\nimport org.jetbrains.kotlin.utils.exceptions.withVirtualFileEntry\nimport kotlin.script.experimental.host.ScriptingHostConfiguration\nimport kotlin.script.experimental.jvm.defaultJvmScriptingHostConfiguration\nimport org.jetbrains.kotlin.fir.session.FirSessionFactoryHelper.registerDefaultComponents\nimport org.jetbrains.kotlin.scripting.compiler.plugin.impl.ma"}
{"code": "keScriptCompilerArguments\n\n@OptIn(PrivateSessionConstructor::class, SessionConfiguration::class)\ninternal abstract class LLFirAbstractSessionFactory(protected val project: Project) {\n    private val globalResolveComponents: LLFirGlobalResolveComponents\n        get() = LLFirGlobalResolveComponents.getInstance(project)\n\n    abstract fun createSourcesSession(module: KtSourceModule): LLFirSourcesSession\n    abstract fun createLibrarySession(module: KtModule): LLFirLibraryOrLibrarySourceResolvableModuleSession\n    abstract fun createBinaryLibrarySession(module: KtBinaryModule): LLFirLibrarySession\n\n    private fun createLibraryProvidersForScope(\n        session: LLFirSession,\n        moduleData: LLFirModuleData,\n        kotlinScopeProvider: FirKotlinScopeProvider,\n        project: Project,\n        builtinTypes: BuiltinTypes,\n        scope: GlobalSearchScope,\n        builtinSymbolProvider: FirSymbolProvider,\n    ): LLFirModuleWithDependenciesSymbolProvider {\n        return LLFirModuleWithDep"}
{"code": "endenciesSymbolProvider(\n            session,\n            providers = createProjectLibraryProvidersForScope(\n                session,\n                moduleData,\n                kotlinScopeProvider,\n                project,\n                builtinTypes,\n                scope\n            ),\n            LLFirDependenciesSymbolProvider(session) {\n                buildList {\n                    addAll(collectDependencySymbolProviders(moduleData.ktModule))\n                    add(builtinSymbolProvider)\n                }\n            },\n        )\n    }\n\n    abstract fun createProjectLibraryProvidersForScope(\n        session: LLFirSession,\n        moduleData: LLFirModuleData,\n        kotlinScopeProvider: FirKotlinScopeProvider,\n        project: Project,\n        builtinTypes: BuiltinTypes,\n        scope: GlobalSearchScope,\n        isFallbackDependenciesProvider: Boolean = false,\n    ): List<FirSymbolProvider>\n\n    fun createScriptSession(module: KtScriptModule): LLFirScriptSession {\n        val"}
{"code": " platform = module.platform\n        val builtinsSession = LLFirBuiltinsSessionFactory.getInstance(project).getBuiltinsSession(platform)\n        val languageVersionSettings = wrapLanguageVersionSettings(module.languageVersionSettings)\n        val scopeProvider = FirKotlinScopeProvider(::wrapScopeWithJvmMapped)\n\n        val components = LLFirModuleResolveComponents(module, globalResolveComponents, scopeProvider)\n\n        val session = LLFirScriptSession(module, components, builtinsSession.builtinTypes)\n        components.session = session\n\n        val moduleData = createModuleData(session)\n\n        return session.apply {\n            registerModuleData(moduleData)\n            register(FirKotlinScopeProvider::class, scopeProvider)\n\n            registerAllCommonComponents(languageVersionSettings)\n\n            registerCommonComponentsAfterExtensionsAreConfigured()\n            registerJavaComponents(JavaModuleResolver.getInstance(project))\n\n\n            val provider = LLFirProvider(\n         "}
{"code": "       this,\n                components,\n                canContainKotlinPackage = true,\n            ) { scope ->\n                scope.createScopedDeclarationProviderForFile(module.file)\n            }\n\n            register(FirProvider::class, provider)\n            register(FirLazyDeclarationResolver::class, LLFirLazyDeclarationResolver())\n\n            val dependencyProvider = LLFirDependenciesSymbolProvider(this) {\n                buildList {\n                    addMerged(collectDependencySymbolProviders(module))\n                    add(builtinsSession.symbolProvider)\n                }\n            }\n\n            val javaSymbolProvider = LLFirJavaSymbolProvider(this, moduleData, project, provider.searchScope)\n            register(JavaSymbolProvider::class, javaSymbolProvider)\n\n            register(\n                FirSymbolProvider::class,\n                LLFirModuleWithDependenciesSymbolProvider(\n                    this,\n                    providers = listOfNotNull(\n                "}
{"code": "        javaSymbolProvider,\n                        provider.symbolProvider,\n                    ),\n                    dependencyProvider,\n                )\n            )\n\n            register(FirPredicateBasedProvider::class, FirEmptyPredicateBasedProvider)\n            register(DEPENDENCIES_SYMBOL_PROVIDER_QUALIFIED_KEY, dependencyProvider)\n            register(FirRegisteredPluginAnnotations::class, FirRegisteredPluginAnnotationsImpl(this))\n            register(FirJvmTypeMapper::class, FirJvmTypeMapper(this))\n\n            registerScriptExtensions(this, module.file)\n\n            LLFirSessionConfigurator.configure(this)\n        }\n    }\n\n    @OptIn(ExperimentalCompilerApi::class)\n    private fun registerScriptExtensions(session: LLFirSession, file: KtFile) {\n        FirSessionConfigurator(session).apply {\n            val hostConfiguration = ScriptingHostConfiguration(defaultJvmScriptingHostConfiguration) {}\n            val scriptDefinition = file.findScriptDefinition()\n                ?"}
{"code": ": errorWithAttachment(\"Cannot load script definition\") {\n                    withVirtualFileEntry(\"file\", file.virtualFile)\n                }\n\n            val compilerArguments = makeScriptCompilerArguments(scriptDefinition.compilerOptions.toList())\n            val commandLineProcessors = listOf(AssignmentCommandLineProcessor())\n            val compilerConfiguration = CompilerConfiguration()\n            processCompilerPluginsOptions(\n                compilerConfiguration, compilerArguments.pluginOptions?.asIterable() ?: emptyList(), commandLineProcessors\n            )\n\n            val extensionRegistrar = FirScriptingCompilerExtensionIdeRegistrar(\n                project,\n                hostConfiguration,\n                scriptDefinitionSources = emptyList(),\n                scriptDefinitions = listOf(scriptDefinition)\n            )\n\n            registerExtensions(extensionRegistrar.configure())\n            registerExtensions(FirScriptingSamWithReceiverExtensionRegistrar().configure()"}
{"code": ")\n            compilerConfiguration.getList(AssignmentConfigurationKeys.ANNOTATION).takeIf { it.isNotEmpty() }?.let {\n                registerExtensions(FirAssignmentPluginExtensionRegistrar(it).configure())\n            }\n        }.configure()\n    }\n\n    fun createNotUnderContentRootResolvableSession(module: KtNotUnderContentRootModule): LLFirNotUnderContentRootResolvableModuleSession {\n        val builtinsSession = LLFirBuiltinsSessionFactory.getInstance(project).getBuiltinsSession(JvmPlatforms.unspecifiedJvmPlatform)\n        val languageVersionSettings = ProjectStructureProvider.getInstance(project).globalLanguageVersionSettings\n        val scopeProvider = FirKotlinScopeProvider(::wrapScopeWithJvmMapped)\n        val components = LLFirModuleResolveComponents(module, globalResolveComponents, scopeProvider)\n\n        val session = LLFirNotUnderContentRootResolvableModuleSession(module, components, builtinsSession.builtinTypes)\n        components.session = session\n\n        val moduleData "}
{"code": "= createModuleData(session)\n\n        return session.apply {\n            registerModuleData(moduleData)\n            register(FirKotlinScopeProvider::class, scopeProvider)\n\n            registerAllCommonComponents(languageVersionSettings)\n\n            registerCommonComponentsAfterExtensionsAreConfigured()\n            registerJavaComponents(JavaModuleResolver.getInstance(project))\n\n\n            val ktFile = module.file as? KtFile\n\n            val provider = LLFirProvider(\n                this,\n                components,\n                canContainKotlinPackage = true,\n            ) { scope ->\n                ktFile?.let { scope.createScopedDeclarationProviderForFile(it) }\n            }\n\n            register(FirProvider::class, provider)\n            register(FirLazyDeclarationResolver::class, LLFirLazyDeclarationResolver())\n\n            val dependencyProvider = LLFirDependenciesSymbolProvider(this) { listOf(builtinsSession.symbolProvider) }\n\n            register(\n                FirSymbolPr"}
{"code": "ovider::class,\n                LLFirModuleWithDependenciesSymbolProvider(\n                    this,\n                    providers = listOf(\n                        provider.symbolProvider,\n                    ),\n                    dependencyProvider,\n                )\n            )\n\n            register(FirPredicateBasedProvider::class, FirEmptyPredicateBasedProvider)\n            register(DEPENDENCIES_SYMBOL_PROVIDER_QUALIFIED_KEY, dependencyProvider)\n            register(FirJvmTypeMapper::class, FirJvmTypeMapper(this))\n            register(FirRegisteredPluginAnnotations::class, FirRegisteredPluginAnnotations.Empty)\n\n            LLFirSessionConfigurator.configure(this)\n        }\n    }\n\n    protected class SourceSessionCreationContext(\n        val moduleData: LLFirModuleData,\n        val contentScope: GlobalSearchScope,\n        val firProvider: LLFirProvider,\n        val dependencyProvider: LLFirDependenciesSymbolProvider,\n        val syntheticFunctionInterfaceProvider: FirExtensionSyn"}
{"code": "theticFunctionInterfaceProvider?,\n        val switchableExtensionDeclarationsSymbolProvider: FirSwitchableExtensionDeclarationsSymbolProvider?,\n    )\n\n    protected fun doCreateSourcesSession(\n        module: KtSourceModule,\n        scopeProvider: FirKotlinScopeProvider = FirKotlinScopeProvider(),\n        additionalSessionConfiguration: LLFirSourcesSession.(context: SourceSessionCreationContext) -> Unit,\n    ): LLFirSourcesSession {\n        val platform = module.platform\n        val builtinsSession = LLFirBuiltinsSessionFactory.getInstance(project).getBuiltinsSession(platform)\n        val languageVersionSettings = wrapLanguageVersionSettings(module.languageVersionSettings)\n\n        val components = LLFirModuleResolveComponents(module, globalResolveComponents, scopeProvider)\n\n        val session = LLFirSourcesSession(module, components, builtinsSession.builtinTypes)\n        components.session = session\n\n        val moduleData = createModuleData(session)\n\n        return session.apply {\n "}
{"code": "           registerModuleData(moduleData)\n            register(FirKotlinScopeProvider::class, scopeProvider)\n\n            registerAllCommonComponents(languageVersionSettings)\n\n            val firProvider = LLFirProvider(\n                this,\n                components,\n                \n                canContainKotlinPackage = false,\n            ) { scope ->\n                project.createDeclarationProvider(scope, module)\n            }\n\n            register(FirProvider::class, firProvider)\n            register(FirLazyDeclarationResolver::class, LLFirLazyDeclarationResolver())\n\n            registerCompilerPluginServices(project, module)\n            registerCompilerPluginExtensions(project, module)\n            registerCommonComponentsAfterExtensionsAreConfigured()\n\n            val dependencyProvider = LLFirDependenciesSymbolProvider(this) {\n                buildList {\n                    addMerged(collectDependencySymbolProviders(module))\n                    add(builtinsSession.symbolPr"}
{"code": "ovider)\n                }\n            }\n\n            register(DEPENDENCIES_SYMBOL_PROVIDER_QUALIFIED_KEY, dependencyProvider)\n            register(LLFirFirClassByPsiClassProvider::class, LLFirFirClassByPsiClassProvider(this))\n\n            LLFirSessionConfigurator.configure(this)\n\n            extensionService.additionalCheckers.forEach(session.checkersComponent::register)\n\n            val syntheticFunctionInterfaceProvider =\n                FirExtensionSyntheticFunctionInterfaceProvider.createIfNeeded(this, moduleData, scopeProvider)\n            val switchableExtensionDeclarationsSymbolProvider =\n                FirSwitchableExtensionDeclarationsSymbolProvider.createIfNeeded(this)?.also {\n                    register(FirSwitchableExtensionDeclarationsSymbolProvider::class, it)\n                }\n\n            val context = SourceSessionCreationContext(\n                moduleData, firProvider.searchScope, firProvider, dependencyProvider, syntheticFunctionInterfaceProvider,\n                "}
{"code": "switchableExtensionDeclarationsSymbolProvider,\n            )\n            additionalSessionConfiguration(context)\n        }\n    }\n\n    protected class LibrarySessionCreationContext(\n        val moduleData: LLFirModuleData,\n        val contentScope: GlobalSearchScope,\n        val firProvider: LLFirProvider,\n        val dependencyProvider: LLFirDependenciesSymbolProvider\n    )\n\n    protected fun doCreateLibrarySession(\n        module: KtModule,\n        additionalSessionConfiguration: LLFirLibraryOrLibrarySourceResolvableModuleSession.(context: LibrarySessionCreationContext) -> Unit\n    ): LLFirLibraryOrLibrarySourceResolvableModuleSession {\n        val libraryModule = when (module) {\n            is KtLibraryModule -> module\n            is KtLibrarySourceModule -> module.binaryLibrary\n            else -> errorWithAttachment(\"Unexpected module ${module::class.simpleName}\") {\n                withKtModuleEntry(\"module\", module)\n            }\n        }\n\n        val platform = module.platform\n "}
{"code": "       val builtinsSession = LLFirBuiltinsSessionFactory.getInstance(project).getBuiltinsSession(platform)\n        val languageVersionSettings = ProjectStructureProvider.getInstance(project).libraryLanguageVersionSettings\n\n        val scopeProvider = FirKotlinScopeProvider()\n        val components = LLFirModuleResolveComponents(module, globalResolveComponents, scopeProvider)\n\n        val session = LLFirLibraryOrLibrarySourceResolvableModuleSession(module, components, builtinsSession.builtinTypes)\n        components.session = session\n\n        val moduleData = createModuleData(session)\n\n        return session.apply {\n            registerModuleData(moduleData)\n            register(FirKotlinScopeProvider::class, scopeProvider)\n\n            registerAllCommonComponents(languageVersionSettings)\n            registerCommonComponentsAfterExtensionsAreConfigured()\n\n            val firProvider = LLFirProvider(\n                this,\n                components,\n                canContainKotlinPackag"}
{"code": "e = true,\n            ) { scope ->\n                project.createDeclarationProvider(scope, module)\n            }\n\n            register(FirProvider::class, firProvider)\n\n            register(FirLazyDeclarationResolver::class, LLFirLazyDeclarationResolver())\n\n            // We need FirRegisteredPluginAnnotations during extensions' registration process\n            val annotationsResolver = project.createAnnotationResolver(firProvider.searchScope)\n            register(FirRegisteredPluginAnnotations::class, LLFirIdeRegisteredPluginAnnotations(this, annotationsResolver))\n            register(FirPredicateBasedProvider::class, FirEmptyPredicateBasedProvider)\n\n            val dependencyProvider = LLFirDependenciesSymbolProvider(this) {\n                buildList {\n                    add(builtinsSession.symbolProvider)\n\n                    // Script dependencies are self-contained and should not depend on other libraries\n                    if (module !is KtScriptDependencyModule) {\n           "}
{"code": "             // Add all libraries excluding the current one\n                        val librariesSearchScope = ProjectScope.getLibrariesScope(project)\n                            .intersectWith(GlobalSearchScope.notScope(libraryModule.contentScope))\n\n                        val restLibrariesProvider = createProjectLibraryProvidersForScope(\n                            session,\n                            moduleData,\n                            scopeProvider,\n                            project,\n                            builtinTypes,\n                            librariesSearchScope,\n                            isFallbackDependenciesProvider = true,\n                        )\n\n                        addAll(restLibrariesProvider)\n\n                        KotlinAnchorModuleProvider.getInstance(project)?.getAnchorModule(libraryModule)?.let { anchorModule ->\n                            val anchorModuleSession = LLFirSessionCache.getInstance(project).getSession(anchorModule)\n               "}
{"code": "             val anchorModuleSymbolProvider = anchorModuleSession.symbolProvider as LLFirModuleWithDependenciesSymbolProvider\n\n                            addAll(anchorModuleSymbolProvider.providers)\n                            addAll(anchorModuleSymbolProvider.dependencyProvider.providers)\n                        }\n                    }\n                }\n            }\n\n            register(DEPENDENCIES_SYMBOL_PROVIDER_QUALIFIED_KEY, dependencyProvider)\n            register(LLFirFirClassByPsiClassProvider::class, LLFirFirClassByPsiClassProvider(this))\n\n            val context = LibrarySessionCreationContext(moduleData, firProvider.searchScope, firProvider, dependencyProvider)\n            additionalSessionConfiguration(context)\n\n            LLFirSessionConfigurator.configure(this)\n        }\n    }\n\n    protected class BinaryLibrarySessionCreationContext\n\n    protected fun doCreateBinaryLibrarySession(\n        module: KtBinaryModule,\n        additionalSessionConfiguration: LLFirLibrarySes"}
{"code": "sion.(context: BinaryLibrarySessionCreationContext) -> Unit,\n    ): LLFirLibrarySession {\n        val platform = module.platform\n        val builtinsSession = LLFirBuiltinsSessionFactory.getInstance(project).getBuiltinsSession(platform)\n\n        val session = LLFirLibrarySession(module, builtinsSession.builtinTypes)\n\n        val moduleData = createModuleData(session)\n\n        return session.apply {\n            registerModuleData(moduleData)\n            registerIdeComponents(project)\n            register(FirLazyDeclarationResolver::class, FirDummyCompilerLazyDeclarationResolver)\n            registerCommonComponents(ProjectStructureProvider.getInstance(project).libraryLanguageVersionSettings)\n            registerCommonComponentsAfterExtensionsAreConfigured()\n            registerDefaultComponents()\n\n            val kotlinScopeProvider = FirKotlinScopeProvider(::wrapScopeWithJvmMapped)\n            register(FirKotlinScopeProvider::class, kotlinScopeProvider)\n\n            val symbolProvider "}
{"code": "= createLibraryProvidersForScope(\n                this,\n                moduleData,\n                kotlinScopeProvider,\n                project,\n                builtinTypes,\n                module.contentScope,\n                builtinsSession.symbolProvider\n            )\n\n            register(LLFirFirClassByPsiClassProvider::class, LLFirFirClassByPsiClassProvider(this))\n            register(FirProvider::class, LLFirLibrarySessionProvider(symbolProvider))\n            register(FirSymbolProvider::class, symbolProvider)\n\n            val context = BinaryLibrarySessionCreationContext()\n            additionalSessionConfiguration(context)\n            LLFirSessionConfigurator.configure(this)\n        }\n    }\n\n    abstract fun createDanglingFileSession(module: KtDanglingFileModule, contextSession: LLFirSession): LLFirSession\n\n    protected fun doCreateDanglingFileSession(\n        module: KtDanglingFileModule,\n        contextSession: LLFirSession,\n        additionalSessionConfiguration: context("}
{"code": "DanglingFileSessionCreationContext) LLFirDanglingFileSession.() -> Unit,\n    ): LLFirSession {\n        val danglingFile = module.file\n        val platform = module.platform\n\n        val builtinsSession = LLFirBuiltinsSessionFactory.getInstance(project).getBuiltinsSession(platform)\n        val languageVersionSettings = wrapLanguageVersionSettings(contextSession.languageVersionSettings)\n        val scopeProvider = FirKotlinScopeProvider(::wrapScopeWithJvmMapped)\n\n        val components = LLFirModuleResolveComponents(module, globalResolveComponents, scopeProvider)\n\n        val session = LLFirDanglingFileSession(module, components, builtinsSession.builtinTypes, danglingFile.modificationStamp)\n        components.session = session\n\n        val moduleData = createModuleData(session)\n\n        return session.apply {\n            registerModuleData(moduleData)\n            register(FirKotlinScopeProvider::class, scopeProvider)\n\n            registerAllCommonComponents(languageVersionSettings)\n\n    "}
{"code": "        val firProvider = LLFirProvider(\n                this,\n                components,\n                canContainKotlinPackage = true,\n                disregardSelfDeclarations = module.resolutionMode == DanglingFileResolutionMode.IGNORE_SELF,\n                declarationProviderFactory = { scope -> scope.createScopedDeclarationProviderForFile(danglingFile) }\n            )\n\n            register(FirProvider::class, firProvider)\n            register(FirLazyDeclarationResolver::class, LLFirLazyDeclarationResolver())\n\n            val contextModule = module.contextModule\n            if (contextModule is KtSourceModule) {\n                registerCompilerPluginServices(project, contextModule)\n                registerCompilerPluginExtensions(project, contextModule)\n            } else {\n                register(FirRegisteredPluginAnnotations::class, FirRegisteredPluginAnnotationsImpl(this))\n                register(FirPredicateBasedProvider::class, FirEmptyPredicateBasedProvider)\n           "}
{"code": " }\n\n            registerCommonComponentsAfterExtensionsAreConfigured()\n\n            val dependencyProvider = LLFirDependenciesSymbolProvider(this) {\n                val providers = buildList {\n                    addMerged(computeFlattenedSymbolProviders(listOf(contextSession)))\n                    add(contextSession.dependenciesSymbolProvider) // Add the context module dependency symbol provider as is\n                    add(builtinsSession.symbolProvider)\n                }\n\n                // Wrap dependencies into a single classpath-filtering provider\n                listOf(LLFirDanglingFileDependenciesSymbolProvider(FirCompositeSymbolProvider(session, providers)))\n            }\n\n            register(DEPENDENCIES_SYMBOL_PROVIDER_QUALIFIED_KEY, dependencyProvider)\n            register(LLFirFirClassByPsiClassProvider::class, LLFirFirClassByPsiClassProvider(this))\n\n            LLFirSessionConfigurator.configure(this)\n\n            extensionService.additionalCheckers.forEach(session.chec"}
{"code": "kersComponent::register)\n\n            val syntheticFunctionInterfaceProvider = FirExtensionSyntheticFunctionInterfaceProvider\n                .createIfNeeded(this, moduleData, scopeProvider)\n\n            val switchableExtensionDeclarationsSymbolProvider = FirSwitchableExtensionDeclarationsSymbolProvider\n                .createIfNeeded(this)\n                ?.also { register(FirSwitchableExtensionDeclarationsSymbolProvider::class, it) }\n\n            if (contextModule is KtScriptModule) {\n                registerScriptExtensions(this, contextModule.file)\n            }\n\n            val context = DanglingFileSessionCreationContext(\n                moduleData,\n                firProvider,\n                dependencyProvider,\n                syntheticFunctionInterfaceProvider,\n                switchableExtensionDeclarationsSymbolProvider\n            )\n\n            additionalSessionConfiguration(context, this)\n        }\n    }\n\n    protected class DanglingFileSessionCreationContext(\n        val"}
{"code": " moduleData: LLFirModuleData,\n        val firProvider: LLFirProvider,\n        val dependencyProvider: LLFirDependenciesSymbolProvider,\n        val syntheticFunctionInterfaceProvider: FirExtensionSyntheticFunctionInterfaceProvider?,\n        val switchableExtensionDeclarationsSymbolProvider: FirSwitchableExtensionDeclarationsSymbolProvider?,\n    )\n\n    private fun wrapLanguageVersionSettings(original: LanguageVersionSettings): LanguageVersionSettings {\n        return object : LanguageVersionSettings by original {\n            override fun getFeatureSupport(feature: LanguageFeature): LanguageFeature.State {\n                return when (feature) {\n                    LanguageFeature.EnableDfaWarningsInK2 -> LanguageFeature.State.ENABLED\n                    else -> original.getFeatureSupport(feature)\n                }\n            }\n\n            override fun supportsFeature(feature: LanguageFeature): Boolean {\n                return when (getFeatureSupport(feature)) {\n                    Lang"}
{"code": "uageFeature.State.ENABLED, LanguageFeature.State.ENABLED_WITH_WARNING -> true\n                    else -> false\n                }\n            }\n        }\n    }\n\n    private fun collectDependencySymbolProviders(module: KtModule): List<FirSymbolProvider> {\n        val llFirSessionCache = LLFirSessionCache.getInstance(project)\n\n        fun getOrCreateSessionForDependency(dependency: KtModule): LLFirSession? = when (dependency) {\n            is KtBuiltinsModule -> null // Built-ins are already added\n\n            is KtBinaryModule -> llFirSessionCache.getSession(dependency, preferBinary = true)\n\n            is KtSourceModule -> llFirSessionCache.getSession(dependency)\n\n            is KtDanglingFileModule -> {\n                requireWithAttachment(dependency.isStable, message = { \"Unstable dangling modules cannot be used as a dependency\" }) {\n                    withKtModuleEntry(\"module\", module)\n                    withKtModuleEntry(\"dependency\", dependency)\n                    withPsiEntr"}
{"code": "y(\"dependencyFile\", dependency.file)\n                }\n                llFirSessionCache.getSession(dependency)\n            }\n\n            is KtScriptModule,\n            is KtScriptDependencyModule,\n            is KtNotUnderContentRootModule,\n            is KtLibrarySourceModule,\n            -> {\n                errorWithAttachment(\"Module ${module::class} cannot depend on ${dependency::class}\") {\n                    withKtModuleEntry(\"module\", module)\n                    withKtModuleEntry(\"dependency\", dependency)\n                }\n            }\n        }\n\n        // Please update KmpModuleSorterTest#buildDependenciesToTest if the logic of collecting dependencies changes\n        val dependencyModules = buildSet {\n            addAll(module.directRegularDependencies)\n            addAll(module.directFriendDependencies)\n\n            // The dependency provider needs to have access to all direct and indirect `dependsOn` dependencies, as `dependsOn`\n            // dependencies are transitive"}
{"code": ".\n            addAll(module.transitiveDependsOnDependencies)\n        }\n\n        val orderedDependencyModules = KmpModuleSorter.order(dependencyModules.toList())\n\n        val dependencySessions = orderedDependencyModules.mapNotNull(::getOrCreateSessionForDependency)\n        return computeFlattenedSymbolProviders(dependencySessions)\n    }\n\n    private fun computeFlattenedSymbolProviders(dependencySessions: List<LLFirSession>): List<FirSymbolProvider> {\n        return dependencySessions.flatMap { session ->\n            when (val dependencyProvider = session.symbolProvider) {\n                is LLFirModuleWithDependenciesSymbolProvider -> dependencyProvider.providers\n                else -> listOf(dependencyProvider)\n            }\n        }\n    }\n\n    private fun createModuleData(session: LLFirSession): LLFirModuleData {\n        return LLFirModuleData(session)\n    }\n\n    private fun LLFirSession.registerAllCommonComponents(languageVersionSettings: LanguageVersionSettings) {\n        registe"}
{"code": "rIdeComponents(project)\n        registerCommonComponents(languageVersionSettings)\n        registerResolveComponents()\n        registerDefaultComponents()\n    }\n\n    \n    context(LLFirSession)\n    private fun MutableList<FirSymbolProvider>.addMerged(dependencies: List<FirSymbolProvider>) {\n        dependencies.mergeDependencySymbolProvidersInto(this@LLFirSession, this)\n    }\n\n    \n    private fun List<FirSymbolProvider>.mergeDependencySymbolProvidersInto(\n        session: LLFirSession,\n        destination: MutableList<FirSymbolProvider>,\n    ) {\n        mergeInto(destination) {\n            merge<LLFirProvider.SymbolProvider> { LLFirCombinedKotlinSymbolProvider.merge(session, project, it) }\n            merge<LLFirJavaSymbolProvider> { LLFirCombinedJavaSymbolProvider.merge(session, project, it) }\n            merge<FirExtensionSyntheticFunctionInterfaceProvider> { LLFirCombinedSyntheticFunctionSymbolProvider.merge(session, it) }\n        }\n    }\n\n    \n    private fun GlobalSearchScope.creat"}
{"code": "eScopedDeclarationProviderForFile(file: KtFile): KotlinDeclarationProvider? =\n        // KtFiles without a backing VirtualFile can't be covered by a shadow scope, and are thus assumed in-scope.\n        if (file.virtualFile == null || contains(file.virtualFile)) {\n            FileBasedKotlinDeclarationProvider(file)\n        } else {\n            null\n        }\n}\n"}
{"code": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE\nfun usage() {\n    for (loopVariable in 1..10) {}\n}"}
{"code": "\n\npackage org.jetbrains.kotlin.cfg.pseudocodeTraverser\n\nimport org.jetbrains.kotlin.cfg.ControlFlowInfo\nimport org.jetbrains.kotlin.cfg.pseudocode.Pseudocode\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.Instruction\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.special.InlinedLocalFunctionDeclarationInstruction\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.special.LocalFunctionDeclarationInstruction\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.special.SubroutineEnterInstruction\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.special.SubroutineSinkInstruction\nimport org.jetbrains.kotlin.cfg.pseudocodeTraverser.TraversalOrder.FORWARD\nimport java.util.*\n\nfun Pseudocode.traverse(\n    traversalOrder: TraversalOrder,\n    analyzeInstruction: (Instruction) -> Unit\n) {\n    val instructions = getInstructions(traversalOrder)\n    for (instruction in instructions) {\n        if (instruction is LocalFunctionDeclarationInstruction) {\n            instruc"}
{"code": "tion.body.traverse(traversalOrder, analyzeInstruction)\n        }\n        analyzeInstruction(instruction)\n    }\n}\n\nfun <D> Pseudocode.traverse(\n    traversalOrder: TraversalOrder,\n    edgesMap: Map<Instruction, Edges<D>>,\n    analyzeInstruction: (Instruction, D, D) -> Unit\n) {\n    val instructions = getInstructions(traversalOrder)\n    for (instruction in instructions) {\n        if (instruction is LocalFunctionDeclarationInstruction) {\n            instruction.body.traverse(traversalOrder, edgesMap, analyzeInstruction)\n        }\n        val edges = edgesMap[instruction] ?: continue\n        analyzeInstruction(instruction, edges.incoming, edges.outgoing)\n    }\n}\n\nfun Pseudocode.traverseIncludingDeadCode(analyzeInstruction: (Instruction) -> Unit) {\n    for (instruction in instructionsIncludingDeadCode) {\n        if (instruction is LocalFunctionDeclarationInstruction) {\n            instruction.body.traverseIncludingDeadCode(analyzeInstruction)\n        }\n        analyzeInstruction(instruction)"}
{"code": "\n    }\n}\n\nfun <I : ControlFlowInfo<*, *, *>> Pseudocode.collectData(\n    traversalOrder: TraversalOrder,\n    mergeEdges: (Instruction, Collection<I>) -> Edges<I>,\n    updateEdge: (Instruction, Instruction, I) -> I,\n    initialInfo: I\n): Map<Instruction, Edges<I>> {\n    val edgesMap = LinkedHashMap<Instruction, Edges<I>>()\n    val startInstruction = getStartInstruction(traversalOrder)\n    edgesMap[startInstruction] = Edges(initialInfo, initialInfo)\n\n    val changed = mutableMapOf<Instruction, Boolean>()\n    do {\n        collectDataFromSubgraph(\n            traversalOrder, edgesMap,\n            mergeEdges, updateEdge, Collections.emptyList<Instruction>(), changed, false\n        )\n    } while (changed.any { it.value })\n\n    return edgesMap\n}\n\nprivate fun <I : ControlFlowInfo<*, *, *>> Pseudocode.collectDataFromSubgraph(\n    traversalOrder: TraversalOrder,\n    edgesMap: MutableMap<Instruction, Edges<I>>,\n    mergeEdges: (Instruction, Collection<I>) -> Edges<I>,\n    updateEdge: (Instruction"}
{"code": ", Instruction, I) -> I,\n    previousSubGraphInstructions: Collection<Instruction>,\n    changed: MutableMap<Instruction, Boolean>,\n    isLocal: Boolean\n) {\n    val instructions = getInstructions(traversalOrder)\n    val startInstruction = getStartInstruction(traversalOrder)\n\n    for (instruction in instructions) {\n        val isStart = instruction.isStartInstruction(traversalOrder)\n        if (!isLocal && isStart)\n            continue\n\n        val previousInstructions =\n            getPreviousIncludingSubGraphInstructions(instruction, traversalOrder, startInstruction, previousSubGraphInstructions)\n\n        if (instruction is LocalFunctionDeclarationInstruction) {\n            val subroutinePseudocode = instruction.body\n            subroutinePseudocode.collectDataFromSubgraph(\n                traversalOrder, edgesMap, mergeEdges, updateEdge, previousInstructions, changed, true\n            )\n            // Special case for inlined functions: take flow from EXIT instructions (it contains flo"}
{"code": "w which exits declaration normally)\n            val lastInstruction = if (instruction is InlinedLocalFunctionDeclarationInstruction && traversalOrder == FORWARD)\n                subroutinePseudocode.exitInstruction\n            else\n                subroutinePseudocode.getLastInstruction(traversalOrder)\n            val previousValue = edgesMap[instruction]\n            val newValue = edgesMap[lastInstruction]\n            val updatedValue = newValue?.let {\n                Edges(updateEdge(lastInstruction, instruction, it.incoming), updateEdge(lastInstruction, instruction, it.outgoing))\n            }\n            updateEdgeDataForInstruction(instruction, previousValue, updatedValue, edgesMap, changed)\n            continue\n        }\n\n\n        val previousDataValue = edgesMap[instruction]\n        if (previousDataValue != null && previousInstructions.all { changed[it] == false }) {\n            changed[instruction] = false\n            continue\n        }\n\n        val incomingEdgesData = HashSet<"}
{"code": "I>()\n\n        for (previousInstruction in previousInstructions) {\n            val previousData = edgesMap[previousInstruction] ?: continue\n            incomingEdgesData.add(updateEdge(previousInstruction, instruction, previousData.outgoing))\n        }\n\n        val mergedData = mergeEdges(instruction, incomingEdgesData)\n        updateEdgeDataForInstruction(instruction, previousDataValue, mergedData, edgesMap, changed)\n    }\n}\n\nprivate fun getPreviousIncludingSubGraphInstructions(\n    instruction: Instruction,\n    traversalOrder: TraversalOrder,\n    startInstruction: Instruction,\n    previousSubGraphInstructions: Collection<Instruction>\n): Collection<Instruction> {\n    val previous = instruction.getPreviousInstructions(traversalOrder)\n    if (instruction != startInstruction || previousSubGraphInstructions.isEmpty()) {\n        return previous\n    }\n    val result = ArrayList(previous)\n    result.addAll(previousSubGraphInstructions)\n    return result\n}\n\nprivate fun <I : ControlFlowInfo<*, "}
{"code": "*, *>> updateEdgeDataForInstruction(\n    instruction: Instruction,\n    previousValue: Edges<I>?,\n    newValue: Edges<I>?,\n    edgesMap: MutableMap<Instruction, Edges<I>>,\n    changed: MutableMap<Instruction, Boolean>\n) {\n    if (previousValue != newValue && newValue != null) {\n        changed[instruction] = true\n        edgesMap[instruction] = newValue\n    } else {\n        changed[instruction] = false\n    }\n}\n\ndata class Edges<out T>(val incoming: T, val outgoing: T)\n\nenum class TraverseInstructionResult {\n    CONTINUE,\n    SKIP,\n    HALT\n}\n\n// returns false when interrupted by handler\nfun traverseFollowingInstructions(\n    rootInstruction: Instruction,\n    visited: MutableSet<Instruction> = HashSet(),\n    order: TraversalOrder = FORWARD,\n    // true to continue traversal\n    handler: ((Instruction) -> TraverseInstructionResult)?\n): Boolean {\n    val stack = ArrayDeque<Instruction>()\n    stack.push(rootInstruction)\n\n    while (!stack.isEmpty()) {\n        val instruction = stack.pop()\n "}
{"code": "       if (!visited.add(instruction)) continue\n        when (handler?.let { it(instruction) } ?: TraverseInstructionResult.CONTINUE) {\n            TraverseInstructionResult.CONTINUE -> instruction.getNextInstructions(order).forEach { stack.push(it) }\n            TraverseInstructionResult.SKIP -> {\n            }\n            TraverseInstructionResult.HALT -> return false\n        }\n    }\n    return true\n}\n\nenum class TraversalOrder {\n    FORWARD,\n    BACKWARD\n}\n\nfun Pseudocode.getStartInstruction(traversalOrder: TraversalOrder): Instruction =\n    if (traversalOrder == FORWARD) enterInstruction else sinkInstruction\n\nfun Pseudocode.getLastInstruction(traversalOrder: TraversalOrder): Instruction =\n    if (traversalOrder == FORWARD) sinkInstruction else enterInstruction\n\nfun Pseudocode.getInstructions(traversalOrder: TraversalOrder): List<Instruction> =\n    if (traversalOrder == FORWARD) instructions else reversedInstructions\n\nfun Instruction.getNextInstructions(traversalOrder: TraversalOrder"}
{"code": "): Collection<Instruction> =\n    if (traversalOrder == FORWARD) nextInstructions else previousInstructions\n\nfun Instruction.getPreviousInstructions(traversalOrder: TraversalOrder): Collection<Instruction> =\n    if (traversalOrder == FORWARD) previousInstructions else nextInstructions\n\nfun Instruction.isStartInstruction(traversalOrder: TraversalOrder): Boolean =\n    if (traversalOrder == FORWARD) this is SubroutineEnterInstruction else this is SubroutineSinkInstruction\n"}
{"code": "\n\npackage org.jetbrains.kotlin.cfg.pseudocode.instructions.special\n\nimport org.jetbrains.kotlin.psi.KtElement\nimport java.util.Collections\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.BlockScope\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.InstructionImpl\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.Instruction\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.InstructionVisitor\nimport org.jetbrains.kotlin.cfg.pseudocode.instructions.InstructionVisitorWithResult\n\nclass SubroutineSinkInstruction(\n    val subroutine: KtElement,\n    blockScope: BlockScope,\n    private val debugLabel: String\n) : InstructionImpl(blockScope) {\n    override val nextInstructions: Collection<Instruction>\n        get() = Collections.emptyList()\n\n    override fun accept(visitor: InstructionVisitor) {\n        visitor.visitSubroutineSink(this)\n    }\n\n    override fun <R> accept(visitor: InstructionVisitorWithResult<R>): R = visitor.visitSubroutineSink(this)\n\n    override fun t"}
{"code": "oString(): String = debugLabel\n\n    override fun createCopy(): InstructionImpl =\n        SubroutineSinkInstruction(subroutine, blockScope, debugLabel)\n}\n"}
{"code": "package properties\n\n@Target(\n    AnnotationTarget.TYPE,\n    AnnotationTarget.PROPERTY,\n    AnnotationTarget.VALUE_PARAMETER,\n    AnnotationTarget.FIELD,\n    AnnotationTarget.PROPERTY_SETTER,\n    AnnotationTarget.PROPERTY_GETTER,\n)\nannotation class Anno(val position: String)\nconst val constant = 0\n\nclass MyClass(\n    @property:Anno(\"property $constant\")\n    @get:Anno(\"get $constant\")\n    @set:Anno(\"set $constant\")\n    @setparam:Anno(\"set $constant\")\n    @field:Anno(\"field $constant\")\n    @param:Anno(\"param $constant\")\n    var pr<caret>operty: @Anno(\"parameter type: $constant\") List<@Anno(\"nested parameter type: $constant\") List<@Anno(\"nested nested parameter type: $constant\") Int>>,\n)\n"}
{"code": "\n\npackage org.jetbrains.kotlin.analysis.api.impl.base.test.cases.components.typeInfoProvider\n\nimport org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule\nimport org.jetbrains.kotlin.analysis.test.framework.services.expressionMarkerProvider\nimport org.jetbrains.kotlin.analysis.test.framework.utils.executeOnPooledThreadInReadAction\nimport org.jetbrains.kotlin.psi.KtDoubleColonExpression\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.assertions\nimport org.jetbrains.kotlin.types.Variance\n\nabstract class AbstractDoubleColonReceiverTypeTest : AbstractAnalysisApiBasedTest() {\n    override fun doTestByMainFile(mainFile: KtFile, mainModule: KtTestModule, testServices: TestServices) {\n        val expressionAtCaret = testServices.expressionMarkerProvider.getElementOfTypeAtCaret(mainFile) as KtDoubleCol"}
{"code": "onExpression\n\n        val type = executeOnPooledThreadInReadAction {\n            analyseForTest(expressionAtCaret) {\n                expressionAtCaret.getReceiverKtType()?.render(position = Variance.INVARIANT)\n            }\n        }\n\n        val actual = buildString {\n            appendLine(\"expression: ${expressionAtCaret.text}\")\n            appendLine(\"receiver:: type: $type\")\n        }\n        testServices.assertions.assertEqualsToTestDataFileSibling(actual)\n    }\n}\n"}
