{"context": "class C {\n\n    var property: Int = 58\n        get() {\n            return field * 2\n        }\n        set(value) {\n            <expr>field += 45</expr>\n        }\n\n}\nfun main() {\n", "line_to_complete": "\n    val c = C()\n    c.property -= 20\n    println(C().property)\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.incremental.classpathDiff\n\nimport com.google.common.util.concurrent.AtomicDouble\nimport org.jetbrains.kotlin.incremental.classpathDiff.InMemoryCacheWithEviction.EntryState.*\nimport org.junit.Test\nimport kotlin.test.assertEquals\nimport kotlin.test.fail\n\nclass InMemoryCacheWithEvictionTest {\n\n    @Test\nfun testComputeIfAbsent() {\n", "line_to_complete": "\n        val cache = InMemoryCacheWithEviction<Int, Any>(\n            maxTimePeriodsToKeepStrongReferences = 10,\n            maxTimePeriodsToKeepSoftReferences = 10,\n            maxMemoryUsageRatioToKeepStrongReferences = 0.8,\n            memoryUsageRatio = { 0.5 }\n        )\n\n        // Check when the entries are not yet present\n        assertEquals(\"One\", cache.computeIfAbsent(1) { \"One\" })\n        assertEquals(\"Two\", cache.computeIfAbsent(2) { \"Two\" })\n\n        // Check when the entries are already present\n        assertEquals(\"One\", cache.computeIfAbsent(1) { fail(\"Must not run\") })\n        assertEquals(\"Two\", cache.computeIfAbsent(2) { fail(\"Must not run\") })\n    }"}
{"context": "interface I\nclass Delegating : I by <expr>compoundDelegate()</expr>\nfun compoundDelegate(): I {\n", "line_to_complete": "\n    return object : I {}\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.tree.generator.model\n\nimport org.jetbrains.kotlin.generators.tree.*\nimport org.jetbrains.kotlin.generators.tree.ElementOrRef as GenericElementOrRef\n\n// ----------- Simple field -----------\nfun field(\n    name: String,\n    type: TypeRefWithNullability,\n    nullable: Boolean = false,\n    withReplace: Boolean = false,\n    isChild: Boolean = true,\n): Field {\n", "line_to_complete": "\n    val isMutable = type is GenericElementOrRef<*> || withReplace\n    return SimpleField(name, type.copy(nullable), isChild = isChild, isMutable = isMutable, withReplace = withReplace)\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.tree.generator.model\n\nimport org.jetbrains.kotlin.generators.tree.*\nimport org.jetbrains.kotlin.generators.tree.ElementOrRef as GenericElementOrRef\n\n// ----------- Simple field -----------\n\nfun field(\n    name: String,\n    type: TypeRefWithNullability,\n    nullable: Boolean = false,\n    withReplace: Boolean = false,\n    isChild: Boolean = true,\n): Field {\n    val isMutable = type is GenericElementOrRef<*> || withReplace\n    return SimpleField(name, type.copy(nullable), isChild = isChild, isMutable = isMutable, withReplace = withReplace)\n}\nfun field(\n    type: ClassOrElementRef,\n    nullable: Boolean = false,\n    withReplace: Boolean = false,\n    isChild: Boolean = true,\n): Field {\n", "line_to_complete": "\n    val name = when (type) {\n        is ClassRef<*> -> type.simpleName\n        is GenericElementOrRef<*> -> type.element.name\n    }.replaceFirstChar(Char::lowercaseChar)\n    return field(name, type, nullable, withReplace, isChild)\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.base\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.annotations.KtAnnotated\nimport org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter\nimport org.jetbrains.kotlin.lexer.KtKeywordToken\n\npublic interface KtKeywordRenderer {\n    context(KtAnalysisSession, KtKeywordsRenderer)\n    public fun renderKeyword(keyword: KtKeywordToken, owner: KtAnnotated, printer: PrettyPrinter)\n\n    context(KtAnalysisSession, KtKeywordsRenderer)\npublic fun renderKeywords(keywords: List<KtKeywordToken>, owner: KtAnnotated, printer: PrettyPrinter) {\n", "line_to_complete": "\n        printer.printCollection(keywords.filter { keywordFilter.filter(it, owner) }, separator = \" \") {\n            renderKeyword(it, owner, this)\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.name.ClassId\n\nclass ConeIdRendererForDebugging : ConeIdRenderer() {\noverride fun renderClassId(classId: ClassId) {\n", "line_to_complete": "\n        builder.append(classId.asString())\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.name.CallableId\nimport org.jetbrains.kotlin.name.ClassId\n\nclass ConeIdRendererForDebugging : ConeIdRenderer() {\n    override fun renderClassId(classId: ClassId) {\n        builder.append(classId.asString())\n    }\noverride fun renderCallableId(callableId: CallableId) {\n", "line_to_complete": "\n        builder.append(callableId.callableName)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.fir.declarations.FirValueParameter\nimport org.jetbrains.kotlin.fir.types.FirResolvedTypeRef\nimport org.jetbrains.kotlin.fir.types.arrayElementType\n\nclass FirValueParameterRendererForReadability : FirValueParameterRenderer() {\noverride fun renderParameterType(valueParameter: FirValueParameter) {\n", "line_to_complete": "\n        val returnTypeRef = valueParameter.returnTypeRef\n\n        if (valueParameter.isVararg && returnTypeRef is FirResolvedTypeRef) {\n            val arrayElementType = returnTypeRef.type.arrayElementType()\n            if (arrayElementType != null) {\n                typeRenderer.render(arrayElementType)\n                return\n            }\n        }\n\n        super.renderParameterType(valueParameter)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.fir.declarations.FirValueParameter\nimport org.jetbrains.kotlin.fir.types.FirResolvedTypeRef\nimport org.jetbrains.kotlin.fir.types.arrayElementType\n\nclass FirValueParameterRendererForReadability : FirValueParameterRenderer() {\n    override fun renderParameterType(valueParameter: FirValueParameter) {\n        val returnTypeRef = valueParameter.returnTypeRef\n\n        if (valueParameter.isVararg && returnTypeRef is FirResolvedTypeRef) {\n            val arrayElementType = returnTypeRef.type.arrayElementType()\n            if (arrayElementType != null) {\n                typeRenderer.render(arrayElementType)\n                return\n            }\n        }\n\n        super.renderParameterType(valueParameter)\n    }\noverride fun renderDefaultValue(valueParameter: FirValueParameter) {\n", "line_to_complete": "\n        valueParameter.defaultValue?.let {\n            printer.print(\" = ...\")\n        }\n    }"}
{"context": "// !DUMP_CFG\nfun test_1() {\n", "line_to_complete": "\n    try {\n        val x = 1\n    } catch (e: RuntimeException) {\n        val y = 2\n    } catch (e: Exception) {\n        val z = 3\n    }\n}"}
{"context": "// !DUMP_CFG\nfun test_1() {\n    try {\n        val x = 1\n    } catch (e: RuntimeException) {\n        val y = 2\n    } catch (e: Exception) {\n        val z = 3\n    }\n}\nfun test_2() {\n", "line_to_complete": "\n    val x = try {\n        1\n    } catch (e: Exception) {\n        2\n    }\n}"}
{"context": "// !DUMP_CFG\nfun test_1() {\n    try {\n        val x = 1\n    } catch (e: RuntimeException) {\n        val y = 2\n    } catch (e: Exception) {\n        val z = 3\n    }\n}\n\nfun test_2() {\n    val x = try {\n        1\n    } catch (e: Exception) {\n        2\n    }\n}\nfun test_3(b: Boolean) {\n", "line_to_complete": "\n    while (true) {\n        try {\n            if (b) return\n            val x = 1\n            if (!b) break\n        } catch (e: Exception) {\n            continue\n        } catch (e: RuntimeException) {\n            break\n        }\n        val y = 2\n    }\n    val z = 3\n}"}
{"context": "// ISSUE: KT-24901\nfun foo(str: String?): Int {\n", "line_to_complete": "\n    when {\n        str == null -> return -1\n    }\n    if (str.length == 123)\n        return 123\n    return 321\n}"}
{"context": "// IGNORE_FE10\n\n// MODULE: context\n\n// FILE: context.kt\nfun test() {\n", "line_to_complete": "\n    fun local() {}\n    <caret_context>Unit\n}"}
{"context": "package one\n\nobject TopLevelObject\n\nclass A constructor(a: Int) {\n    class B {\n        inner class C {\nfun foo() {\n", "line_to_complete": "\n                typealias F = C\n\n                class BBA\n            }"}
{"context": "package one\n\nobject TopLevelObject\n\nclass A constructor(a: Int) {\n    class B {\n        inner class C {\n            fun foo() {\n                typealias F = C\n\n                class BBA\n            }\n        }\n    }\nfun boo() {\n", "line_to_complete": "\n        class A\n        typealias B = A\n    }"}
{"context": "interface State\ninterface Complex {\n    val superClass: Complex?\n}\n\ninterface ExceptionState : State\nfun test(qualifier: State?) {\n", "line_to_complete": "\n    if (qualifier == null || qualifier is ExceptionState || (qualifier as? Complex)?.superClass == null) {\n        return\n    }\n    qualifier.superClass\n}"}
{"context": "// FILE: main.kt\nfun some() {\n", "line_to_complete": "\n  JavaClass().f<caret>oo();\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.resolve.providers.impl\n\nimport org.jetbrains.annotations.TestOnly\nimport org.jetbrains.kotlin.fir.*\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.declarations.synthetic.FirSyntheticProperty\nimport org.jetbrains.kotlin.fir.resolve.providers.*\nimport org.jetbrains.kotlin.fir.scopes.FirKotlinScopeProvider\nimport org.jetbrains.kotlin.fir.symbols.impl.*\nimport org.jetbrains.kotlin.fir.visitors.FirDefaultVisitor\nimport org.jetbrains.kotlin.name.*\nimport org.jetbrains.kotlin.utils.mapToSetOrEmpty\n\n@ThreadSafeMutableState\nclass FirProviderImpl(val session: FirSession, val kotlinScopeProvider: FirKotlinScopeProvider) : FirProvider() {\n    override val symbolProvider: FirSymbolProvider = SymbolProvider()\noverride fun getFirCallableContainerFile(symbol: FirCallableSymbol<*>): FirFile? {\n", "line_to_complete": "\n        symbol.originalIfFakeOverride()?.let { originalSymbol ->\n            return originalSymbol.moduleData.session.firProvider.getFirCallableContainerFile(originalSymbol)\n        }\n        if (symbol is FirBackingFieldSymbol) {\n            return getFirCallableContainerFile(symbol.fir.propertySymbol)\n        }\n        if (symbol is FirSyntheticPropertySymbol) {\n            val fir = symbol.fir\n            if (fir is FirSyntheticProperty) {\n                return getFirCallableContainerFile(fir.getter.delegate.symbol)\n            }\n        }\n        return state.callableContainerMap[symbol]\n    }"}
{"context": "package test\n\nabstract class ClassMembers(private val p: Int, public open var p2: String, p3: Int, p4: Int = 10, final val p5: String = \"aaa\") {\n    val foo = 3\nfun bar(): Int {\n", "line_to_complete": "\n        return 3\n    }"}
{"context": "fun test_1(array: Array<String>) {\n    array.clone()\n}\nfun test_2(array: IntArray) {\n", "line_to_complete": "\n    array.clone()\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.declarations\n\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\nimport org.jetbrains.kotlin.fir.util.ConeTypeRegistry\nimport org.jetbrains.kotlin.util.ArrayMap\nimport org.jetbrains.kotlin.util.AttributeArrayOwner\nimport org.jetbrains.kotlin.util.NullableArrayMapAccessor\nimport org.jetbrains.kotlin.util.TypeRegistry\nimport kotlin.properties.ReadWriteProperty\nimport kotlin.reflect.KClass\nimport kotlin.reflect.KProperty\n\nabstract class FirDeclarationDataKey\n\n\nclass FirDeclarationAttributes : AttributeArrayOwner<FirDeclarationDataKey, Any> {\n    override val typeRegistry: TypeRegistry<FirDeclarationDataKey, Any>\n        get() = FirDeclarationDataRegistry\n\n    constructor() : super()\n    private constructor(arrayMap: ArrayMap<Any>) : super(arrayMap)\ninternal operator fun set(key: KClass<out FirDeclarationDataKey>, value: Any?) {\n", "line_to_complete": "\n        if (value == null) {\n            removeComponent(key)\n        } else {\n            registerComponent(key, value)\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.decompiler.stub.file\n\nimport org.jetbrains.kotlin.analysis.decompiler.stub.AnnotationWithArgs\nimport org.jetbrains.kotlin.metadata.ProtoBuf\nimport org.jetbrains.kotlin.metadata.deserialization.NameResolver\nimport org.jetbrains.kotlin.psi.stubs.impl.createConstantValue\nimport org.jetbrains.kotlin.serialization.SerializerExtensionProtocol\nimport org.jetbrains.kotlin.serialization.deserialization.*\n\nclass AnnotationLoaderForStubBuilderImpl(\n    protocol: SerializerExtensionProtocol,\n) : AbstractAnnotationLoader<AnnotationWithArgs>(protocol) {\noverride fun loadAnnotation(proto: ProtoBuf.Annotation, nameResolver: NameResolver): AnnotationWithArgs {\n", "line_to_complete": "\n        val valueMap = proto.argumentList.associate { nameResolver.getName(it.nameId) to createConstantValue(it.value, nameResolver) }\n        return AnnotationWithArgs(nameResolver.getClassId(proto.id), valueMap)\n    }"}
{"context": "interface Foo {\n    fun foo(): Int\n}\n\ninterface Bar {\n    fun bar(): Int\n}\n\ncontext(Foo, Bar)\nfun test() {\n", "line_to_complete": "\n    <expr>foo() + bar()</expr>\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.utils\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.FirClass\nimport org.jetbrains.kotlin.fir.declarations.FirResolvePhase\nimport org.jetbrains.kotlin.fir.declarations.utils.superConeTypes\nimport org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase\nimport org.jetbrains.kotlin.fir.types.toRegularClassSymbol\nfun isSubClassOf(subClass: FirClass, superClass: FirClass, useSiteSession: FirSession, allowIndirectSubtyping: Boolean = true): Boolean {\n", "line_to_complete": "\n    subClass.lazyResolveToPhase(FirResolvePhase.SUPER_TYPES)\n\n    if (subClass.superConeTypes.any { it.toRegularClassSymbol(useSiteSession) == superClass.symbol }) return true\n    if (!allowIndirectSubtyping) return false\n\n    subClass.superConeTypes.forEach { superType ->\n        val superOfSub = superType.toRegularClassSymbol(useSiteSession) ?: return@forEach\n        if (isSubClassOf(superOfSub.fir, superClass, useSiteSession, allowIndirectSubtyping = true)) return true\n    }\n    return false\n}"}
{"context": "// WITH_STDLIB\nfun foo() {\n", "line_to_complete": "\n    var list = listOf(1, 2, 3)\n    // Should not be highlighted because it's the way we use to say explicitly\n    // \"yes, we want to re-assign this immutable list\"\n    <!ASSIGNED_VALUE_IS_NEVER_READ!>list<!> = list + 4\n}"}
{"context": "// FILE: RunnerModule.kt\n\nclass RunnerModule : AbstractModule() {\nfun configure() {\n", "line_to_complete": "\n        <expr>install(CoroutineModule.builder())</expr>\n    }"}
{"context": "// ISSUE: KT-49747\n// DUMP_CFG\n\nclass A(val path: String?, val index: Int)\n\ninterface Base\nclass Derived(val index: Int) : Base\nfun test(a: A?): Base? {\n", "line_to_complete": "\n    val path = a?.path ?: return null\n    takeInt(a.index) // should be ok\n    return object : Base by Derived(a.index) {\n        val x: Int = a.index\n\n        fun foo() {\n            takeInt(a.index)\n        }\n    }\n}"}
{"context": "// ISSUE: KT-49747\n// DUMP_CFG\n\nclass A(val path: String?, val index: Int)\n\ninterface Base\nclass Derived(val index: Int) : Base\n\nfun test(a: A?): Base? {\n    val path = a?.path ?: return null\n    takeInt(a.index) // should be ok\n    return object : Base by Derived(a.index) {\n        val x: Int = a.index\nfun foo() {\n", "line_to_complete": "\n            takeInt(a.index)\n        }"}
{"context": "class Klass {\n    constructor(a: Int) {}\n    constructor(a: String) {}\n}\n\nfun user(f: (Int) -> Klass) {}\nfun fn() {\n", "line_to_complete": "\n    user(::Klass)\n}"}
{"context": "// FILE: K1.kt\nclass KotlinClass\n\n// FILE: JavaClass.java\npublic class JavaClass {\n    public static void baz(KotlinClass k) {}\n}\n\n// FILE: K2.kt\nfun main() {\n", "line_to_complete": "\n    JavaClass.baz(KotlinClass())\n    JavaClass.baz(<!ARGUMENT_TYPE_MISMATCH!>\"\"<!>)\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.resolve.jvm.checkers\n\nimport org.jetbrains.kotlin.config.JvmAnalysisFlags\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.psi.KtClass\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtNamedFunction\nimport org.jetbrains.kotlin.resolve.checkers.DeclarationChecker\nimport org.jetbrains.kotlin.resolve.checkers.DeclarationCheckerContext\nimport org.jetbrains.kotlin.resolve.sam.getSingleAbstractMethodOrNull\nimport org.jetbrains.kotlin.resolve.source.getPsi\n\nclass SuspendInFunInterfaceChecker : DeclarationChecker {\noverride fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n", "line_to_complete": "\n        if (declaration !is KtClass) return\n        if (descriptor !is ClassDescriptor || !descriptor.isFun) return\n\n        val funKeyword = declaration.getFunKeyword() ?: return\n\n        val abstractMember = getSingleAbstractMethodOrNull(descriptor) ?: return\n        if (!abstractMember.isSuspend) return\n\n        if (context.languageVersionSettings.supportsFeature(LanguageFeature.SuspendFunctionsInFunInterfaces) &&\n            context.languageVersionSettings.getFlag(JvmAnalysisFlags.useIR)\n        ) return\n\n        val ktFunction = abstractMember.source.getPsi() as? KtNamedFunction\n        val reportOn = ktFunction?.modifierList?.getModifier(KtTokens.SUSPEND_KEYWORD) ?: funKeyword\n        context.trace.report(Errors.FUN_INTERFACE_WITH_SUSPEND_FUNCTION.on(reportOn))\n    }"}
{"context": "// FILE: main.kt\nfun <T> myRun(action: () -> T): T = action()\nfun test(other: TypeWithBoundedGeneric<*>) = myRun {\n", "line_to_complete": " other }"}
{"context": "enum class MyEnum {\n    A, B, C\n}\nfun test(e: MyEnum) {\n", "line_to_complete": "\n    <caret>when (e) {\n        else -> {}\n    }\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.types\n\nobject ConeKotlinTypeComparator : Comparator<ConeKotlinType> {\n    private val ConeKotlinType.priority : Int\n        get() = when (this) {\n            is ConeErrorType -> 9\n            is ConeLookupTagBasedType -> 8\n            is ConeFlexibleType -> 7\n            is ConeCapturedType -> 6\n            is ConeDefinitelyNotNullType -> 5\n            is ConeIntersectionType -> 4\n            is ConeStubType -> 3\n            is ConeIntegerLiteralConstantType -> 2\n            is ConeIntegerConstantOperatorType -> 1\n            else -> 0\n        }\nprivate fun compare(a: ConeTypeProjection, b: ConeTypeProjection): Int {\n", "line_to_complete": "\n        val kindDiff = a.kind.ordinal - b.kind.ordinal\n        if (kindDiff != 0) {\n            return kindDiff\n        }\n        when (a) {\n            is ConeStarProjection -> return 0\n            is ConeKotlinTypeProjectionIn -> {\n                require(b is ConeKotlinTypeProjectionIn) {\n                    \"ordinal is inconsistent: $a v.s. $b\"\n                }\n                return compare(a.type, b.type)\n            }\n            is ConeKotlinTypeProjectionOut -> {\n                require(b is ConeKotlinTypeProjectionOut) {\n                    \"ordinal is inconsistent: $a v.s. $b\"\n                }\n                return compare(a.type, b.type)\n            }\n            else -> {\n                assert(a is ConeKotlinType && b is ConeKotlinType) {\n                    \"Expect INVARIANT: $a v.s. $b\"\n                }\n                return compare(a as ConeKotlinType, b as ConeKotlinType)\n            }\n        }\n    }"}
{"context": "open class A {\nopen fun test(x: Int): String {\n", "line_to_complete": "\n        return \"OK\"\n    }"}
{"context": "open class A {\n    open fun test(x: Int): String {\n        return \"OK\"\n    }\n}\n\nclass B : A() {\noverride fun test(x: Int): String {\n", "line_to_complete": "\n        return <expr>super.test(x * 2)</expr>\n    }"}
{"context": "fun <R> x(p: R): Int {\n\n}\n\nclass Y<T> {\n    fun a() = 1\n}\n\nvar z: Int\n    get = 10\n    set(value) {}\n\nobject Q\n\nval z: String = \"\"\nfun yyy() {\n", "line_to_complete": "\n//    val q = 10\n//    fun aaa() {}\n//\n//    class F {}\n}"}
{"context": "// FILE: ComponentSerializationUtil.java\n\nimport org.jetbrains.annotations.NotNull;\n\npublic final class ComponentSerializationUtil {\n    @NotNull\n    public static <S> Class<S> getStateClass(@NotNull Class<? extends PersistentStateComponent> aClass)\n    {}\n}\n\n// FILE: use.kt\n\nclass BeforeRunTask<T>\n\ninterface PersistentStateComponent<T>\n\nfun <T> deserializeAndLoadState(\n    component: PersistentStateComponent<T>,\n    clazz: Class<T> = ComponentSerializationUtil.getStateClass(component::class.java)\n) {}\nfun use(beforeRunTask: BeforeRunTask<*>) {\n", "line_to_complete": "\n    if (<!USELESS_IS_CHECK!>beforeRunTask is PersistentStateComponent<*><!>) {\n        deserializeAndLoadState(beforeRunTask)\n    }\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.resolve.jvm.checkers\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.resolve.calls.checkers.CallChecker\nimport org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\nimport org.jetbrains.kotlin.resolve.calls.model.VarargValueArgument\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm\n\nobject PolymorphicSignatureCallChecker : CallChecker {\n    @JvmField\n    val polymorphicSignatureFqName = FqName(\"java.lang.invoke.MethodHandle.PolymorphicSignature\")\noverride fun check(resolvedCall: ResolvedCall<*>, reportOn: PsiElement, context: CallCheckerContext) {\n", "line_to_complete": "\n        if (!context.languageVersionSettings.supportsFeature(LanguageFeature.PolymorphicSignature)) return\n        if (!resolvedCall.resultingDescriptor.annotations.hasAnnotation(polymorphicSignatureFqName)) return\n\n        for (valueArgument in resolvedCall.valueArgumentsByIndex ?: return) {\n            if (valueArgument !is VarargValueArgument) continue\n            for (argument in valueArgument.arguments) {\n                val spread = argument.getSpreadElement() ?: continue\n                context.trace.report(ErrorsJvm.SPREAD_ON_SIGNATURE_POLYMORPHIC_CALL.on(context.languageVersionSettings, spread))\n            }\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.declarations.renderers.callables\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.renderer.declarations.KtDeclarationRenderer\nimport org.jetbrains.kotlin.analysis.api.renderer.declarations.renderAnnotationsModifiersAndContextReceivers\nimport org.jetbrains.kotlin.analysis.api.symbols.KtPropertySetterSymbol\nimport org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter\nimport org.jetbrains.kotlin.lexer.KtTokens\n\npublic interface KtPropertySetterSymbolRenderer {\n    context(KtAnalysisSession, KtDeclarationRenderer)\n    public fun renderSymbol(symbol: KtPropertySetterSymbol, printer: PrettyPrinter)\n\n    public object AS_SOURCE : KtPropertySetterSymbolRenderer {\n        context(KtAnalysisSession, KtDeclarationRenderer)\noverride fun renderSymbol(symbol: KtPropertySetterSymbol, printer: PrettyPrinter): Unit = printer {\n", "line_to_complete": "\n            \" \".separated(\n                {\n                    renderAnnotationsModifiersAndContextReceivers(symbol, printer, KtTokens.SET_KEYWORD)\n                    valueParametersRenderer.renderValueParameters(symbol, printer)\n                },\n                { accessorBodyRenderer.renderBody(symbol, printer) },\n            )\n        }"}
{"context": "\n\npackage org.jetbrains.kotlin.build.report\n\nimport java.io.File\n\nabstract class ICReporterBase(private val pathsBase: File? = null) : ICReporter {\noverride fun reportMarkDirtyClass(affectedFiles: Iterable<File>, classFqName: String) {\n", "line_to_complete": "\n        reportMarkDirty(affectedFiles, \"dirty class $classFqName\")\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.build.report\n\nimport java.io.File\n\nabstract class ICReporterBase(private val pathsBase: File? = null) : ICReporter {\n    override fun reportMarkDirtyClass(affectedFiles: Iterable<File>, classFqName: String) {\n        reportMarkDirty(affectedFiles, \"dirty class $classFqName\")\n    }\noverride fun reportMarkDirtyMember(affectedFiles: Iterable<File>, scope: String, name: String) {\n", "line_to_complete": "\n        reportMarkDirty(affectedFiles, \"dirty member $scope#$name\")\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.build.report\n\nimport java.io.File\n\nabstract class ICReporterBase(private val pathsBase: File? = null) : ICReporter {\n    override fun reportMarkDirtyClass(affectedFiles: Iterable<File>, classFqName: String) {\n        reportMarkDirty(affectedFiles, \"dirty class $classFqName\")\n    }\n\n    override fun reportMarkDirtyMember(affectedFiles: Iterable<File>, scope: String, name: String) {\n        reportMarkDirty(affectedFiles, \"dirty member $scope#$name\")\n    }\noverride fun reportMarkDirty(affectedFiles: Iterable<File>, reason: String) {\n", "line_to_complete": "\n        affectedFiles.forEach { file ->\n            debug { \"${pathsAsString(file)} is marked dirty: $reason\" }\n        }\n    }"}
{"context": "interface FirTargetElement\n\ninterface FirFunction<F : FirFunction<F>> : FirTargetElement\n\ninterface FirPropertyAccessor : FirFunction<FirPropertyAccessor>\n\ninterface FirProperty {\n    val getter: FirPropertyAccessor\n}\n\ninterface FirTarget<E : FirTargetElement> {\n    val labeledElement: E\n}\nfun foo(target: FirTarget<FirFunction<*>>, property: FirProperty) {\n", "line_to_complete": "\n    val functionTarget = target.labeledElement\n    val x = (functionTarget <!USELESS_CAST!>as? FirFunction<!>)?.let {\n        if (property.getter === functionTarget) {\n            return@let 1\n        }\n        0\n    }\n}"}
{"context": "\npackage org.jetbrains.kotlin.codegen.optimization\n\nimport org.jetbrains.kotlin.codegen.ClassBuilder\nimport org.jetbrains.kotlin.codegen.DelegatingClassBuilder\nimport org.jetbrains.kotlin.codegen.state.GenerationState\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOriginKind\nimport org.jetbrains.org.objectweb.asm.MethodVisitor\n\nclass OptimizationClassBuilder(private val delegate: ClassBuilder, private val generationState: GenerationState) :\n    DelegatingClassBuilder() {\n\n    public override fun getDelegate(): ClassBuilder = delegate\noverride fun newMethod(\n        origin: JvmDeclarationOrigin,\n        access: Int,\n        name: String,\n        desc: String,\n        signature: String?,\n        exceptions: Array<out String>?\n    ): MethodVisitor {\n", "line_to_complete": "\n        return OptimizationMethodVisitor(\n            super.newMethod(origin, access, name, desc, signature, exceptions),\n            origin.originKind == JvmDeclarationOriginKind.INLINE_VERSION_OF_SUSPEND_FUN,\n            generationState, access, name, desc, signature, exceptions\n        )\n    }"}
{"context": "// FILE: Some.java\n\npublic class Some {\n    public boolean foo(int param) {\n        return param > 0;\n    }\n\n    public String[] bar(int[] arr) {\n        String[] result = new String[arr.length];\n        int i = 0;\n        for (int elem: arr) {\n            result[i++] = elem;\n        }\n        return result;\n    }\n}\n\n// FILE: jvm.kt\n\nclass A : Some() {\nfun test() {\n", "line_to_complete": "\n        val res1 = foo(1)\n        val res2 = foo(-1)\n        val res3 = bar(intArrayOf(0, 2, -2))\n    }"}
{"context": "// JVM_FILE_NAME: ContractsKt\n\n@file:OptIn(ExperimentalContracts::class)\npackage test\n\nimport kotlin.contracts.*\nfun myRequire(x: Boolean) {\n", "line_to_complete": "\n    contract {\n        returns() implies x\n    }\n}"}
{"context": "// JVM_FILE_NAME: ContractsKt\n\n@file:OptIn(ExperimentalContracts::class)\npackage test\n\nimport kotlin.contracts.*\n\nfun myRequire(x: Boolean) {\n    contract {\n        returns() implies x\n    }\n}\n\nfun <R> call_InPlace(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\nfun isNull(obj: Any?): Boolean {\n", "line_to_complete": "\n    contract {\n        returns(true) implies (obj != null)\n    }\n    return obj != null\n}"}
{"context": "// JVM_FILE_NAME: ContractsKt\n\n@file:OptIn(ExperimentalContracts::class)\npackage test\n\nimport kotlin.contracts.*\n\nfun myRequire(x: Boolean) {\n    contract {\n        returns() implies x\n    }\n}\n\nfun <R> call_InPlace(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun isNull(obj: Any?): Boolean {\n    contract {\n        returns(true) implies (obj != null)\n    }\n    return obj != null\n}\nfun isNotNull(foo: Any?): Any? {\n", "line_to_complete": "\n    contract {\n        returnsNotNull() implies (foo != null)\n    }\n    return foo\n}"}
{"context": "// JVM_FILE_NAME: ContractsKt\n\n@file:OptIn(ExperimentalContracts::class)\npackage test\n\nimport kotlin.contracts.*\n\nfun myRequire(x: Boolean) {\n    contract {\n        returns() implies x\n    }\n}\n\nfun <R> call_InPlace(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun isNull(obj: Any?): Boolean {\n    contract {\n        returns(true) implies (obj != null)\n    }\n    return obj != null\n}\n\nfun isNotNull(foo: Any?): Any? {\n    contract {\n        returnsNotNull() implies (foo != null)\n    }\n    return foo\n}\nfun isString(foo: Any?): String? {\n", "line_to_complete": "\n    contract {\n        returnsNotNull() implies (foo is String)\n    }\n    return foo as? String\n}"}
{"context": "// JVM_FILE_NAME: ContractsKt\n\n@file:OptIn(ExperimentalContracts::class)\npackage test\n\nimport kotlin.contracts.*\n\nfun myRequire(x: Boolean) {\n    contract {\n        returns() implies x\n    }\n}\n\nfun <R> call_InPlace(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun isNull(obj: Any?): Boolean {\n    contract {\n        returns(true) implies (obj != null)\n    }\n    return obj != null\n}\n\nfun isNotNull(foo: Any?): Any? {\n    contract {\n        returnsNotNull() implies (foo != null)\n    }\n    return foo\n}\n\nfun isString(foo: Any?): String? {\n    contract {\n        returnsNotNull() implies (foo is String)\n    }\n    return foo as? String\n}\nfun isNotString(foo: Any?): String? {\n", "line_to_complete": "\n    contract {\n        returnsNotNull() implies (foo !is String)\n    }\n    return if (foo is String) null else \"not a string\"\n}"}
{"context": "// MODULE: context\n\n// FILE: context.kt\nfun test() {\n", "line_to_complete": "\n    <caret_context>val x = 0\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.sessions\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.LLFirModuleResolveComponents\nimport org.jetbrains.kotlin.analysis.project.structure.KtModule\nimport org.jetbrains.kotlin.fir.BuiltinTypes\nimport org.jetbrains.kotlin.fir.FirElementWithResolveState\nimport org.jetbrains.kotlin.fir.resolve.ScopeSession\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\n\nabstract class LLFirResolvableModuleSession(\n    ktModule: KtModule,\n    builtinTypes: BuiltinTypes\n) : LLFirModuleSession(ktModule, builtinTypes, Kind.Source) {\n    internal abstract val moduleComponents: LLFirModuleResolveComponents\nfinal override fun getScopeSession(): ScopeSession {\n", "line_to_complete": "\n        return moduleComponents.scopeSessionProvider.getScopeSession()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.annotations\n\nimport com.intellij.psi.PsiAnnotation\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.light.classes.symbol.methods.SymbolLightMethodBase\nimport org.jetbrains.kotlin.load.java.JvmAnnotationNames\n\ninternal object MethodAdditionalAnnotationsProvider : AdditionalAnnotationsProvider {\noverride fun addAllAnnotations(\n        currentRawAnnotations: MutableList<in PsiAnnotation>,\n        foundQualifiers: MutableSet<String>,\n        owner: PsiElement,\n    ) {\n", "line_to_complete": "\n        if (owner.parent.isMethodWithOverride()) {\n            addSimpleAnnotationIfMissing(JvmAnnotationNames.OVERRIDE_ANNOTATION.asString(), currentRawAnnotations, foundQualifiers, owner)\n        }\n    }"}
{"context": "// MODULE: dependency\n// MODULE_KIND: LibraryBinary\n// FILE: Declaration.kt\ninternal class Declaration\n\n// MODULE: main(dependency)\n// FILE: main.kt\nfun foo() {\n", "line_to_complete": "\n    p<caret>rintln()\n}"}
{"context": "inline fun <T> foo(arg: T) {\n    println(arg.toString())\n}\nfun test() {\n", "line_to_complete": "\n    foo<Strin<caret>g>(\"42\")\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.getModifier\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirClass\nimport org.jetbrains.kotlin.fir.declarations.utils.isFun\nimport org.jetbrains.kotlin.fir.declarations.utils.isInterface\nimport org.jetbrains.kotlin.lexer.KtTokens\n\nobject FirSealedInterfaceAllowedChecker : FirClassChecker(MppCheckerKind.Common) {\noverride fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {\n", "line_to_complete": "\n        if (!declaration.isInterface || !declaration.isFun) {\n            return\n        }\n        val keyword = declaration.getModifier(KtTokens.SEALED_KEYWORD) ?: return\n        reporter.reportOn(keyword.source, FirErrors.UNSUPPORTED_SEALED_FUN_INTERFACE, context)\n    }"}
{"context": "interface IrElement\n\nfun IrElement.dumpKotlinLike(options: String = \"\"): String = \"\"\nfun IrElement.dump(normalizeNames: Boolean = false): String = \"\"\nfun foo(dumpStrategy: String) {\n", "line_to_complete": "\n    val dump: IrElement.() -> String = if (dumpStrategy == \"KotlinLike\") IrElement::dumpKotlinLike else IrElement::dump\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.test.framework.services\n\nimport com.intellij.mock.MockApplication\nimport com.intellij.mock.MockProject\nimport org.jetbrains.kotlin.analysis.test.framework.project.structure.ktTestModuleStructureProvider\nimport org.jetbrains.kotlin.analysis.test.framework.test.configurators.AnalysisApiTestConfigurator\nimport org.jetbrains.kotlin.test.services.PreAnalysisHandler\nimport org.jetbrains.kotlin.test.services.TestModuleStructure\nimport org.jetbrains.kotlin.test.services.TestServices\nimport org.jetbrains.kotlin.test.services.compilerConfigurationProvider\n\nclass ProjectStructureInitialisationPreAnalysisHandler(\n    testServices: TestServices,\n    private val configurator: AnalysisApiTestConfigurator,\n) : PreAnalysisHandler(testServices) {\noverride fun preprocessModuleStructure(moduleStructure: TestModuleStructure) {\n", "line_to_complete": "\n        checkAllModulesHaveTheSameProject(moduleStructure)\n\n        testServices.environmentManager.initializeEnvironment()\n\n        val project = testServices.environmentManager.getProject() as MockProject\n        val application = testServices.environmentManager.getApplication() as MockApplication\n\n        configurator.registerApplicationServices(application, testServices)\n        createAndRegisterKtModules(moduleStructure, project)\n        configurator.registerProjectExtensionPoints(project, testServices)\n        configurator.registerProjectServices(project, testServices)\n        testServices.environmentManager.initializeProjectStructure()\n        configurator.registerProjectModelServices(project, testServices)\n    }"}
{"context": "// DO_NOT_CHECK_SYMBOL_RESTORE_K1\n// WITH_STDLIB\n// FILE: main.kt\nfun some() {\n", "line_to_complete": "\n    val jClass = JavaClass()\n    jClass.<caret>field;\n}"}
{"context": "// IGNORE_FE10\n// KT-64503\n\n// MODULE: lib\n// MODULE_KIND: LibraryBinary\n// FILE: Lib.kt\nclass SimpleVarClass(var constructorVariable: Boolean) {\n    var memberVariable: Boolean = constructorVariable\n}\n\n// MODULE: main(lib)\n// FILE: usage.kt\nimport kotlin.reflect.KMutableProperty\n\nfun moreFun(a: KMutableProperty<Boolean>) = a\nfun testMutableProp() {\n", "line_to_complete": "\n    moreFun(SimpleVarClass::constructorVariable)\n    moreFun(SimpleVarClass::memberVariable)\n}"}
{"context": "// FILE: BindingContext.java\npublic interface BindingContext {\n    @org.jetbrains.annotations.Nullable\n    <K, V> V get(ReadOnlySlice<K, V> slice, K key);\n}\n\n// FILE: ReadOnlySlice.java\npublic interface ReadOnlySlice<K, V> {}\n\n// FILE: Slices.java\n\npublic class Slices {\n    public static ReadOnlySlice<String, Double> X = null;\n    public static ReadOnlySlice<Integer, String> Y = null;\n}\n\n// FILE: main.kt\nfun bar(bindingContext: BindingContext) {\n", "line_to_complete": "\n    bindingContext[Slices.X, bindingContext[Slices.Y, 1]]\n}"}
{"context": "// FILE: call.kt\nfun call() {\n", "line_to_complete": "\n    val javaClass = JavaClass()\n    javaClass.<expr>javaMethod()</expr>\n}"}
{"context": "var a: Any = 1\nfun test() {\n", "line_to_complete": "\n    if (a is String) {\n        <expr>a</expr>\n    }\n}"}
{"context": "// FE1.0 can resolve to `kotlin` package when it's not allowed\n// IGNORE_FE10\n// COMPILATION_ERRORS\n// FILE: a.kt\npackage kotlin.pckg\nfun foo() {\n", "line_to_complete": "\n    b<caret>ar()\n}"}
{"context": "\n\n@file:JvmName(\"CommonVariableAsmNameManglingUtils\")\npackage org.jetbrains.kotlin.codegen\n\nimport org.jetbrains.kotlin.resolve.jvm.checkers.isValidDalvikCharacter\nfun mangleNameIfNeeded(name: String): String {\n", "line_to_complete": "\n    if (name.all { it.isValidCharacter() }) {\n        return name\n    }\n\n    return buildString {\n        for (c in name) {\n            if (c.isValidCharacter()) {\n                append(c)\n            } else {\n                val hexString = Integer.toHexString(c.code)\n                assert(hexString.length <= 4)\n                append(\"_u\").append(hexString)\n            }\n        }\n    }\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.diagnostics\n\nimport com.intellij.openapi.util.TextRange\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.AbstractKtSourceElement\nimport org.jetbrains.kotlin.KtLightSourceElement\nimport org.jetbrains.kotlin.KtPsiSourceElement\n\nclass SourceElementPositioningStrategy(\n    private val lightTreeStrategy: LightTreePositioningStrategy,\n    private val psiStrategy: PositioningStrategy<*>,\n    private val offsetsOnlyPositioningStrategy: OffsetsOnlyPositioningStrategy = OffsetsOnlyPositioningStrategy(),\n) : AbstractSourceElementPositioningStrategy() {\noverride fun markDiagnostic(diagnostic: KtDiagnostic): List<TextRange> {\n", "line_to_complete": "\n        return when (val element = diagnostic.element) {\n            is KtPsiSourceElement -> psiStrategy.markDiagnostic(diagnostic)\n            is KtLightSourceElement -> lightTreeStrategy.markKtDiagnostic(element, diagnostic)\n            else -> offsetsOnlyPositioningStrategy.markKtDiagnostic(element, diagnostic)\n        }\n    }"}
{"context": "open class A {\n    companion object {\n        fun foo() {}\n        val D = \"\"\n    }\nfun bar() {\n", "line_to_complete": "\n        foo()\n    }"}
{"context": "open class A {\n    companion object {\n        fun foo() {}\n        val D = \"\"\n    }\n\n    fun bar() {\n        foo()\n    }\n}\n\nclass B {\n    companion object : A() {\n        fun baz() {}\n        val C = \"\"\n    }\n}\nfun test() {\n", "line_to_complete": "\n    A.foo()\n    B.bar()\n    B.baz()\n    val x = A.D\n    val y = B.C\n    val z = B.<!UNRESOLVED_REFERENCE!>D<!>\n}"}
{"context": "// ISSUE: KT-50160\n// WITH_STDLIB\n\nsealed interface Square\nobject MARKED : Square\nobject UNMARKED : Square\nfun test_1() {\n", "line_to_complete": "\n    val lines: List<String> = listOf()\n    val cards = lines.windowed(6)\n        .map { card ->\n            card.map { line: String ->\n                line.map { UNMARKED as Square }\n                    .toMutableList()\n            }\n        }\n    cards[0][0][0] = MARKED\n}"}
{"context": "// ISSUE: KT-50160\n// WITH_STDLIB\n\nsealed interface Square\nobject MARKED : Square\nobject UNMARKED : Square\n\nfun test_1() {\n    val lines: List<String> = listOf()\n    val cards = lines.windowed(6)\n        .map { card ->\n            card.map { line: String ->\n                line.map { UNMARKED as Square }\n                    .toMutableList()\n            }\n        }\n    cards[0][0][0] = MARKED\n}\nfun test_2() {\n", "line_to_complete": "\n    val lines: List<String> = listOf()\n    val cards = lines.windowed(6)\n        .map { card ->\n            card.map { line: String ->\n                line.map { UNMARKED }\n                    .toMutableList()\n            }\n        }\n    cards[0][0][0] = <!ARGUMENT_TYPE_MISMATCH!>MARKED<!>\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.extended\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.type.FirTypeRefChecker\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.scopes.platformClassMapper\nimport org.jetbrains.kotlin.fir.types.FirResolvedTypeRef\nimport org.jetbrains.kotlin.fir.types.FirTypeRef\nimport org.jetbrains.kotlin.fir.types.classId\n\nobject PlatformClassMappedToKotlinTypeRefChecker : FirTypeRefChecker(MppCheckerKind.Common) {\noverride fun check(typeRef: FirTypeRef, context: CheckerContext, reporter: DiagnosticReporter) {\n", "line_to_complete": "\n        if (typeRef is FirResolvedTypeRef && typeRef.source != null) {\n            val kotlinClass = context.session.platformClassMapper.getCorrespondingKotlinClass(typeRef.type.classId)\n            if (kotlinClass != null) {\n                reporter.reportOn(typeRef.source, FirErrors.PLATFORM_CLASS_MAPPED_TO_KOTLIN, kotlinClass, context)\n            }\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.resolve.checkers\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.descriptors.ClassifierDescriptor\nimport org.jetbrains.kotlin.descriptors.ConstructorDescriptor\nimport org.jetbrains.kotlin.psi.KtEnumEntrySuperclassReferenceExpression\nimport org.jetbrains.kotlin.psi.KtThisExpression\nimport org.jetbrains.kotlin.psi.synthetics.findClassDescriptor\nimport org.jetbrains.kotlin.resolve.calls.util.getResolvedCall\nimport org.jetbrains.kotlin.resolve.deprecation.createDeprecationDiagnostic\n\nclass DeprecatedClassifierUsageChecker : ClassifierUsageChecker {\noverride fun check(targetDescriptor: ClassifierDescriptor, element: PsiElement, context: ClassifierUsageCheckerContext) {\n", "line_to_complete": "\n        if (element.parent is KtThisExpression) return\n\n        if (context.languageVersionSettings.supportsFeature(LanguageFeature.NoDeprecationOnDeprecatedEnumEntries) && element is KtEnumEntrySuperclassReferenceExpression) {\n            val referencedEnum =\n                (element.getResolvedCall(context.trace.bindingContext)?.resultingDescriptor as? ConstructorDescriptor)?.constructedClass\n            if (referencedEnum == targetDescriptor) {\n                return\n            }\n        }\n\n        for (deprecation in context.deprecationResolver.getDeprecations(targetDescriptor)) {\n            context.trace.report(createDeprecationDiagnostic(element, deprecation, context.languageVersionSettings))\n        }\n    }"}
{"context": "package test\n\nclass Foo\n\nval Foo.action: () -> Unit get() = {}\nfun usage(foo: Foo) {\n", "line_to_complete": "\n    foo.acti<caret>on()\n}"}
{"context": "class Foo(vararg val strings: String)\nfun test_1(foo: Foo) {\n", "line_to_complete": "\n    for (s in foo.strings) {\n        s.length\n    }\n}"}
{"context": "class Foo(vararg val strings: String)\n\nfun test_1(foo: Foo) {\n    for (s in foo.strings) {\n        s.length\n    }\n}\nfun test_2(vararg strings: String) {\n", "line_to_complete": "\n    for (s in strings) {\n        s.length\n    }\n}"}
{"context": "fun resolve<caret>Me() {\n    receive(functionWithLazyBody())\n}\n\nfun receive(value: String){}\nfun functionWithLazyBody(): String {\n", "line_to_complete": "\n    return \"42\"\n}"}
{"context": "class A {\n    constructor(i: Int)\n}\nfun call() {\n", "line_to_complete": "\n    val a = <expr>A(42)</expr>\n}"}
{"context": "// TARGET_PLATFORM: JS\n// DO_NOT_CHECK_SYMBOL_RESTORE\nfun foo(jsObject: dynamic) {\n", "line_to_complete": "\n    jsObject.dynamic<caret>PropertyAccess\n}"}
{"context": "// WITH_STDLIB\nfun foo() {\n", "line_to_complete": "\n    var listVar = mutableListOf(1, 2, 3)\n    // now, Idea hightlights this code like error (cuz listVar\n    // is mutable and listVar + 4 is immutable) and like warning\n    // (cuz can be replaced with +=)\n    <!ASSIGNED_VALUE_IS_NEVER_READ!>listVar<!> = <!ASSIGNMENT_TYPE_MISMATCH!>listVar + 4<!>\n}"}
{"context": "// ISSUE: KT-52262\nfun test_1(name: String?) {\n", "line_to_complete": "\n    when (name) {\n        null -> return\n    }\n    name.length\n}"}
{"context": "// ISSUE: KT-52262\n\nfun test_1(name: String?) {\n    when (name) {\n        null -> return\n    }\n    name.length\n}\nfun test_2(name: String?) {\n", "line_to_complete": "\n    when (val s = name) {\n        null -> return\n    }\n    name.length\n}"}
{"context": "class A {\nfun x() {\n", "line_to_complete": "\n        val <expr>a</expr> = doSmth(\"str\")\n    }"}
{"context": "// !CHECK_TYPE\n// UNEXPECTED BEHAVIOUR\n// ISSUES: KT-37066\n\n// TESTCASE NUMBER: 1\n// FILE: JavaClass.java\npublic final class JavaClass implements Comparable<JavaClass> {\n    private final String name;\n\n    public JavaClass (String name) {\n        this.name = name;\n    }\n\n    @Override\n    public int compareTo(JavaClass that) {\n        return this.name.compareTo(that.name);\n    }\n}\n\n\n// FILE: KotlinClass.kt\nfun case1(javaClass: JavaClass?) {\n", "line_to_complete": "\n    val validType: (JavaClass) -> Boolean = if (javaClass != null) { it -> it == javaClass } else BooCase1.FILTER\n\n    val invalidType = if (javaClass != null) { it -> it == javaClass } else BooCase1.FILTER\n\n    validType.checkType { _<Function1<JavaClass, Boolean>>() } //ok\n\n    invalidType.checkType { <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Function1<Nothing, Boolean>>() } //(!!!)\n\n    Case1(javaClass).x.checkType { <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Function1<Nothing, Boolean>>() } //(!!!)\n}"}
{"context": "// FILE: main.kt\nfun some() {\n", "line_to_complete": "\n    JavaClass().<caret>count\n}"}
{"context": "// FILE: main.kt\nimport dependency.Base\nimport dependency.Child\nimport dependency.Child.staticFunFromBase\nimport dependency.Child.STATIC_CONSTANT_FROM_BASE\nimport KotlinChild.nonStaticFieldFromBase\nfun usage() {\n", "line_to_complete": "\n    Child.staticFunFromBase()\n    Child.STATIC_CONSTANT_FROM_BASE\n    KotlinChild.nonStaticFieldFromBase\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen.optimization\n\nimport org.jetbrains.kotlin.codegen.inline.insnText\nimport org.jetbrains.kotlin.codegen.optimization.common.OptimizationBasicInterpreter\nimport org.jetbrains.kotlin.codegen.optimization.common.StrictBasicValue\nimport org.jetbrains.kotlin.codegen.optimization.common.removeAll\nimport org.jetbrains.kotlin.codegen.optimization.fixStack.peek\nimport org.jetbrains.kotlin.codegen.optimization.fixStack.top\nimport org.jetbrains.kotlin.codegen.optimization.transformer.MethodTransformer\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.tree.*\nimport org.jetbrains.org.objectweb.asm.tree.analysis.BasicValue\nimport org.jetbrains.org.objectweb.asm.tree.analysis.Frame\n\nclass ConstantConditionEliminationMethodTransformer : MethodTransformer() {\noverride fun transform(internalClassName: String, methodNode: MethodNode) {\n", "line_to_complete": "\n        if (!methodNode.hasOptimizableConditions()) {\n            return\n        }\n        do {\n            val changes = ConstantConditionsOptimization(internalClassName, methodNode).run()\n        } while (changes)\n    }"}
{"context": "// ISSUE: KT-53920\nfun test() {\n", "line_to_complete": "\n    return\n    object {}\n}"}
{"context": "interface A {\n    operator fun plusAssign(i: Int)\n}\n\ninterface MyMap<K, V> {\n    operator fun get(k: K): V\n}\nfun test(m: MyMap<String, A>) {\n", "line_to_complete": "\n    <expr>m[\"a\"]</expr> += 1\n}"}
{"context": "// MODULE: lib\n\n// FILE: some/Outer.kt\npackage some\n\ninterface Flag<T>\n\nclass Outer {\n    val VAL_FLAG: Flag<*> = TODO()\n    var varFlag: Flag<*> = TODO()\n\n    inner class Inner {\n        val VAL_FLAG: Flag<*> = TODO()\n        var varFlag: Flag<*> = TODO()\n    }\n}\n\n// MODULE: app(lib)\n// MODULE_KIND: Source\n// FILE: main.kt\npackage some\n\nprivate fun consumeFlag(p: Flag<*>) {\n", "line_to_complete": "\n    println(p)\n}"}
{"context": "// MODULE: lib\n\n// FILE: some/Outer.kt\npackage some\n\ninterface Flag<T>\n\nclass Outer {\n    val VAL_FLAG: Flag<*> = TODO()\n    var varFlag: Flag<*> = TODO()\n\n    inner class Inner {\n        val VAL_FLAG: Flag<*> = TODO()\n        var varFlag: Flag<*> = TODO()\n    }\n}\n\n// MODULE: app(lib)\n// MODULE_KIND: Source\n// FILE: main.kt\n\npackage some\n\nprivate fun consumeFlag(p: Flag<*>) {\n    println(p)\n}\nfun test() {\n", "line_to_complete": "\n    val o = Outer()\n    consumeFlag(o.VAL_<caret>FLAG)\n    consumeFlag(o.varFlag)\n    val i = o.Inner()\n    consumeFlag(i.VAL_FLAG)\n    consumeFlag(i.varFlag)\n}"}
{"context": "// FULL_JDK\nfun test(map: java.util.AbstractMap<String, Int>) {\n", "line_to_complete": "\n    map.remove(\"\", null)\n    map.remove(null)\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.base.contextReceivers.renderers\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.base.KtContextReceiversOwner\nimport org.jetbrains.kotlin.analysis.api.renderer.base.contextReceivers.KtContextReceiversRenderer\nimport org.jetbrains.kotlin.analysis.api.renderer.types.KtTypeRenderer\nimport org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter\n\npublic interface KtContextReceiverListRenderer {\n    context(KtAnalysisSession, KtContextReceiversRenderer, KtTypeRenderer)\n    public fun renderContextReceivers(owner: KtContextReceiversOwner, printer: PrettyPrinter)\n\n    public object AS_SOURCE : KtContextReceiverListRenderer {\n        context(KtAnalysisSession, KtContextReceiversRenderer, KtTypeRenderer)\noverride fun renderContextReceivers(owner: KtContextReceiversOwner, printer: PrettyPrinter) {\n", "line_to_complete": "\n            val contextReceivers = owner.contextReceivers\n            if (contextReceivers.isEmpty()) return\n\n            printer {\n                append(\"context(\")\n                printCollection(contextReceivers) { contextReceiver ->\n                    contextReceiverLabelRenderer.renderLabel(contextReceiver, printer)\n                    renderType(contextReceiver.type, printer)\n                }\n                append(\")\")\n            }\n        }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.declarations.bodies\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.symbols.KtValueParameterSymbol\nimport org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter\n\npublic interface KtParameterDefaultValueRenderer {\n    context(KtAnalysisSession)\n    public fun renderDefaultValue(symbol: KtValueParameterSymbol, printer: PrettyPrinter)\n\n    public object NO_DEFAULT_VALUE : KtParameterDefaultValueRenderer {\n        context(KtAnalysisSession)\n        override fun renderDefaultValue(symbol: KtValueParameterSymbol, printer: PrettyPrinter) {\n        }\n    }\n\n    public object THREE_DOTS : KtParameterDefaultValueRenderer {\n        context(KtAnalysisSession)\noverride fun renderDefaultValue(symbol: KtValueParameterSymbol, printer: PrettyPrinter) {\n", "line_to_complete": "\n            if (symbol.hasDefaultValue) {\n                printer.append(\"...\")\n            }\n        }"}
{"context": "// LANGUAGE: +ContextReceivers\n\n// MODULE: context\n\n// FILE: context.kt\nclass Ctx1\nclass Ctx2\n\ncontext(Ctx1, Ctx2)\nfun useWithCtx1Ctx2() = 3\n\ncontext(Ctx1, Ctx2)\nfun foo() {\n", "line_to_complete": "\n    <caret_context>val x = 1\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen.inline\n\nimport org.jetbrains.kotlin.codegen.StackValue\nimport org.jetbrains.org.objectweb.asm.Type\n\nclass ParametersBuilder private constructor() {\n\n    private val params = arrayListOf<ParameterInfo>()\n\n    private var valueParamFirstIndex = 0\n\n    var nextParameterOffset = 0\n        private set\n\n    private var nextValueParameterIndex = 0\nfun addThis(type: Type, skipped: Boolean): ParameterInfo {\n", "line_to_complete": "\n        return addParameter(ParameterInfo(type, skipped, nextParameterOffset, -1, nextValueParameterIndex), false)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen.inline\n\nimport org.jetbrains.kotlin.codegen.StackValue\nimport org.jetbrains.org.objectweb.asm.Type\n\nclass ParametersBuilder private constructor() {\n\n    private val params = arrayListOf<ParameterInfo>()\n\n    private var valueParamFirstIndex = 0\n\n    var nextParameterOffset = 0\n        private set\n\n    private var nextValueParameterIndex = 0\n\n    fun addThis(type: Type, skipped: Boolean): ParameterInfo {\n        return addParameter(ParameterInfo(type, skipped, nextParameterOffset, -1, nextValueParameterIndex), false)\n    }\nfun addNextParameter(type: Type, skipped: Boolean, typeOnStack: Type = type): ParameterInfo {\n", "line_to_complete": "\n        return addParameter(ParameterInfo(type, skipped, nextParameterOffset, null, nextValueParameterIndex, typeOnStack), false)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen.inline\n\nimport org.jetbrains.kotlin.codegen.StackValue\nimport org.jetbrains.org.objectweb.asm.Type\n\nclass ParametersBuilder private constructor() {\n\n    private val params = arrayListOf<ParameterInfo>()\n\n    private var valueParamFirstIndex = 0\n\n    var nextParameterOffset = 0\n        private set\n\n    private var nextValueParameterIndex = 0\n\n    fun addThis(type: Type, skipped: Boolean): ParameterInfo {\n        return addParameter(ParameterInfo(type, skipped, nextParameterOffset, -1, nextValueParameterIndex), false)\n    }\n\n    fun addNextParameter(type: Type, skipped: Boolean, typeOnStack: Type = type): ParameterInfo {\n        return addParameter(ParameterInfo(type, skipped, nextParameterOffset, null, nextValueParameterIndex, typeOnStack), false)\n    }\nfun addNextValueParameter(type: Type, skipped: Boolean, remapValue: StackValue?, parameterIndex: Int): ParameterInfo {\n", "line_to_complete": "\n        return addParameter(\n            ParameterInfo(type, skipped, nextParameterOffset, remapValue, parameterIndex + valueParamFirstIndex),\n            true\n        )\n    }"}
{"context": "fun test() {\n    <expr>call()</expr>\n}\nfun call(): String? {\n", "line_to_complete": "\n    return null\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.resolve\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.resolve.providers.symbolProvider\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol\nimport org.jetbrains.kotlin.fir.types.ConeClassLikeType\n\nclass FirOuterClassManager(\n    private val session: FirSession,\n    private val outerLocalClassForNested: Map<FirClassLikeSymbol<*>, FirClassLikeSymbol<*>>,\n) {\n    private val symbolProvider = session.symbolProvider\nfun outerClass(classSymbol: FirClassLikeSymbol<*>): FirClassLikeSymbol<*>? {\n", "line_to_complete": "\n        if (classSymbol !is FirClassSymbol<*>) return null\n        val classId = classSymbol.classId\n        if (classId.isLocal) return outerLocalClassForNested[classSymbol]\n        val outerClassId = classId.outerClassId ?: return null\n        return symbolProvider.getClassLikeSymbolByClassId(outerClassId)\n    }"}
{"context": "var a = 5\nfun foo() = <expr>if (true) {\n", "line_to_complete": "\n    a = 6\n}"}
{"context": "// FILE: main.kt\npackage test\n\nimport dependency.Bar.extFun\nfun usage() {\n", "line_to_complete": "\n    with(10) {\n        extFun()\n    }\n}"}
{"context": "// FULL_JDK\nfun foo() {\n", "line_to_complete": "\n    val y = listOf(\"Alpha\", \"Beta\")\n    val x = LinkedHashSet<String>().apply {\n        addAll(y)\n    }\n\n    val z = ArrayList<String>()\n    z.addAll(y)\n    z.add(\"Omega\")\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.build.report.metrics\n\nimport java.io.Serializable\nimport java.util.*\nimport kotlin.collections.HashMap\n\nclass BuildTimes<T : BuildTime> : Serializable {\n    private val buildTimesNs = HashMap<T, Long>()\nfun addAll(other: BuildTimes<T>) {\n", "line_to_complete": "\n        for ((buildTime, timeNs) in other.buildTimesNs) {\n            addTimeNs(buildTime, timeNs)\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.build.report.metrics\n\nimport java.io.Serializable\nimport java.util.*\nimport kotlin.collections.HashMap\n\nclass BuildTimes<T : BuildTime> : Serializable {\n    private val buildTimesNs = HashMap<T, Long>()\n\n    fun addAll(other: BuildTimes<T>) {\n        for ((buildTime, timeNs) in other.buildTimesNs) {\n            addTimeNs(buildTime, timeNs)\n        }\n    }\nfun addTimeNs(buildTime: T, timeNs: Long) {\n", "line_to_complete": "\n        buildTimesNs[buildTime] = buildTimesNs.getOrDefault(buildTime, 0) + timeNs\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.build.report.metrics\n\nimport java.io.Serializable\nimport java.util.*\nimport kotlin.collections.HashMap\n\nclass BuildTimes<T : BuildTime> : Serializable {\n    private val buildTimesNs = HashMap<T, Long>()\n\n    fun addAll(other: BuildTimes<T>) {\n        for ((buildTime, timeNs) in other.buildTimesNs) {\n            addTimeNs(buildTime, timeNs)\n        }\n    }\n\n    fun addTimeNs(buildTime: T, timeNs: Long) {\n        buildTimesNs[buildTime] = buildTimesNs.getOrDefault(buildTime, 0) + timeNs\n    }\n\n    fun addTimeMs(buildTime: T, timeMs: Long) = addTimeNs(buildTime, timeMs * 1_000_000)\nfun asMapMs(): Map<T, Long> = buildTimesNs.mapValues {\n", "line_to_complete": " it.value / 1_000_000 }"}
{"context": "// DUMP_CFG\n\nfun getNullableString(): String? = null\nfun takeNullableString(s: String?) {}\nfun test_1() {\n", "line_to_complete": "\n    val x: String?\n\n    try {\n        val y = getNullableString()!! // 3\n        x = getNullableString()\n    } finally {\n        Unit\n    }\n\n    takeNullableString(x)\n}"}
{"context": "// DUMP_CFG\n\nfun getNullableString(): String? = null\nfun takeNullableString(s: String?) {}\n\nfun test_1() {\n    val x: String?\n\n    try {\n        val y = getNullableString()!! // 3\n        x = getNullableString()\n    } finally {\n        Unit\n    }\n\n    takeNullableString(x)\n}\nfun test_2() {\n", "line_to_complete": "\n    val x: String?\n\n    try {\n        val y = getNullableString()\n        x = getNullableString()\n    } finally {\n        Unit\n    }\n\n    takeNullableString(x)\n}"}
{"context": "interface A {\n    fun foo() {}\n}\n\ninterface B {\n    fun bar() {}\n}\n\nclass C : A, B {\nfun test() {\n", "line_to_complete": "\n        <expr>super</expr>.unresolved()\n    }"}
{"context": "// COMPILATION_ERRORS\nfun test() {\n", "line_to_complete": "\n    call(val<caret>ue = \"foo\")\n}"}
{"context": "// !DUMP_CFG\nfun test_1(x: Any) {\n", "line_to_complete": "\n    if (x is String) {\n        x.length\n    }\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}"}
{"context": "// !DUMP_CFG\nfun test_1(x: Any) {\n    if (x is String) {\n        x.length\n    }\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}\nfun test_2(x: Any) {\n", "line_to_complete": "\n    val b = x is String\n    if (b) {\n        x.length\n    }\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}"}
{"context": "// !DUMP_CFG\nfun test_1(x: Any) {\n    if (x is String) {\n        x.length\n    }\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}\n\nfun test_2(x: Any) {\n    val b = x is String\n    if (b) {\n        x.length\n    }\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}\nfun test_3(x: Any) {\n", "line_to_complete": "\n    when {\n        x !is String -> {}\n        <!USELESS_IS_CHECK!>x !is Int<!> -> {}\n        else -> {\n            x.length\n            x.inc()\n        }\n    }\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.declarations.renderers.callables\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.renderer.declarations.KtDeclarationRenderer\nimport org.jetbrains.kotlin.analysis.api.symbols.KtReceiverParameterSymbol\nimport org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter\nimport org.jetbrains.kotlin.types.Variance\n\npublic interface KtCallableReceiverRenderer {\n    context(KtAnalysisSession, KtDeclarationRenderer)\n    public fun renderReceiver(symbol: KtReceiverParameterSymbol, printer: PrettyPrinter)\n\n    public object AS_TYPE_WITH_IN_APPROXIMATION : KtCallableReceiverRenderer {\n        context(KtAnalysisSession, KtDeclarationRenderer)\noverride fun renderReceiver(symbol: KtReceiverParameterSymbol, printer: PrettyPrinter): Unit = printer {\n", "line_to_complete": "\n            \" \".separated(\n                {\n                    annotationRenderer.renderAnnotations(symbol, printer)\n                },\n                {\n                    val receiverType = declarationTypeApproximator.approximateType(symbol.type, Variance.IN_VARIANCE)\n                    typeRenderer.renderType(receiverType, printer)\n                },\n            )\n        }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.components\n\nimport org.jetbrains.kotlin.analysis.api.components.KtSubstitutorBuilder\nimport org.jetbrains.kotlin.analysis.api.components.KtSubstitutorFactory\nimport org.jetbrains.kotlin.analysis.api.fir.KtFirAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.fir.symbols.KtFirTypeParameterSymbol\nimport org.jetbrains.kotlin.analysis.api.fir.types.KtFirGenericSubstitutor\nimport org.jetbrains.kotlin.analysis.api.fir.types.KtFirMapBackedSubstitutor\nimport org.jetbrains.kotlin.analysis.api.fir.types.KtFirType\nimport org.jetbrains.kotlin.analysis.api.types.KtSubstitutor\nimport org.jetbrains.kotlin.fir.resolve.substitution.ConeSubstitutorByMap\n\ninternal class KtFirSubstitutorFactory(\n    override val analysisSession: KtFirAnalysisSession\n) : KtSubstitutorFactory(), KtFirAnalysisSessionComponent {\noverride fun buildSubstitutor(builder: KtSubstitutorBuilder): KtSubstitutor {\n", "line_to_complete": "\n        if (builder.mappings.isEmpty()) return KtSubstitutor.Empty(token)\n\n        val firSubstitution = buildMap {\n            builder.mappings.forEach { (ktTypeParameterSymbol, ktType) ->\n                check(ktTypeParameterSymbol is KtFirTypeParameterSymbol)\n                check(ktType is KtFirType)\n                put(ktTypeParameterSymbol.firSymbol, ktType.coneType)\n            }\n        }\n\n        return when (val coneSubstitutor = ConeSubstitutorByMap.create(firSubstitution, analysisSession.useSiteSession)) {\n            is ConeSubstitutorByMap -> KtFirMapBackedSubstitutor(coneSubstitutor, analysisSession.firSymbolBuilder)\n            else -> KtFirGenericSubstitutor(coneSubstitutor, analysisSession.firSymbolBuilder)\n        }\n    }"}
{"context": "// FILE: Sample.java\n\nimport java.util.List;\n\npublic class Sample {\n    public static void foo(List<List<String>> listOfLists) {}\n}\n\n// FILE: test.kt\nfun main() {\n", "line_to_complete": "\n    Sample.foo(<!ARGUMENT_TYPE_MISMATCH(\"kotlin.collections.(Mutable)List<kotlin.collections.(Mutable)List<kotlin.String!>!>!; kotlin.String\")!>\"123\"<!>)\n}"}
{"context": "// ISSUE: KT-39046\n\nfun foo(b: B<Int, Int>) {}\nfun test_1(b: B<String, Number>) {\n", "line_to_complete": "\n    foo(b.myMap {\n        it.k.length // implicits\n    } <!UNCHECKED_CAST!>as B<Int, Int><!>)\n}"}
{"context": "// ISSUE: KT-39046\n\nfun foo(b: B<Int, Int>) {}\n\nfun test_1(b: B<String, Number>) {\n    foo(b.myMap {\n        it.k.length // implicits\n    } <!UNCHECKED_CAST!>as B<Int, Int><!>)\n}\nfun test_2(s: String) {\n", "line_to_complete": "\n    val func = { s.length } <!CAST_NEVER_SUCCEEDS!>as<!> B<Int, Int>\n}"}
{"context": "typealias X<XT> = List<X>\nclass A {\n    typealias Y<YS, YV> = Map<YS, YV>\n\n    class B {\n        typealias Q<QS, QV> = MutableMap<QS, QV>\n    }\n}\nfun foo() {\n", "line_to_complete": "\n    typealias L<LS, LV> = Map<LS, LV>\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.types.impl\n\nimport org.jetbrains.kotlin.fir.symbols.ConeTypeParameterLookupTag\nimport org.jetbrains.kotlin.fir.types.ConeAttributes\nimport org.jetbrains.kotlin.fir.types.ConeTypeProjection\nimport org.jetbrains.kotlin.fir.types.ConeNullability\nimport org.jetbrains.kotlin.fir.types.ConeTypeParameterType\n\nclass ConeTypeParameterTypeImpl(\n    override val lookupTag: ConeTypeParameterLookupTag,\n    isNullable: Boolean,\n    override val attributes: ConeAttributes = ConeAttributes.Empty\n) : ConeTypeParameterType() {\n    override val typeArguments: Array<out ConeTypeProjection>\n        get() = EMPTY_ARRAY\n\n    override val nullability: ConeNullability = ConeNullability.create(isNullable)\noverride fun equals(other: Any?): Boolean {\n", "line_to_complete": "\n        if (this === other) return true\n        if (javaClass != other?.javaClass) return false\n\n        other as ConeTypeParameterTypeImpl\n\n        if (lookupTag != other.lookupTag) return false\n        if (nullability != other.nullability) return false\n\n        return true\n    }"}
{"context": "// new contracts syntax for simple functions\nfun test1(s: MyClass?) contract [returns() implies (s != null), returns() implies (s is MySubClass)] {\n", "line_to_complete": "\n    test_1()\n}"}
{"context": "// new contracts syntax for simple functions\nfun test1(s: MyClass?) contract [returns() implies (s != null), returns() implies (s is MySubClass)] {\n    test_1()\n}\nfun test2() contract [returnsNotNull()] {\n", "line_to_complete": "\n    test2()\n}"}
{"context": "// WITH_FIR_TEST_COMPILER_PLUGIN\n// DUMP_IR\n\n// MODULE: lib\n// MODULE_KIND: LibraryBinary\n// FILE: p2/foo.kt\npackage p2\n\nclass A {\n    fun callA() {}\n}\n\nclass B {\n    fun callB() {}\n}\n// MODULE: lib2(lib)\n// MODULE_KIND: LibraryBinary\n// FILE: p3/bar.kt\npackage p3\n\nimport org.jetbrains.kotlin.fir.plugin.MyComposable\nimport p2.A\ninterface RowScope\n\ninline fun Row(a: A, content: @MyComposable RowScope.() -> Unit) {\n", "line_to_complete": "\n    a.callA()\n}"}
{"context": "// WITH_FIR_TEST_COMPILER_PLUGIN\n// DUMP_IR\n\n// MODULE: lib\n// MODULE_KIND: LibraryBinary\n// FILE: p2/foo.kt\npackage p2\n\nclass A {\n    fun callA() {}\n}\n\nclass B {\n    fun callB() {}\n}\n// MODULE: lib2(lib)\n// MODULE_KIND: LibraryBinary\n// FILE: p3/bar.kt\npackage p3\n\nimport org.jetbrains.kotlin.fir.plugin.MyComposable\nimport p2.A\n\ninterface RowScope\n\ninline fun Row(a: A, content: @MyComposable RowScope.() -> Unit) {\n    a.callA()\n}\n// MODULE: main(lib, lib2)\n// FILE: main.kt\nimport org.jetbrains.kotlin.fir.plugin.MyComposable\nimport p2.A\nimport p2.B\nimport p3.Row\nfun AuthorAndReadTime(b: B) {\n", "line_to_complete": "\n    Row(A()) {\n        b.callB()\n    }\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.providers.impl\n\nimport com.intellij.openapi.project.Project\nimport org.jetbrains.annotations.TestOnly\n\npublic class KotlinStaticGlobalModificationService(private val project: Project) : KotlinGlobalModificationServiceBase(project) {\n    @TestOnly\noverride fun incrementModificationTrackers(includeBinaryTrackers: Boolean) {\n", "line_to_complete": "\n        KotlinStaticModificationTrackerFactory.getInstance(project).incrementModificationsCount(includeBinaryTrackers)\n    }"}
{"context": "// IGNORE_FE10\nclass F {\n    var a = 1\nfun handleLeftBracketInFragment() {\n", "line_to_complete": "\n        foo().<expr>peek()</expr>.a++\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators\n\nimport com.intellij.openapi.Disposable\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.diagnostic.compiler.based.configureCustomScriptDefinitions\nimport org.jetbrains.kotlin.test.builders.TestConfigurationBuilder\n\nclass AnalysisApiFirCustomScriptDefinitionTestConfigurator(analyseInDependentSession: Boolean) :\n    AnalysisApiFirScriptTestConfigurator(analyseInDependentSession) {\noverride fun configureTest(builder: TestConfigurationBuilder, disposable: Disposable) {\n", "line_to_complete": "\n        super.configureTest(builder, disposable)\n        builder.configureCustomScriptDefinitions()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.container\n\nimport com.intellij.util.containers.MultiMap\nimport java.lang.reflect.Type\n\ninternal class ComponentRegistry {\nfun buildRegistrationMap(descriptors: Collection<ComponentDescriptor>): MultiMap<Type, ComponentDescriptor> {\n", "line_to_complete": "\n        val registrationMap = MultiMap<Type, ComponentDescriptor>()\n        for (descriptor in descriptors) {\n            for (registration in descriptor.getRegistrations()) {\n                registrationMap.putValue(registration, descriptor)\n            }\n        }\n        return registrationMap\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.container\n\nimport com.intellij.util.containers.MultiMap\nimport java.lang.reflect.Type\n\ninternal class ComponentRegistry {\n    fun buildRegistrationMap(descriptors: Collection<ComponentDescriptor>): MultiMap<Type, ComponentDescriptor> {\n        val registrationMap = MultiMap<Type, ComponentDescriptor>()\n        for (descriptor in descriptors) {\n            for (registration in descriptor.getRegistrations()) {\n                registrationMap.putValue(registration, descriptor)\n            }\n        }\n        return registrationMap\n    }\n\n    private val registrationMap = hashMapOf<Type, Any>()\nfun addAll(descriptors: Collection<ComponentDescriptor>) {\n", "line_to_complete": "\n        val newRegistrationMap = buildRegistrationMap(descriptors)\n        for (entry in newRegistrationMap.entrySet()) {\n            val oldEntries = registrationMap[entry.key]\n            if (oldEntries != null || entry.value.size > 1) {\n                val list = mutableListOf<ComponentDescriptor>()\n                if (oldEntries is Collection<*>) {\n                    @Suppress(\"UNCHECKED_CAST\")\n                    list.addAll(oldEntries as Collection<ComponentDescriptor>)\n                }\n                else if (oldEntries != null) {\n                    list.add(oldEntries as ComponentDescriptor)\n                }\n                list.addAll(entry.value)\n                registrationMap[entry.key] = list.singleOrNull() ?: list\n            }\n            else {\n                registrationMap[entry.key] = entry.value.single()\n            }\n        }\n    }"}
{"context": "fun foo(x: (String) -> Int) {}\n\n\nfun bar(y: Any): Int = 1\nfun bar(x: String): Int = 1\nfun main() {\n", "line_to_complete": "\n    foo(::bar)\n}"}
{"context": "// WITH_STDLIB\nfun a () {\n", "line_to_complete": "\n    val list = mutableListOf(1)\n    list<caret>[0] = 1\n\n    if (true) list<caret_singleIfStatement>[0] = 1\n\n    when { else -> list<caret_singleWhenStatement>[0] = 1 }\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.resolve.transformers\n\nimport org.jetbrains.kotlin.fir.diagnostics.ConeDiagnostic\nimport org.jetbrains.kotlin.fir.resolve.diagnostics.ConeUnresolvedParentInImport\nimport org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProvider\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.name.FqName\nfun findLongestExistingPackage(symbolProvider: FirSymbolProvider, fqName: FqName): PackageAndClass {\n", "line_to_complete": "\n    var currentPackage = fqName\n\n    val pathSegments = fqName.pathSegments()\n    var prefixSize = pathSegments.size\n    while (!currentPackage.isRoot && prefixSize > 0) {\n        if (symbolProvider.getPackage(currentPackage) != null) {\n            break\n        }\n        currentPackage = currentPackage.parent()\n        prefixSize--\n    }\n\n    if (currentPackage == fqName) return PackageAndClass(currentPackage, relativeClassFqName = null)\n    val relativeClassFqName = FqName.fromSegments((prefixSize until pathSegments.size).map { pathSegments[it].asString() })\n\n    return PackageAndClass(currentPackage, relativeClassFqName)\n}"}
{"context": "// SKIP_JAVAC\n// This directive is needed to skip this test in LazyBodyIsNotTouchedTilContractsPhaseTestGenerated,\n//  because it fails to parse module structure of multimodule test\n\n// MODULE: lib\npackage dependency\n\nabstract class A {\n    abstract fun foo()\n}\ninterface I {\n    fun foo()\n}\n\n// MODULE: main(lib)\n// FILE: B.kt\npackage main\nimport dependency.A\nimport dependency.I\n\nabstract class B : A(), I {}\nfun usage(b : B?) {\n", "line_to_complete": "\n    if (b != null) {\n        b.foo()\n    }\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.idea.references\n\nimport com.intellij.openapi.util.TextRange\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.util.OperatorNameConventions\n\nabstract class KtForLoopInReference(element: KtForExpression) : KtMultiReference<KtForExpression>(element) {\noverride fun getRangeInElement(): TextRange {\n", "line_to_complete": "\n        val inKeyword = expression.inKeyword ?: return TextRange.EMPTY_RANGE\n\n        val offset = inKeyword.startOffsetInParent\n        return TextRange(offset, offset + inKeyword.textLength)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analyzer\n\nimport org.jetbrains.kotlin.descriptors.ModuleDescriptor\n\nval ModuleDescriptor.moduleInfo: ModuleInfo?\n    get() = getCapability(ModuleInfo.Capability)\ninternal fun collectAllExpectedByModules(entryModule: ModuleInfo): Set<ModuleInfo> {\n", "line_to_complete": "\n    val unprocessedModules = ArrayDeque<ModuleInfo>().apply { addAll(entryModule.expectedBy) }\n    val expectedByModules = HashSet<ModuleInfo>()\n\n    while (unprocessedModules.isNotEmpty()) {\n        val nextImplemented = unprocessedModules.removeFirst()\n        if (expectedByModules.add(nextImplemented)) {\n            unprocessedModules.addAll(nextImplemented.expectedBy)\n        }\n    }\n\n    return expectedByModules\n}"}
{"context": "fun String.function(a: Int) {}\nfun call() {\n", "line_to_complete": "\n    \"str\"?.<expr>function(1)</expr>\n}"}
{"context": "fun foo1() {\n    println(\"foo1\")\n}\nfun foo2() {\n", "line_to_complete": "\n    println(\"foo2\")\n}"}
{"context": "fun foo1() {\n    println(\"foo1\")\n}\n\nfun foo2() {\n    println(\"foo2\")\n}\nfun foo3() {\n", "line_to_complete": "\n    println(\"foo3\")\n}"}
{"context": "fun foo1() {\n    println(\"foo1\")\n}\n\nfun foo2() {\n    println(\"foo2\")\n}\n\nfun foo3() {\n    println(\"foo3\")\n}\nfun foo4() {\n", "line_to_complete": "\n    println(\"foo4\")\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.daemon\n\nimport org.jetbrains.kotlin.daemon.common.DummyProfiler\nimport org.jetbrains.kotlin.daemon.common.Profiler\nimport org.jetbrains.kotlin.daemon.common.withMeasure\nimport org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache\nimport org.jetbrains.kotlin.load.kotlin.incremental.components.JvmPackagePartProto\nimport org.jetbrains.kotlin.modules.TargetId\n\nclass RemoteIncrementalCacheClient(\n    @Suppress(\"DEPRECATION\") val facade: org.jetbrains.kotlin.daemon.common.CompilerCallbackServicesFacade,\n    val target: TargetId,\n    val profiler: Profiler = DummyProfiler()\n): IncrementalCache {\noverride fun getObsoletePackageParts(): Collection<String> = profiler.withMeasure(this) {\n", "line_to_complete": " facade.incrementalCache_getObsoletePackageParts(target) }"}
{"context": "\n\npackage org.jetbrains.kotlin.daemon\n\nimport org.jetbrains.kotlin.daemon.common.DummyProfiler\nimport org.jetbrains.kotlin.daemon.common.Profiler\nimport org.jetbrains.kotlin.daemon.common.withMeasure\nimport org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache\nimport org.jetbrains.kotlin.load.kotlin.incremental.components.JvmPackagePartProto\nimport org.jetbrains.kotlin.modules.TargetId\n\nclass RemoteIncrementalCacheClient(\n    @Suppress(\"DEPRECATION\") val facade: org.jetbrains.kotlin.daemon.common.CompilerCallbackServicesFacade,\n    val target: TargetId,\n    val profiler: Profiler = DummyProfiler()\n): IncrementalCache {\n    override fun getObsoletePackageParts(): Collection<String> = profiler.withMeasure(this) { facade.incrementalCache_getObsoletePackageParts(target) }\noverride fun getObsoleteMultifileClasses(): Collection<String> = profiler.withMeasure(this) {\n", "line_to_complete": " facade.incrementalCache_getObsoleteMultifileClassFacades(target) }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.declarations\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.types.KtType\nimport org.jetbrains.kotlin.types.Variance\n\npublic interface KtRendererTypeApproximator {\n    context(KtAnalysisSession)\n    public fun approximateType(type: KtType, position: Variance): KtType\n\n    public object TO_DENOTABLE : KtRendererTypeApproximator {\n        context(KtAnalysisSession)\noverride fun approximateType(type: KtType, position: Variance): KtType {\n", "line_to_complete": "\n            type.getEnhancedType()?.let { return it }\n\n            return when (position) {\n                Variance.INVARIANT -> type\n                Variance.IN_VARIANCE -> type.approximateToSubPublicDenotableOrSelf(approximateLocalTypes = false)\n                Variance.OUT_VARIANCE -> type.approximateToSuperPublicDenotableOrSelf(approximateLocalTypes = false)\n            }\n        }"}
{"context": "// WITH_EXTENDED_CHECKERS\nclass A {\n    <!VALUE_CLASS_NOT_TOP_LEVEL!>inline<!> inner class B(val x: Int)\nfun foo() {\n", "line_to_complete": "\n        <!VALUE_CLASS_NOT_TOP_LEVEL, WRONG_MODIFIER_TARGET!>inline<!> class C(val x: Int)\n    }"}
{"context": "// !DUMP_CFG\ninterface A {\n    fun foo(): Boolean\n}\ninterface B : A\ninterface C : A\nfun test() {\n", "line_to_complete": "\n    var a: A? = null\n    while (a is B || a is C) {\n        a.foo()\n    }\n}"}
{"context": "// LOOK_UP_FOR_ELEMENT_OF_TYPE: org.jetbrains.kotlin.psi.KtDestructuringDeclarationEntry\n\ndata class X(val a: Int, val b: Int)\n\nfun x(action: (X) -> Unit) {}\nfun main() {\n", "line_to_complete": "\n    x { (<expr>_</expr>, b) ->\n\n    }\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.config\n\nimport org.jetbrains.kotlin.config.AnalysisFlags\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.declarations.getAnnotationByClassId\nimport org.jetbrains.kotlin.fir.declarations.getOwnDeprecation\nimport org.jetbrains.kotlin.fir.resolve.providers.symbolProvider\nimport org.jetbrains.kotlin.fir.resolve.transformers.PackageResolutionResult\nimport org.jetbrains.kotlin.fir.resolve.transformers.resolveToPackageOrClass\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.resolve.checkers.OptInNames\nimport org.jetbrains.kotlin.resolve.deprecation.DeprecationLevelValue\n\nobject FirOptInLanguageVersionSettingsChecker : FirLanguageVersionSettingsChecker() {\noverride fun check(context: CheckerContext, rawReport: (Boolean, String) -> Unit) {\n", "line_to_complete": "\n        context.languageVersionSettings.getFlag(AnalysisFlags.optIn).forEach { fqNameAsString ->\n            if (fqNameAsString != OptInNames.REQUIRES_OPT_IN_FQ_NAME.asString()) {\n                checkOptInMarkerArgument(context, fqNameAsString, rawReport)\n            }\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.build.report.statistics.file\n\nimport org.jetbrains.kotlin.build.report.metrics.*\nimport org.jetbrains.kotlin.build.report.statistics.*\nimport java.io.File\n\ndata class ReadableFileReportData<B : BuildTime, P : BuildPerformanceMetric>(\n    val statisticsData: List<CompileStatisticsData<B, P>>,\n    val startParameters: BuildStartParameters,\n    val failureMessages: List<String> = emptyList(),\n    val version: Int = 1\n)\n\nopen class ReadableFileReportService<B : BuildTime, P : BuildPerformanceMetric>(\n    buildReportDir: File,\n    projectName: String,\n    private val printMetrics: Boolean,\n) : FileReportService<ReadableFileReportData<B, P>>(buildReportDir, projectName, \"txt\") {\n\n    open fun printCustomTaskMetrics(statisticsData: CompileStatisticsData<B, P>, printer: Printer) {}\noverride fun printBuildReport(data: ReadableFileReportData<B, P>, outputFile: File) {\n", "line_to_complete": "\n        outputFile.bufferedWriter().use { writer ->\n            Printer(writer).printBuildReport(data, printMetrics) { compileStatisticsData ->\n                printCustomTaskMetrics(\n                    compileStatisticsData,\n                    this\n                )\n            }\n        }\n    }"}
{"context": "// IGNORE_FE10\nclass F {\n    val a = arrayOf(1, 2)\nfun handleLeftBracketInFragment() {\n", "line_to_complete": "\n        foo().<expr>peek()</expr>.a[0]++\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.resolve.calls\n\nimport com.intellij.lang.ASTNode\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.psi.KtExpression\nimport org.jetbrains.kotlin.psi.KtQualifiedExpression\nimport java.util.*\nfun unrollToLeftMostQualifiedExpression(expression: KtQualifiedExpression): List<KtQualifiedExpression> {\n", "line_to_complete": "\n    val unrolled = arrayListOf<KtQualifiedExpression>()\n\n    var finger = expression\n    while (true) {\n        unrolled.add(finger)\n        val receiver = finger.receiverExpression\n        if (receiver !is KtQualifiedExpression) {\n            break\n        }\n        finger = receiver\n    }\n\n    return unrolled.asReversed()\n}"}
{"context": "class A\nfun test(a: A, b: A) {\n", "line_to_complete": "\n    <expr>a !== b</expr>\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget\nimport org.jetbrains.kotlin.fir.FirAnnotationContainer\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotationCall\nimport org.jetbrains.kotlin.fir.references.FirErrorNamedReference\nimport org.jetbrains.kotlin.fir.references.FirResolvedNamedReference\n\nopen class FirAnnotationRenderer {\n\n    internal lateinit var components: FirRendererComponents\n    protected val visitor get() = components.visitor\n    protected val printer get() = components.printer\n    protected val callArgumentsRenderer get() = components.callArgumentsRenderer\nfun render(annotationContainer: FirAnnotationContainer, explicitAnnotationUseSiteTarget: AnnotationUseSiteTarget? = null) {\n", "line_to_complete": "\n        renderAnnotations(annotationContainer.annotations, explicitAnnotationUseSiteTarget)\n    }"}
{"context": "interface Foo\n\noperator fun <T> Foo.invoke(t: T) {}\nfun test(f: Foo) {\n", "line_to_complete": "\n    <expr>f(\"\")</expr>\n}"}
{"context": "fun foo() {}\nfun bar(s: String) {}\nfun bar(f: () -> Unit) {}\nfun test() {\n", "line_to_complete": "\n    foo(1)\n    bar(2)\n    bar(\"\", 1)\n    bar()\n}"}
{"context": "// FILE: main.kt\nimport dependency.Bar.property\nimport dependency.Bar.function\nimport dependency.Bar.callable\nfun test() {\n", "line_to_complete": "\n    dependency.Bar.property\n    dependency.Bar.function()\n    dependency.Bar::callable\n\n    with(dependency.Bar) {\n        property\n        function()\n        ::callable\n    }\n\n    val bar = dependency.Bar\n    bar.property\n    bar.function()\n    bar::callable\n}"}
{"context": "// FILE: J.java\npublic class J {\n    public static void f(Byte x) {}\n    public static void f(Integer x) {}\n    public static void f(Long x) {}\n}\n\n// FILE: x.kt\nfun f(x: Byte) {}\nfun f(x: Int) {}\nfun f(x: Long) {}\n\nfun g(x: Byte?) {}\nfun g(x: Int?) {}\nfun g(x: Long?) {}\nfun main() {\n", "line_to_complete": "\n    J.f(123)\n    J.f(123123123123)\n    f(123)\n    f(123123123123)\n    g(123)\n    g(123123123123)\n}"}
{"context": "package testing\n\ninterface Foo\n\nval otherFoo: Foo = makeFoo()\n\nfun makeFoo(action: () -> Unit): Foo = Foo()\n\nfun test() {}\nfun test() {\n", "line_to_complete": "\n    makeFoo {\n        <caret>test()\n    }.\n}"}
{"context": "fun <A> generic(a: A) { }\nfun foo() {\n", "line_to_complete": "\n    <expr>generic<Int, String>(5)</expr>\n}"}
{"context": "fun String.foo(i: Int): String = \"\"\nfun take(s: String?) {\n", "line_to_complete": "\n    s?.<expr>foo</expr>(10)\n}"}
{"context": "// FILE: JavaClass.java\npublic class JavaClass {\n    public static int bar(String x) { return 0; }\n    public int bar(CharSequence x) { return 0; }\n}\n\n// FILE: main.kt\n\nclass KotlinClass : JavaClass() {\n    fun baz(x: CharSequence): Int = 1\n    companion object {\n        fun baz(x: String): Int = 1\n    }\n}\n\nclass KotlinClass2 : JavaClass() {\n    override fun bar(x: CharSequence): Int = 1\n    companion object {\n        fun bar(x: String): Int = 1\n    }\n}\n\nfun foo1(x: (String) -> Int) {}\n\nfun foo2(x: (KotlinClass, CharSequence) -> Int) {}\n\nfun foo3(x: (KotlinClass, CharSequence) -> Int) {}\nfun foo3(x: (String) -> Int) {}\nfun main() {\n", "line_to_complete": "\n    foo1(KotlinClass::baz)\n    foo2(KotlinClass::baz)\n    // Ambiguity (companion/class)\n    <!OVERLOAD_RESOLUTION_AMBIGUITY!>foo3<!>(KotlinClass::baz)\n\n    // Type mismatch\n    foo1(KotlinClass::<!INAPPLICABLE_CANDIDATE!>bar<!>)\n    foo2(KotlinClass::bar)\n    foo3(KotlinClass::bar)\n\n    foo1(KotlinClass2::bar)\n    // Type mismatch\n    foo2(KotlinClass2::<!NONE_APPLICABLE!>bar<!>)\n    foo3(KotlinClass2::bar)\n}"}
{"context": "fun foo() {\n    val base = object {\nfun bar() = object {\n", "line_to_complete": "\n            fun buz() = foobar\n        }"}
{"context": "\n\npackage org.jetbrains.kotlin.util\n\nimport com.intellij.openapi.progress.ProgressManager\n\nobject ProgressManagerBasedCancellationChecker : CancellationChecker {\noverride fun check() {\n", "line_to_complete": "\n        ProgressManager.checkCanceled()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nclass FirDeclarationRendererWithFilteredAttributes : FirDeclarationRendererWithAttributes() {\noverride fun attributeTypesToIds(): List<Pair<String, Int>> {\n", "line_to_complete": "\n        return super.attributeTypesToIds().filter { it.first !in IGNORED_ATTRIBUTES }\n    }"}
{"context": "interface A\ninterface B\n\nvar a: Any = 1\nfun test() {\n", "line_to_complete": "\n    if (a is A && a is B) {\n        <expr>a</expr>\n    }\n}"}
{"context": "// LOOK_UP_FOR_ELEMENT_OF_TYPE: org.jetbrains.kotlin.psi.KtObjectLiteralExpression\nfun test() {\n", "line_to_complete": "\n    <expr>object {}</expr>\n}"}
{"context": "class A {\n    object B {\n        object C {\n\n        }\n    }\n    companion object {\n        val B = \"\"\n    }\n}\n\nval ab = A.B // property\nval abc = A.B.C // object\n\nobject D {\n    class E {\n        object F {\n\n        }\n    }\n}\n\nval D.E get() = \"\"\n\nval def = D.E.F // object\n// See KT-46409\nval de = D.E\n\nenum class G {\n    H;\nfun foo() {\n", "line_to_complete": "\n        values()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.resolve.checkers\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.config.LanguageFeature.ProhibitIllegalValueParameterUsageInDefaultArguments\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.descriptors.FunctionDescriptor\nimport org.jetbrains.kotlin.descriptors.ValueParameterDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.resolve.calls.tower.NewVariableAsFunctionResolvedCallImpl\nimport org.jetbrains.kotlin.resolve.calls.util.getResolvedCall\n\nobject ValueParameterUsageInDefaultArgumentChecker : DeclarationChecker {\noverride fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n", "line_to_complete": "\n        if (declaration !is KtFunction || descriptor !is FunctionDescriptor) return\n        val allParameters = descriptor.valueParameters\n        val declaredParameters = mutableListOf<ValueParameterDescriptor>()\n        // We can don't check last parameter, because all other parameters already declared\n        for ((parameter, parameterDescriptor) in declaration.valueParameters.zip(allParameters).dropLast(1)) {\n            checkParameter(parameter, allParameters, declaredParameters, context)\n            declaredParameters += parameterDescriptor\n        }\n    }"}
{"context": "// MODULE: lib\n\n// FILE: some/Dependency.kt\npackage some\n\ninterface Flag<T>\n\nclass Dependency {\n    companion object Named {\n        @JvmField val JVM_FIELD_FLAG: Flag<*> = TODO()\n        @JvmStatic val JVM_STATIC_FLAG: Flag<*> = TODO()\n        val VAL_FLAG: Flag<*> = TODO()\n        var varFlag: Flag<*> = TODO()\n    }\n}\n\nval DEPENDENCY_TOP_LEVEL_VAL_FLAG: Flag<*> = TODO()\n\n// MODULE: app(lib)\n// MODULE_KIND: Source\n// FILE: main.kt\npackage some\n\nprivate fun consumeFlag(p: Flag<*>) {\n", "line_to_complete": "\n    println(p)\n}"}
{"context": "// MODULE: lib\n\n// FILE: some/Dependency.kt\npackage some\n\ninterface Flag<T>\n\nclass Dependency {\n    companion object Named {\n        @JvmField val JVM_FIELD_FLAG: Flag<*> = TODO()\n        @JvmStatic val JVM_STATIC_FLAG: Flag<*> = TODO()\n        val VAL_FLAG: Flag<*> = TODO()\n        var varFlag: Flag<*> = TODO()\n    }\n}\n\nval DEPENDENCY_TOP_LEVEL_VAL_FLAG: Flag<*> = TODO()\n\n// MODULE: app(lib)\n// MODULE_KIND: Source\n// FILE: main.kt\n\npackage some\n\nprivate fun consumeFlag(p: Flag<*>) {\n    println(p)\n}\nfun test() {\n", "line_to_complete": "\n    consumeFlag(Dependency.JVM_FIELD_FLAG)\n    consumeFlag(Dependency.JVM_STATIC_FLAG)\n    consumeFlag(Dependency.VAL_<caret>FLAG)\n    consumeFlag(Dependency.varFlag)\n    consumeFlag(DEPENDENCY_TOP_LEVEL_VAL_FLAG)\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.test.framework.project.structure\n\nimport org.jetbrains.kotlin.test.services.TestService\nimport org.jetbrains.kotlin.test.services.TestServices\n\nabstract class AnalysisApiKtTestModuleStructureProvider : TestService {\n    protected abstract val testServices: TestServices\n\n    abstract fun registerModuleStructure(moduleStructure: KtTestModuleStructure)\n\n    abstract fun getModuleStructure(): KtTestModuleStructure\n}\n\nclass AnalysisApiKtTestModuleStructureProviderImpl(\n    override val testServices: TestServices,\n) : AnalysisApiKtTestModuleStructureProvider() {\n    private lateinit var moduleStructure: KtTestModuleStructure\noverride fun registerModuleStructure(moduleStructure: KtTestModuleStructure) {\n", "line_to_complete": "\n        require(!this::moduleStructure.isInitialized)\n\n        this.moduleStructure = moduleStructure\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.api.descriptors.components\n\nimport org.jetbrains.kotlin.analysis.api.components.KtSubtypingComponent\nimport org.jetbrains.kotlin.analysis.api.descriptors.KtFe10AnalysisSession\nimport org.jetbrains.kotlin.analysis.api.descriptors.components.base.Fe10KtAnalysisSessionComponent\nimport org.jetbrains.kotlin.analysis.api.descriptors.types.base.KtFe10Type\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken\nimport org.jetbrains.kotlin.analysis.api.types.KtType\n\ninternal class KtFe10SubtypingComponent(\n    override val analysisSession: KtFe10AnalysisSession\n) : KtSubtypingComponent(), Fe10KtAnalysisSessionComponent {\n    override val token: KtLifetimeToken\n        get() = analysisSession.token\noverride fun isEqualTo(first: KtType, second: KtType): Boolean {\n", "line_to_complete": "\n        require(first is KtFe10Type)\n        require(second is KtFe10Type)\n        return analysisContext.resolveSession.kotlinTypeCheckerOfOwnerModule.equalTypes(first.fe10Type, second.fe10Type)\n    }"}
{"context": "// See KT-40327\n\ninterface Foo {\n    fun some(x: Int = 1, y: Int)\n}\n\ninterface Bar {\n    fun some(x: Int, y: Int = 2)\n}\n\nclass Impl : Foo, Bar {\noverride fun some(x: Int, y: Int) {\n", "line_to_complete": "\n        // println(\"x = $x y = $y\")\n    }"}
{"context": "// See KT-40327\n\ninterface Foo {\n    fun some(x: Int = 1, y: Int)\n}\n\ninterface Bar {\n    fun some(x: Int, y: Int = 2)\n}\n\nclass Impl : Foo, Bar {\n    override fun some(x: Int, y: Int) {\n        // println(\"x = $x y = $y\")\n    }\n}\nfun main() {\n", "line_to_complete": "\n    Impl().some()\n}"}
{"context": "\nclass Foo {\n    val x = 1\n\n    fun abc() = x\n\n    fun cba() = abc()\n}\n\nclass Bar {\n    val x = \"\"\n\n    // NB: unused\n    fun Foo.abc() = x\n\n    fun bar(): Bar = this\n\n    // NB: unused\n    operator fun String.plus(bar: Bar): String {\n        return \"\"\n    }\n\n    // NB! abc() here is resolved to member Foo.abc(), and not to extension member of Bar\n    fun Foo.check() = abc() <!NONE_APPLICABLE!>+<!> bar()\n\n    // NB! + here is resolved to member String.plus (not to extension member above)\n    fun Foo.check2() = \"\" + bar()\n}\n\nfun Foo.ext() = x\n\nfun bar() {\n\n}\nfun buz() {\n", "line_to_complete": "\n    bar()\n}"}
{"context": "\nclass Foo {\n    val x = 1\n\n    fun abc() = x\n\n    fun cba() = abc()\n}\n\nclass Bar {\n    val x = \"\"\n\n    // NB: unused\n    fun Foo.abc() = x\n\n    fun bar(): Bar = this\n\n    // NB: unused\n    operator fun String.plus(bar: Bar): String {\n        return \"\"\n    }\n\n    // NB! abc() here is resolved to member Foo.abc(), and not to extension member of Bar\n    fun Foo.check() = abc() <!NONE_APPLICABLE!>+<!> bar()\n\n    // NB! + here is resolved to member String.plus (not to extension member above)\n    fun Foo.check2() = \"\" + bar()\n}\n\nfun Foo.ext() = x\n\nfun bar() {\n\n}\n\nfun buz() {\n    bar()\n}\nfun f() {\n", "line_to_complete": "\n    val a = 10\n    val b = a\n    val d = \"\"\n    val c = <!UNRESOLVED_REFERENCE!>c<!>\n\n    <!UNRESOLVED_REFERENCE!>abc<!>()\n\n    fun bcd() {}\n\n    fun abc() {\n        val a = d\n        val b = a\n        bcd()\n\n        fun dcb() {}\n\n        dcb()\n    }\n\n    <!UNRESOLVED_REFERENCE!>dcb<!>()\n\n    abc()\n}"}
{"context": "\nclass Foo {\n    val x = 1\n\n    fun abc() = x\n\n    fun cba() = abc()\n}\n\nclass Bar {\n    val x = \"\"\n\n    // NB: unused\n    fun Foo.abc() = x\n\n    fun bar(): Bar = this\n\n    // NB: unused\n    operator fun String.plus(bar: Bar): String {\n        return \"\"\n    }\n\n    // NB! abc() here is resolved to member Foo.abc(), and not to extension member of Bar\n    fun Foo.check() = abc() <!NONE_APPLICABLE!>+<!> bar()\n\n    // NB! + here is resolved to member String.plus (not to extension member above)\n    fun Foo.check2() = \"\" + bar()\n}\n\nfun Foo.ext() = x\n\nfun bar() {\n\n}\n\nfun buz() {\n    bar()\n}\n\nfun f() {\n    val a = 10\n    val b = a\n    val d = \"\"\n    val c = <!UNRESOLVED_REFERENCE!>c<!>\n\n    <!UNRESOLVED_REFERENCE!>abc<!>()\n\n    fun bcd() {}\nfun abc() {\n", "line_to_complete": "\n        val a = d\n        val b = a\n        bcd()\n\n        fun dcb() {}\n\n        dcb()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.test.framework.test.configurators\n\nabstract class AnalysisApiTestConfiguratorFactory {\n    abstract fun createConfigurator(data: AnalysisApiTestConfiguratorFactoryData): AnalysisApiTestConfigurator\n\n    abstract fun supportMode(data: AnalysisApiTestConfiguratorFactoryData): Boolean\nprotected fun requireSupported(data: AnalysisApiTestConfiguratorFactoryData) {\n", "line_to_complete": "\n        if (!supportMode(data)) {\n            unsupportedModeError(data)\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.test.framework.test.configurators\n\nabstract class AnalysisApiTestConfiguratorFactory {\n    abstract fun createConfigurator(data: AnalysisApiTestConfiguratorFactoryData): AnalysisApiTestConfigurator\n\n    abstract fun supportMode(data: AnalysisApiTestConfiguratorFactoryData): Boolean\n\n    protected fun requireSupported(data: AnalysisApiTestConfiguratorFactoryData) {\n        if (!supportMode(data)) {\n            unsupportedModeError(data)\n        }\n    }\nprotected fun unsupportedModeError(data: AnalysisApiTestConfiguratorFactoryData): Nothing {\n", "line_to_complete": "\n        error(\"${this::class} is does not support $data\")\n    }"}
{"context": "fun <T> foo(x: () -> T, y: Int) {}\nfun <E> bar(x: E): Int = 1\nfun main() {\n", "line_to_complete": "\n    fun bar(): Int = 1\n    fun foo(x: (String) -> Int, y: String) {}\n\n    foo(::bar, 1)\n    foo(::bar, \"\")\n}"}
{"context": "//DO_NOT_CHECK_SYMBOL_RESTORE_K1\n\n// FILE: main.kt\nclass J: JavaClass<String> {}\nfun some(j: J) {\n", "line_to_complete": "\n  j.f<caret>oo()\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.daemon\n\nimport org.jetbrains.kotlin.daemon.client.KotlinCompilerClient\nimport org.jetbrains.kotlin.daemon.common.CompileService\nimport org.junit.jupiter.api.DisplayName\nimport org.junit.jupiter.api.Test\nimport java.io.File\nimport java.lang.Thread.sleep\nimport kotlin.test.assertEquals\n\n@DisplayName(\"Compiler daemon operations test in the LastSession mode\")\nclass LastSessionDaemonTest : BaseDaemonSessionTest() {\n    private val logFile\n        get() = workingDirectory.resolve(\"daemon.log\")\n\n    @DisplayName(\"Already leased session can perform compilation\")\n    @Test\nfun canCompileInLastSessionMode() {\n", "line_to_complete": "\n        val (compileService, sessionId) = leaseSession(logFile = logFile)\n        sleep(DAEMON_PERIODIC_CHECK_INTERVAL_MS + 1_000)\n        logFile.assertLogFileContains(\"Some sessions are active, waiting for them to finish\")\n        val testMessageCollector = TestMessageCollector()\n        val exitCode = KotlinCompilerClient.compile(\n            compileService,\n            sessionId,\n            CompileService.TargetPlatform.JVM,\n            arrayOf(\"-include-runtime\", File(getHelloAppBaseDir(), \"hello.kt\").absolutePath, \"-d\", outputDirectory.absolutePath),\n            testMessageCollector\n        )\n        assertEquals(0, exitCode)\n    }"}
{"context": "// FILE: main.kt\npackage test\n\nclass TestClass {\nfun test() {\n", "line_to_complete": "\n        <!UNRESOLVED_REFERENCE!>extensionFun<!>()\n    }"}
{"context": "// FILE: MyRunnable.java\npublic interface MyRunnable {\n    Object foo(int x);\n    default void bar() {}\n}\n\n// FILE: DerivedRunnable.java\npublic interface DerivedRunnable extends MyRunnable {\n    @Override\n    Boolean foo(int x);\n    default void baz() {}\n}\n\n// FILE: JavaUsage.java\n\npublic class JavaUsage {\n    public static void foo(DerivedRunnable x) {}\n}\n// FILE: main.kt\n\nfun foo(m: MyRunnable) {}\nfun main() {\n", "line_to_complete": "\n    JavaUsage.foo {\n            x ->\n        x > 1\n    }\n\n    JavaUsage.foo({ it > 1 })\n\n    val x = { x: Int -> x > 1 }\n\n    JavaUsage.foo(x)\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.idea.references\n\nimport com.intellij.openapi.util.TextRange\nimport com.intellij.psi.MultiRangeReference\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.*\nimport org.jetbrains.kotlin.resolve.ArrayFqNames\n\nabstract class KtCollectionLiteralReference(expression: KtCollectionLiteralExpression) :\n    KtSimpleReference<KtCollectionLiteralExpression>(expression), MultiRangeReference {\n    companion object {\n        private val COLLECTION_LITERAL_CALL_NAMES = ArrayFqNames.PRIMITIVE_TYPE_TO_ARRAY.values + ArrayFqNames.ARRAY_OF_FUNCTION\n    }\n\n    override fun getRangeInElement(): TextRange = element.normalizeRange()\noverride fun getRanges(): List<TextRange> {\n", "line_to_complete": "\n        return listOfNotNull(element.leftBracket?.normalizeRange(), element.rightBracket?.normalizeRange())\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.sessions\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.LLFirModuleResolveComponents\nimport org.jetbrains.kotlin.analysis.project.structure.KtLibraryModule\nimport org.jetbrains.kotlin.analysis.project.structure.KtLibrarySourceModule\nimport org.jetbrains.kotlin.analysis.project.structure.KtModule\nimport org.jetbrains.kotlin.fir.BuiltinTypes\n\ninternal class LLFirLibraryOrLibrarySourceResolvableModuleSession(\n    ktModule: KtModule,\n    override val moduleComponents: LLFirModuleResolveComponents,\n    builtinTypes: BuiltinTypes,\n) : LLFirResolvableModuleSession(ktModule, builtinTypes) {\n    init {\n        checkIsValidKtModule(ktModule)\n    }\n\n    companion object {\nfun checkIsValidKtModule(module: KtModule) {\n", "line_to_complete": "\n            require(module is KtLibraryModule || module is KtLibrarySourceModule) {\n                \"Expected ${KtLibraryModule::class.simpleName} or ${KtLibrarySourceModule::class.simpleName}, but ${module::class.simpleName} found\"\n            }\n        }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.test.framework\n\nimport com.intellij.openapi.Disposable\nimport com.intellij.openapi.util.Disposer\nimport org.jetbrains.kotlin.test.TestConfiguration\nimport org.jetbrains.kotlin.test.runners.AbstractKotlinCompilerTest\nimport org.jetbrains.kotlin.test.services.isKtFile\nimport org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.TestInfo\n\nabstract class AbstractCompilerBasedTest : AbstractKotlinCompilerTest() {\n    private var _disposable: Disposable? = null\n    protected val disposable: Disposable get() = _disposable!!\n\n    @BeforeEach\nfun initDisposable(testInfo: TestInfo) {\n", "line_to_complete": "\n        _disposable = Disposer.newDisposable(\"disposable for ${testInfo.displayName}\")\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.test.framework\n\nimport com.intellij.openapi.Disposable\nimport com.intellij.openapi.util.Disposer\nimport org.jetbrains.kotlin.test.TestConfiguration\nimport org.jetbrains.kotlin.test.runners.AbstractKotlinCompilerTest\nimport org.jetbrains.kotlin.test.services.isKtFile\nimport org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.TestInfo\n\nabstract class AbstractCompilerBasedTest : AbstractKotlinCompilerTest() {\n    private var _disposable: Disposable? = null\n    protected val disposable: Disposable get() = _disposable!!\n\n    @BeforeEach\n    fun initDisposable(testInfo: TestInfo) {\n        _disposable = Disposer.newDisposable(\"disposable for ${testInfo.displayName}\")\n    }\n\n    @AfterEach\nfun disposeDisposable() {\n", "line_to_complete": "\n        _disposable?.let { Disposer.dispose(it) }\n        _disposable = null\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.test.framework\n\nimport com.intellij.openapi.Disposable\nimport com.intellij.openapi.util.Disposer\nimport org.jetbrains.kotlin.test.TestConfiguration\nimport org.jetbrains.kotlin.test.runners.AbstractKotlinCompilerTest\nimport org.jetbrains.kotlin.test.services.isKtFile\nimport org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.TestInfo\n\nabstract class AbstractCompilerBasedTest : AbstractKotlinCompilerTest() {\n    private var _disposable: Disposable? = null\n    protected val disposable: Disposable get() = _disposable!!\n\n    @BeforeEach\n    fun initDisposable(testInfo: TestInfo) {\n        _disposable = Disposer.newDisposable(\"disposable for ${testInfo.displayName}\")\n    }\n\n    @AfterEach\n    fun disposeDisposable() {\n        _disposable?.let { Disposer.dispose(it) }\n        _disposable = null\n    }\nprotected fun ignoreTest(filePath: String, configuration: TestConfiguration): Boolean {\n", "line_to_complete": "\n        val modules = configuration.moduleStructureExtractor.splitTestDataByModules(filePath, configuration.directives)\n\n        if (modules.modules.none { it.files.any { it.isKtFile } }) {\n            return true // nothing to highlight\n        }\n\n        return shouldSkipTest(filePath, configuration)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.buildtools.api.tests.compilation.model\n\nimport org.jetbrains.kotlin.buildtools.api.tests.BaseTest\nimport org.junit.jupiter.api.Named.named\nimport org.junit.jupiter.api.extension.ExtensionContext\nimport org.junit.jupiter.params.provider.Arguments\nimport org.junit.jupiter.params.provider.ArgumentsProvider\nimport java.util.stream.Stream\nimport kotlin.streams.asStream\n\nclass DefaultStrategyAgnosticCompilationTestArgumentProvider : ArgumentsProvider {\noverride fun provideArguments(context: ExtensionContext): Stream<out Arguments> {\n", "line_to_complete": "\n        val compilationService = BaseTest.compilationService\n        return sequenceOf(\n            named(\"in-process\", compilationService.makeCompilerExecutionStrategyConfiguration().useInProcessStrategy()),\n            named(\"within daemon\", compilationService.makeCompilerExecutionStrategyConfiguration().useDaemonStrategy(emptyList())),\n        ).map { Arguments.of(it) }.asStream()\n    }"}
{"context": "import kotlin.reflect.KProperty\n\nclass Delegate<T>(var value: T) {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): T = value\noperator fun setValue(thisRef: Any?, property: KProperty<*>, newValue: T) {\n", "line_to_complete": "\n        value = newValue\n    }"}
{"context": "// WITH_RESOLVE_EXTENSION\n// RESOLVE_EXTENSION_PACKAGE: generated\n// RESOLVE_EXTENSION_SHADOWED: \\.hidden\\.kt$\n\n// FILE: extension.kt\n// RESOLVE_EXTENSION_FILE\npackage generated\n\n// RESOLVE_EXTENSION_CALLABLE: generatedOverloadedExtensionFunction\nfun Any.generatedOverloadedExtensionFunction(): Int = TODO()\n\n// FILE: generated.hidden.kt\npackage generated\n\nfun String.generatedOverloadedExtensionFunction(): Int = TODO()\n\n// FILE: main.kt\nimport generated.*\nfun main() {\n", "line_to_complete": "\n    \"string\".generatedOverloadedExtension<caret>Function()\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.declarations.modifiers.renderers\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.renderer.declarations.modifiers.KtDeclarationModifiersRenderer\nimport org.jetbrains.kotlin.analysis.api.symbols.KtDeclarationSymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolWithModality\nimport org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolWithVisibility\nimport org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter\nimport org.jetbrains.kotlin.lexer.KtModifierKeywordToken\n\npublic interface KtModifierListRenderer {\n    context(KtAnalysisSession, KtDeclarationModifiersRenderer)\n    public fun renderModifiers(symbol: KtDeclarationSymbol, printer: PrettyPrinter)\n\n    public object AS_LIST : KtModifierListRenderer {\n        context(KtAnalysisSession, KtDeclarationModifiersRenderer)\noverride fun renderModifiers(symbol: KtDeclarationSymbol, printer: PrettyPrinter) {\n", "line_to_complete": "\n            val modifiers = getModifiers(symbol)\n                .distinct()\n                .let { modifiersSorter.sort(it, symbol) }\n                .ifEmpty { return }\n            keywordsRenderer.renderKeywords(modifiers, symbol, printer)\n        }"}
{"context": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\", \"unused\")\n\npackage org.jetbrains.kotlin.fir.references.builder\n\nimport kotlin.contracts.*\nimport org.jetbrains.kotlin.fir.builder.FirBuilderDsl\nimport org.jetbrains.kotlin.fir.diagnostics.ConeDiagnostic\nimport org.jetbrains.kotlin.fir.references.FirThisReference\nimport org.jetbrains.kotlin.fir.references.impl.FirImplicitThisReference\nimport org.jetbrains.kotlin.fir.symbols.FirBasedSymbol\n\n@FirBuilderDsl\nclass FirImplicitThisReferenceBuilder {\n    var boundSymbol: FirBasedSymbol<*>? = null\n    var contextReceiverNumber: Int = -1\n    var diagnostic: ConeDiagnostic? = null\nfun build(): FirThisReference {\n", "line_to_complete": "\n        return FirImplicitThisReference(\n            boundSymbol,\n            contextReceiverNumber,\n            diagnostic,\n        )\n    }"}
{"context": "// FILE: main.kt\npackage a.b.c\n\nfun foo() {}\nfun test() {\n", "line_to_complete": "\n    <expr>dependency.foo()</expr>\n}"}
{"context": "interface Foo\n\nval Foo.foo: String\n    get() = \"\"\nfun test() {\n", "line_to_complete": "\n    consume(<expr>Foo::foo</expr>)\n}"}
{"context": "// MODULE: context\n\n// FILE: context.kt\nfun test() {\n", "line_to_complete": "\n    1.ext\n}"}
{"context": "package t\n\ninterface Trait {\n    val some : Int get() = 1\n}\n\nopen class A {\n    companion object Companion : Trait {\n\n    }\n}\nfun test() {\n", "line_to_complete": "\n    <caret>A.some\n}"}
{"context": "class Outer<O> {\n   inner class A<X> {\n      fun <Y> foo(x: X, y: Y): Map<X, Map<Y, O>>\n\n      val map: Map<X, O>\n   }\n}\nfun foo(a: Outer<String>.A<Int>) {\n", "line_to_complete": "\n   println(<expr>a</expr>)\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.providers.impl\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.search.GlobalSearchScope\nimport org.jetbrains.kotlin.analysis.providers.KotlinPackageProvider\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.platform.TargetPlatform\nimport org.jetbrains.kotlin.platform.jvm.isJvm\n\npublic abstract class KotlinPackageProviderBase(\n    protected val project: Project,\n    public val searchScope: GlobalSearchScope,\n) : KotlinPackageProvider() {\noverride fun doesPackageExist(packageFqName: FqName, platform: TargetPlatform): Boolean {\n", "line_to_complete": "\n        return doesPlatformSpecificPackageExist(packageFqName, platform) || doesKotlinOnlyPackageExist(packageFqName)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.providers.impl\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.search.GlobalSearchScope\nimport org.jetbrains.kotlin.analysis.providers.KotlinPackageProvider\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.platform.TargetPlatform\nimport org.jetbrains.kotlin.platform.jvm.isJvm\n\npublic abstract class KotlinPackageProviderBase(\n    protected val project: Project,\n    public val searchScope: GlobalSearchScope,\n) : KotlinPackageProvider() {\n\n    override fun doesPackageExist(packageFqName: FqName, platform: TargetPlatform): Boolean {\n        return doesPlatformSpecificPackageExist(packageFqName, platform) || doesKotlinOnlyPackageExist(packageFqName)\n    }\noverride fun doesPlatformSpecificPackageExist(packageFqName: FqName, platform: TargetPlatform): Boolean {\n", "line_to_complete": "\n        when {\n            platform.isJvm() -> {\n                val fqNameString = packageFqName.asString()\n                forEachNonKotlinPsiElementFinder(project) { finder ->\n                    val psiPackage = finder.findPackage(fqNameString)\n                    if (psiPackage != null) {\n                        // we cannot easily check if some PsiPackage is in GlobalSearchScope or not\n                        return true\n                    }\n                }\n                return false\n            }\n            else -> {\n                // non-JVM platforms are not supported yet\n                return false\n            }\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.api.renderer.declarations.modifiers.renderers\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.symbols.KtDeclarationSymbol\nimport org.jetbrains.kotlin.lexer.KtModifierKeywordToken\nimport org.jetbrains.kotlin.psi.addRemoveModifier.sortModifiers\n\npublic interface KtModifiersSorter {\n    context(KtAnalysisSession)\n    public fun sort(modifiers: List<KtModifierKeywordToken>, owner: KtDeclarationSymbol): List<KtModifierKeywordToken>\n\n    public object CANONICAL : KtModifiersSorter {\n        context(KtAnalysisSession)\noverride fun sort(modifiers: List<KtModifierKeywordToken>, owner: KtDeclarationSymbol): List<KtModifierKeywordToken> {\n", "line_to_complete": "\n            return sortModifiers(modifiers)\n        }"}
{"context": "class A {\n    var v: String? = null\n}\nfun foo(): String? {\n", "line_to_complete": "\n    val t = A().v\n\n    return t\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.descriptors.Visibilities\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirDeclaration\nimport org.jetbrains.kotlin.fir.declarations.FirMemberDeclaration\nimport org.jetbrains.kotlin.fir.declarations.FirValueParameter\nimport org.jetbrains.kotlin.fir.declarations.getAnnotationByClassId\nimport org.jetbrains.kotlin.fir.declarations.utils.visibility\nimport org.jetbrains.kotlin.name.StandardClassIds\n\nobject FirPublishedApiChecker : FirBasicDeclarationChecker(MppCheckerKind.Common) {\noverride fun check(declaration: FirDeclaration, context: CheckerContext, reporter: DiagnosticReporter) {\n", "line_to_complete": "\n        if (declaration !is FirMemberDeclaration) return\n        if (declaration is FirValueParameter) return\n        if (declaration.visibility == Visibilities.Internal) return\n        val annotation = declaration.getAnnotationByClassId(StandardClassIds.Annotations.PublishedApi, context.session) ?: return\n        reporter.reportOn(annotation.source, FirErrors.NON_INTERNAL_PUBLISHED_API, context)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.diagnostic.compiler.based.facades\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.DiagnosticCheckerFilter\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.api.LLFirResolveSession\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.compiler.based.LowLevelFirAnalyzerFacade\nimport org.jetbrains.kotlin.fir.declarations.FirFile\nimport org.jetbrains.kotlin.test.model.TestFile\n\nobject LLFirAnalyzerFacadeFactoryWithoutPreresolve : LLFirAnalyzerFacadeFactory() {\noverride fun createFirFacade(\n        firResolveSession: LLFirResolveSession,\n        allFirFiles: Map<TestFile, FirFile>,\n        diagnosticCheckerFilter: DiagnosticCheckerFilter\n    ): LowLevelFirAnalyzerFacade {\n", "line_to_complete": "\n        return LowLevelFirAnalyzerFacade(firResolveSession, allFirFiles, diagnosticCheckerFilter)\n    }"}
{"context": "import kotlin.contracts.*\n\nclass A {\nfun passLambdaValue(l: ContractBuilder.() -> Unit) {\n", "line_to_complete": "\n        contract(l)\n        <expr>42</expr>\n    }"}
{"context": "val items: List<String>\n    field = mutableListOf()\nfun test() {\n", "line_to_complete": "\n    items.<!UNRESOLVED_REFERENCE!>add<!>(\"one more item\")\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.daemon.report\n\nimport org.jetbrains.kotlin.build.report.metrics.BuildMetricsReporter\nimport org.jetbrains.kotlin.build.report.metrics.GradleBuildPerformanceMetric\nimport org.jetbrains.kotlin.build.report.metrics.GradleBuildTime\nimport org.jetbrains.kotlin.build.report.metrics.RemoteBuildMetricsReporter\nimport org.jetbrains.kotlin.daemon.common.CompilationResultCategory\nimport org.jetbrains.kotlin.daemon.common.CompilationResults\n\nclass RemoteBuildMetricsReporterAdapter(\n    private val delegate: BuildMetricsReporter<GradleBuildTime, GradleBuildPerformanceMetric>,\n    private val shouldReport: Boolean,\n    private val compilationResults: CompilationResults\n) :\n    BuildMetricsReporter<GradleBuildTime, GradleBuildPerformanceMetric> by delegate,\n    RemoteBuildMetricsReporter<GradleBuildTime, GradleBuildPerformanceMetric> {\noverride fun flush() {\n", "line_to_complete": "\n        if (shouldReport) {\n            val metrics = delegate.getMetrics()\n            compilationResults.add(CompilationResultCategory.BUILD_METRICS.code, metrics)\n        }\n    }"}
{"context": "interface I<T> {\n    fun i(t: T): Int\n}\n\nclass C<T>(val x: Int): I<T> {\n    companion object {\n        val K: Int = 58\n    }\n\n    <expr>fun test(): Int {\n        return 45 * K\n    }</expr>\nfun count(xs: List<T>): Int {\n", "line_to_complete": "\n        return xs.size\n    }"}
{"context": "interface I<T> {\n    fun i(t: T): Int\n}\n\nclass C<T>(val x: Int): I<T> {\n    companion object {\n        val K: Int = 58\n    }\n\n    <expr>fun test(): Int {\n        return 45 * K\n    }</expr>\n\n    fun count(xs: List<T>): Int {\n        return xs.size\n    }\noverride fun i(t: T): Int {\n", "line_to_complete": "\n        return test() + t.hashCode()\n    }"}
{"context": "package test\n\ninterface Foo\n\ninterface WithOperator {\n    operator fun plusAssign(f: Foo)\n}\nfun test(withOperator: WithOperator, foo: Foo) {\n", "line_to_complete": "\n    withOperator <caret>+= foo\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.cli.jvm.modules\n\nimport org.jetbrains.kotlin.resolve.jvm.modules.JavaModule\nimport org.jetbrains.kotlin.resolve.jvm.modules.JavaModuleFinder\nimport org.jetbrains.kotlin.storage.LockBasedStorageManager\n\nclass JavaModuleGraph(finder: JavaModuleFinder) {\n    private val module: (String) -> JavaModule? =\n        LockBasedStorageManager.NO_LOCKS.createMemoizedFunctionWithNullableValues(finder::findModule)\n\n    fun getAllDependencies(moduleNames: List<String>): LinkedHashSet<String> {\n        val visited = LinkedHashSet(moduleNames)\n\n        // Every module implicitly depends on java.base\n        visited += \"java.base\"\nfun dfs(moduleName: String): Boolean {\n", "line_to_complete": "\n            // Automatic modules have no transitive exports, so we only consider explicit modules here\n            val moduleInfo = (module(moduleName) as? JavaModule.Explicit)?.moduleInfo ?: return false\n            for ((dependencyModuleName, isTransitive) in moduleInfo.requires) {\n                if (isTransitive && visited.add(dependencyModuleName)) {\n                    dfs(dependencyModuleName)\n                }\n            }\n            return true\n        }"}
{"context": "class Foo {\n    inner class Bar\n}\nfun foo(foo: Foo) {\n", "line_to_complete": "\n    foo.<expr>Bar</expr>()\n}"}
{"context": "// MODULE: lib\n// WITH_STDLIB\n\n// FILE: src/my/collections/Maps.kt\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage my.collections\n\nfun <K, V> myEmptyMap(): Map<K, V> = emptyMap()\n\n// FILE: src/my/collections/jvm/MapsJVM.kt\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage my.collections\n\nfun <K, V> myMapOf(vararg pairs: Pair<K, V>): Map<K, V> = mapOf(*pairs)\n\n// MODULE: app(lib)\n// MODULE_KIND: Source\n// FILE: main.kt\n\nimport my.collections.*\nfun test() {\n", "line_to_complete": "\n    myMap<caret>Of<Int, String>(\n        2 to \"2\",\n        4 to \"4\",\n    )\n}"}
{"context": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect open class A() {\n    fun foo()\n\n    val x: Int\n}\n\nopen class B : A()\n\n// MODULE: m1-jvm()()(m1-common)\n// FILE: jvm.kt\n\nactual open class A {\n    actual fun foo() {}\n\n    fun bar() {}\n\n    actual val x = 42\n}\n\nclass C : B() {\nfun test() {\n", "line_to_complete": "\n        foo()\n        bar()\n        x + x\n    }"}
{"context": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect open class A() {\n    fun foo()\n\n    val x: Int\n}\n\nopen class B : A()\n\n// MODULE: m1-jvm()()(m1-common)\n// FILE: jvm.kt\n\nactual open class A {\n    actual fun foo() {}\n\n    fun bar() {}\n\n    actual val x = 42\n}\n\nclass C : B() {\n    fun test() {\n        foo()\n        bar()\n        x + x\n    }\n}\n\nclass D : A() {\nfun test() {\n", "line_to_complete": "\n        foo()\n        bar()\n        x + x\n    }"}
{"context": "// FILE: main.kt\nimport dependency.A\nfun test() {\n", "line_to_complete": "\n    val b: A.B<<expr>dependency.Foo</expr>>\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.java.enhancement\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.FirRegularClass\nimport org.jetbrains.kotlin.fir.resolve.transformers.plugin.CompilerRequiredAnnotationEnhancementProvider\nimport org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirEnumEntrySymbol\nimport org.jetbrains.kotlin.name.JvmStandardClassIds\n\nobject JavaCompilerRequiredAnnotationEnhancementProvider : CompilerRequiredAnnotationEnhancementProvider() {\noverride fun enhance(enumSymbol: FirClassSymbol<*>, enumEntrySymbol: FirEnumEntrySymbol, session: FirSession): FirEnumEntrySymbol {\n", "line_to_complete": "\n        val firRegularClass = enumSymbol.fir as? FirRegularClass ?: return enumEntrySymbol\n        if (enumSymbol.classId != JvmStandardClassIds.Annotations.Java.ElementType) return enumEntrySymbol\n\n        return FirSignatureEnhancement(firRegularClass, session) { emptyList() }.enhancedProperty(\n            enumEntrySymbol,\n            enumEntrySymbol.name,\n        ) as FirEnumEntrySymbol\n    }"}
{"context": "package t\n\nclass A {\n    companion object Companion {\n\n    }\n}\n\nfun A.Companion.foo() {}\nfun test() {\n", "line_to_complete": "\n    <caret>A.foo()\n}"}
{"context": "// MODULE: context\n\n// FILE: context.kt\nclass Test {\n    var a: String = \"foo\"\nfun test() {\n", "line_to_complete": "\n        <caret_context>val x = 0\n    }"}
{"context": "// FILE: main.kt\nfun main() {\n", "line_to_complete": "\n    val j: JavaClass =  JavaClass()\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.diagnostics\n\nimport com.intellij.openapi.util.TextRange\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.KtPsiSourceElement\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.cfg.UnreachableCode\nimport org.jetbrains.kotlin.psi\nimport org.jetbrains.kotlin.psi.KtElement\nimport org.jetbrains.kotlin.psi.KtNamedDeclaration\n\n\nobject PsiPositioningStrategies {\n    val UNREACHABLE_CODE = object : PositioningStrategy<PsiElement>() {\noverride fun markDiagnostic(diagnostic: DiagnosticMarker): List<TextRange> {\n", "line_to_complete": "\n            //todo it is better to implement arguments extraction in KtDiagnosticFactory, but kotlin struggle with checking types in it atm\n            @Suppress(\"UNCHECKED_CAST\")\n            val typed = diagnostic as KtDiagnosticWithParameters2<Set<KtSourceElement>, Set<KtSourceElement>>\n            val source = diagnostic.element as KtPsiSourceElement\n            return UnreachableCode.getUnreachableTextRanges(\n                source.psi as KtElement,\n                typed.a.mapNotNull { it.psi as? KtElement }.toSet(),\n                typed.b.mapNotNull { it.psi as? KtElement }.toSet()\n            )\n        }"}
{"context": "fun bar(): <!UNSUPPORTED!>dynamic<!> = TODO()\nfun foo() {\n", "line_to_complete": "\n    val x = bar()\n    if (x is String) {\n        val y = <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Nothing..kotlin.Any?! & kotlin.Nothing..kotlin.Any?!\")!>x<!>\n    }\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.providers.impl.packageProviders\n\nimport org.jetbrains.kotlin.analysis.providers.KotlinCompositeProvider\nimport org.jetbrains.kotlin.analysis.providers.KotlinPackageProvider\nimport org.jetbrains.kotlin.analysis.providers.impl.KotlinCompositeProviderFactory\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.platform.TargetPlatform\n\npublic class CompositeKotlinPackageProvider private constructor(\n    override val providers: List<KotlinPackageProvider>,\n) : KotlinPackageProvider(), KotlinCompositeProvider<KotlinPackageProvider> {\noverride fun doesPackageExist(packageFqName: FqName, platform: TargetPlatform): Boolean {\n", "line_to_complete": "\n        return providers.any { it.doesPackageExist(packageFqName, platform) }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.providers.impl.packageProviders\n\nimport org.jetbrains.kotlin.analysis.providers.KotlinCompositeProvider\nimport org.jetbrains.kotlin.analysis.providers.KotlinPackageProvider\nimport org.jetbrains.kotlin.analysis.providers.impl.KotlinCompositeProviderFactory\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.platform.TargetPlatform\n\npublic class CompositeKotlinPackageProvider private constructor(\n    override val providers: List<KotlinPackageProvider>,\n) : KotlinPackageProvider(), KotlinCompositeProvider<KotlinPackageProvider> {\n    override fun doesPackageExist(packageFqName: FqName, platform: TargetPlatform): Boolean {\n        return providers.any { it.doesPackageExist(packageFqName, platform) }\n    }\noverride fun doesKotlinOnlyPackageExist(packageFqName: FqName): Boolean {\n", "line_to_complete": "\n        return providers.any { it.doesKotlinOnlyPackageExist(packageFqName) }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.annotations\n\nimport com.intellij.psi.PsiAnnotation\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.analysis.api.types.KtTypeNullability\nimport org.jetbrains.kotlin.asJava.classes.lazyPub\nimport org.jetbrains.kotlin.light.classes.symbol.asAnnotationQualifier\nimport org.jetbrains.kotlin.load.java.JvmAnnotationNames\n\ninternal class NullabilityAnnotationsProvider(private val lazyNullabilityType: Lazy<KtTypeNullability>) : AdditionalAnnotationsProvider {\n    constructor(initializer: () -> KtTypeNullability) : this(lazyPub(initializer))\noverride fun addAllAnnotations(\n        currentRawAnnotations: MutableList<in PsiAnnotation>,\n        foundQualifiers: MutableSet<String>,\n        owner: PsiElement\n    ) {\n", "line_to_complete": "\n        val qualifier = lazyNullabilityType.value.asAnnotationQualifier ?: return\n        addSimpleAnnotationIfMissing(qualifier, currentRawAnnotations, foundQualifiers, owner)\n    }"}
{"context": "// FILE: JavaEnum.java\npublic enum JavaEnum {\n    A, B, C;\n\n    public String getName() {\n        return \"FromJava\";\n    }\n}\n\n// FILE: Usage.kt\nfun foo(enum: JavaEnum) {\n", "line_to_complete": "\n    enum.na<caret>me\n}"}
{"context": "open class IJProject(val init: () -> Unit = {})\n\n@Suppress(\"UNUSED_VARIABLE\")\nclass KotlinIDE() : IJProject(init = {\nfun foo() {\n", "line_to_complete": "\n        val f = anySymbols\n    }"}
{"context": "fun function(a: Int) {}\nfun call() {\n", "line_to_complete": "\n    <expr>function(1)</expr>\n}"}
{"context": "interface Parent\ninterface Child1 : Parent\ninterface Child2 : Parent\n\nfun foo(): Child1 = TODO()\nfun bar(): Child2 = TODO()\n\nfun <K> select(x: K, y: K): K = TODO()\nfun test() {\n", "line_to_complete": "\n    val a = select(::foo, ::bar)\n}"}
{"context": "import kotlin.reflect.KMutableProperty\n\nclass SimpleVarClass(var constructorVariable: Boolean) {\n    var memberVariable: Boolean = constructorVariable\n}\n\nfun moreFun(a: KMutableProperty<Boolean>) = a\nfun testMutableProp() {\n", "line_to_complete": "\n    moreFun(SimpleVarClass::constructorVariable)\n    moreFun(SimpleVarClass::memberVariable)\n}"}
{"context": "// ISSUE: KT-37639\n\nfun takeInt(x: Int) {}\nfun test_1(b: Boolean) {\n", "line_to_complete": "\n    val x = if (b) 1 else null\n    takeInt(<!ARGUMENT_TYPE_MISMATCH!>x<!>)\n}"}
{"context": "// ISSUE: KT-37639\n\nfun takeInt(x: Int) {}\n\nfun test_1(b: Boolean) {\n    val x = if (b) 1 else null\n    takeInt(<!ARGUMENT_TYPE_MISMATCH!>x<!>)\n}\nfun test_2(b: Boolean, y: Int) {\n", "line_to_complete": "\n    val x = if (b) y else null\n    takeInt(<!ARGUMENT_TYPE_MISMATCH!>x<!>)\n}"}
{"context": "// FILE: JavaClass.java\n\npublic class JavaClass {\n    public String getText() {\n        return \"Text\";\n    }\n\n    public String getText(String param) {\n        return \"Text with \" + param;\n    }\n}\n\n// FILE: Test.kt\nfun test() {\n", "line_to_complete": "\n    val jc = JavaClass()\n    val result = jc.text\n}"}
{"context": "// FILE: JavaClass.java\n\npublic class JavaClass {\n    public String getText() {\n        return \"Text\";\n    }\n\n    public String getText(String param) {\n        return \"Text with \" + param;\n    }\n}\n\n// FILE: Test.kt\n\nfun test() {\n    val jc = JavaClass()\n    val result = jc.text\n}\nfun otherTest(jc: JavaClass) {\n", "line_to_complete": "\n    val result = jc.text\n}"}
{"context": "fun callee(): Int {\n    return 598\n}\nfun test() {\n", "line_to_complete": "\n    <expr>(::callee)</expr>() + 45\n}"}
{"context": "class Test {\n    fun bar(): Int = 42\nfun m() {\n", "line_to_complete": "\n        val f = this:<caret>:bar\n    }"}
{"context": "// WITH_STDLIB\nfun test() {\n", "line_to_complete": "\n    var x = 0\n    val x1 = x++\n    val x2 = ++x\n    val x3 = --x\n    val x4 = x--\n    if (!(x == 0)) {\n        println(\"000\")\n    }\n}"}
{"context": "// WITH_STDLIB\nfun test() {\n    var x = 0\n    val x1 = x++\n    val x2 = ++x\n    val x3 = --x\n    val x4 = x--\n    if (!(x == 0)) {\n        println(\"000\")\n    }\n}\n\nclass X(val i: Int)\nfun test2(x: X) {\n", "line_to_complete": "\n    val x1 = x.i++\n    val x2 = ++x.i\n}"}
{"context": "// WITH_STDLIB\nfun test() {\n    var x = 0\n    val x1 = x++\n    val x2 = ++x\n    val x3 = --x\n    val x4 = x--\n    if (!(x == 0)) {\n        println(\"000\")\n    }\n}\n\nclass X(val i: Int)\n\nfun test2(x: X) {\n    val x1 = x.i++\n    val x2 = ++x.i\n}\nfun test3(arr: Array<Int>) {\n", "line_to_complete": "\n    val x1 = arr[0]++\n    val x2 = ++arr[1]\n}"}
{"context": "// WITH_STDLIB\nfun test() {\n    var x = 0\n    val x1 = x++\n    val x2 = ++x\n    val x3 = --x\n    val x4 = x--\n    if (!(x == 0)) {\n        println(\"000\")\n    }\n}\n\nclass X(val i: Int)\n\nfun test2(x: X) {\n    val x1 = x.i++\n    val x2 = ++x.i\n}\n\nfun test3(arr: Array<Int>) {\n    val x1 = arr[0]++\n    val x2 = ++arr[1]\n}\n\nclass Y(val arr: Array<Int>)\nfun test4(y: Y) {\n", "line_to_complete": "\n    val x1 = y.arr[0]++\n    val x2 = ++y.arr[1]\n}"}
{"context": "// MODULE: extendedModule\n// WITH_RESOLVE_EXTENSION\n// RESOLVE_EXTENSION_PACKAGE: generated\n// RESOLVE_EXTENSION_SHADOWED: \\.hidden\\.[a-z]+$\n\n// FILE: TestClass.hidden.java\npackage foo;\n\npublic class TestClass {\n    public TestClass() {}\n}\n\n// MODULE: dependency2\n\n// MODULE: main(extendedModule, dependency2)()()\n// FILE: main.kt\npackage foo\n\nfun main() {\n", "line_to_complete": "\n    val x = <caret>TestClass()\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.declaration\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirRegularClass\nimport org.jetbrains.kotlin.fir.declarations.utils.isCompanion\n\nobject FirManyCompanionObjectsChecker : FirRegularClassChecker(MppCheckerKind.Common) {\noverride fun check(declaration: FirRegularClass, context: CheckerContext, reporter: DiagnosticReporter) {\n", "line_to_complete": "\n        var hasCompanion = false\n\n        for (it in declaration.declarations) {\n            if (it is FirRegularClass && it.isCompanion) {\n                if (hasCompanion) {\n                    reporter.reportOn(it.source, FirErrors.MANY_COMPANION_OBJECTS, context)\n                }\n                hasCompanion = true\n            }\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.resolve.checkers\n\nimport org.jetbrains.kotlin.builtins.KotlinBuiltIns\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.ClassKind\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.descriptors.FunctionDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.resolve.DescriptorUtils\nimport org.jetbrains.kotlin.util.OperatorNameConventions\n\nobject DataObjectContentChecker : DeclarationChecker {\noverride fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n", "line_to_complete": "\n        if (descriptor !is FunctionDescriptor) return\n        if (descriptor.name != OperatorNameConventions.EQUALS && descriptor.name != OperatorNameConventions.HASH_CODE) return\n\n        val container = descriptor.containingDeclaration\n        if (container !is ClassDescriptor) return\n        if (!container.isData || container.kind != ClassKind.OBJECT) return\n\n        if (DescriptorUtils.getAllOverriddenDescriptors(descriptor).any(::isDeclaredInAny)) {\n            val target = declaration.modifierList?.getModifier(KtTokens.OVERRIDE_KEYWORD) ?: declaration\n            context.trace.report(Errors.DATA_OBJECT_CUSTOM_EQUALS_OR_HASH_CODE.on(target))\n        }\n    }"}
{"context": "package a.b\n\nclass X {\nfun foo() {\n", "line_to_complete": "\n        class U {\n            inner class K {\n                inner class D {\n                    fun check() {\n                        class F {\n                            inner class L\n                        }\n                    }\n                }\n            }\n\n            <!NESTED_CLASS_NOT_ALLOWED!>class T<!>\n        }\n    }"}
{"context": "package a.b\n\nclass X {\n    fun foo() {\n        class U {\n            inner class K {\n                inner class D {\nfun check() {\n", "line_to_complete": "\n                        class F {\n                            inner class L\n                        }\n                    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.api.descriptors.components\n\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisNonPublicApi\nimport org.jetbrains.kotlin.analysis.api.KtAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.components.KtKlibSourceFileNameProvider\nimport org.jetbrains.kotlin.analysis.api.symbols.KtDeclarationSymbol\n\n@OptIn(KtAnalysisNonPublicApi::class)\ninternal class KtFe10KlibSourceFileNameProvider(\n    override val analysisSession: KtAnalysisSession,\n) : KtKlibSourceFileNameProvider() {\noverride fun getKlibSourceFileName(declaration: KtDeclarationSymbol): String? {\n", "line_to_complete": "\n        throw NotImplementedError(\"Method is not implemented for FE 1.0\")\n    }"}
{"context": "// DO_NOT_CHECK_SYMBOL_RESTORE_K1\n\nenum class MyKotlinEnum {\n    FirstEntry, SecondEntry;\n}\nfun test() {\n", "line_to_complete": "\n    MyKotlinEnum.val<caret>ueOf(\"\")\n}"}
{"context": "package foo.bar\ninterface A {\n    fun foo(i: Int) {}\n}\n\ninterface B {\n    fun foo(i2: Int) {}\n}\n\nclass C : A, B {\noverride fun foo(j: Int) {\n", "line_to_complete": "\n        super<<expr>foo.bar.A</expr>>.foo()\n    }"}
{"context": "// MODULE: context\n\n// FILE: context.kt\nfun test() {\n", "line_to_complete": "\n    block(\"foo\") { foo ->\n        fun call() {\n            consume(foo)\n        }\n\n        <caret_context>call()\n    }\n}"}
{"context": "// MODULE: context\n\n// FILE: context.kt\nfun test() {\n    block(\"foo\") { foo ->\nfun call() {\n", "line_to_complete": "\n            consume(foo)\n        }"}
{"context": "operator fun Int.invoke(): String {}\nfun call(x: kotlin.Int) {\n", "line_to_complete": "\n    <expr>x()</expr>\n}"}
{"context": "class Empty<caret>Class : InterfaceWithMembers {\n    override val property: Int = 4\n    override fun baseFunction() {}\n}\n\ninterface InterfaceWithMembers : AnotherSuperInterface {\n    val property: Int\n\n    fun functionWithDefaultImplementation(i: Int): Int = i\n\n    override fun baseFunction()\noverride fun baz() {\n", "line_to_complete": "\n        // default implementation\n    }"}
{"context": "// ISSUE: KT-64044\n// IGNORE_FE10\n// (stream call is unresolved for some reason)\n// FULL_JDK\n// RENDER_PSI_CLASS_NAME\nfun f(collection: Collection<String>) {\n", "line_to_complete": "\n    collection.strea<caret>m()\n}"}
{"context": "// ISSUE: KT-50134\n// WITH_STDLIB\n// FULL_JDK\n\nimport java.util.stream.Collectors\nfun foo() {\n", "line_to_complete": "\n    listOf(\"\").stream().collect(\n        Collectors.groupingBy(\n            { it },\n            Collectors.collectingAndThen(\n                Collectors.counting<String>(),\n                Long::toInt\n            )\n        )\n    )\n}"}
{"context": "class A {\n    companion object Comp {}\nfun foo() {\n", "line_to_complete": "\n        <!UNRESOLVED_REFERENCE!>Comp<!>()\n    }"}
{"context": "class A {\n    companion object Comp {}\n\n    fun foo() {\n        <!UNRESOLVED_REFERENCE!>Comp<!>()\n    }\n}\n\nobject B {\n    private val x = <!UNRESOLVED_REFERENCE!>B<!>()\n}\n\nclass D {\n    companion object Comp2 {\n        operator fun invoke() {}\n    }\nfun foo() {\n", "line_to_complete": "\n        Comp2()\n    }"}
{"context": "class A {\n    companion object Comp {}\n\n    fun foo() {\n        <!UNRESOLVED_REFERENCE!>Comp<!>()\n    }\n}\n\nobject B {\n    private val x = <!UNRESOLVED_REFERENCE!>B<!>()\n}\n\nclass D {\n    companion object Comp2 {\n        operator fun invoke() {}\n    }\n\n    fun foo() {\n        Comp2()\n    }\n}\n\nenum class E {\n    X {\n\n    };\nfun foo() {\n", "line_to_complete": "\n        <!UNRESOLVED_REFERENCE!>X<!>()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.resolve.calls.tower\n\nimport org.jetbrains.kotlin.diagnostics.Diagnostic\nimport org.jetbrains.kotlin.resolve.BindingTrace\n\nclass TrackingBindingTrace(val trace: BindingTrace) : BindingTrace by trace {\n    var reported: Boolean = false\noverride fun report(diagnostic: Diagnostic) {\n", "line_to_complete": "\n        if (bindingContext.diagnostics.noSuppression().forElement(diagnostic.psiElement).any { it == diagnostic }) return\n\n        trace.report(diagnostic)\n        reported = true\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.resolve.calls.tower\n\nimport org.jetbrains.kotlin.diagnostics.Diagnostic\nimport org.jetbrains.kotlin.resolve.BindingTrace\n\nclass TrackingBindingTrace(val trace: BindingTrace) : BindingTrace by trace {\n    var reported: Boolean = false\n\n    override fun report(diagnostic: Diagnostic) {\n        if (bindingContext.diagnostics.noSuppression().forElement(diagnostic.psiElement).any { it == diagnostic }) return\n\n        trace.report(diagnostic)\n        reported = true\n    }\nfun markAsReported() {\n", "line_to_complete": "\n        reported = true\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.cli.common.repl\n\nimport java.io.Serializable\nimport java.util.*\n\n\ntypealias CompiledHistoryItem<T> = Pair<CompiledReplCodeLine, T>\ntypealias SourceHistoryItem<T> = Pair<ReplCodeLine, T>\n\ntypealias CompiledHistoryStorage<T> = ArrayDeque<CompiledHistoryItem<T>>\ntypealias CompiledHistoryList<T> = List<CompiledHistoryItem<T>>\ntypealias SourceHistoryList<T> = List<SourceHistoryItem<T>>\ntypealias SourceList = List<ReplCodeLine>\n\n\nclass ReplHistory<T>(startingHistory: CompiledHistoryList<T> = emptyList()) : Serializable {\n    private val history: CompiledHistoryStorage<T> = ArrayDeque(startingHistory)\n\n    fun isEmpty(): Boolean = history.isEmpty()\n    fun isNotEmpty(): Boolean = history.isNotEmpty()\nfun add(line: CompiledReplCodeLine, value: T) {\n", "line_to_complete": "\n        history.add(line to value)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.cli.common.repl\n\nimport java.io.Serializable\nimport java.util.*\n\n\ntypealias CompiledHistoryItem<T> = Pair<CompiledReplCodeLine, T>\ntypealias SourceHistoryItem<T> = Pair<ReplCodeLine, T>\n\ntypealias CompiledHistoryStorage<T> = ArrayDeque<CompiledHistoryItem<T>>\ntypealias CompiledHistoryList<T> = List<CompiledHistoryItem<T>>\ntypealias SourceHistoryList<T> = List<SourceHistoryItem<T>>\ntypealias SourceList = List<ReplCodeLine>\n\n\nclass ReplHistory<T>(startingHistory: CompiledHistoryList<T> = emptyList()) : Serializable {\n    private val history: CompiledHistoryStorage<T> = ArrayDeque(startingHistory)\n\n    fun isEmpty(): Boolean = history.isEmpty()\n    fun isNotEmpty(): Boolean = history.isNotEmpty()\n\n    fun add(line: CompiledReplCodeLine, value: T) {\n        history.add(line to value)\n    }\nfun removeLast(line: CompiledReplCodeLine): Boolean {\n", "line_to_complete": "\n        return if (history.peekLast().first == line) {\n            history.removeLast()\n            true\n        }\n        else {\n            false\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen\n\nimport com.intellij.psi.PsiElement\nimport com.intellij.util.containers.MultiMap\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.MemberKind\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.RawSignature\nimport org.jetbrains.org.objectweb.asm.FieldVisitor\nimport org.jetbrains.org.objectweb.asm.MethodVisitor\n\nabstract class DelegatingClassBuilderFactory(\n        protected val delegate: ClassBuilderFactory\n\n) : ClassBuilderFactory by delegate {\n\n    abstract override fun newClassBuilder(origin: JvmDeclarationOrigin): DelegatingClassBuilder\noverride fun asBytes(builder: ClassBuilder?): ByteArray? {\n", "line_to_complete": "\n        return delegate.asBytes((builder as DelegatingClassBuilder).delegate)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen\n\nimport com.intellij.psi.PsiElement\nimport com.intellij.util.containers.MultiMap\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.MemberKind\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.RawSignature\nimport org.jetbrains.org.objectweb.asm.FieldVisitor\nimport org.jetbrains.org.objectweb.asm.MethodVisitor\n\nabstract class DelegatingClassBuilderFactory(\n        protected val delegate: ClassBuilderFactory\n\n) : ClassBuilderFactory by delegate {\n\n    abstract override fun newClassBuilder(origin: JvmDeclarationOrigin): DelegatingClassBuilder\n\n    override fun asBytes(builder: ClassBuilder?): ByteArray? {\n        return delegate.asBytes((builder as DelegatingClassBuilder).delegate)\n    }\noverride fun asText(builder: ClassBuilder?): String? {\n", "line_to_complete": "\n        return delegate.asText((builder as DelegatingClassBuilder).delegate)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.decompiler.stub.files\n\nimport com.intellij.util.indexing.FileContentImpl\nimport org.jetbrains.kotlin.analysis.decompiler.stub.file.KotlinClsStubBuilder\nimport org.jetbrains.kotlin.test.KotlinTestUtils\nimport java.nio.file.Paths\n\nabstract class AbstractAdditionalStubInfoTest : AbstractDecompiledClassTest() {\nfun runTest(testDirectory: String) {\n", "line_to_complete": "\n        val testDirectoryPath = Paths.get(testDirectory)\n        val testData = TestData.createFromDirectory(testDirectoryPath)\n        val stub = KotlinClsStubBuilder().buildFileStub(FileContentImpl.createByFile(getClassFileToDecompile(testData, false)))!!\n        KotlinTestUtils.assertEqualsToFile(testData.getExpectedFile(useK2ToCompileCode), extractAdditionalStubInfo(stub))\n        testData.checkIfIdentical(useK2ToCompileCode)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.daemon.client\n\nimport org.jetbrains.kotlin.cli.common.repl.*\nimport org.jetbrains.kotlin.daemon.common.ReplStateFacade\nimport java.util.concurrent.atomic.AtomicInteger\nimport java.util.concurrent.locks.ReentrantReadWriteLock\n\n// NOTE: the lock is local\n// TODO: verify that locla lock doesn't lead to any synch problems\nclass RemoteReplCompilerStateHistory(private val state: RemoteReplCompilerState) : IReplStageHistory<Unit>, AbstractList<ReplHistoryRecord<Unit>>() {\n    override val size: Int\n        get() = state.replStateFacade.getHistorySize()\n\n    override fun get(index: Int): ReplHistoryRecord<Unit> = ReplHistoryRecord(state.replStateFacade.historyGet(index), Unit)\noverride fun push(id: ILineId, item: Unit) {\n", "line_to_complete": "\n        throw NotImplementedError(\"push to remote history is not supported\")\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.daemon.client\n\nimport org.jetbrains.kotlin.cli.common.repl.*\nimport org.jetbrains.kotlin.daemon.common.ReplStateFacade\nimport java.util.concurrent.atomic.AtomicInteger\nimport java.util.concurrent.locks.ReentrantReadWriteLock\n\n// NOTE: the lock is local\n// TODO: verify that locla lock doesn't lead to any synch problems\nclass RemoteReplCompilerStateHistory(private val state: RemoteReplCompilerState) : IReplStageHistory<Unit>, AbstractList<ReplHistoryRecord<Unit>>() {\n    override val size: Int\n        get() = state.replStateFacade.getHistorySize()\n\n    override fun get(index: Int): ReplHistoryRecord<Unit> = ReplHistoryRecord(state.replStateFacade.historyGet(index), Unit)\n\n    override fun push(id: ILineId, item: Unit) {\n        throw NotImplementedError(\"push to remote history is not supported\")\n    }\noverride fun pop(): ReplHistoryRecord<Unit>? {\n", "line_to_complete": "\n        throw NotImplementedError(\"pop from remote history is not supported\")\n    }"}
{"context": "// ISSUE: KT-42715\n\nfun foo(x: (a: Int) -> Unit): Int = 1 // (1)\nfun foo(x: (a: Int, b: String) -> Unit): String = \"\" // (2)\n\nfun takeInt(x: Int) {}\nfun takeString(x: String) {}\nfun test_1() {\n", "line_to_complete": "\n    val res = foo { x -> } // (1)\n    takeInt(res)\n}"}
{"context": "// ISSUE: KT-42715\n\nfun foo(x: (a: Int) -> Unit): Int = 1 // (1)\nfun foo(x: (a: Int, b: String) -> Unit): String = \"\" // (2)\n\nfun takeInt(x: Int) {}\nfun takeString(x: String) {}\n\nfun test_1() {\n    val res = foo { x -> } // (1)\n    takeInt(res)\n}\nfun test_2() {\n", "line_to_complete": "\n    val res = foo { x, y -> } // (2)\n    takeString(res)\n}"}
{"context": "// ISSUE: KT-42715\n\nfun foo(x: (a: Int) -> Unit): Int = 1 // (1)\nfun foo(x: (a: Int, b: String) -> Unit): String = \"\" // (2)\n\nfun takeInt(x: Int) {}\nfun takeString(x: String) {}\n\nfun test_1() {\n    val res = foo { x -> } // (1)\n    takeInt(res)\n}\n\nfun test_2() {\n    val res = foo { x, y -> } // (2)\n    takeString(res)\n}\nfun test_3() {\n", "line_to_complete": "\n    val res = foo {} // (1)\n    takeInt(res)\n}"}
{"context": "// IGNORE_FE10\n// MODULE: lib\n// MODULE_KIND: LibraryBinary\n// FILE: Lib.kt\npackage one\n\ndata class DataClass(val name: String)\n\n// MODULE: main(lib)\n// FILE: usage.kt\nfun usage(instance: one.DataClass) {\n", "line_to_complete": "\n    instance.<caret>hashCode()\n}"}
{"context": "fun z() {\n    val localInZ = 3\n    class Y {\n        val propertyInY = 2\nfun x() {\n", "line_to_complete": "\n            val localInX = 1\n            <expr>e</expr>\n        }"}
{"context": "// ISSUE: KT-39048\n\n// FILE: JavaClass.java\npublic class JavaClass<T extends Comparable<? super T>> {\n    public JavaClass(T from) {}\n}\n\n// FILE: main.kt\n\nclass K<T : Comparable<T>>(t: T)\nfun main() {\n", "line_to_complete": "\n    K(0)\n    JavaClass(0)\n}"}
{"context": "fun foo(runnable: Runnable) {}\nfun main() {\n", "line_to_complete": "\n    foo(Runnable {})\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.resolve.jvm.checkers\n\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtNamedDeclaration\nimport org.jetbrains.kotlin.resolve.checkers.DeclarationChecker\nimport org.jetbrains.kotlin.resolve.checkers.DeclarationCheckerContext\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm\n\nobject FunctionDelegateMemberNameClashChecker : DeclarationChecker {\noverride fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n", "line_to_complete": "\n        if (descriptor !is CallableMemberDescriptor) return\n        val container = descriptor.containingDeclaration\n        if (container !is ClassDescriptor || !container.isFun) return\n        if (descriptor.extensionReceiverParameter != null || descriptor.valueParameters.isNotEmpty()) return\n\n        if (descriptor is FunctionDescriptor && descriptor.name.asString() == \"getFunctionDelegate\" ||\n            descriptor is PropertyDescriptor && descriptor.name.asString() == \"functionDelegate\"\n        ) {\n            val reportOn = (declaration as? KtNamedDeclaration)?.nameIdentifier ?: declaration\n            context.trace.report(ErrorsJvm.FUNCTION_DELEGATE_MEMBER_NAME_CLASH.on(reportOn))\n        }\n    }"}
{"context": "// FILE: dependency.kt\npackage dependency\n\noperator fun String.invoke() {}\n\n// FILE: main.kt\npackage test\n\nimport dependency.invoke\nimport dependency.invoke as str\n\nclass My(val str: String)\nfun usage(m: My) {\n", "line_to_complete": "\n    m.str.str()\n}"}
{"context": "// FILE: pkg/JavaClass.java\npackage pkg;\n\npublic class JavaClass<T1> {\n    public static <T2> void staticMember() {}\n}\n\n// FILE: main.kt\npackage test\n\nimport pkg.JavaClass\nclass MyClass\n\nfun constructor() {\n", "line_to_complete": "\n    JavaClass<<caret_constructor_MyClass>MyClass>()\n    JavaClass<test.<caret_constructor_MyClass_fqn>MyClass>()\n\n    JavaClass<<caret_constructor_List>List<MyClass>>()\n    JavaClass<<caret_constructor_MutableList>MutableList<MyClass>>()\n\n    JavaClass<List<<caret_constructor_List_MyClass>MyClass>>()\n}"}
{"context": "// FILE: pkg/JavaClass.java\npackage pkg;\n\npublic class JavaClass<T1> {\n    public static <T2> void staticMember() {}\n}\n\n// FILE: main.kt\npackage test\n\nimport pkg.JavaClass\n\nclass MyClass\n\nfun constructor() {\n    JavaClass<<caret_constructor_MyClass>MyClass>()\n    JavaClass<test.<caret_constructor_MyClass_fqn>MyClass>()\n\n    JavaClass<<caret_constructor_List>List<MyClass>>()\n    JavaClass<<caret_constructor_MutableList>MutableList<MyClass>>()\n\n    JavaClass<List<<caret_constructor_List_MyClass>MyClass>>()\n}\nfun staticMember() {\n", "line_to_complete": "\n    JavaClass.staticMember<<caret_staticMember_MyClass>MyClass>()\n    JavaClass.staticMember<test.<caret_staticMember_MyClass_fqn>MyClass>()\n\n    JavaClass.staticMember<<caret_staticMember_List>List<MyClass>>()\n    JavaClass.staticMember<<caret_staticMember_MutableList>MutableList<MyClass>>()\n\n    JavaClass.staticMember<List<<caret_staticMember_List_MyClass>MyClass>>()\n}"}
{"context": "interface SomeInterface {\n    fun foo(x: Int, y: String): String\n    val bar: Boolean\n}\nclass SomeClass : SomeInterface {\n    private val baz = 42\noverride fun foo(x: Int, y: String): String {\n", "line_to_complete": "\n        return y + x + baz\n    }"}
{"context": "fun foo(lambda: (String) -> Int): Int = lambda(\"jello!\")\nfun test() {\n", "line_to_complete": "\n    foo <expr>@Deprecated(\"\") {\n        it.length\n    }</expr>\n}"}
{"context": "import kotlin.contracts.InvocationKind\ninline fun foo(block: () -> Unit) {\n", "line_to_complete": "\n    <expr>kotlin.contracts.contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }</expr>\n\n    block()\n}"}
{"context": "interface A\ninterface B\n\nfun foo(x: A) {}\nfun foo(x: B) {}\n\nopen class C : A, B\nfun main(a: A) {\n", "line_to_complete": "\n    foo(a)\n\n    val anonymousA: A = object : C() {}\n    foo(anonymousA)\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.resolve.dfa\n\nimport kotlinx.collections.immutable.*\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.types.*\nimport org.jetbrains.kotlin.types.AbstractTypeChecker\nimport java.util.*\nimport kotlin.math.max\n\nabstract class LogicSystem(private val context: ConeInferenceContext) {\n    val session: FirSession get() = context.session\n    private val nullableNothingType = session.builtinTypes.nullableNothingType.type\n    private val anyType = session.builtinTypes.anyType.type\n\n    abstract val variableStorage: VariableStorageImpl\n\n    protected open fun ConeKotlinType.isAcceptableForSmartcast(): Boolean {\n        return !isNullableNothing\n    }\nfun joinFlow(flows: Collection<PersistentFlow>, statementFlows: Collection<PersistentFlow>, union: Boolean): MutableFlow {\n", "line_to_complete": "\n        when (flows.size) {\n            0 -> return MutableFlow()\n            1 -> return flows.first().fork()\n        }\n        // If you're debugging this assertion error, most likely cause is that a node is not\n        // marked as dead when all its input edges are dead. In that case it will have an empty flow,\n        // and joining that with a non-empty flow from another branch will fail.\n        val commonFlow = flows.reduce { a, b -> a.lowestCommonAncestor(b) ?: error(\"no common ancestor in $a, $b\") }\n        val result = commonFlow.fork()\n        result.mergeAssignments(flows)\n        if (union) {\n            result.copyNonConflictingAliases(flows, commonFlow)\n        } else {\n            result.copyCommonAliases(flows)\n        }\n        result.copyStatements(statementFlows, commonFlow, union)\n        result.copyImplications(statementFlows)\n        return result\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.incremental.utils\n\nimport com.intellij.util.containers.Interner\nimport org.jetbrains.kotlin.incremental.LookupSymbol\nimport org.jetbrains.kotlin.incremental.components.LookupInfo\nimport org.jetbrains.kotlin.incremental.components.LookupTracker\nimport org.jetbrains.kotlin.incremental.components.Position\nimport org.jetbrains.kotlin.incremental.components.ScopeKind\n\nclass TestLookupTracker(val savedLookups: MutableSet<LookupSymbol> = mutableSetOf()) : LookupTracker {\n    val lookups = arrayListOf<LookupInfo>()\n    private val interner = Interner.createStringInterner()\n\n    override val requiresPosition: Boolean\n        get() = true\noverride fun record(filePath: String, position: Position, scopeFqName: String, scopeKind: ScopeKind, name: String) {\n", "line_to_complete": "\n        val internedFilePath = interner.intern(filePath)\n        val internedScopeFqName = interner.intern(scopeFqName)\n        val internedName = interner.intern(name)\n\n        lookups.add(LookupInfo(internedFilePath, position, internedScopeFqName, scopeKind, internedName))\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.incremental.snapshots\n\nimport org.jetbrains.kotlin.TestWithWorkingDir\nimport org.junit.Assert.assertNotEquals\nimport org.junit.Test\nimport java.io.*\n\nclass FileSnapshotTest : TestWithWorkingDir() {\n    private val fileSnapshotProvider: FileSnapshotProvider\n        get() = SimpleFileSnapshotProviderImpl()\n\n    @Test\nfun testExternalizer() {\n", "line_to_complete": "\n        val file = File(workingDir, \"1.txt\")\n        file.writeText(\"test\")\n        val snapshot = fileSnapshotProvider[file]\n        val deserializedSnapshot = saveAndReadBack(snapshot)\n        assertEquals(snapshot, deserializedSnapshot)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.incremental.snapshots\n\nimport org.jetbrains.kotlin.TestWithWorkingDir\nimport org.junit.Assert.assertNotEquals\nimport org.junit.Test\nimport java.io.*\n\nclass FileSnapshotTest : TestWithWorkingDir() {\n    private val fileSnapshotProvider: FileSnapshotProvider\n        get() = SimpleFileSnapshotProviderImpl()\n\n    @Test\n    fun testExternalizer() {\n        val file = File(workingDir, \"1.txt\")\n        file.writeText(\"test\")\n        val snapshot = fileSnapshotProvider[file]\n        val deserializedSnapshot = saveAndReadBack(snapshot)\n        assertEquals(snapshot, deserializedSnapshot)\n    }\n\n    @Test\nfun testEqualityNoChanges() {\n", "line_to_complete": "\n        val file = File(workingDir, \"1.txt\").apply { writeText(\"file\") }\n        val oldSnapshot = fileSnapshotProvider[file]\n        val newSnapshot = fileSnapshotProvider[file]\n        assertEquals(oldSnapshot, newSnapshot)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.incremental.snapshots\n\nimport org.jetbrains.kotlin.TestWithWorkingDir\nimport org.junit.Assert.assertNotEquals\nimport org.junit.Test\nimport java.io.*\n\nclass FileSnapshotTest : TestWithWorkingDir() {\n    private val fileSnapshotProvider: FileSnapshotProvider\n        get() = SimpleFileSnapshotProviderImpl()\n\n    @Test\n    fun testExternalizer() {\n        val file = File(workingDir, \"1.txt\")\n        file.writeText(\"test\")\n        val snapshot = fileSnapshotProvider[file]\n        val deserializedSnapshot = saveAndReadBack(snapshot)\n        assertEquals(snapshot, deserializedSnapshot)\n    }\n\n    @Test\n    fun testEqualityNoChanges() {\n        val file = File(workingDir, \"1.txt\").apply { writeText(\"file\") }\n        val oldSnapshot = fileSnapshotProvider[file]\n        val newSnapshot = fileSnapshotProvider[file]\n        assertEquals(oldSnapshot, newSnapshot)\n    }\n\n    @Test\nfun testEqualityDifferentFile() {\n", "line_to_complete": "\n        val file1 = File(workingDir, \"1.txt\").apply { writeText(\"file1\") }\n        val file2 = File(workingDir, \"2.txt\").apply {\n            writeText(file1.readText())\n            setLastModified(file1.lastModified())\n        }\n        val oldSnapshot = fileSnapshotProvider[file1]\n        val newSnapshot = fileSnapshotProvider[file2]\n        assertNotEquals(oldSnapshot, newSnapshot)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.types\n\nobject ConeIntegerLiteralIntersector {\nfun findCommonIntersectionType(types: Collection<ConeKotlinType>): ConeKotlinType? {\n", "line_to_complete": "\n        if (types.isEmpty()) return null\n        return types.reduce { left: ConeKotlinType?, right: ConeKotlinType? -> fold(left, right) }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.types\n\nobject ConeIntegerLiteralIntersector {\n    fun findCommonIntersectionType(types: Collection<ConeKotlinType>): ConeKotlinType? {\n        if (types.isEmpty()) return null\n        return types.reduce { left: ConeKotlinType?, right: ConeKotlinType? -> fold(left, right) }\n    }\nprivate fun fold(left: ConeKotlinType?, right: ConeKotlinType?): ConeKotlinType? {\n", "line_to_complete": "\n        if (left == null || right == null) return null\n        return when {\n            left is ConeIntegerLiteralType && right is ConeIntegerLiteralType ->\n                fold(left, right)\n\n            left is ConeIntegerLiteralType -> fold(left, right)\n            right is ConeIntegerLiteralType -> fold(right, left)\n            else -> null\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.types\n\nobject ConeIntegerLiteralIntersector {\n    fun findCommonIntersectionType(types: Collection<ConeKotlinType>): ConeKotlinType? {\n        if (types.isEmpty()) return null\n        return types.reduce { left: ConeKotlinType?, right: ConeKotlinType? -> fold(left, right) }\n    }\n\n    private fun fold(left: ConeKotlinType?, right: ConeKotlinType?): ConeKotlinType? {\n        if (left == null || right == null) return null\n        return when {\n            left is ConeIntegerLiteralType && right is ConeIntegerLiteralType ->\n                fold(left, right)\n\n            left is ConeIntegerLiteralType -> fold(left, right)\n            right is ConeIntegerLiteralType -> fold(right, left)\n            else -> null\n        }\n    }\nprivate fun fold(left: ConeIntegerLiteralType, right: ConeIntegerLiteralType): ConeKotlinType? {\n", "line_to_complete": "\n        return when {\n            left.possibleTypes.containsAll(right.possibleTypes) -> right\n            right.possibleTypes.containsAll(left.possibleTypes) -> left\n            else -> null\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.diagnostics\n\nimport org.jetbrains.kotlin.diagnostics.rendering.DiagnosticRenderer\nimport java.lang.IllegalArgumentException\n\nabstract class DiagnosticFactory<D : UnboundDiagnostic> protected constructor(\n    private var _name: String?,\n    open val severity: Severity\n) {\n    open val name: String\n        get() = _name!!\nfun initializeName(name: String) {\n", "line_to_complete": "\n        _name = name\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.diagnostics\n\nimport org.jetbrains.kotlin.diagnostics.rendering.DiagnosticRenderer\nimport java.lang.IllegalArgumentException\n\nabstract class DiagnosticFactory<D : UnboundDiagnostic> protected constructor(\n    private var _name: String?,\n    open val severity: Severity\n) {\n    open val name: String\n        get() = _name!!\n\n    fun initializeName(name: String) {\n        _name = name\n    }\n\n    open var defaultRenderer: DiagnosticRenderer<D>? = null\n\n    protected constructor(severity: Severity) : this(null, severity)\n\n    @Suppress(\"UNCHECKED_CAST\")\nfun initDefaultRenderer(defaultRenderer: DiagnosticRenderer<*>?) {\n", "line_to_complete": "\n        this.defaultRenderer = defaultRenderer as DiagnosticRenderer<D>?\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.diagnostics\n\nimport org.jetbrains.kotlin.diagnostics.rendering.DiagnosticRenderer\nimport java.lang.IllegalArgumentException\n\nabstract class DiagnosticFactory<D : UnboundDiagnostic> protected constructor(\n    private var _name: String?,\n    open val severity: Severity\n) {\n    open val name: String\n        get() = _name!!\n\n    fun initializeName(name: String) {\n        _name = name\n    }\n\n    open var defaultRenderer: DiagnosticRenderer<D>? = null\n\n    protected constructor(severity: Severity) : this(null, severity)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun initDefaultRenderer(defaultRenderer: DiagnosticRenderer<*>?) {\n        this.defaultRenderer = defaultRenderer as DiagnosticRenderer<D>?\n    }\nfun cast(diagnostic: UnboundDiagnostic): D {\n", "line_to_complete": "\n        require(!(diagnostic.factory !== this)) { \"Factory mismatch: expected \" + this + \" but was \" + diagnostic.factory }\n        @Suppress(\"UNCHECKED_CAST\")\n        return diagnostic as D\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.backend.common\n\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.SimpleFunctionDescriptor\nimport org.jetbrains.kotlin.resolve.sam.getAbstractMembers\nimport org.jetbrains.kotlin.types.KotlinType\n\nclass SamType constructor(val type: KotlinType) {\n\n    val classDescriptor: ClassDescriptor\n        get() = type.constructor.declarationDescriptor as? ClassDescriptor ?: error(\"Sam/Fun interface not a class descriptor: $type\")\n\n    val kotlinFunctionType: KotlinType\n        get() = classDescriptor.defaultFunctionTypeForSamInterface!!\n\n    val originalAbstractMethod: SimpleFunctionDescriptor\n        get() = getAbstractMembers(classDescriptor)[0] as SimpleFunctionDescriptor\noverride fun equals(other: Any?): Boolean {\n", "line_to_complete": "\n        return other is SamType && type == other.type\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.backend.common\n\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.SimpleFunctionDescriptor\nimport org.jetbrains.kotlin.resolve.sam.getAbstractMembers\nimport org.jetbrains.kotlin.types.KotlinType\n\nclass SamType constructor(val type: KotlinType) {\n\n    val classDescriptor: ClassDescriptor\n        get() = type.constructor.declarationDescriptor as? ClassDescriptor ?: error(\"Sam/Fun interface not a class descriptor: $type\")\n\n    val kotlinFunctionType: KotlinType\n        get() = classDescriptor.defaultFunctionTypeForSamInterface!!\n\n    val originalAbstractMethod: SimpleFunctionDescriptor\n        get() = getAbstractMembers(classDescriptor)[0] as SimpleFunctionDescriptor\n\n    override fun equals(other: Any?): Boolean {\n        return other is SamType && type == other.type\n    }\noverride fun hashCode(): Int {\n", "line_to_complete": "\n        return type.hashCode()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.backend.common\n\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.SimpleFunctionDescriptor\nimport org.jetbrains.kotlin.resolve.sam.getAbstractMembers\nimport org.jetbrains.kotlin.types.KotlinType\n\nclass SamType constructor(val type: KotlinType) {\n\n    val classDescriptor: ClassDescriptor\n        get() = type.constructor.declarationDescriptor as? ClassDescriptor ?: error(\"Sam/Fun interface not a class descriptor: $type\")\n\n    val kotlinFunctionType: KotlinType\n        get() = classDescriptor.defaultFunctionTypeForSamInterface!!\n\n    val originalAbstractMethod: SimpleFunctionDescriptor\n        get() = getAbstractMembers(classDescriptor)[0] as SimpleFunctionDescriptor\n\n    override fun equals(other: Any?): Boolean {\n        return other is SamType && type == other.type\n    }\n\n    override fun hashCode(): Int {\n        return type.hashCode()\n    }\noverride fun toString(): String {\n", "line_to_complete": "\n        return \"SamType($type)\"\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.container\n\nimport java.lang.reflect.*\n\ninterface ValueDescriptor {\n    fun getValue(): Any\n}\n\ninternal interface ComponentDescriptor : ValueDescriptor {\n    fun getRegistrations(): Iterable<Type>\n    fun getDependencies(context: ValueResolveContext): Collection<Type>\n    val shouldInjectProperties: Boolean\n        get() = false\n}\n\nclass IterableDescriptor(val descriptors: Iterable<ValueDescriptor>) : ValueDescriptor {\noverride fun getValue(): Any {\n", "line_to_complete": "\n        return descriptors.map { it.getValue() }\n    }"}
{"context": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.visitors\n\nimport org.jetbrains.kotlin.fir.*\nimport org.jetbrains.kotlin.fir.contracts.*\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.diagnostics.FirDiagnosticHolder\nimport org.jetbrains.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.references.*\nimport org.jetbrains.kotlin.fir.types.*\n\n\nabstract class FirTransformer<in D> : FirVisitor<FirElement, D>() {\n\n    abstract fun <E : FirElement> transformElement(element: E, data: D): E\nfinal override fun visitElement(element: FirElement, data: D): FirElement {\n", "line_to_complete": "\n        return transformElement(element, data)\n    }"}
{"context": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\npackage org.jetbrains.kotlin.fir.visitors\n\nimport org.jetbrains.kotlin.fir.*\nimport org.jetbrains.kotlin.fir.contracts.*\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.diagnostics.FirDiagnosticHolder\nimport org.jetbrains.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.references.*\nimport org.jetbrains.kotlin.fir.types.*\n\n\nabstract class FirTransformer<in D> : FirVisitor<FirElement, D>() {\n\n    abstract fun <E : FirElement> transformElement(element: E, data: D): E\n\n    final override fun visitElement(element: FirElement, data: D): FirElement {\n        return transformElement(element, data)\n    }\nopen fun transformAnnotationContainer(annotationContainer: FirAnnotationContainer, data: D): FirAnnotationContainer {\n", "line_to_complete": "\n        return transformElement(annotationContainer, data)\n    }"}
{"context": "// FILE: Test.java\n\nimport java.lang.*;\nimport java.util.*;\n\npublic class Test {\n    public static class MapEntryImpl implements Map.Entry<String, String> {\n        public String getKey() { return null; }\n        public String getValue() { return null; }\n        public String setValue(String s) { return null; }\n    }\n}\n\n// FILE: main.kt\n\nclass MyMapEntry : Test.MapEntryImpl()\nfun test() {\n", "line_to_complete": "\n    val b = MyMapEntry()\n    val key = b.key\n    val value = b.value\n    b.setValue(null)\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.type\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.types.*\n\nobject FirDefinitelyNotNullableChecker : FirTypeRefChecker(MppCheckerKind.Common) {\noverride fun check(typeRef: FirTypeRef, context: CheckerContext, reporter: DiagnosticReporter) {\n", "line_to_complete": "\n        val intersection = (typeRef as? FirResolvedTypeRef)?.delegatedTypeRef as? FirIntersectionTypeRef ?: return\n\n        if (intersection.isMarkedNullable) {\n            reporter.reportOn(intersection.source, FirErrors.NULLABLE_ON_DEFINITELY_NOT_NULLABLE, context)\n        }\n\n        if (!intersection.isLeftValidForDefinitelyNotNullable(context.session)) {\n            reporter.reportOn(intersection.leftType.source, FirErrors.INCORRECT_LEFT_COMPONENT_OF_INTERSECTION, context)\n        }\n\n        if (!intersection.isRightValidForDefinitelyNotNullable) {\n            reporter.reportOn(intersection.rightType.source, FirErrors.INCORRECT_RIGHT_COMPONENT_OF_INTERSECTION, context)\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.analysis.checkers.expression\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.checkModifiersCompatibility\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.expressions.FirQualifiedAccessExpression\n\n\nobject FirIncompatibleProjectionsOnTypeArgumentChecker : FirQualifiedAccessExpressionChecker(MppCheckerKind.Common) {\noverride fun check(expression: FirQualifiedAccessExpression, context: CheckerContext, reporter: DiagnosticReporter) {\n", "line_to_complete": "\n        for (it in expression.typeArguments) {\n            checkModifiersCompatibility(it, context, reporter)\n        }\n    }"}
{"context": "// LANGUAGE: +MultiPlatformProjects\n\n// FILE: B.kt\n\npackage b.d\n\nexpect interface Other\n\nexpect class Another\n\nfun baz() {}\n\n// FILE: A.kt\n\npackage a.d\n\nimport b.d.*\n\n<!NON_MEMBER_FUNCTION_NO_BODY!>fun foo(arg: Other): Another<!>\nfun bar() {\n", "line_to_complete": "\n    baz()\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.types.builder\n\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.builder.FirAnnotationContainerBuilder\nimport org.jetbrains.kotlin.fir.builder.FirBuilderDsl\nimport org.jetbrains.kotlin.fir.builder.toMutableOrEmpty\nimport org.jetbrains.kotlin.fir.expressions.FirAnnotation\nimport org.jetbrains.kotlin.fir.types.FirQualifierPart\nimport org.jetbrains.kotlin.fir.types.FirUserTypeRef\nimport org.jetbrains.kotlin.fir.types.impl.FirUserTypeRefImpl\n\n\n@FirBuilderDsl\nopen class FirUserTypeRefBuilder : FirAnnotationContainerBuilder {\n    override var source: KtSourceElement? = null\n    override val annotations: MutableList<FirAnnotation> = mutableListOf()\n    open var isMarkedNullable: Boolean by kotlin.properties.Delegates.notNull()\n    val qualifier: MutableList<FirQualifierPart> = mutableListOf()\noverride fun build(): FirUserTypeRef {\n", "line_to_complete": "\n        return FirUserTypeRefImpl(source, isMarkedNullable, qualifier, annotations.toMutableOrEmpty())\n    }"}
{"context": "// FILE: Utils.java\n\npublic class Utils {\n    public static String[] getStrings() {\n        return new String[0];\n    }\n}\n\n// FILE: Main.kt\n\nfun <T> myListOf(vararg elements: T): List<T> = null!!\nfun <T> myListOf(element: T): List<T> = null!!\n\nfun takeStrings(list: List<String>) {}\n\nfun getStrings(): Array<String> = null!!\nfun testFromKotlin() {\n", "line_to_complete": "\n    val values = getStrings()\n    val list = myListOf(*values)\n    takeStrings(list)\n}"}
{"context": "// FILE: Utils.java\n\npublic class Utils {\n    public static String[] getStrings() {\n        return new String[0];\n    }\n}\n\n// FILE: Main.kt\n\nfun <T> myListOf(vararg elements: T): List<T> = null!!\nfun <T> myListOf(element: T): List<T> = null!!\n\nfun takeStrings(list: List<String>) {}\n\nfun getStrings(): Array<String> = null!!\n\nfun testFromKotlin() {\n    val values = getStrings()\n    val list = myListOf(*values)\n    takeStrings(list)\n}\nfun testFromJava() {\n", "line_to_complete": "\n    val values = Utils.getStrings()\n    val list = myListOf(*values)\n    takeStrings(list)\n}"}
{"context": "class Foo() {\n    fun call() {}\nprivate fun foo() {\n", "line_to_complete": "\n        c<caret>all()\n    }"}
{"context": "package org.jetbrains.kotlin.fir.declarations\n\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget\nimport org.jetbrains.kotlin.resolve.deprecation.DeprecationInfo\n\n\n\n\nclass DeprecationsPerUseSite(\n    val all: DeprecationInfo?,\n    val bySpecificSite: Map<AnnotationUseSiteTarget, DeprecationInfo>?\n) {\nfun forUseSite(vararg sites: AnnotationUseSiteTarget): DeprecationInfo? {\n", "line_to_complete": "\n        if (bySpecificSite != null) {\n            for (site in sites) {\n                bySpecificSite[site]?.let { return it }\n            }\n        }\n        return all\n    }"}
{"context": "// !DUMP_CFG\nimport kotlin.contracts.*\n\nfun bar(x: () -> Unit) {\n\n}\n\n@ExperimentalContracts\nfun foo(x: () -> Unit, y: () -> Unit, z: () -> Unit) {\n", "line_to_complete": "\n    <!LEAKED_IN_PLACE_LAMBDA, LEAKED_IN_PLACE_LAMBDA, LEAKED_IN_PLACE_LAMBDA!>contract {\n        callsInPlace(x, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(y, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(z, InvocationKind.AT_MOST_ONCE)\n    }<!>\n\n    if (true) {\n        bar(<!LEAKED_IN_PLACE_LAMBDA!>x<!>)\n    } else {\n        val yCopy = <!LEAKED_IN_PLACE_LAMBDA!>y<!>\n        yCopy()\n    }\n\n    val zCopy: () -> Unit\n    zCopy = <!LEAKED_IN_PLACE_LAMBDA!>z<!>\n    zCopy()\n}"}
{"context": "// FILE: MyFunction.java\npublic interface MyFunction<T, R> {\n    R foo(T x);\n}\n\n// FILE: JavaUsage.java\n\npublic class JavaUsage {\n    public static void foo1(MyFunction<Integer, String> x) {}\n    public static void foo2(MyFunction<? super Number, ? extends CharSequence> x) {}\n    public static <X, Y> Y foo3(MyFunction<X, Y> f, X x) {}\n}\n// FILE: main.kt\nfun main() {\n", "line_to_complete": "\n    JavaUsage.foo1 { x ->\n        x.toInt().toString()\n    }\n\n    JavaUsage.foo2 { x ->\n        x.toInt().toString()\n    }\n\n    JavaUsage.foo2 <!ARGUMENT_TYPE_MISMATCH!>{ x: Int ->\n        x.toString()\n    }<!>\n\n    JavaUsage.foo3(\n        { x ->\n            (x + 1).toString()\n        },\n        1\n    )\n\n    JavaUsage.foo3(\n        { x: Number ->\n            x.toInt().toString()\n        },\n        2\n    )\n}"}
{"context": "interface I<T> {\n    fun i(t: T): Int\n}\n\nclass C<<expr>T</expr>>(val x: Int): I<T> {\n    companion object {\n        val K: Int = 58\n    }\nfun test(): Int {\n", "line_to_complete": "\n        return 45 * K\n    }"}
{"context": "interface I<T> {\n    fun i(t: T): Int\n}\n\nclass C<<expr>T</expr>>(val x: Int): I<T> {\n    companion object {\n        val K: Int = 58\n    }\n\n    fun test(): Int {\n        return 45 * K\n    }\nfun count(xs: List<T>): Int {\n", "line_to_complete": "\n        return xs.size\n    }"}
{"context": "interface I<T> {\n    fun i(t: T): Int\n}\n\nclass C<<expr>T</expr>>(val x: Int): I<T> {\n    companion object {\n        val K: Int = 58\n    }\n\n    fun test(): Int {\n        return 45 * K\n    }\n\n    fun count(xs: List<T>): Int {\n        return xs.size\n    }\noverride fun i(t: T): Int {\n", "line_to_complete": "\n        return test() + t.hashCode()\n    }"}
{"context": "class SomeClass\n\nclass OtherClass {\n    class NestedClass {\n        @Suppress(\"CONFLICTING_OVERLOADS\")\nfun someFun(): SomeClass {\n", "line_to_complete": "\n            return SomeClass()\n        }"}
{"context": "\n\npackage org.jetbrains.kotlin.build.report.statistics\ninternal fun formatTime(ms: Long): String {\n", "line_to_complete": "\n    val seconds = ms.toDouble() / 1_000\n    return seconds.asString(2) + \" s\"\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.build.report.statistics\n\ninternal fun formatTime(ms: Long): String {\n    val seconds = ms.toDouble() / 1_000\n    return seconds.asString(2) + \" s\"\n}\n\nprivate const val kbSize = 1024\nprivate const val mbSize = kbSize * 1024\nprivate const val gbSize = mbSize * 1024\nfun formatSize(sizeInBytes: Long): String = when {\n", "line_to_complete": "\n    sizeInBytes / gbSize >= 1 -> \"${(sizeInBytes.toDouble() / gbSize).asString(1)} GB\"\n    sizeInBytes / mbSize >= 1 -> \"${(sizeInBytes.toDouble() / mbSize).asString(1)} MB\"\n    sizeInBytes / kbSize >= 1 -> \"${(sizeInBytes.toDouble() / kbSize).asString(1)} KB\"\n    else -> \"$sizeInBytes B\"\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.resolve.jvm.checkers\n\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.resolve.DescriptorToSourceUtils\nimport org.jetbrains.kotlin.resolve.JVM_INLINE_ANNOTATION_FQ_NAME\nimport org.jetbrains.kotlin.resolve.checkers.DeclarationChecker\nimport org.jetbrains.kotlin.resolve.checkers.DeclarationCheckerContext\nimport org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm\n\nclass JvmInlineApplicabilityChecker : DeclarationChecker {\noverride fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n", "line_to_complete": "\n        if (descriptor !is ClassDescriptor) return\n        val annotation = descriptor.annotations.findAnnotation(JVM_INLINE_ANNOTATION_FQ_NAME)\n        if (annotation != null && !descriptor.isValue) {\n            val annotationEntry = DescriptorToSourceUtils.getSourceFromAnnotation(annotation) ?: return\n            context.trace.report(ErrorsJvm.JVM_INLINE_WITHOUT_VALUE_CLASS.on(annotationEntry))\n        }\n\n        if (descriptor.isValue && annotation == null && !descriptor.isExpect) {\n            val valueKeyword = declaration.modifierList?.getModifier(KtTokens.VALUE_KEYWORD) ?: return\n            context.trace.report(ErrorsJvm.VALUE_CLASS_WITHOUT_JVM_INLINE_ANNOTATION.on(valueKeyword))\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.asJava.elements\n\nimport com.intellij.psi.PsiElement\nimport com.intellij.psi.PsiIdentifier\nimport com.intellij.psi.PsiMember\nimport com.intellij.psi.PsiModifierList\nimport com.intellij.psi.javadoc.PsiDocComment\nimport org.jetbrains.kotlin.asJava.builder.LightMemberOriginForDeclaration\nimport org.jetbrains.kotlin.asJava.classes.KtLightClass\nimport org.jetbrains.kotlin.psi.KtDeclaration\nimport org.jetbrains.kotlin.psi.KtNamedDeclaration\n\nabstract class KtLightMemberImpl<out D : PsiMember>(\n    override val lightMemberOrigin: LightMemberOriginForDeclaration?,\n    private val containingClass: KtLightClass,\n) : KtLightElementBase(containingClass), PsiMember, KtLightMember<D> {\n    abstract override fun hasModifierProperty(name: String): Boolean\n\n    abstract override fun getModifierList(): PsiModifierList?\noverride fun toString(): String = \"$ {\n", "line_to_complete": "this::class.java.simpleName}"}
{"context": "\n\npackage org.jetbrains.kotlin.daemon.client\n\nimport org.jetbrains.kotlin.cli.common.messages.CompilerMessageSourceLocation\nimport org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity\nimport org.jetbrains.kotlin.cli.common.messages.MessageCollector\nimport org.jetbrains.kotlin.cli.common.messages.OutputMessageUtil\nimport org.jetbrains.kotlin.daemon.common.*\nimport java.io.File\nimport java.io.Serializable\nimport java.rmi.server.UnicastRemoteObject\n\n\nopen class BasicCompilerServicesWithResultsFacadeServer(\n        val messageCollector: MessageCollector,\n        val outputsCollector: ((File, List<File>) -> Unit)? = null,\n        port: Int = SOCKET_ANY_FREE_PORT\n) : CompilerServicesFacadeBase,\n    UnicastRemoteObject(port, LoopbackNetworkInterface.clientLoopbackSocketFactory, LoopbackNetworkInterface.serverLoopbackSocketFactory)\n{\noverride fun report(category: Int, severity: Int, message: String?, attachment: Serializable?) {\n", "line_to_complete": "\n        messageCollector.reportFromDaemon(outputsCollector, category, severity, message, attachment)\n    }"}
{"context": "// WITH_STDLIB\n// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE_K1\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\n\n@OptIn(ExperimentalContracts::class)\nfun unknownContract(block: () -> Unit) {\n", "line_to_complete": "\n    contr<caret>act {\n        callsInPlace(block, InvocationKind.UNKNOWN)\n    }\n    block()\n}"}
{"context": "// MODULE: dep\n// FILE: issue/pack/RowIcon.java\npackage issue.pack;\n\npublic class RowIcon {\n    public class RClass {}\n}\n\n// MODULE: main(dep)\n// FILE: usage.kt\npackage usage\n\nfun testJavaNestedClass(alignment: issue.pack.RowIcon.RClass) {\n}\nfun checkIt() {\n", "line_to_complete": "\n    testJavaNestedClass(issue.pack.RowIcon().RClass())\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.resolve.checkers\n\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.lexer.KtTokens\nimport org.jetbrains.kotlin.psi.KtDeclaration\n\nobject SealedInterfaceAllowedChecker : DeclarationChecker {\noverride fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n", "line_to_complete": "\n        if (descriptor !is ClassDescriptor) return\n        if (descriptor.kind != ClassKind.INTERFACE) return\n        val keyword = declaration.modifierList?.getModifier(KtTokens.SEALED_KEYWORD) ?: return\n        val diagnostic = if (context.languageVersionSettings.supportsFeature(LanguageFeature.SealedInterfaces)) {\n            if (descriptor.isFun) {\n                Errors.UNSUPPORTED_SEALED_FUN_INTERFACE.on(keyword)\n            } else return\n        } else {\n            Errors.UNSUPPORTED_FEATURE.on(keyword, LanguageFeature.SealedInterfaces to context.languageVersionSettings)\n        }\n        context.trace.report(diagnostic)\n    }"}
{"context": "expect abstract class A {\n    abstract fun foo()\n}\n\nabstract actual class A {\n    abstract actual fun foo()\n}\n\nclass Bar: A() {\noverride fun foo() {\n", "line_to_complete": "\n        TODO(\"Not yet implemented\")\n    }"}
{"context": "fun String.foo(i: Int): String = \"\"\nfun take(s: String) {\n", "line_to_complete": "\n    s.<expr>foo</expr>(10)\n}"}
{"context": "fun test() {\n    <expr>call()</expr>\n}\nfun call(): Foo? {\n", "line_to_complete": "\n    return null\n}"}
{"context": "class A {\nfun test() {\n", "line_to_complete": "\n        \"\".<expr>f()</expr>\n    }"}
{"context": "operator fun Int.invoke() : Long = 1L\noperator fun Long.invoke() : Double = 1.0\noperator fun Double.invoke() {}\nfun test(i: Int) {\n", "line_to_complete": "\n    <expr>i()</expr>()()\n}"}
{"context": "abstract class Base {\n    class BaseNested\n}\n\nclass Derived : Base() {\n    class DerivedNested\n\n    companion object {\n        val b: BaseNested = BaseNested()\n\n        val d: DerivedNested = DerivedNested()\nfun foo() {\n", "line_to_complete": "\n            val bb: BaseNested = BaseNested()\n            val dd: DerivedNested = DerivedNested()\n        }"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen.intrinsics\n\nimport org.jetbrains.kotlin.codegen.Callable\nimport org.jetbrains.kotlin.codegen.CallableMethod\nimport org.jetbrains.kotlin.descriptors.CallableMemberDescriptor\nimport org.jetbrains.kotlin.descriptors.PackageFragmentDescriptor\n\nabstract class UnsignedIntrinsic(private val targetDescriptor: String) : IntrinsicMethod() {\noverride fun isApplicableToOverload(descriptor: CallableMemberDescriptor): Boolean {\n", "line_to_complete": "\n        if (descriptor.containingDeclaration is PackageFragmentDescriptor) return true\n        val valueParameter = descriptor.valueParameters.singleOrNull() ?: return true\n        val singleValueParameterTypeDescriptor = valueParameter.type.constructor.declarationDescriptor\n            ?: throw AssertionError(\"Unexpected descriptor for unsigned intrinsic: $descriptor\")\n        return singleValueParameterTypeDescriptor.name.asString() == targetDescriptor\n    }"}
{"context": "// FILE: main.kt\npackage a.b.c\n\nfun <T> foo(a: T, b: T) = a.hashCode() + b.hashCode()\nfun test(): Int {\n", "line_to_complete": "\n    fun foo(a: Int, b: Int) = a + b\n    return <expr>a.b.c.foo(1, 2)</expr>\n}"}
{"context": "// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n\npackage org.jetbrains.kotlin.analysis.decompiler.psi.file\n\nimport com.intellij.openapi.vfs.VirtualFile\nimport org.jetbrains.kotlin.analysis.decompiler.psi.KotlinDecompiledFileViewProvider\nimport org.jetbrains.kotlin.analysis.decompiler.psi.text.DecompiledText\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.utils.concurrent.block.LockedClearableLazyValue\n\nopen class KtDecompiledFile(\n    private val provider: KotlinDecompiledFileViewProvider,\n    buildDecompiledText: (VirtualFile) -> DecompiledText\n) : KtFile(provider, true) {\n\n    private val decompiledText = LockedClearableLazyValue(Any()) {\n        buildDecompiledText(provider.virtualFile)\n    }\noverride fun getText(): String? {\n", "line_to_complete": "\n        return decompiledText.get().text\n    }"}
{"context": "// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n\npackage org.jetbrains.kotlin.analysis.decompiler.psi.file\n\nimport com.intellij.openapi.vfs.VirtualFile\nimport org.jetbrains.kotlin.analysis.decompiler.psi.KotlinDecompiledFileViewProvider\nimport org.jetbrains.kotlin.analysis.decompiler.psi.text.DecompiledText\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.utils.concurrent.block.LockedClearableLazyValue\n\nopen class KtDecompiledFile(\n    private val provider: KotlinDecompiledFileViewProvider,\n    buildDecompiledText: (VirtualFile) -> DecompiledText\n) : KtFile(provider, true) {\n\n    private val decompiledText = LockedClearableLazyValue(Any()) {\n        buildDecompiledText(provider.virtualFile)\n    }\n\n    override fun getText(): String? {\n        return decompiledText.get().text\n    }\noverride fun onContentReload() {\n", "line_to_complete": "\n        super.onContentReload()\n\n        provider.content.drop()\n        decompiledText.drop()\n    }"}
{"context": "// WITH_STDLIB\nfun test() {\n", "line_to_complete": "\n    set<caret>Of(\"4\", \"2\")\n}"}
{"context": "fun function(a: Int) {}\nfun call() {\n", "line_to_complete": "\n    <expr>function(1)</expr>\n}"}
{"context": "interface Foo {}\nfun test(obj: Any) {\n", "line_to_complete": "\n    if (obj is Foo) {\n        consume(obj)\n    }\n    <expr>obj.hashCode()</expr>\n}"}
{"context": "//  Ignore reason: KT-57619\nimport <!UNRESOLVED_IMPORT!>my<!>.println\n\nenum class Order {\n    FIRST,\n    SECOND,\n    THIRD\n}\n\nenum class Planet(val m: Double, internal val r: Double) {\n    MERCURY(1.0, 2.0) {\noverride fun sayHello() {\n", "line_to_complete": "\n            <!UNRESOLVED_REFERENCE!>println<!>(\"Hello!!!\")\n        }"}
{"context": "//  Ignore reason: KT-57619\nimport <!UNRESOLVED_IMPORT!>my<!>.println\n\nenum class Order {\n    FIRST,\n    SECOND,\n    THIRD\n}\n\nenum class Planet(val m: Double, internal val r: Double) {\n    MERCURY(1.0, 2.0) {\n        override fun sayHello() {\n            <!UNRESOLVED_REFERENCE!>println<!>(\"Hello!!!\")\n        }\n    },\n    VENERA(3.0, 4.0) {\noverride fun sayHello() {\n", "line_to_complete": "\n            <!UNRESOLVED_REFERENCE!>println<!>(\"Ola!!!\")\n        }"}
{"context": "//  Ignore reason: KT-57619\nimport <!UNRESOLVED_IMPORT!>my<!>.println\n\nenum class Order {\n    FIRST,\n    SECOND,\n    THIRD\n}\n\nenum class Planet(val m: Double, internal val r: Double) {\n    MERCURY(1.0, 2.0) {\n        override fun sayHello() {\n            <!UNRESOLVED_REFERENCE!>println<!>(\"Hello!!!\")\n        }\n    },\n    VENERA(3.0, 4.0) {\n        override fun sayHello() {\n            <!UNRESOLVED_REFERENCE!>println<!>(\"Ola!!!\")\n        }\n    },\n    EARTH(5.0, 6.0) {\noverride fun sayHello() {\n", "line_to_complete": "\n            <!UNRESOLVED_REFERENCE!>println<!>(\"Privet!!!\")\n        }"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen.context\n\nimport org.jetbrains.kotlin.codegen.OwnerKind\nimport org.jetbrains.kotlin.codegen.StackValue\nimport org.jetbrains.kotlin.codegen.binding.MutableClosure\nimport org.jetbrains.kotlin.codegen.state.KotlinTypeMapper\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.DeclarationDescriptor\n\nabstract class ScriptLikeContext(\n    val typeMapper: KotlinTypeMapper,\n    contextDescriptor: ClassDescriptor,\n    parentContext: CodegenContext<*>?\n) : ClassContext(typeMapper, contextDescriptor, OwnerKind.IMPLEMENTATION, parentContext, null) {\n    abstract fun getOuterReceiverExpression(prefix: StackValue?, thisOrOuterClass: ClassDescriptor): StackValue\nopen fun captureVariable(closure: MutableClosure, target: DeclarationDescriptor): StackValue? {\n", "line_to_complete": "\n        return null\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen.optimization.boxing\n\nimport org.jetbrains.kotlin.codegen.optimization.common.FastAnalyzer\nimport org.jetbrains.kotlin.codegen.optimization.common.findPreviousOrNull\nimport org.jetbrains.kotlin.codegen.optimization.common.nodeType\nimport org.jetbrains.kotlin.codegen.optimization.transformer.MethodTransformer\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode\nimport org.jetbrains.org.objectweb.asm.tree.InsnNode\nimport org.jetbrains.org.objectweb.asm.tree.LdcInsnNode\nimport org.jetbrains.org.objectweb.asm.tree.MethodNode\n\nclass StackPeepholeOptimizationsTransformer : MethodTransformer() {\noverride fun transform(internalClassName: String, methodNode: MethodNode) {\n", "line_to_complete": "\n        while (true) {\n            if (!transformOnce(methodNode)) break\n        }\n    }"}
{"context": "// FILE: lib.kt\n\nfun foo() {}\n\n// FILE: main.kt\nfun test() {\n", "line_to_complete": "\n    fo<caret>o()\n}"}
{"context": "// FILE: issue/pack/RowIcon.java\npackage issue.pack;\n\npublic class RowIcon {\n    public class RClass {}\n}\n\n// FILE: usage.kt\npackage usage\n\nfun testJavaNestedClass(alignment: issue.pack.RowIcon.RClass) {\n}\nfun checkIt() {\n", "line_to_complete": "\n    testJavaNestedClass(issue.pack.RowIcon().RClass())\n}"}
{"context": "interface SomeInterface {\n    fun foo(x: Int, y: String): String\n\n    val bar: Boolean\n}\n\nclass SomeClass : SomeInterface {\n    private val baz = 42\noverride fun foo(x: Int, y: String): String {\n", "line_to_complete": "\n        return y + x + baz\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen.intrinsics\n\nimport org.jetbrains.kotlin.builtins.StandardNames.COLLECTIONS_PACKAGE_FQ_NAME\nimport org.jetbrains.kotlin.codegen.AsmUtil\nimport org.jetbrains.kotlin.codegen.Callable\nimport org.jetbrains.kotlin.codegen.CallableMethod\nimport org.jetbrains.kotlin.fileClasses.internalNameWithoutInnerClasses\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes\nimport org.jetbrains.kotlin.resolve.jvm.JvmPrimitiveType\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\n\nclass IteratorNext : IntrinsicMethod() {\noverride fun toCallable(method: CallableMethod): Callable {\n", "line_to_complete": "\n        val type = AsmUtil.unboxType(method.returnType)\n        return object : IntrinsicCallable(type, listOf(), AsmTypes.OBJECT_TYPE, null) {\n            override fun invokeIntrinsic(v: InstructionAdapter) {\n                val primitiveClassName = getKotlinPrimitiveClassName(returnType)\n                v.invokevirtual(\n                        getPrimitiveIteratorType(primitiveClassName).internalName,\n                        \"next${primitiveClassName.asString()}\",\n                        \"()\" + returnType.descriptor,\n                        false\n                )\n            }\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen.intrinsics\n\nimport org.jetbrains.kotlin.builtins.StandardNames.COLLECTIONS_PACKAGE_FQ_NAME\nimport org.jetbrains.kotlin.codegen.AsmUtil\nimport org.jetbrains.kotlin.codegen.Callable\nimport org.jetbrains.kotlin.codegen.CallableMethod\nimport org.jetbrains.kotlin.fileClasses.internalNameWithoutInnerClasses\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes\nimport org.jetbrains.kotlin.resolve.jvm.JvmPrimitiveType\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\n\nclass IteratorNext : IntrinsicMethod() {\n    override fun toCallable(method: CallableMethod): Callable {\n        val type = AsmUtil.unboxType(method.returnType)\n        return object : IntrinsicCallable(type, listOf(), AsmTypes.OBJECT_TYPE, null) {\noverride fun invokeIntrinsic(v: InstructionAdapter) {\n", "line_to_complete": "\n                val primitiveClassName = getKotlinPrimitiveClassName(returnType)\n                v.invokevirtual(\n                        getPrimitiveIteratorType(primitiveClassName).internalName,\n                        \"next${primitiveClassName.asString()}\",\n                        \"()\" + returnType.descriptor,\n                        false\n                )\n            }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.types\n\nimport org.jetbrains.kotlin.types.Variance\nimport org.jetbrains.kotlin.types.model.TypeArgumentMarker\n\nenum class ProjectionKind {\n    STAR, IN, OUT, INVARIANT;\n}\n\nsealed class ConeTypeProjection : TypeArgumentMarker {\n    abstract val kind: ProjectionKind\n\n    companion object {\n        val EMPTY_ARRAY = arrayOf<ConeTypeProjection>()\n    }\n}\n\nobject ConeStarProjection : ConeTypeProjection() {\n    override val kind: ProjectionKind\n        get() = ProjectionKind.STAR\n}\n\nsealed class ConeKotlinTypeProjection : ConeTypeProjection() {\n    abstract val type: ConeKotlinType\noverride fun equals(other: Any?): Boolean {\n", "line_to_complete": "\n        if (this === other) return true\n        if (other !is ConeKotlinTypeProjection) return false\n\n        if (kind != other.kind) return false\n        if (type != other.type) return false\n\n        return true\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.types\n\nimport org.jetbrains.kotlin.types.Variance\nimport org.jetbrains.kotlin.types.model.TypeArgumentMarker\n\nenum class ProjectionKind {\n    STAR, IN, OUT, INVARIANT;\n}\n\nsealed class ConeTypeProjection : TypeArgumentMarker {\n    abstract val kind: ProjectionKind\n\n    companion object {\n        val EMPTY_ARRAY = arrayOf<ConeTypeProjection>()\n    }\n}\n\nobject ConeStarProjection : ConeTypeProjection() {\n    override val kind: ProjectionKind\n        get() = ProjectionKind.STAR\n}\n\nsealed class ConeKotlinTypeProjection : ConeTypeProjection() {\n    abstract val type: ConeKotlinType\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other !is ConeKotlinTypeProjection) return false\n\n        if (kind != other.kind) return false\n        if (type != other.type) return false\n\n        return true\n    }\noverride fun hashCode(): Int {\n", "line_to_complete": "\n        return type.hashCode() * 31 + kind.hashCode()\n    }"}
{"context": "data class My(val x: Unit)\n\ninterface I {\n    val x: Unit\n}\n\nclass A {\n    fun too(): <!WRONG_ANNOTATION_TARGET!>@<!NOT_AN_ANNOTATION_CLASS!>Annotation<!><!> Unit {}\n\n    fun foo(): <!REDUNDANT_RETURN_UNIT_TYPE!>Unit<!>\n    {\n    }\n\n    fun bar(): <!REDUNDANT_RETURN_UNIT_TYPE!>Unit<!>\n    {\n        return Unit\n    }\n\n    fun baz(): Unit = bar()\n\n    fun f1(): Int = 1\n\n    fun f2(): <!REDUNDANT_RETURN_UNIT_TYPE!>Unit<!>\n    {\n        throw UnsupportedOperationException(\"\")\n    }\n\n    fun f3(): Unit = throw UnsupportedOperationException(\"\")\n}\n\nclass B {\n    fun <T> run(f: () -> T) = f()\nfun foo(): Unit = run {\n", "line_to_complete": "\n        bar()\n    }"}
{"context": "data class My(val x: Unit)\n\ninterface I {\n    val x: Unit\n}\n\nclass A {\n    fun too(): <!WRONG_ANNOTATION_TARGET!>@<!NOT_AN_ANNOTATION_CLASS!>Annotation<!><!> Unit {}\n\n    fun foo(): <!REDUNDANT_RETURN_UNIT_TYPE!>Unit<!>\n    {\n    }\n\n    fun bar(): <!REDUNDANT_RETURN_UNIT_TYPE!>Unit<!>\n    {\n        return Unit\n    }\n\n    fun baz(): Unit = bar()\n\n    fun f1(): Int = 1\n\n    fun f2(): <!REDUNDANT_RETURN_UNIT_TYPE!>Unit<!>\n    {\n        throw UnsupportedOperationException(\"\")\n    }\n\n    fun f3(): Unit = throw UnsupportedOperationException(\"\")\n}\n\nclass B {\n    fun <T> run(f: () -> T) = f()\n\n    fun foo(): Unit = run {\n        bar()\n    }\n\n    fun bar() = 1\n\n    fun call(f: () -> Unit) = f()\nfun boo(): Unit = call {\n", "line_to_complete": "\n        baz()\n    }"}
{"context": "data class My(val x: Unit)\n\ninterface I {\n    val x: Unit\n}\n\nclass A {\n    fun too(): <!WRONG_ANNOTATION_TARGET!>@<!NOT_AN_ANNOTATION_CLASS!>Annotation<!><!> Unit {}\n\n    fun foo(): <!REDUNDANT_RETURN_UNIT_TYPE!>Unit<!>\n    {\n    }\n\n    fun bar(): <!REDUNDANT_RETURN_UNIT_TYPE!>Unit<!>\n    {\n        return Unit\n    }\n\n    fun baz(): Unit = bar()\n\n    fun f1(): Int = 1\n\n    fun f2(): <!REDUNDANT_RETURN_UNIT_TYPE!>Unit<!>\n    {\n        throw UnsupportedOperationException(\"\")\n    }\n\n    fun f3(): Unit = throw UnsupportedOperationException(\"\")\n}\n\nclass B {\n    fun <T> run(f: () -> T) = f()\n\n    fun foo(): Unit = run {\n        bar()\n    }\n\n    fun bar() = 1\n\n    fun call(f: () -> Unit) = f()\n\n    fun boo(): Unit = call {\n        baz()\n    }\n\n    fun baz() {}\n\n    fun <T, R> T.let(f: (T) -> R) = f(this)\nfun goo(): Unit = 1.let {\n", "line_to_complete": "\n        bar()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.incremental\n\nimport org.jetbrains.kotlin.load.kotlin.FileBasedKotlinClass\nimport org.jetbrains.kotlin.load.kotlin.header.KotlinClassHeader\nimport org.jetbrains.kotlin.metadata.jvm.deserialization.JvmMetadataVersion\nimport org.jetbrains.kotlin.name.ClassId\nimport org.jetbrains.kotlin.resolve.jvm.JvmClassName\nimport java.io.File\n\nclass LocalFileKotlinClass private constructor(\n    private val file: File,\n    private val fileContents: ByteArray,\n    className: ClassId,\n    classVersion: Int,\n    classHeader: KotlinClassHeader,\n    innerClasses: InnerClassesInfo\n) : FileBasedKotlinClass(className, classVersion, classHeader, innerClasses) {\n\n    companion object {\nfun create(file: File, jvmMetadataVersionFromLanguageVersion: JvmMetadataVersion): LocalFileKotlinClass? {\n", "line_to_complete": "\n            val fileContents = file.readBytes()\n            return FileBasedKotlinClass.create(\n                fileContents,\n                jvmMetadataVersionFromLanguageVersion\n            ) { className, classVersion, classHeader, innerClasses ->\n                LocalFileKotlinClass(file, fileContents, className, classVersion, classHeader, innerClasses)\n            }\n        }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.PsiElementFinder\nimport org.jetbrains.kotlin.asJava.finder.JavaElementFinder\nimport org.jetbrains.kotlin.test.KotlinTestWithEnvironment\n\nabstract class AbstractFirResolveWithSessionTestCase : KotlinTestWithEnvironment() {\noverride fun setUp() {\n", "line_to_complete": "\n        super.setUp()\n\n        prepareProjectExtensions(project)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir\n\nimport com.intellij.openapi.project.Project\nimport com.intellij.psi.PsiElementFinder\nimport org.jetbrains.kotlin.asJava.finder.JavaElementFinder\nimport org.jetbrains.kotlin.test.KotlinTestWithEnvironment\n\nabstract class AbstractFirResolveWithSessionTestCase : KotlinTestWithEnvironment() {\n\n    override fun setUp() {\n        super.setUp()\n\n        prepareProjectExtensions(project)\n    }\nprotected fun prepareProjectExtensions(project: Project) {\n", "line_to_complete": "\n        PsiElementFinder.EP.getPoint(project).unregisterExtension(JavaElementFinder::class.java)\n    }"}
{"context": "// WITH_STDLIB\n// IS_APPLICABLE: false\nfun foo(s: String?) {\n", "line_to_complete": "\n    val <!UNUSED_VARIABLE!>t<!>: String = s.toString()\n}"}
{"context": "// FILE: main.kt\npackage test\n\nimport dependency.component1\nimport dependency.component2\nimport dependency.component3\nfun usage(target: dependency.Target) {\n", "line_to_complete": "\n    val (c1, _) = target\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.resolve.calls.checkers\n\nimport com.intellij.psi.PsiElement\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.diagnostics.Errors\nimport org.jetbrains.kotlin.psi.KtCallableReferenceExpression\nimport org.jetbrains.kotlin.psi.KtDotQualifiedExpression\nimport org.jetbrains.kotlin.psi.KtParenthesizedExpression\nimport org.jetbrains.kotlin.psi.KtReferenceExpression\nimport org.jetbrains.kotlin.resolve.BindingContext\nimport org.jetbrains.kotlin.resolve.calls.context.CallPosition\nimport org.jetbrains.kotlin.resolve.calls.model.ResolvedCall\nimport org.jetbrains.kotlin.resolve.scopes.receivers.ClassQualifier\nimport org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver\nimport org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValue\n\n\nobject CompanionInParenthesesLHSCallChecker : CallChecker {\noverride fun check(resolvedCall: ResolvedCall<*>, reportOn: PsiElement, context: CallCheckerContext) {\n", "line_to_complete": "\n        val callableReference = resolvedCall.call.callElement.parent as? KtCallableReferenceExpression ?: return\n        val parenthesizedExpression = callableReference.lhs as? KtParenthesizedExpression ?: return\n        val unwrappedLhs = parenthesizedExpression.expression ?: return\n        val expressionReceiver = resolvedCall.call.explicitReceiver as? ExpressionReceiver ?: return\n\n        if (!isReferenceToShortFormCompanion(expressionReceiver, unwrappedLhs, context)) return\n\n        context.trace.report(Errors.PARENTHESIZED_COMPANION_LHS_DEPRECATION.on(parenthesizedExpression))\n    }"}
{"context": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE\nclass X<T>\n\ntypealias TopLevelAlias = X<Int>\n\nclass A {\n    typealias NestedLevelAlias = X<String>\nfun check() {\n", "line_to_complete": "\n        typealias LocalTypeAlias = X<String>\n        class LocalClass {\n            typealias NestedLevelAliasInLocalClass = X<String>\n\n            fun check() {\n                typealias LocalTypeAlias = X<String>\n                class LocalClass {\n                    typealias NestedLevelAliasInLocalClass = X<String>\n                    fun check() {\n\n                    }\n                }\n            }\n        }\n    }"}
{"context": "// DO_NOT_CHECK_NON_PSI_SYMBOL_RESTORE\nclass X<T>\n\ntypealias TopLevelAlias = X<Int>\n\nclass A {\n    typealias NestedLevelAlias = X<String>\n    fun check() {\n        typealias LocalTypeAlias = X<String>\n        class LocalClass {\n            typealias NestedLevelAliasInLocalClass = X<String>\nfun check() {\n", "line_to_complete": "\n                typealias LocalTypeAlias = X<String>\n                class LocalClass {\n                    typealias NestedLevelAliasInLocalClass = X<String>\n                    fun check() {\n\n                    }\n                }\n            }"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.low.level.api.fir.diagnostic.compiler.based\n\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.LLFirOnlyReversedTestSuppressor\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.compiler.based.AbstractLowLevelCompilerBasedTest\nimport org.jetbrains.kotlin.analysis.low.level.api.fir.diagnostic.compiler.based.facades.LLFirAnalyzerFacadeFactoryWithPreresolveInReversedOrder\nimport org.jetbrains.kotlin.test.builders.TestConfigurationBuilder\nimport org.jetbrains.kotlin.test.runners.baseFirDiagnosticTestConfiguration\nimport org.jetbrains.kotlin.utils.bind\n\nabstract class AbstractLLFirPreresolvedReversedDiagnosticCompilerTestDataSpecTest : AbstractLowLevelCompilerBasedTest() {\noverride fun configureTest(builder: TestConfigurationBuilder) {\n", "line_to_complete": "\n        with(builder) {\n            baseFirDiagnosticTestConfiguration(\n                frontendFacade = ::LowLevelFirFrontendFacade.bind(LLFirAnalyzerFacadeFactoryWithPreresolveInReversedOrder),\n            )\n\n            baseFirSpecDiagnosticTestConfigurationForIde()\n            useAfterAnalysisCheckers(::LLFirOnlyReversedTestSuppressor)\n            useMetaTestConfigurators(::ReversedDiagnosticsConfigurator)\n            useAfterAnalysisCheckers(::ReversedFirIdenticalChecker)\n        }\n    }"}
{"context": "// FILE: main.kt\npackage test\n\nimport dependency.function\nfun test() {\n", "line_to_complete": "\n    function\n}"}
{"context": "fun <T> run(block: () -> T): T = block()\nfun test(a: Any) {\n", "line_to_complete": "\n    run {\n        // Should be an error, see KT-44810\n        when (a) {\n            is String -> 1\n        }\n    }\n}"}
{"context": "// MODULE: lib\n\n// FILE: some/Outer.kt\npackage some\n\ninterface Flag<T>\n\nclass Outer {\n    val VAL_FLAG: Flag<*> = TODO()\n    var varFlag: Flag<*> = TODO()\n\n    object O {\n        val VAL_FLAG: Flag<*> = TODO()\n        var varFlag: Flag<*> = TODO()\n    }\n}\n\n// MODULE: app(lib)\n// MODULE_KIND: Source\n// FILE: main.kt\npackage some\n\nprivate fun consumeFlag(p: Flag<*>) {\n", "line_to_complete": "\n    println(p)\n}"}
{"context": "// MODULE: lib\n\n// FILE: some/Outer.kt\npackage some\n\ninterface Flag<T>\n\nclass Outer {\n    val VAL_FLAG: Flag<*> = TODO()\n    var varFlag: Flag<*> = TODO()\n\n    object O {\n        val VAL_FLAG: Flag<*> = TODO()\n        var varFlag: Flag<*> = TODO()\n    }\n}\n\n// MODULE: app(lib)\n// MODULE_KIND: Source\n// FILE: main.kt\n\npackage some\n\nprivate fun consumeFlag(p: Flag<*>) {\n    println(p)\n}\nfun test() {\n", "line_to_complete": "\n    val o = Outer()\n    consumeFlag(o.VAL_FLAG)\n    consumeFlag(o.varFlag)\n    consumeFlag(Outer.O.VAL_FLAG)\n    consumeFlag(Outer.O.var<caret>Flag)\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.decompiled.light.classes.fe10\n\nimport com.intellij.psi.PsiMember\nimport org.jetbrains.kotlin.analysis.decompiled.light.classes.origin.KotlinDeclarationInCompiledFileSearcher\nimport org.jetbrains.kotlin.analysis.decompiler.psi.file.KtClsFile\nimport org.jetbrains.kotlin.load.kotlin.MemberSignature\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.psi.KtDeclaration\n\nclass KotlinDeclarationInCompiledFileSearcherFE10Impl : KotlinDeclarationInCompiledFileSearcher() {\noverride fun findDeclarationInCompiledFile(file: KtClsFile, member: PsiMember, signature: MemberSignature): KtDeclaration? {\n", "line_to_complete": "\n        val relativeClassName = generateSequence(member.containingClass) { it.containingClass }.toList().dropLast(1).reversed()\n            .map { Name.identifier(it.name!!) }\n\n        val memberName = member.name ?: return null\n        return findByStubs(file, relativeClassName, member, memberName)\n    }"}
{"context": "interface I1 {\n    fun foo(x: Int = 1)\n}\n\ninterface I2 {\n    fun bar(x: String = \"\", y: Int)\n}\n\nclass A : I1, I2 {\n    override fun foo(x: Int) {}\n    override fun bar(x: String, y: Int) {}\n}\nfun foo(a: A) {\n", "line_to_complete": "\n    a.foo()\n    a.foo(1)\n\n    a.bar<!NO_VALUE_FOR_PARAMETER!>()<!>\n    a.bar(<!NO_VALUE_FOR_PARAMETER!>\"\")<!>\n    a.bar(y = 1)\n    a.bar(\"\", 2)\n}"}
{"context": "class A\nfun test(a: A, b: A) {\n", "line_to_complete": "\n    <expr>a ?: b</expr>\n}"}
{"context": "\n\n// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.\n// DO NOT MODIFY IT MANUALLY.\n\n@file:Suppress(\"DuplicatedCode\", \"unused\")\n\npackage org.jetbrains.kotlin.fir.contracts.builder\n\nimport kotlin.contracts.*\nimport org.jetbrains.kotlin.KtSourceElement\nimport org.jetbrains.kotlin.fir.builder.FirBuilderDsl\nimport org.jetbrains.kotlin.fir.contracts.FirContractElementDeclaration\nimport org.jetbrains.kotlin.fir.contracts.description.ConeContractDescriptionElement\nimport org.jetbrains.kotlin.fir.contracts.impl.FirContractElementDeclarationImpl\n\n@FirBuilderDsl\nclass FirContractElementDeclarationBuilder {\n    var source: KtSourceElement? = null\n    lateinit var effect: ConeContractDescriptionElement\nfun build(): FirContractElementDeclaration {\n", "line_to_complete": "\n        return FirContractElementDeclarationImpl(\n            source,\n            effect,\n        )\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.utils.Printer\n\nopen class FirPrinter(builder: StringBuilder) {\n    private val printer = Printer(builder)\n\n    private var lineBeginning = true\nfun print(vararg objects: Any) {\n", "line_to_complete": "\n        if (lineBeginning) {\n            lineBeginning = false\n            printer.print(*objects)\n        } else {\n            printer.printWithNoIndent(*objects)\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.utils.Printer\n\nopen class FirPrinter(builder: StringBuilder) {\n    private val printer = Printer(builder)\n\n    private var lineBeginning = true\n\n    fun print(vararg objects: Any) {\n        if (lineBeginning) {\n            lineBeginning = false\n            printer.print(*objects)\n        } else {\n            printer.printWithNoIndent(*objects)\n        }\n    }\nfun println(vararg objects: Any) {\n", "line_to_complete": "\n        print(*objects)\n        printer.printlnWithNoIndent()\n        lineBeginning = true\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.utils.Printer\n\nopen class FirPrinter(builder: StringBuilder) {\n    private val printer = Printer(builder)\n\n    private var lineBeginning = true\n\n    fun print(vararg objects: Any) {\n        if (lineBeginning) {\n            lineBeginning = false\n            printer.print(*objects)\n        } else {\n            printer.printWithNoIndent(*objects)\n        }\n    }\n\n    fun println(vararg objects: Any) {\n        print(*objects)\n        printer.printlnWithNoIndent()\n        lineBeginning = true\n    }\ninternal fun pushIndent() {\n", "line_to_complete": "\n        printer.pushIndent()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.utils.Printer\n\nopen class FirPrinter(builder: StringBuilder) {\n    private val printer = Printer(builder)\n\n    private var lineBeginning = true\n\n    fun print(vararg objects: Any) {\n        if (lineBeginning) {\n            lineBeginning = false\n            printer.print(*objects)\n        } else {\n            printer.printWithNoIndent(*objects)\n        }\n    }\n\n    fun println(vararg objects: Any) {\n        print(*objects)\n        printer.printlnWithNoIndent()\n        lineBeginning = true\n    }\n\n    internal fun pushIndent() {\n        printer.pushIndent()\n    }\ninternal fun popIndent() {\n", "line_to_complete": "\n        printer.popIndent()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.utils.Printer\n\nopen class FirPrinter(builder: StringBuilder) {\n    private val printer = Printer(builder)\n\n    private var lineBeginning = true\n\n    fun print(vararg objects: Any) {\n        if (lineBeginning) {\n            lineBeginning = false\n            printer.print(*objects)\n        } else {\n            printer.printWithNoIndent(*objects)\n        }\n    }\n\n    fun println(vararg objects: Any) {\n        print(*objects)\n        printer.printlnWithNoIndent()\n        lineBeginning = true\n    }\n\n    internal fun pushIndent() {\n        printer.pushIndent()\n    }\n\n    internal fun popIndent() {\n        printer.popIndent()\n    }\nfun newLine() {\n", "line_to_complete": "\n        println()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport org.jetbrains.kotlin.utils.Printer\n\nopen class FirPrinter(builder: StringBuilder) {\n    private val printer = Printer(builder)\n\n    private var lineBeginning = true\n\n    fun print(vararg objects: Any) {\n        if (lineBeginning) {\n            lineBeginning = false\n            printer.print(*objects)\n        } else {\n            printer.printWithNoIndent(*objects)\n        }\n    }\n\n    fun println(vararg objects: Any) {\n        print(*objects)\n        printer.printlnWithNoIndent()\n        lineBeginning = true\n    }\n\n    internal fun pushIndent() {\n        printer.pushIndent()\n    }\n\n    internal fun popIndent() {\n        printer.popIndent()\n    }\n\n    fun newLine() {\n        println()\n    }\nfun renderInBraces(leftBrace: String = \" {\n", "line_to_complete": "\", rightBrace: String = \"}"}
{"context": "// !OPT_IN: kotlin.RequiresOptIn\nimport kotlin.contracts.*\n\n@OptIn(ExperimentalContracts::class)\nfun testAlwaysNotNull(x: String?): Any? {\n", "line_to_complete": "\n    contract {\n        returnsNotNull() implies (x is String && <!SENSELESS_COMPARISON!>x != null<!>)\n    }\n\n    return x\n}"}
{"context": "// !OPT_IN: kotlin.RequiresOptIn\nimport kotlin.contracts.*\n\n@OptIn(ExperimentalContracts::class)\nfun testAlwaysNotNull(x: String?): Any? {\n    contract {\n        returnsNotNull() implies (x is String && <!SENSELESS_COMPARISON!>x != null<!>)\n    }\n\n    return x\n}\n\n@OptIn(ExperimentalContracts::class)\nfun testAlwaysAny(x: String?): Any? {\n", "line_to_complete": "\n    contract {\n        returnsNotNull() implies (<!USELESS_IS_CHECK!>x is String?<!> || <!USELESS_IS_CHECK!>x is Any?<!>)\n    }\n\n    return x\n}"}
{"context": "// ISSUE: KT-42449\n\ndata class NodePropertyDescriptor<TNode : Node, TProperty : Any, TPropertyVal : TProperty?>(\n    val description: String,\n    val propertyRef: NodePropertyRef<TNode, TProperty, TPropertyVal>,\n) {\nfun test_1(other: Any?): Boolean {\n", "line_to_complete": "\n        if (other !is NodePropertyDescriptor<*, *, *>) return false\n        if (description != other.description) return false\n        if (propertyRef != other.propertyRef) return false\n        return true\n    }"}
{"context": "// ISSUE: KT-42449\n\ndata class NodePropertyDescriptor<TNode : Node, TProperty : Any, TPropertyVal : TProperty?>(\n    val description: String,\n    val propertyRef: NodePropertyRef<TNode, TProperty, TPropertyVal>,\n) {\n    fun test_1(other: Any?): Boolean {\n        if (other !is NodePropertyDescriptor<*, *, *>) return false\n        if (description != other.description) return false\n        if (propertyRef != other.propertyRef) return false\n        return true\n    }\nfun test_2(other: Any?): Boolean {\n", "line_to_complete": "\n        if (other !is NodePropertyDescriptor<*, *, *>) return false\n        if (<!USELESS_IS_CHECK!>other is NodePropertyDescriptor<*, *, *><!>) {\n            if (description != other.description) return false\n            if (propertyRef != other.propertyRef) return false\n        }\n        return true\n    }"}
{"context": "// ISSUE: KT-42449\n\ndata class NodePropertyDescriptor<TNode : Node, TProperty : Any, TPropertyVal : TProperty?>(\n    val description: String,\n    val propertyRef: NodePropertyRef<TNode, TProperty, TPropertyVal>,\n) {\n    fun test_1(other: Any?): Boolean {\n        if (other !is NodePropertyDescriptor<*, *, *>) return false\n        if (description != other.description) return false\n        if (propertyRef != other.propertyRef) return false\n        return true\n    }\n\n    fun test_2(other: Any?): Boolean {\n        if (other !is NodePropertyDescriptor<*, *, *>) return false\n        if (<!USELESS_IS_CHECK!>other is NodePropertyDescriptor<*, *, *><!>) {\n            if (description != other.description) return false\n            if (propertyRef != other.propertyRef) return false\n        }\n        return true\n    }\nfun test_3(other: Any?): Boolean {\n", "line_to_complete": "\n        if (other is NodePropertyDescriptor<*, *, *>) {\n            if (description != other.description) return false\n            if (propertyRef != other.propertyRef) return false\n        }\n        return true\n    }"}
{"context": "data class D(val x: Int, val y: String)\nfun foo(list: List<D>) {\n", "line_to_complete": "\n    for ((x, y) in list) {\n    }\n    val (x, y) = list.first()\n    list.forEach { (x, y) ->\n        println(x)\n        println(y)\n    }\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.renderer\n\nimport org.jetbrains.kotlin.builtins.StandardNames\nimport org.jetbrains.kotlin.fir.types.ConeDefinitelyNotNullType\nimport org.jetbrains.kotlin.fir.types.ConeFlexibleType\nimport org.jetbrains.kotlin.fir.types.ConeIntegerLiteralType\nimport org.jetbrains.kotlin.fir.types.ConeKotlinType\nimport org.jetbrains.kotlin.renderer.replacePrefixesInTypeRepresentations\nimport org.jetbrains.kotlin.renderer.typeStringsDifferOnlyInNullability\nimport org.jetbrains.kotlin.utils.addToStdlib.applyIf\n\nclass ConeTypeRendererForReadability(\n    private val idRendererCreator: () -> ConeIdRenderer,\n) : ConeTypeRenderer(ConeAttributeRenderer.ForReadability) {\n    constructor(builder: StringBuilder, idRendererCreator: () -> ConeIdRenderer) : this(idRendererCreator) {\n        this.builder = builder\n        this.idRenderer = idRendererCreator()\n        idRenderer.builder = builder\n    }\noverride fun render(flexibleType: ConeFlexibleType) {\n", "line_to_complete": "\n        val lower = flexibleType.lowerBound\n\n        val lowerRendered = renderBound(lower)\n        val upperRendered = renderBound(flexibleType.upperBound)\n\n        val rendered =\n            renderFlexibleTypeCompact(lowerRendered, upperRendered)\n                ?: run {\n                    if (lower is ConeDefinitelyNotNullType) {\n                        renderFlexibleTypeCompact(renderBound(lower.original), upperRendered)\n                    } else null\n                }\n                ?: \"($lowerRendered..$upperRendered)\"\n\n        builder.append(rendered)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.benchmarks\n\nimport org.openjdk.jmh.annotations.*\nimport org.openjdk.jmh.infra.Blackhole\nimport java.util.concurrent.TimeUnit\n\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class InferenceFromReturnTypeCallsBenchmark : AbstractInferenceBenchmark() {\n\n    @Param(\"1\", \"10\", \"100\", \"1000\", \"5000\", \"10000\")\n    private var size: Int = 0\n\n    @Benchmark\nfun benchmark(bh: Blackhole) {\n", "line_to_complete": "\n        analyzeGreenFile(bh)\n    }"}
{"context": "// LANGUAGE: +ContextReceivers\n\n// MODULE: context\n\n// FILE: context.kt\nfun test() {\n", "line_to_complete": "\n    with(Foo()) {\n        call()\n    }\n}"}
{"context": "// LANGUAGE: +ContextReceivers\n\n// MODULE: context\n\n// FILE: context.kt\nfun test() {\n    with(Foo()) {\n        call()\n    }\n}\n\ncontext(Foo)\nfun call() {\n", "line_to_complete": "\n    <caret_context>val x = 0\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.analysis.jvm.checkers.declaration\n\nimport org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.declaration.FirPropertyChecker\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.jvm.FirJvmErrors\nimport org.jetbrains.kotlin.fir.declarations.FirProperty\nimport org.jetbrains.kotlin.fir.declarations.getAnnotationByClassId\nimport org.jetbrains.kotlin.name.JvmStandardClassIds.JVM_SYNTHETIC_ANNOTATION_CLASS_ID\n\nobject FirJvmSyntheticApplicabilityChecker : FirPropertyChecker(MppCheckerKind.Common) {\noverride fun check(declaration: FirProperty, context: CheckerContext, reporter: DiagnosticReporter) {\n", "line_to_complete": "\n        val annotation = declaration.backingField?.getAnnotationByClassId(JVM_SYNTHETIC_ANNOTATION_CLASS_ID, context.session)\n        if (annotation != null && annotation.useSiteTarget == AnnotationUseSiteTarget.PROPERTY_DELEGATE_FIELD) {\n            reporter.reportOn(annotation.source, FirJvmErrors.JVM_SYNTHETIC_ON_DELEGATE, context)\n        }\n    }"}
{"context": "operator fun Int.set(index: Int, value: Int) = value\nfun f() {\n", "line_to_complete": "\n    1<caret>[2] = 42\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.analysis.jvm.checkers.declaration\n\nimport org.jetbrains.kotlin.diagnostics.DiagnosticReporter\nimport org.jetbrains.kotlin.diagnostics.reportOn\nimport org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind\nimport org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\nimport org.jetbrains.kotlin.fir.analysis.checkers.declaration.FirRegularClassChecker\nimport org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\nimport org.jetbrains.kotlin.fir.declarations.FirRegularClass\nimport org.jetbrains.kotlin.fir.declarations.utils.classId\nimport org.jetbrains.kotlin.fir.java.javaSymbolProvider\n\nobject FirJvmConflictsChecker : FirRegularClassChecker(MppCheckerKind.Common) {\noverride fun check(declaration: FirRegularClass, context: CheckerContext, reporter: DiagnosticReporter) {\n", "line_to_complete": "\n        val javaSymbol = context.session.javaSymbolProvider?.getClassLikeSymbolByClassId(declaration.classId) ?: return\n        reporter.reportOn(\n            declaration.source, FirErrors.PACKAGE_OR_CLASSIFIER_REDECLARATION, listOf(declaration.symbol, javaSymbol), context\n        )\n    }"}
{"context": "fun interface MySam {\n    fun run(x: String): Int\n}\n\nclass A {\nfun bar(x: String): Int {\n", "line_to_complete": "<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}"}
{"context": "fun interface MySam {\n    fun run(x: String): Int\n}\n\nclass A {\n    fun bar(x: String): Int {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n}\n\nfun foo(x: MySam) {}\nfun main() {\n", "line_to_complete": "\n    val a = A()\n    foo(a::bar)\n}"}
{"context": "// NO_RUNTIME\nfun call() {\n", "line_to_complete": "\n    <expr>1 == 2</expr>\n}"}
{"context": "package Jet87\n\nopen class A() {\n  fun foo() : Int = 1\n}\n\ninterface B {\n  fun bar() : Double = 1.0;\n}\n\ninterface G<X> {\n    val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>X<!>> boo: Double  where X : A, X : B\n    val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>A<!>> bal: Double  where A : B\n    val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>Y<!>> bas: Double where Y : B, <!NAME_IN_CONSTRAINT_IS_NOT_A_TYPE_PARAMETER!>X<!> : B\n}\n\nclass C() : A(), B\n\nclass D() {\n  companion object : A(), B {}\n}\n\nclass Test1<T>()\n  where\n    T : A,\n    T : B,\n    <!NAME_IN_CONSTRAINT_IS_NOT_A_TYPE_PARAMETER!>B<!> : T // error\n  {\nfun test(t : T) {\n", "line_to_complete": "\n    <!TYPE_PARAMETER_ON_LHS_OF_DOT!>T<!>.<!UNRESOLVED_REFERENCE!>foo<!>()\n    <!TYPE_PARAMETER_ON_LHS_OF_DOT!>T<!>.<!UNRESOLVED_REFERENCE!>bar<!>()\n    t.foo()\n    t.bar()\n  }"}
{"context": "package Jet87\n\nopen class A() {\n  fun foo() : Int = 1\n}\n\ninterface B {\n  fun bar() : Double = 1.0;\n}\n\ninterface G<X> {\n    val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>X<!>> boo: Double  where X : A, X : B\n    val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>A<!>> bal: Double  where A : B\n    val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>Y<!>> bas: Double where Y : B, <!NAME_IN_CONSTRAINT_IS_NOT_A_TYPE_PARAMETER!>X<!> : B\n}\n\nclass C() : A(), B\n\nclass D() {\n  companion object : A(), B {}\n}\n\nclass Test1<T>()\n  where\n    T : A,\n    T : B,\n    <!NAME_IN_CONSTRAINT_IS_NOT_A_TYPE_PARAMETER!>B<!> : T // error\n  {\n\n  fun test(t : T) {\n    <!TYPE_PARAMETER_ON_LHS_OF_DOT!>T<!>.<!UNRESOLVED_REFERENCE!>foo<!>()\n    <!TYPE_PARAMETER_ON_LHS_OF_DOT!>T<!>.<!UNRESOLVED_REFERENCE!>bar<!>()\n    t.foo()\n    t.bar()\n  }\n}\nfun test() {\n", "line_to_complete": "\n  Test1<<!UPPER_BOUND_VIOLATED!>B<!>>()\n  Test1<<!UPPER_BOUND_VIOLATED!>A<!>>()\n  Test1<C>()\n}"}
{"context": "// ISSUE: KT-38031\n\n// FILE: W.java\npublic class W {\n    public static class E {\n        public static String w = \"\";\n    }\n\n    public static String E() {return \"\";}\n\n    public static final String E = \"\";\n}\n\n// FILE: main.kt\nfun main() {\n", "line_to_complete": "\n    W.<!OVERLOAD_RESOLUTION_AMBIGUITY!>E<!>().<!UNRESOLVED_REFERENCE!>length<!> // ambiguity in both FIR / old FE\n    W.E.<!UNRESOLVED_REFERENCE!>length<!> // resolved with error to the class W.E in FIR and old FE\n    W.E.w // resolved to static field W.e.W in FE\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.resolve.calls\n\nimport org.jetbrains.kotlin.util.PrivateForInline\nimport kotlin.coroutines.Continuation\n\nabstract class CheckerSink {\n    abstract fun reportDiagnostic(diagnostic: ResolutionDiagnostic)\n\n    abstract val needYielding: Boolean\n\n    @PrivateForInline\n    abstract suspend fun yield()\n}\n\n@OptIn(PrivateForInline::class)\nsuspend inline fun CheckerSink.yieldIfNeed() {\n    if (needYielding) {\n        yield()\n    }\n}\n\nsuspend inline fun CheckerSink.yieldDiagnostic(diagnostic: ResolutionDiagnostic) {\n    reportDiagnostic(diagnostic)\n    yieldIfNeed()\n}\n\nclass CheckerSinkImpl(\n    private val candidate: Candidate,\n    var continuation: Continuation<Unit>? = null,\n    val stopOnFirstError: Boolean = true,\n) : CheckerSink() {\noverride fun reportDiagnostic(diagnostic: ResolutionDiagnostic) {\n", "line_to_complete": "\n        candidate.addDiagnostic(diagnostic)\n    }"}
{"context": "// !DUMP_CFG\n\nimport kotlin.contracts.*\n\n@OptIn(ExperimentalContracts::class)\ninline fun inlineRun(block: () -> Unit) {\n", "line_to_complete": "\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    block()\n}"}
{"context": "// !DUMP_CFG\n\nimport kotlin.contracts.*\n\n@OptIn(ExperimentalContracts::class)\ninline fun inlineRun(block: () -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    block()\n}\n\n@OptIn(ExperimentalContracts::class)\nfun myRun(block: () -> Unit) {\n", "line_to_complete": "\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    block()\n}"}
{"context": "// !DUMP_CFG\n\nimport kotlin.contracts.*\n\n@OptIn(ExperimentalContracts::class)\ninline fun inlineRun(block: () -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    block()\n}\n\n@OptIn(ExperimentalContracts::class)\nfun myRun(block: () -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    block()\n}\nfun test_1() {\n", "line_to_complete": "\n    val x: Int\n    inlineRun {\n        <!VAL_REASSIGNMENT!>x<!> = 1\n    }\n    x.inc()\n}"}
{"context": "// !DUMP_CFG\n\nimport kotlin.contracts.*\n\n@OptIn(ExperimentalContracts::class)\ninline fun inlineRun(block: () -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    block()\n}\n\n@OptIn(ExperimentalContracts::class)\nfun myRun(block: () -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    block()\n}\n\nfun test_1() {\n    val x: Int\n    inlineRun {\n        <!VAL_REASSIGNMENT!>x<!> = 1\n    }\n    x.inc()\n}\nfun test_2() {\n", "line_to_complete": "\n    val x: Int\n    myRun {\n        <!VAL_REASSIGNMENT!>x<!> = 1\n    }\n    x.inc()\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.resolve.jvm\n\nimport org.jetbrains.kotlin.config.LanguageFeature\nimport org.jetbrains.kotlin.config.LanguageVersionSettings\nimport org.jetbrains.kotlin.descriptors.CallableDescriptor\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.PropertyDescriptor\nimport org.jetbrains.kotlin.load.java.lazy.descriptors.isJavaField\nimport org.jetbrains.kotlin.resolve.DescriptorEquivalenceForOverrides\nimport org.jetbrains.kotlin.resolve.calls.results.PlatformOverloadsSpecificityComparator\n\nclass JvmPlatformOverloadsSpecificityComparator(\n    val languageVersionSettings: LanguageVersionSettings\n) : PlatformOverloadsSpecificityComparator {\noverride fun isMoreSpecificShape(specific: CallableDescriptor, general: CallableDescriptor): Boolean {\n", "line_to_complete": "\n        if (specific !is PropertyDescriptor || general !is PropertyDescriptor) return false\n\n        if (specific.dispatchReceiverParameter == null || general.dispatchReceiverParameter == null) return false\n        if (specific.containingDeclaration !is ClassDescriptor) return false\n        if (!DescriptorEquivalenceForOverrides\n                .areEquivalent(specific.containingDeclaration, general.containingDeclaration, allowCopiesFromTheSameDeclaration = true)\n        ) return false\n\n        if (!languageVersionSettings.supportsFeature(LanguageFeature.PreferJavaFieldOverload)) return false\n\n        return specific.isJavaField && !general.isJavaField\n    }"}
{"context": "// WITH_STDLIB\nfun foo() {\n", "line_to_complete": "\n    for (i in 1..2) { }\n\n    val <!UNUSED_VARIABLE!>a<!> = 3..4\n\n    val v = 1\n    if (v in 5..6) { }\n}"}
{"context": "// WITH_STDLIB\n\nfun foo() {\n    for (i in 1..2) { }\n\n    val <!UNUSED_VARIABLE!>a<!> = 3..4\n\n    val v = 1\n    if (v in 5..6) { }\n}\nfun backward() {\n", "line_to_complete": "\n    for (i in 2 downTo 1) { }\n\n    val <!UNUSED_VARIABLE!>a<!> = 4 downTo 3\n\n    val v = 1\n    if (v in -5 downTo -6) { }\n}"}
{"context": "// WITH_STDLIB\n\nfun foo() {\n    for (i in 1..2) { }\n\n    val <!UNUSED_VARIABLE!>a<!> = 3..4\n\n    val v = 1\n    if (v in 5..6) { }\n}\n\n\nfun backward() {\n    for (i in 2 downTo 1) { }\n\n    val <!UNUSED_VARIABLE!>a<!> = 4 downTo 3\n\n    val v = 1\n    if (v in -5 downTo -6) { }\n}\nfun until() {\n", "line_to_complete": "\n    for (i in 1 until 2) { }\n\n    val <!UNUSED_VARIABLE!>a<!> = 3 until 4\n\n    val v = 1\n    if (v in -5 until -4) { }\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen.intrinsics\n\nimport org.jetbrains.kotlin.codegen.Callable\nimport org.jetbrains.kotlin.codegen.CallableMethod\nimport org.jetbrains.kotlin.name.FqName\n\nobject ArrayConstructor : IntrinsicMethod() {\noverride fun toCallable(method: CallableMethod): Callable {\n", "line_to_complete": "\n        return object : IntrinsicCallable(method.owner, method.valueParameterTypes, null, null) {}\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.resolve.calls\n\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.declarations.*\nimport org.jetbrains.kotlin.fir.declarations.utils.isExpect\nimport org.jetbrains.kotlin.fir.resolve.inference.inferenceComponents\nimport org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirFunctionSymbol\nimport org.jetbrains.kotlin.fir.types.coneType\nimport org.jetbrains.kotlin.resolve.calls.results.*\nimport org.jetbrains.kotlin.types.model.KotlinTypeMarker\n\nclass FirDeclarationOverloadabilityHelperImpl(val session: FirSession) : FirDeclarationOverloadabilityHelper {\noverride fun isOverloadable(a: FirCallableSymbol<*>, b: FirCallableSymbol<*>): Boolean {\n", "line_to_complete": "\n        val sigA = createSignature(a)\n        val sigB = createSignature(b)\n\n        return !(isNotLessSpecific(sigA, sigB) && isNotLessSpecific(sigB, sigA))\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.checkers.generator\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport java.io.File\nimport kotlin.reflect.KClass\n\nclass CheckersConfigurator {\n    private val registeredAliases: MutableMap<KClass<*>, String> = LinkedHashMap()\n    private val additionalCheckers: MutableMap<String, String> = LinkedHashMap()\n\n    inline fun <reified T : FirElement> alias(name: String) {\n        alias(T::class, name)\n    }\nfun alias(kClass: KClass<out FirElement>, name: String) {\n", "line_to_complete": "\n        val realName = name.takeIf { it.startsWith(\"Fir\") } ?: \"Fir$name\"\n        registeredAliases[kClass] = realName\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.checkers.generator\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport java.io.File\nimport kotlin.reflect.KClass\n\nclass CheckersConfigurator {\n    private val registeredAliases: MutableMap<KClass<*>, String> = LinkedHashMap()\n    private val additionalCheckers: MutableMap<String, String> = LinkedHashMap()\n\n    inline fun <reified T : FirElement> alias(name: String) {\n        alias(T::class, name)\n    }\n\n    fun alias(kClass: KClass<out FirElement>, name: String) {\n        val realName = name.takeIf { it.startsWith(\"Fir\") } ?: \"Fir$name\"\n        registeredAliases[kClass] = realName\n    }\nfun additional(fieldName: String, classFqn: String) {\n", "line_to_complete": "\n        additionalCheckers[fieldName] = classFqn\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.fir.checkers.generator\n\nimport org.jetbrains.kotlin.fir.FirElement\nimport java.io.File\nimport kotlin.reflect.KClass\n\nclass CheckersConfigurator {\n    private val registeredAliases: MutableMap<KClass<*>, String> = LinkedHashMap()\n    private val additionalCheckers: MutableMap<String, String> = LinkedHashMap()\n\n    inline fun <reified T : FirElement> alias(name: String) {\n        alias(T::class, name)\n    }\n\n    fun alias(kClass: KClass<out FirElement>, name: String) {\n        val realName = name.takeIf { it.startsWith(\"Fir\") } ?: \"Fir$name\"\n        registeredAliases[kClass] = realName\n    }\n\n    fun additional(fieldName: String, classFqn: String) {\n        additionalCheckers[fieldName] = classFqn\n    }\nfun build(): CheckersConfiguration {\n", "line_to_complete": "\n        return CheckersConfiguration(registeredAliases, additionalCheckers)\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.storage\n\nimport com.intellij.ide.util.PropertiesComponent\nimport com.intellij.openapi.util.ModificationTracker\nimport org.jetbrains.kotlin.util.ReenteringLazyValueComputationException\nimport org.jetbrains.kotlin.utils.isProcessCanceledException\nimport org.jetbrains.kotlin.utils.rethrow\nimport java.util.concurrent.atomic.AtomicLong\n\nopen class ExceptionTracker : ModificationTracker, LockBasedStorageManager.ExceptionHandlingStrategy {\n    private val cancelledTracker: AtomicLong = AtomicLong()\noverride fun handleException(throwable: Throwable): RuntimeException {\n", "line_to_complete": "\n        // should not increment counter when ReenteringLazyValueComputationException is thrown since it implements correct frontend behaviour\n        if (throwable !is ReenteringLazyValueComputationException) {\n            if (!throwable.isProcessCanceledException() || CacheResetOnProcessCanceled.enabled) {\n                incCounter()\n            }\n        }\n        throw rethrow(throwable)\n    }"}
{"context": "\n\nopen class A {\n    open fun foo(): A = this\n    open fun bar(): A = this\n    open fun buz(p: A): A = this\n}\n\nclass B : A() {\n    override fun foo(): B = this\n    fun <!VIRTUAL_MEMBER_HIDDEN!>bar<!>(): B = this // Missing 'override'\n    <!NOTHING_TO_OVERRIDE!>override<!> fun buz(p: B): B = this //No override as B not :> A\nfun test() {\n", "line_to_complete": "\n        foo()\n        bar()\n        <!NONE_APPLICABLE!>buz<!>()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.benchmarks\n\nimport org.openjdk.jmh.annotations.*\nimport org.openjdk.jmh.infra.Blackhole\nimport java.util.concurrent.TimeUnit\n\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class SimpleDataFlowBenchmark : AbstractSimpleFileBenchmark(){\n\n    @Param(\"1\", \"100\", \"1000\", \"3000\", \"5000\", \"7000\", \"10000\")\n    private var size: Int = 0\n\n    @Benchmark\nfun benchmark(bh: Blackhole) {\n", "line_to_complete": "\n        analyzeGreenFile(bh)\n    }"}
{"context": "// FILE: call.kt\nfun call() {\n", "line_to_complete": "\n    val javaClass = JavaClass()\n    javaClass.<expr>sub</expr>.foo = 42\n}"}
{"context": "sealed class Foo {\n    object A : Foo()\n    class B(val i: Int) : Foo()\n}\nfun test(e: Foo?) {\n", "line_to_complete": "\n    <caret>when (e) {\n    }\n}"}
{"context": "fun run(block: () -> Unit) {}\nfun test(b1: Boolean, b2: Boolean) {\n", "line_to_complete": "\n    var result = false\n    run {\n        if (b1)\n            if (b2)\n                result = true\n    }\n}"}
{"context": "// IGNORE_FE10\n\n// MODULE: context\n\ninterface MyList {\n    operator fun get(index: Int): String\n    operator fun set(index: Int, value: String)\n}\n\n// FILE: context.kt\nfun test(list: MyList) {\n", "line_to_complete": "\n    <caret_context>Unit\n}"}
{"context": "// FILE: main.kt\npackage foo.www.ddd\n\nclass Check {\n    class BBD {\n        class Bwd {\nfun dad() {\n", "line_to_complete": "\n                val Bwd = 42\n\n                val BBD = 3\n\n                val a = <expr>foo.www.ddd.Check.BBD.Bwd::class.java.annotatedInterfaces.size</expr>\n            }"}
{"context": "// ISSUE: KT-36057\n\nfun String.foo() {}\nfun test_1(a: Any?) {\n", "line_to_complete": "\n    when (a) {\n        is String, is Any -> a.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>() // Should be Bad\n    }\n}"}
{"context": "// ISSUE: KT-36057\n\nfun String.foo() {}\n\nfun test_1(a: Any?) {\n    when (a) {\n        is String, is Any -> a.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>() // Should be Bad\n    }\n}\nfun test_2(a: Any?) {\n", "line_to_complete": "\n    if (a is String || a is Any) {\n        a.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>() // Should be Bad\n    }\n}"}
{"context": "// ISSUE: KT-36057\n\nfun String.foo() {}\n\nfun test_1(a: Any?) {\n    when (a) {\n        is String, is Any -> a.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>() // Should be Bad\n    }\n}\n\nfun test_2(a: Any?) {\n    if (a is String || a is Any) {\n        a.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>() // Should be Bad\n    }\n}\nfun test_3(a: Any?, b: Boolean) {\n", "line_to_complete": "\n    when (a) {\n        is String, b -> a.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>() // Should be Bad\n    }\n}"}
{"context": "// ISSUE: KT-36057\n\nfun String.foo() {}\n\nfun test_1(a: Any?) {\n    when (a) {\n        is String, is Any -> a.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>() // Should be Bad\n    }\n}\n\nfun test_2(a: Any?) {\n    if (a is String || a is Any) {\n        a.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>() // Should be Bad\n    }\n}\n\nfun test_3(a: Any?, b: Boolean) {\n    when (a) {\n        is String, b -> a.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>() // Should be Bad\n    }\n}\nfun test_4(a: Any?, b: Boolean) {\n", "line_to_complete": "\n    if (a is String || b) {\n        a.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>() // Should be Bad\n    }\n}"}
{"context": "// LANGUAGE: +ContextSensitiveEnumResolutionInWhen\nenum class Some {\n    FIRST,\n    SECOND;\n}\nfun foo(s: Some) = when (s) {\n", "line_to_complete": "\n    FIRST -> <!UNRESOLVED_REFERENCE!>SECOND<!>\n    SECOND -> <!UNRESOLVED_REFERENCE!>FIRST<!>\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.daemon\n\nimport org.jetbrains.kotlin.daemon.common.*\nimport org.jetbrains.kotlin.progress.CompilationCanceledException\nimport org.jetbrains.kotlin.progress.CompilationCanceledStatus\nimport java.util.concurrent.TimeUnit\nimport java.util.logging.Logger\n\nval CANCELED_STATUS_CHECK_THRESHOLD_NS = TimeUnit.MILLISECONDS.toNanos(100)\n\nclass RemoteCompilationCanceledStatusClient(\n    @Suppress(\"DEPRECATION\") val facade: CompilerCallbackServicesFacade,\n    val profiler: Profiler = DummyProfiler()\n): CompilationCanceledStatus {\n\n    private val log by lazy { Logger.getLogger(\"compiler\") }\n\n    @Volatile var lastChecked: Long = System.nanoTime()\n\n    override fun checkCanceled() {\nfun cancelOnError(e: Exception) {\n", "line_to_complete": "\n            log.warning(\"error communicating with host, assuming compilation canceled (${e.message})\")\n            throw CompilationCanceledException()\n        }"}
{"context": "open class A {\n    open fun foo() {}\n}\n\nclass B : A() {\nfun bar() {\n", "line_to_complete": "\n        foo()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen.intrinsics\n\nimport org.jetbrains.kotlin.codegen.Callable\nimport org.jetbrains.kotlin.codegen.CallableMethod\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes.OBJECT_TYPE\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\n\nclass MonitorInstruction private constructor(private val opcode: Int) : IntrinsicMethod() {\n    companion object {\n        @JvmField\n        val MONITOR_ENTER: MonitorInstruction = MonitorInstruction(Opcodes.MONITORENTER)\n\n        @JvmField\n        val MONITOR_EXIT: MonitorInstruction = MonitorInstruction(Opcodes.MONITOREXIT)\n    }\noverride fun toCallable(method: CallableMethod): Callable {\n", "line_to_complete": "\n        return object : IntrinsicCallable(Type.VOID_TYPE, listOf(OBJECT_TYPE), null, null) {\n            override fun invokeIntrinsic(v: InstructionAdapter) {\n                v.visitInsn(opcode)\n            }\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.codegen.intrinsics\n\nimport org.jetbrains.kotlin.codegen.Callable\nimport org.jetbrains.kotlin.codegen.CallableMethod\nimport org.jetbrains.kotlin.resolve.jvm.AsmTypes.OBJECT_TYPE\nimport org.jetbrains.org.objectweb.asm.Opcodes\nimport org.jetbrains.org.objectweb.asm.Type\nimport org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\n\nclass MonitorInstruction private constructor(private val opcode: Int) : IntrinsicMethod() {\n    companion object {\n        @JvmField\n        val MONITOR_ENTER: MonitorInstruction = MonitorInstruction(Opcodes.MONITORENTER)\n\n        @JvmField\n        val MONITOR_EXIT: MonitorInstruction = MonitorInstruction(Opcodes.MONITOREXIT)\n    }\n\n    override fun toCallable(method: CallableMethod): Callable {\n        return object : IntrinsicCallable(Type.VOID_TYPE, listOf(OBJECT_TYPE), null, null) {\noverride fun invokeIntrinsic(v: InstructionAdapter) {\n", "line_to_complete": "\n                v.visitInsn(opcode)\n            }"}
{"context": "\n\npackage org.jetbrains.kotlin.incremental\n\nimport com.intellij.psi.PsiClass\nimport com.intellij.psi.PsiFile\nimport com.intellij.psi.PsiJavaFile\nimport org.jetbrains.kotlin.build.report.ICReporter\nimport org.jetbrains.kotlin.build.report.info\nimport org.jetbrains.kotlin.build.report.metrics.BuildAttribute\nimport java.io.File\nimport java.util.*\n\ninternal class ChangedJavaFilesProcessor(\n    private val reporter: ICReporter,\n    private val psiFileFactory: (File) -> PsiFile?\n) {\n    private val allSymbols = HashSet<LookupSymbol>()\n\n    val allChangedSymbols: Collection<LookupSymbol>\n        get() = allSymbols\nfun process(filesDiff: ChangedFiles.Known): ChangesEither {\n", "line_to_complete": "\n        val modifiedJava = filesDiff.modified.filter(File::isJavaFile)\n        val removedJava = filesDiff.removed.filter(File::isJavaFile)\n\n        if (removedJava.any()) {\n            reporter.info { \"Some java files are removed: [${removedJava.joinToString()}]\" }\n            return ChangesEither.Unknown(BuildAttribute.JAVA_CHANGE_UNTRACKED_FILE_IS_REMOVED)\n        }\n\n        val symbols = HashSet<LookupSymbol>()\n        for (javaFile in modifiedJava) {\n            assert(javaFile.extension.equals(\"java\", ignoreCase = true))\n\n            val psiFile = psiFileFactory(javaFile)\n            if (psiFile !is PsiJavaFile) {\n                reporter.info { \"Expected PsiJavaFile, got ${psiFile?.javaClass}\" }\n                return ChangesEither.Unknown(BuildAttribute.JAVA_CHANGE_UNEXPECTED_PSI)\n            }\n\n            psiFile.classes.forEach { it.addLookupSymbols(symbols) }\n        }\n        allSymbols.addAll(symbols)\n        return ChangesEither.Known(lookupSymbols = symbols)\n    }"}
{"context": "// IGNORE_FE10\n\n// MODULE: context\n\n// FILE: context.kt\nfun test() {\n", "line_to_complete": "\n    class Local {}\n\n    <caret_context>Local()\n}"}
{"context": "@Suppress(\"INVISIBLE_MEMBER\", <!ERROR_SUPPRESSION!>\"INVISIBLE_REFERENCE\"<!>)\n@kotlin.internal.LowPriorityInOverloadResolution\nfun foo(): Int = 1\n\nfun foo(): String = \"\"\nfun test() {\n", "line_to_complete": "\n    val s = foo()\n    s.length\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.analysis.api.fir.components\n\nimport org.jetbrains.kotlin.analysis.api.components.KtInheritorsProvider\nimport org.jetbrains.kotlin.analysis.api.fir.KtFirAnalysisSession\nimport org.jetbrains.kotlin.analysis.api.fir.symbols.KtFirNamedClassOrObjectSymbol\nimport org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken\nimport org.jetbrains.kotlin.analysis.api.symbols.KtClassKind\nimport org.jetbrains.kotlin.analysis.api.symbols.KtEnumEntrySymbol\nimport org.jetbrains.kotlin.analysis.api.symbols.KtNamedClassOrObjectSymbol\nimport org.jetbrains.kotlin.descriptors.Modality\nimport org.jetbrains.kotlin.fir.declarations.getSealedClassInheritors\n\ninternal class KtFirInheritorsProvider(\n    override val analysisSession: KtFirAnalysisSession,\n    override val token: KtLifetimeToken,\n) : KtInheritorsProvider(), KtFirAnalysisSessionComponent {\noverride fun getInheritorsOfSealedClass(\n        classSymbol: KtNamedClassOrObjectSymbol\n    ): List<KtNamedClassOrObjectSymbol> {\n", "line_to_complete": "\n        require(classSymbol.modality == Modality.SEALED)\n        require(classSymbol is KtFirNamedClassOrObjectSymbol)\n\n        val inheritorClassIds = classSymbol.firSymbol.fir.getSealedClassInheritors(analysisSession.useSiteSession)\n\n        return with(analysisSession) {\n            inheritorClassIds.mapNotNull { getClassOrObjectSymbolByClassId(it) as? KtNamedClassOrObjectSymbol }\n        }\n    }"}
{"context": "// WITH_STDLIB\nfun foo(a: Int, b: Int) = if (a > b) a else b\nfun bar(a: Double, b: Double): Double {\n", "line_to_complete": "\n    if (a > b) {\n        println(a)\n        return a\n    } else {\n        println(b)\n        return b\n    }\n}"}
{"context": "// WITH_STDLIB\nfun foo(a: Int, b: Int) = if (a > b) a else b\n\nfun bar(a: Double, b: Double): Double {\n    if (a > b) {\n        println(a)\n        return a\n    } else {\n        println(b)\n        return b\n    }\n}\nfun baz(a: Long, b: Long): Long {\n", "line_to_complete": "\n    when {\n        a > b -> {\n            println(a)\n            return a\n        }\n        else -> return b\n    }\n}"}
{"context": "// WITH_STDLIB\nfun foo(a: Int, b: Int) = if (a > b) a else b\n\nfun bar(a: Double, b: Double): Double {\n    if (a > b) {\n        println(a)\n        return a\n    } else {\n        println(b)\n        return b\n    }\n}\n\nfun baz(a: Long, b: Long): Long {\n    when {\n        a > b -> {\n            println(a)\n            return a\n        }\n        else -> return b\n    }\n}\nfun grade(g: Int): String {\n", "line_to_complete": "\n    return when (g) {\n        6, 7 -> \"Outstanding\"\n        5 -> \"Excellent\"\n        4 -> \"Good\"\n        3 -> \"Mediocre\"\n        in 1..2 -> \"Fail\"\n        is Number -> \"Number\"\n        else -> \"Unknown\"\n    }\n}"}
{"context": "// IGNORE_FIR\npackage foo.bar.baz\n\nclass AA {\n    class BB {\n        companion object\n    }\n}\nfun test() {\n", "line_to_complete": "\n    val b = foo.bar.baz.AA.B<caret>B\n}"}
{"context": "\n\npackage org.jetbrains.kotlin.buildtools.internal\n\nimport org.jetbrains.kotlin.buildtools.api.KotlinLogger\n\nprivate enum class LogLevel {\n    ERROR,\n    WARN,\n    LIFECYCLE,\n    INFO,\n    DEBUG,\n    ;\n\n    companion object {\nfun fromString(rawValue: String) = entries.firstOrNull {\n", "line_to_complete": " it.name.equals(rawValue, ignoreCase = true) }"}
{"context": "\n\npackage org.jetbrains.kotlin.buildtools.internal\n\nimport org.jetbrains.kotlin.buildtools.api.KotlinLogger\n\nprivate enum class LogLevel {\n    ERROR,\n    WARN,\n    LIFECYCLE,\n    INFO,\n    DEBUG,\n    ;\n\n    companion object {\n        fun fromString(rawValue: String) = entries.firstOrNull { it.name.equals(rawValue, ignoreCase = true) }\n            ?: error(\"Unknown log level for the DefaultKotlinLogger: $rawValue\")\n    }\n}\n\ninternal object DefaultKotlinLogger : KotlinLogger {\n    private val logLevel: LogLevel = System.getProperty(\"kotlin.build-tools-api.log.level\")?.let {\n        LogLevel.fromString(it)\n    } ?: LogLevel.WARN\n\n    private val LogLevel.isEnabled: Boolean\n        get() = logLevel >= this\n\n    override val isDebugEnabled: Boolean\n        get() = LogLevel.DEBUG.isEnabled\noverride fun error(msg: String, throwable: Throwable?) {\n", "line_to_complete": "\n        if (!LogLevel.ERROR.isEnabled) return\n        System.err.println(\"e: $msg\")\n        throwable?.printStackTrace()\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.annotations\n\nimport com.intellij.psi.PsiAnnotation\nimport com.intellij.psi.PsiElement\n\ninternal class CollectionAdditionalAnnotationsProvider(\n    private val additionalAnnotationQualifiers: Collection<String>,\n) : AdditionalAnnotationsProvider {\n    constructor(qualifiedName: String) : this(setOf(qualifiedName))\noverride fun addAllAnnotations(\n        currentRawAnnotations: MutableList<in PsiAnnotation>,\n        foundQualifiers: MutableSet<String>,\n        owner: PsiElement,\n    ) {\n", "line_to_complete": "\n        additionalAnnotationQualifiers.forEach { qualifiedName ->\n            addSimpleAnnotationIfMissing(qualifiedName, currentRawAnnotations, foundQualifiers, owner)\n        }\n    }"}
{"context": "\n\npackage org.jetbrains.kotlin.light.classes.symbol.annotations\n\nimport com.intellij.psi.PsiAnnotation\nimport com.intellij.psi.PsiElement\n\ninternal class CollectionAdditionalAnnotationsProvider(\n    private val additionalAnnotationQualifiers: Collection<String>,\n) : AdditionalAnnotationsProvider {\n    constructor(qualifiedName: String) : this(setOf(qualifiedName))\n\n    override fun addAllAnnotations(\n        currentRawAnnotations: MutableList<in PsiAnnotation>,\n        foundQualifiers: MutableSet<String>,\n        owner: PsiElement,\n    ) {\n        additionalAnnotationQualifiers.forEach { qualifiedName ->\n            addSimpleAnnotationIfMissing(qualifiedName, currentRawAnnotations, foundQualifiers, owner)\n        }\n    }\noverride fun findSpecialAnnotation(\n        annotationsBox: GranularAnnotationsBox,\n        qualifiedName: String,\n        owner: PsiElement,\n    ): PsiAnnotation? {\n", "line_to_complete": "\n        if (qualifiedName !in additionalAnnotationQualifiers) return null\n\n        return createSimpleAnnotationIfMatches(qualifiedName, qualifiedName, owner)\n    }"}
